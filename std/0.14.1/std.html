<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="std.html" class="active">std</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std</span><a href="#src.zig-std">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.array_hash_map.html">std.array_hash_map</a></li><li><a href="std.atomic.html">std.atomic</a></li><li><a href="std.base64.html">std.base64</a></li><li><a href="std.bit_set.html">std.bit_set</a></li><li><a href="std.builtin.html">std.builtin</a></li><li><a href="std.c.html">std.c</a></li><li><a href="std.coff.html">std.coff</a></li><li><a href="std.compress.html">std.compress</a></li><li><a href="std.static_string_map.html">std.static_string_map</a></li><li><a href="std.crypto.html">std.crypto</a></li><li><a href="std.debug.html">std.debug</a></li><li><a href="std.dwarf.html">std.dwarf</a></li><li><a href="std.elf.html">std.elf</a></li><li><a href="std.enums.html">std.enums</a></li><li><a href="std.fifo.html">std.fifo</a></li><li><a href="std.fmt.html">std.fmt</a></li><li><a href="std.fs.html">std.fs</a></li><li><a href="std.gpu.html">std.gpu</a></li><li><a href="std.hash.html">std.hash</a></li><li><a href="std.hash_map.html">std.hash_map</a></li><li><a href="std.heap.html">std.heap</a></li><li><a href="std.http.html">std.http</a></li><li><a href="std.io.html">std.io</a></li><li><a href="std.json.html">std.json</a></li><li><a href="std.leb128.html">std.leb128</a></li><li><a href="std.log.html">std.log</a></li><li><a href="std.macho.html">std.macho</a></li><li><a href="std.math.html">std.math</a></li><li><a href="std.mem.html">std.mem</a></li><li><a href="std.meta.html">std.meta</a></li><li><a href="std.net.html">std.net</a></li><li><a href="std.os.html">std.os</a></li><li><a href="std.pdb.html">std.pdb</a></li><li><a href="std.posix.html">std.posix</a></li><li><a href="std.process.html">std.process</a></li><li><a href="std.sort.html">std.sort</a></li><li><a href="std.simd.html">std.simd</a></li><li><a href="std.ascii.html">std.ascii</a></li><li><a href="std.tar.html">std.tar</a></li><li><a href="std.testing.html">std.testing</a></li><li><a href="std.time.html">std.time</a></li><li><a href="std.tz.html">std.tz</a></li><li><a href="std.unicode.html">std.unicode</a></li><li><a href="std.valgrind.html">std.valgrind</a></li><li><a href="std.wasm.html">std.wasm</a></li><li><a href="std.zig.html">std.zig</a></li><li><a href="std.zip.html">std.zip</a></li><li><a href="std.zon.html">std.zon</a></li><li><a href="std.start.html">std.start</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.BitStack.html">std.BitStack</a></li><li><a href="std.Build.html">std.Build</a></li><li><a href="std.buf_map.BufMap.html">std.buf_map.BufMap</a></li><li><a href="std.buf_set.BufSet.html">std.buf_set.BufSet</a></li><li><a href="std.dynamic_library.DynLib.html">std.dynamic_library.DynLib</a></li><li><a href="std.bit_set.DynamicBitSet.html">std.bit_set.DynamicBitSet</a></li><li><a href="std.bit_set.DynamicBitSetUnmanaged.html">std.bit_set.DynamicBitSetUnmanaged</a></li><li><a href="std.Progress.html">std.Progress</a></li><li><a href="std.Random.html">std.Random</a></li><li><a href="std.RingBuffer.html">std.RingBuffer</a></li><li><a href="std.SemanticVersion.html">std.SemanticVersion</a></li><li><a href="std.Target.html">std.Target</a></li><li><a href="std.Thread.html">std.Thread</a></li><li><a href="std.tz.Tz.html">std.tz.Tz</a></li><li><a href="std.Uri.html">std.Uri</a></li><li><a href="std.Options.html">std.Options</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.array_hash_map.ArrayHashMapWithAllocator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayHashMapWithAllocator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator">[src]</a></h2><div class="tldDocs"><p>A hash table of keys and values, each stored sequentially.</p>
<p>Insertion order is preserved. In general, this data structure supports the same
operations as <code><a href="std.array_list.html#std.array_list.ArrayList">std.ArrayList</a></code>.</p>
<p>Deletion operations:</p>
<ul>
<li><code>swapRemove</code> - O(1)</li>
<li><code>orderedRemove</code> - O(N)</li>
</ul>
<p>Modifying the hash map while iterating is allowed, however, one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.</p>
<p>See <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> for a variant of this data structure that accepts an
<code><a href="std.mem.Allocator.html">Allocator</a></code> as a parameter when needed rather than storing it.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>A namespace that provides these two functions:</p>
<ul>
<li><code>pub fn hash(self, K) u32</code></li>
<li><code>pub fn eql(self, K, K, usize) bool</code></li>
</ul>
<p>The final <code>usize</code> in the <code>eql</code> function represents the index of the key
that's already inside the map.</p>
</div></div><div><pre><code>store_hash: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>When <code>false</code>, this data structure is biased towards cheap <code>eql</code>
functions and avoids storing each key's hash in the table. Setting
<code>store_hash</code> to <code>true</code> incurs more memory cost but limits <code>eql</code> to
being called only once per insertion/deletion (provided there are no
hash collisions).</p>
</div></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMapUnmanaged type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Entry">[src]</a></h3><div class="tldDocs"><p>Pointers to a key and value in the backing store of this map.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless <code>ensureTotalCapacity</code>/<code>ensureUnusedCapacity</code> was previously used.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.KV">[src]</a></h3><div class="tldDocs"><p>A KV pair which has been copied out of the backing store</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Data" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Data</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Data">[src]</a></h3><div class="tldDocs"><p>The Data type used for the MultiArrayList backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Data">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Data</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.DataList" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">DataList</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>getOrPut variants return this structure, with pointers
to the backing store and a flag to indicate whether an
existing entry was found.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless <code>ensureTotalCapacity</code>/<code>ensureUnusedCapacity</code> was previously used.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Iterator">[src]</a></h3><div class="tldDocs"><p>An Iterator over Entry pointers.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create an ArrayHashMap instance which will use a specified allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call initContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.initContext">initContext</a>(allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K {
    <span class="tok-kw">return</span> self.unmanaged.keys();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V {
    <span class="tok-kw">return</span> self.unmanaged.values();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, new_capacity, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happuns, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.getIndexContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.swapRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.swapRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.unmanaged.swapRemoveAtContext(index, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.unmanaged.orderedRemoveAtContext(index, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context and allocator as this instance.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but the specified
allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash)</code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same allocator as this instance, but the
specified context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash)</code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, ctx);
    <span class="tok-kw">return</span> other.promoteContext(allocator, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.reIndexContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.sortContext(sort_ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.shrinkRetainingCapacityContext(new_len, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.shrinkAndFreeContext(self.allocator, new_len, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it if count is nonzero.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.popContext(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayHashMapWithAllocator</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-comment">/// A namespace that provides these two functions:</span>
    <span class="tok-comment">/// * `pub fn hash(self, K) u32`</span>
    <span class="tok-comment">/// * `pub fn eql(self, K, K, usize) bool`</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The final `usize` in the `eql` function represents the index of the key</span>
    <span class="tok-comment">/// that's already inside the map.</span>
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-comment">/// When `false`, this data structure is biased towards cheap `eql`</span>
    <span class="tok-comment">/// functions and avoids storing each key's hash in the table. Setting</span>
    <span class="tok-comment">/// `store_hash` to `true` incurs more memory cost but limits `eql` to</span>
    <span class="tok-comment">/// being called only once per insertion/deletion (provided there are no</span>
    <span class="tok-comment">/// hash collisions).</span>
    <span class="tok-kw">comptime</span> store_hash: <span class="tok-type">bool</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        unmanaged: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        ctx: Context,

        <span class="tok-comment">/// The ArrayHashMapUnmanaged type using the same settings as this managed map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, Context, store_hash);

        <span class="tok-comment">/// Pointers to a key and value in the backing store of this map.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Entry</a>;

        <span class="tok-comment">/// A KV pair which has been copied out of the backing store</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">KV</a>;

        <span class="tok-comment">/// The Data type used for the MultiArrayList backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Data</a>;
        <span class="tok-comment">/// The MultiArrayList type backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">DataList</a>;

        <span class="tok-comment">/// The stored hash type, either u32 or void.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Hash</a>;

        <span class="tok-comment">/// getOrPut variants return this structure, with pointers</span>
        <span class="tok-comment">/// to the backing store and a flag to indicate whether an</span>
        <span class="tok-comment">/// existing entry was found.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a>;

        <span class="tok-comment">/// An Iterator over Entry pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a>;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Create an ArrayHashMap instance which will use a specified allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call initContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.initContext">initContext</a>(allocator, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Frees the backing allocation and leaves the map in an undefined state.</span>
        <span class="tok-comment">/// Note that this does not free keys or values.  You must take care of that</span>
        <span class="tok-comment">/// before calling this function, if it is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.deinit(self.allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.lockPointers();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.unlockPointers();
        }

        <span class="tok-comment">/// Clears the map but retains the backing allocation for future use.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
        }

        <span class="tok-comment">/// Clears the map and releases the backing allocation</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
        }

        <span class="tok-comment">/// Returns the number of KV pairs stored in this map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.count();
        }

        <span class="tok-comment">/// Returns the backing array of keys in this map. Modifying the map may</span>
        <span class="tok-comment">/// invalidate this array. Modifying this array in a way that changes</span>
        <span class="tok-comment">/// key hashes or key equality puts the map into an unusable state until</span>
        <span class="tok-comment">/// `reIndex` is called.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K {
            <span class="tok-kw">return</span> self.unmanaged.keys();
        }
        <span class="tok-comment">/// Returns the backing array of values in this map. Modifying the map</span>
        <span class="tok-comment">/// may invalidate this array. It is permitted to modify the values in</span>
        <span class="tok-comment">/// this array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V {
            <span class="tok-kw">return</span> self.unmanaged.values();
        }

        <span class="tok-comment">/// Returns an iterator over the pairs in this map.</span>
        <span class="tok-comment">/// Modifying the map may invalidate this iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.iterator();
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, new_capacity, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.capacity();
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happuns, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Finds pointers to the key and value storage associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the index in the `entries` array where a key is stored</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.getIndexContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.getIndexAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find a pointer to the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find a pointer to the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Check whether a key is stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by swapping it with the last</span>
        <span class="tok-comment">/// element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by shifting all elements forward</span>
        <span class="tok-comment">/// thereby maintaining the current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.  Returns true if an entry</span>
        <span class="tok-comment">/// was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.swapRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.swapRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.  Returns true if an entry was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.unmanaged.swapRemoveAtContext(index, self.ctx);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.unmanaged.orderedRemoveAtContext(index, self.ctx);
        }

        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context and allocator as this instance.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context as this instance, but the specified</span>
        <span class="tok-comment">/// allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(allocator, self.ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same allocator as this instance, but the</span>
        <span class="tok-comment">/// specified context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the specified allocator and context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, ctx);
            <span class="tok-kw">return</span> other.promoteContext(allocator, ctx);
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            self.unmanaged.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.unmanaged = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Recomputes stored hashes and rebuilds the key indexes. If the</span>
        <span class="tok-comment">/// underlying keys have been modified directly, call this method to</span>
        <span class="tok-comment">/// recompute the denormalized metadata necessary for the operation of</span>
        <span class="tok-comment">/// the methods of this map that lookup entries by key.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// One use case for this is directly calling `entries.resize()` to grow</span>
        <span class="tok-comment">/// the underlying storage, and then setting the `keys` and `values`</span>
        <span class="tok-comment">/// directly without going through the methods of this map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// The time complexity of this operation is O(n).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.reIndexContext(self.allocator, self.ctx);
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.sortContext(sort_ctx, self.ctx);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.shrinkRetainingCapacityContext(new_len, self.ctx);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacity` can be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.shrinkAndFreeContext(self.allocator, new_len, self.ctx);
        }

        <span class="tok-comment">/// Removes the last inserted `Entry` in the hash map and returns it if count is nonzero.</span>
        <span class="tok-comment">/// Otherwise returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.popContext(self.ctx);
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.ArrayHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayHashMapUnmanaged</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>A hash table of keys and values, each stored sequentially.</p>
<p>Insertion order is preserved. In general, this data structure supports the same
operations as <code><a href="std.array_list.html#std.array_list.ArrayListUnmanaged">std.ArrayListUnmanaged</a></code>.</p>
<p>Deletion operations:</p>
<ul>
<li><code>swapRemove</code> - O(1)</li>
<li><code>orderedRemove</code> - O(N)</li>
</ul>
<p>Modifying the hash map while iterating is allowed, however, one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.</p>
<p>This type does not store an <code><a href="std.mem.Allocator.html">Allocator</a></code> field - the <code><a href="std.mem.Allocator.html">Allocator</a></code> must be passed in
with each function call that requires it. See <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a></code> for a type that stores
an <code><a href="std.mem.Allocator.html">Allocator</a></code> field for convenience.</p>
<p>Can be initialized directly using the default field values.</p>
<p>This type is designed to have low overhead for small numbers of entries. When
<code>store_hash</code> is <code>false</code> and the number of entries in the map is less than 9,
the overhead cost of using <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> rather than <code><a href="std.array_list.html#std.array_list.ArrayList">std.ArrayList</a></code> is
only a single pointer-sized integer.</p>
<p>Default initialization of this struct is deprecated; use <code>.empty</code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>A namespace that provides these two functions:</p>
<ul>
<li><code>pub fn hash(self, K) u32</code></li>
<li><code>pub fn eql(self, K, K, usize) bool</code></li>
</ul>
<p>The final <code>usize</code> in the <code>eql</code> function represents the index of the key
that's already inside the map.</p>
</div></div><div><pre><code>store_hash: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>When <code>false</code>, this data structure is biased towards cheap <code>eql</code>
functions and avoids storing each key's hash in the table. Setting
<code>store_hash</code> to <code>true</code> incurs more memory cost but limits <code>eql</code> to
being called only once per insertion/deletion (provided there are no
hash collisions).</p>
</div></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">std.array_hash_map.ArrayHashMapUnmanaged.Entry</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">std.array_hash_map.ArrayHashMapUnmanaged.KV</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">std.array_hash_map.ArrayHashMapUnmanaged.Data</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">std.array_hash_map.ArrayHashMapUnmanaged.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.DataList" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMap type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{}</code></pre><div class="fieldDocs"><p>It is permitted to access this field directly.
After any modification to the keys, consider calling <code>reIndex</code>.</p>
</div></div><div><pre><code>index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>When entries length is less than <code>linear_scan_max</code>, this remains <code>null</code>.
Once entries length grows big enough, this field is allocated. There is
an IndexHeader followed by an array of Index(I) structs, where I is defined
by how many total indexes there are.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
    .entries = .{},
    .index_header = <span class="tok-null">null</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="tldDocs"><p>Convert from an unmanaged map to a managed map.  After calling this,
the promoted map should no longer be used.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = gpa,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    <span class="tok-kw">errdefer</span> self.deinit(gpa);
    <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>An empty <code>value_list</code> may be passed, in which case the values array becomes <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
    <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
    <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
        <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
        <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
    }
    <span class="tok-kw">try</span> self.reIndex(gpa);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.entries.deinit(gpa);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
    }
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.len = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">switch</span> (header.capacityIndexType()) {
            .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
            .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
            .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
        self.index_header = <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.entries.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
    <span class="tok-kw">return</span> self.entries.items(.key);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
    <span class="tok-kw">return</span> self.entries.items(.value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> .{
        .keys = slice.items(.key).ptr,
        .values = slice.items(.value).ptr,
        .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // &quot;If key exists this function cannot fail.&quot;
        </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            .found_existing = <span class="tok-null">true</span>,
            .index = index,
        };
    };
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
both the key and the value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = item_key,<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = i,
                };
            }
        }

        <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
        // The slice length changed, so we directly index the pointer.
        </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
            .found_existing = <span class="tok-null">false</span>,
            .index = index,
        };
    };

    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> res;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
        <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">return</span>;
        }
    }

    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
    <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
    <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

    <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
    self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
    self.index_header = new_header;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ctx: Context, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
    ctx: Context,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
    <span class="tok-kw">const</span> indexes_cap = header.capacity();
    <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
        .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
        // workaround for #6974
        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> i;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    };
    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // workaround for #6974
    </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> &amp;self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but is allocated
with the provided allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
    <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

    <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
        // TODO: I'm pretty sure this could be memcpy'd instead of
        // doing all this work.
        </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
        other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
        other.index_header = new_header;
    }
    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Recompute all hashes.
    </span><span class="tok-kw">if</span> (store_hash) {
        <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            hash.* = h;
        }
    }
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify an entry's key without reordering any entries.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
    key_ptr.* = new_key;
    <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses a stable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstable</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses an unstable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstableContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkRetainingCapacity(new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFreeContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacityContext</code> can be used
instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkAndFree(gpa, new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.popContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (self.index_header) |header|
        self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    self.entries.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> .{
        .key = item.key,
        .value = item.value,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayHashMapUnmanaged</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-comment">/// A namespace that provides these two functions:</span>
    <span class="tok-comment">/// * `pub fn hash(self, K) u32`</span>
    <span class="tok-comment">/// * `pub fn eql(self, K, K, usize) bool`</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The final `usize` in the `eql` function represents the index of the key</span>
    <span class="tok-comment">/// that's already inside the map.</span>
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-comment">/// When `false`, this data structure is biased towards cheap `eql`</span>
    <span class="tok-comment">/// functions and avoids storing each key's hash in the table. Setting</span>
    <span class="tok-comment">/// `store_hash` to `true` incurs more memory cost but limits `eql` to</span>
    <span class="tok-comment">/// being called only once per insertion/deletion (provided there are no</span>
    <span class="tok-comment">/// hash collisions).</span>
    <span class="tok-kw">comptime</span> store_hash: <span class="tok-type">bool</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// It is permitted to access this field directly.</span>
        <span class="tok-comment">/// After any modification to the keys, consider calling `reIndex`.</span>
        entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{},

        <span class="tok-comment">/// When entries length is less than `linear_scan_max`, this remains `null`.</span>
        <span class="tok-comment">/// Once entries length grows big enough, this field is allocated. There is</span>
        <span class="tok-comment">/// an IndexHeader followed by an array of Index(I) structs, where I is defined</span>
        <span class="tok-comment">/// by how many total indexes there are.</span>
        index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span>,

        <span class="tok-comment">/// Used to detect memory safety violations.</span>
        pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{},

        <span class="tok-comment">/// A map containing no keys or values.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
            .entries = .{},
            .index_header = <span class="tok-null">null</span>,
        };

        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
        };

        <span class="tok-comment">/// A KV pair which has been copied out of the backing store</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <span class="tok-kw">struct</span> {
            key: K,
            value: V,
        };

        <span class="tok-comment">/// The Data type used for the MultiArrayList backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">struct</span> {
            hash: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Hash">Hash</a>,
            key: K,
            value: V,
        };

        <span class="tok-comment">/// The MultiArrayList type backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>);

        <span class="tok-comment">/// The stored hash type, either u32 or void.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span>;

        <span class="tok-comment">/// getOrPut variants return this structure, with pointers</span>
        <span class="tok-comment">/// to the backing store and a flag to indicate whether an</span>
        <span class="tok-comment">/// existing entry was found.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
            found_existing: <span class="tok-type">bool</span>,
            index: <span class="tok-type">usize</span>,
        };

        <span class="tok-comment">/// The ArrayHashMap type using the same settings as this managed map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash);

        <span class="tok-comment">/// Some functions require a context only if hashes are not stored.</span>
        <span class="tok-comment">/// To keep the api simple, this type is only used internally.</span>
        <span class="tok-kw">const</span> ByIndexContext = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">void</span> <span class="tok-kw">else</span> Context;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">const</span> linear_scan_max = <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@min</span>(
            <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.cache_line">cache_line</a> / <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Hash">Hash</a>))),
            <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.cache_line">cache_line</a> / <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@sizeOf</span>(K))),
        ))));

        <span class="tok-kw">const</span> RemovalType = <span class="tok-kw">enum</span> {
            swap,
            ordered,
        };

        <span class="tok-kw">const</span> Oom = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>;

        <span class="tok-comment">/// Convert from an unmanaged map to a managed map.  After calling this,</span>
        <span class="tok-comment">/// the promoted map should no longer be used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = self,
                .allocator = gpa,
                .ctx = ctx,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
            <span class="tok-kw">errdefer</span> self.deinit(gpa);
            <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// An empty `value_list` may be passed, in which case the values array becomes `undefined`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
            <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
            <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
                <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
            } <span class="tok-kw">else</span> {
                <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
                <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
            }
            <span class="tok-kw">try</span> self.reIndex(gpa);
        }

        <span class="tok-comment">/// Frees the backing allocation and leaves the map in an undefined state.</span>
        <span class="tok-comment">/// Note that this does not free keys or values.  You must take care of that</span>
        <span class="tok-comment">/// before calling this function, if it is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.assertUnlocked();
            self.entries.deinit(gpa);
            <span class="tok-kw">if</span> (self.index_header) |header| {
                header.free(gpa);
            }
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.unlock();
        }

        <span class="tok-comment">/// Clears the map but retains the backing allocation for future use.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.entries.len = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                    .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
                    .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
                    .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
                }
            }
        }

        <span class="tok-comment">/// Clears the map and releases the backing allocation</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
            <span class="tok-kw">if</span> (self.index_header) |header| {
                header.free(gpa);
                self.index_header = <span class="tok-null">null</span>;
            }
        }

        <span class="tok-comment">/// Returns the number of KV pairs stored in this map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.entries.len;
        }

        <span class="tok-comment">/// Returns the backing array of keys in this map. Modifying the map may</span>
        <span class="tok-comment">/// invalidate this array. Modifying this array in a way that changes</span>
        <span class="tok-comment">/// key hashes or key equality puts the map into an unusable state until</span>
        <span class="tok-comment">/// `reIndex` is called.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
            <span class="tok-kw">return</span> self.entries.items(.key);
        }
        <span class="tok-comment">/// Returns the backing array of values in this map. Modifying the map</span>
        <span class="tok-comment">/// may invalidate this array. It is permitted to modify the values in</span>
        <span class="tok-comment">/// this array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
            <span class="tok-kw">return</span> self.entries.items(.value);
        }

        <span class="tok-comment">/// Returns an iterator over the pairs in this map.</span>
        <span class="tok-comment">/// Modifying the map may invalidate this iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">return</span> .{
                .keys = slice.items(.key).ptr,
                .values = slice.items(.value).ptr,
                .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
            };
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            keys: [*]K,
            values: [*]V,
            len: <span class="tok-type">u32</span>,
            index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
                <span class="tok-kw">if</span> (it.index &gt;= it.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                <span class="tok-kw">const</span> result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
                    .key_ptr = &amp;it.keys[it.index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;it.values[it.index],
                };
                it.index += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-comment">/// Reset the iterator to the initial index</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(it: *<a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a>) <span class="tok-type">void</span> {
                it.index = <span class="tok-number">0</span>;
            }
        };

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
                // &quot;If key exists this function cannot fail.&quot;
                </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = index,
                };
            };
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined key and value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// both the key and the value.</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                            .key_ptr = item_key,<span class="tok-comment">
                            // workaround for #6974
                            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                            .found_existing = <span class="tok-null">true</span>,
                            .index = i,
                        };
                    }
                }

                <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
                // The slice length changed, so we directly index the pointer.
                </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
                    .found_existing = <span class="tok-null">false</span>,
                    .index = index,
                };
            };

            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
            <span class="tok-kw">if</span> (!res.found_existing) {
                res.key_ptr.* = key;
                res.value_ptr.* = value;
            }
            <span class="tok-kw">return</span> res;
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
                <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
                    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
                    <span class="tok-kw">return</span>;
                }
            }

            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
            <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

            <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
            self.index_header = new_header;
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            gpa: <a href="std.mem.Allocator.html">Allocator</a>,
            additional_capacity: <span class="tok-type">usize</span>,
        ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            gpa: <a href="std.mem.Allocator.html">Allocator</a>,
            additional_capacity: <span class="tok-type">usize</span>,
            ctx: Context,
        ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
            <span class="tok-kw">const</span> indexes_cap = header.capacity();
            <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
            <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Finds pointers to the key and value storage associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
                .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
                // workaround for #6974
                </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            };
        }

        <span class="tok-comment">/// Finds the index in the `entries` array where a key is stored</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                        <span class="tok-kw">return</span> i;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            };
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">getIndexWithHeaderGeneric</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> slot = self.getSlotByKey(key, ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> indexes[slot].entry_index;
        }

        <span class="tok-comment">/// Find the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
            <span class="tok-kw">return</span> self.getAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.values()[index];
        }

        <span class="tok-comment">/// Find a pointer to the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
            <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
            // workaround for #6974
            </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
        }

        <span class="tok-comment">/// Find the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
            <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.keys()[index];
        }

        <span class="tok-comment">/// Find a pointer to the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
            <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> &amp;self.keys()[index];
        }

        <span class="tok-comment">/// Check whether a key is stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by swapping it with the last</span>
        <span class="tok-comment">/// element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by shifting all elements forward</span>
        <span class="tok-comment">/// thereby maintaining the current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.  Returns true if an entry</span>
        <span class="tok-comment">/// was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.  Returns true if an entry was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context as this instance, but is allocated</span>
        <span class="tok-comment">/// with the provided allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
            other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
            <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

            <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
                // TODO: I'm pretty sure this could be memcpy'd instead of
                // doing all this work.
                </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
                other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
                other.index_header = new_header;
            }
            <span class="tok-kw">return</span> other;
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            self.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.* = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Recomputes stored hashes and rebuilds the key indexes. If the</span>
        <span class="tok-comment">/// underlying keys have been modified directly, call this method to</span>
        <span class="tok-comment">/// recompute the denormalized metadata necessary for the operation of</span>
        <span class="tok-comment">/// the methods of this map that lookup entries by key.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// One use case for this is directly calling `entries.resize()` to grow</span>
        <span class="tok-comment">/// the underlying storage, and then setting the `keys` and `values`</span>
        <span class="tok-comment">/// directly without going through the methods of this map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// The time complexity of this operation is O(n).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
            // Recompute all hashes.
            </span><span class="tok-kw">if</span> (store_hash) {
                <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
                    <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
                    hash.* = h;
                }
            }
            <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
        }

        <span class="tok-comment">/// Modify an entry's key without reordering any entries.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
            key_ptr.* = new_key;
            <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
            <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">rebuildIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.entries.capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) <span class="tok-kw">return</span>;<span class="tok-comment">

            // We're going to rebuild the index header and replace the existing one (if any). The
            // indexes should sized such that they will be at most 60% full.
            </span><span class="tok-kw">const</span> bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(self.entries.capacity);
            <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, bit_index);
            <span class="tok-kw">if</span> (self.index_header) |header| header.free(gpa);
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
            self.index_header = new_header;
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-comment">/// Uses a stable sorting algorithm.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-comment">/// Uses an unstable sorting algorithm.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">sortContextInternal</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            <span class="tok-kw">comptime</span> mode: <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.Mode.html">Mode</a>,
            sort_ctx: <span class="tok-kw">anytype</span>,
            ctx: Context,
        ) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">switch</span> (mode) {
                .stable =&gt; self.entries.sort(sort_ctx),
                .unstable =&gt; self.entries.sortUnstable(sort_ctx),
            }
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
            header.reset();
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

            // Remove index entries from the new length onwards.
            // Explicitly choose to ONLY remove index entries and not the underlying array list
            // entries as we're going to remove them in the subsequent shrink call.
            </span><span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
                <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
                    self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            }
            self.entries.shrinkRetainingCapacity(new_len);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacity` can be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacityContext` can be used</span>
        <span class="tok-comment">/// instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

            // Remove index entries from the new length onwards.
            // Explicitly choose to ONLY remove index entries and not the underlying array list
            // entries as we're going to remove them in the subsequent shrink call.
            </span><span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
                <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
                    self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            }
            self.entries.shrinkAndFree(gpa, new_len);
        }

        <span class="tok-comment">/// Removes the last inserted `Entry` in the hash map and returns it.</span>
        <span class="tok-comment">/// Otherwise returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
            <span class="tok-kw">if</span> (self.index_header) |header|
                self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            self.entries.len -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> .{
                .key = item.key,
                .value = item.value,
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveByKey</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> key_hash = <span class="tok-kw">if</span> (store_hash) key_ctx.hash(key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) hashes_array[i] == key_hash <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                    <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> key_ctx.eql(key, item_key.*, i)) {
                        <span class="tok-kw">const</span> removed_entry: <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = .{
                            .key = keys_array[i],
                            .value = slice.items(.value)[i],
                        };
                        <span class="tok-kw">switch</span> (removal_type) {
                            .swap =&gt; self.entries.swapRemove(i),
                            .ordered =&gt; self.entries.orderedRemove(i),
                        }
                        <span class="tok-kw">return</span> removed_entry;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            };
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u32</span>, removal_type),
            };
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveByKeyGeneric</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>,
            <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> entry_index = self.removeFromIndexByKey(key, key_ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> removed_entry: <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = .{
                .key = slice.items(.key)[entry_index],
                .value = slice.items(.value)[entry_index],
            };
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
            <span class="tok-kw">return</span> removed_entry;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByKey</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> key_hash = <span class="tok-kw">if</span> (store_hash) key_ctx.hash(key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) hashes_array[i] == key_hash <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                    <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> key_ctx.eql(key, item_key.*, i)) {
                        <span class="tok-kw">switch</span> (removal_type) {
                            .swap =&gt; self.entries.swapRemove(i),
                            .ordered =&gt; self.entries.orderedRemove(i),
                        }
                        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            };
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u32</span>, removal_type),
            };
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeByKeyGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> entry_index = self.removeFromIndexByKey(key, key_ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(entry_index &lt; self.entries.len);
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {
                <span class="tok-kw">switch</span> (removal_type) {
                    .swap =&gt; self.entries.swapRemove(entry_index),
                    .ordered =&gt; self.entries.orderedRemove(entry_index),
                }
                <span class="tok-kw">return</span>;
            };
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u32</span>, removal_type),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndexGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            self.removeFromIndexByIndexGeneric(entry_index, ctx, header, I, indexes);
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromArrayAndUpdateIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I), <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> last_index = self.entries.len - <span class="tok-number">1</span>;<span class="tok-comment"> // overflow =&gt; remove from empty map
            </span><span class="tok-kw">switch</span> (removal_type) {
                .swap =&gt; {
                    <span class="tok-kw">if</span> (last_index != entry_index) {<span class="tok-comment">
                        // Because of the swap remove, now we need to update the index that was
                        // pointing to the last entry and is now pointing to this removed item slot.
                        </span>self.updateEntryIndex(header, last_index, entry_index, ctx, I, indexes);
                    }<span class="tok-comment">
                    // updateEntryIndex reads from the old entry index,
                    // so it needs to run before removal.
                    </span>self.entries.swapRemove(entry_index);
                },
                .ordered =&gt; {
                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = entry_index;
                    <span class="tok-kw">while</span> (i &lt; last_index) : (i += <span class="tok-number">1</span>) {<span class="tok-comment">
                        // Because of the ordered remove, everything from the entry index onwards has
                        // been shifted forward so we'll need to update the index entries.
                        </span>self.updateEntryIndex(header, i + <span class="tok-number">1</span>, i, ctx, I, indexes);
                    }<span class="tok-comment">
                    // updateEntryIndex reads from the old entry index,
                    // so it needs to run before removal.
                    </span>self.entries.orderedRemove(entry_index);
                },
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">updateEntryIndex</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>,
            old_entry_index: <span class="tok-type">usize</span>,
            new_entry_index: <span class="tok-type">usize</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>,
            indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I),
        ) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByIndex(old_entry_index, ctx, header, I, indexes);
            indexes[slot].entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_entry_index));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u8</span>, header.indexes(<span class="tok-type">u8</span>)),
                .<span class="tok-type">u16</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u16</span>, header.indexes(<span class="tok-type">u16</span>)),
                .<span class="tok-type">u32</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u32</span>, header.indexes(<span class="tok-type">u32</span>)),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByIndexGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByIndex(entry_index, ctx, header, I, indexes);
            <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.removeSlot">removeSlot</a>(slot, header, I, indexes);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByKey(key, ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> removed_entry_index = indexes[slot].entry_index;
            <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.removeSlot">removeSlot</a>(slot, header, I, indexes);
            <span class="tok-kw">return</span> removed_entry_index;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeSlot</span>(removed_slot: <span class="tok-type">usize</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> start_index = removed_slot +% <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> last_slot = removed_slot;
            <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = start_index;
            <span class="tok-kw">while</span> (index != end_index) : (index +%= <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];
                <span class="tok-kw">if</span> (slot_data.isEmpty() <span class="tok-kw">or</span> slot_data.distance_from_start_index == <span class="tok-number">0</span>) {
                    indexes[last_slot].setEmpty();
                    <span class="tok-kw">return</span>;
                }
                indexes[last_slot] = .{
                    .entry_index = slot_data.entry_index,
                    .distance_from_start_index = slot_data.distance_from_start_index - <span class="tok-number">1</span>,
                };
                last_slot = slot;
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSlotByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) slice.items(.hash)[entry_index] <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, slice.items(.key)[entry_index]);
            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];<span class="tok-comment">

                // This is the fundamental property of the array hash map index.  If this
                // assert fails, it probably means that the entry was not in the index.
                </span><a href="std.debug.html#std.debug.assert">assert</a>(!slot_data.isEmpty());
                <a href="std.debug.html#std.debug.assert">assert</a>(slot_data.distance_from_start_index &gt;= distance_from_start_index);

                <span class="tok-kw">if</span> (slot_data.entry_index == entry_index) {
                    <span class="tok-kw">return</span> slot;
                }
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-comment">/// Must `ensureTotalCapacity`/`ensureUnusedCapacity` before calling this.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutInternal</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
            <span class="tok-kw">const</span> keys_array = slice.items(.key);
            <span class="tok-kw">const</span> values_array = slice.items(.value);
            <span class="tok-kw">const</span> indexes = header.indexes(I);

            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">var</span> slot = header.constrainIndex(index);
                <span class="tok-kw">var</span> slot_data = indexes[slot];<span class="tok-comment">

                // If the slot is empty, there can be no more items in this run.
                // We didn't find a matching item, so this must be new.
                // Put it in the empty slot.
                </span><span class="tok-kw">if</span> (slot_data.isEmpty()) {
                    <span class="tok-kw">const</span> new_index = self.entries.addOneAssumeCapacity();
                    indexes[slot] = .{
                        .distance_from_start_index = distance_from_start_index,
                        .entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_index)),
                    };<span class="tok-comment">

                    // update the hash if applicable
                    </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[new_index] = h;

                    <span class="tok-kw">return</span> .{
                        .found_existing = <span class="tok-null">false</span>,
                        .key_ptr = &amp;keys_array.ptr[new_index],<span class="tok-comment">
                        // workaround for #6974
                        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array.ptr[new_index],
                        .index = new_index,
                    };
                }<span class="tok-comment">

                // This pointer survives the following append because we call
                // entries.ensureTotalCapacity before getOrPutInternal.
                </span><span class="tok-kw">const</span> i = slot_data.entry_index;
                <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) h == hashes_array[i] <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, keys_array[i], i)) {
                    <span class="tok-kw">return</span> .{
                        .found_existing = <span class="tok-null">true</span>,
                        .key_ptr = &amp;keys_array[slot_data.entry_index],<span class="tok-comment">
                        // workaround for #6974
                        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array[slot_data.entry_index],
                        .index = slot_data.entry_index,
                    };
                }<span class="tok-comment">

                // If the entry is closer to its target than our current distance,
                // the entry we are looking for does not exist.  It would be in
                // this slot instead if it was here.  So stop looking, and switch
                // to insert mode.
                </span><span class="tok-kw">if</span> (slot_data.distance_from_start_index &lt; distance_from_start_index) {<span class="tok-comment">
                    // In this case, we did not find the item. We will put a new entry.
                    // However, we will use this index for the new entry, and move
                    // the previous index down the line, to keep the max distance_from_start_index
                    // as small as possible.
                    </span><span class="tok-kw">const</span> new_index = self.entries.addOneAssumeCapacity();
                    <span class="tok-kw">if</span> (store_hash) hashes_array.ptr[new_index] = h;
                    indexes[slot] = .{
                        .entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_index)),
                        .distance_from_start_index = distance_from_start_index,
                    };
                    distance_from_start_index = slot_data.distance_from_start_index;
                    <span class="tok-kw">var</span> displaced_index = slot_data.entry_index;<span class="tok-comment">

                    // Find somewhere to put the index we replaced by shifting
                    // following indexes backwards.
                    </span>index +%= <span class="tok-number">1</span>;
                    distance_from_start_index += <span class="tok-number">1</span>;
                    <span class="tok-kw">while</span> (index != end_index) : ({
                        index +%= <span class="tok-number">1</span>;
                        distance_from_start_index += <span class="tok-number">1</span>;
                    }) {
                        slot = header.constrainIndex(index);
                        slot_data = indexes[slot];
                        <span class="tok-kw">if</span> (slot_data.isEmpty()) {
                            indexes[slot] = .{
                                .entry_index = displaced_index,
                                .distance_from_start_index = distance_from_start_index,
                            };
                            <span class="tok-kw">return</span> .{
                                .found_existing = <span class="tok-null">false</span>,
                                .key_ptr = &amp;keys_array.ptr[new_index],<span class="tok-comment">
                                // workaround for #6974
                                </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array.ptr[new_index],
                                .index = new_index,
                            };
                        }

                        <span class="tok-kw">if</span> (slot_data.distance_from_start_index &lt; distance_from_start_index) {
                            indexes[slot] = .{
                                .entry_index = displaced_index,
                                .distance_from_start_index = distance_from_start_index,
                            };
                            displaced_index = slot_data.entry_index;
                            distance_from_start_index = slot_data.distance_from_start_index;
                        }
                    }
                    <span class="tok-kw">unreachable</span>;
                }
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSlotByKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
            <span class="tok-kw">const</span> keys_array = slice.items(.key);
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);

            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];
                <span class="tok-kw">if</span> (slot_data.isEmpty() <span class="tok-kw">or</span> slot_data.distance_from_start_index &lt; distance_from_start_index)
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                <span class="tok-kw">const</span> i = slot_data.entry_index;
                <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) h == hashes_array[i] <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, keys_array[i], i))
                    <span class="tok-kw">return</span> slot;
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">insertAllEntriesIntoNewHeader</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u32</span>),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">insertAllEntriesIntoNewHeaderGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> items = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> slice.items(.key);
            <span class="tok-kw">const</span> indexes = header.indexes(I);

            entry_loop: <span class="tok-kw">for</span> (items, <span class="tok-number">0</span>..) |key, i| {
                <span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) key <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
                <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
                <span class="tok-kw">const</span> end_index = start_index +% indexes.len;
                <span class="tok-kw">var</span> index = start_index;
                <span class="tok-kw">var</span> entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(i));
                <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (index != end_index) : ({
                    index +%= <span class="tok-number">1</span>;
                    distance_from_start_index += <span class="tok-number">1</span>;
                }) {
                    <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                    <span class="tok-kw">const</span> next_index = indexes[slot];
                    <span class="tok-kw">if</span> (next_index.isEmpty()) {
                        indexes[slot] = .{
                            .distance_from_start_index = distance_from_start_index,
                            .entry_index = entry_index,
                        };
                        <span class="tok-kw">continue</span> :entry_loop;
                    }
                    <span class="tok-kw">if</span> (next_index.distance_from_start_index &lt; distance_from_start_index) {
                        indexes[slot] = .{
                            .distance_from_start_index = distance_from_start_index,
                            .entry_index = entry_index,
                        };
                        distance_from_start_index = next_index.distance_from_start_index;
                        entry_index = next_index.entry_index;
                    }
                }
                <span class="tok-kw">unreachable</span>;
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">checkedHash</span>(ctx: <span class="tok-kw">anytype</span>, key: <span class="tok-kw">anytype</span>) <span class="tok-type">u32</span> {<span class="tok-comment">
            // If you get a compile error on the next line, it means that your
            // generic hash function doesn't accept your key.
            </span><span class="tok-kw">return</span> ctx.hash(key);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">checkedEql</span>(ctx: <span class="tok-kw">anytype</span>, a: <span class="tok-kw">anytype</span>, b: K, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {<span class="tok-comment">
            // If you get a compile error on the next line, it means that your
            // generic eql function doesn't accept (self, adapt key, K, index).
            </span><span class="tok-kw">return</span> ctx.eql(a, b, b_index);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpState</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, <span class="tok-kw">comptime</span> keyFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> valueFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call dumpStateContext instead.&quot;</span>);
            self.dumpStateContext(keyFmt, valueFmt, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">dumpStateContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, <span class="tok-kw">comptime</span> keyFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> valueFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> p = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>;
            p(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>)});
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hash_status = <span class="tok-kw">if</span> (store_hash) <span class="tok-str">&quot;stored&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;computed&quot;</span>;
            p(<span class="tok-str">&quot;  len={} capacity={} hashes {s}\n&quot;</span>, .{ slice.len, slice.capacity, hash_status });
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> mask: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (self.index_header) |header| header.mask() <span class="tok-kw">else</span> ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">while</span> (i &lt; slice.len) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> hash = <span class="tok-kw">if</span> (store_hash) slice.items(.hash)[i] <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, slice.items(.key)[i]);
                <span class="tok-kw">if</span> (store_hash) {
                    p(
                        <span class="tok-str">&quot;  [{}]: key=&quot;</span> ++ keyFmt ++ <span class="tok-str">&quot; value=&quot;</span> ++ valueFmt ++ <span class="tok-str">&quot; hash=0x{x} slot=[0x{x}]\n&quot;</span>,
                        .{ i, slice.items(.key)[i], slice.items(.value)[i], hash, hash &amp; mask },
                    );
                } <span class="tok-kw">else</span> {
                    p(
                        <span class="tok-str">&quot;  [{}]: key=&quot;</span> ++ keyFmt ++ <span class="tok-str">&quot; value=&quot;</span> ++ valueFmt ++ <span class="tok-str">&quot; slot=[0x{x}]\n&quot;</span>,
                        .{ i, slice.items(.key)[i], slice.items(.value)[i], hash &amp; mask },
                    );
                }
            }
            <span class="tok-kw">if</span> (self.index_header) |header| {
                p(<span class="tok-str">&quot;\n&quot;</span>, .{});
                <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                    .<span class="tok-type">u8</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u8</span>),
                    .<span class="tok-type">u16</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u16</span>),
                    .<span class="tok-type">u32</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u32</span>),
                }
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">dumpIndex</span>(header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> p = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>;
            p(<span class="tok-str">&quot;  index len=0x{x} type={}\n&quot;</span>, .{ header.length(), header.capacityIndexType() });
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">if</span> (indexes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
            <span class="tok-kw">var</span> is_empty = <span class="tok-null">false</span>;
            <span class="tok-kw">for</span> (indexes, <span class="tok-number">0</span>..) |idx, i| {
                <span class="tok-kw">if</span> (idx.isEmpty()) {
                    is_empty = <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">if</span> (is_empty) {
                        is_empty = <span class="tok-null">false</span>;
                        p(<span class="tok-str">&quot;  ...\n&quot;</span>, .{});
                    }
                    p(<span class="tok-str">&quot;  [0x{x}]: [{}] +{}\n&quot;</span>, .{ i, idx.entry_index, idx.distance_from_start_index });
                }
            }
            <span class="tok-kw">if</span> (is_empty) {
                p(<span class="tok-str">&quot;  ...\n&quot;</span>, .{});
            }
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_list.ArrayList" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayList</span><a href="#src.zig-std.array_list.ArrayList">[src]</a></h2><div class="tldDocs"><p>A contiguous, growable list of items in memory.
This is a wrapper around an array of T values. Initialize with <code>init</code>.</p>
<p>This struct internally stores a <code><a href="std.mem.Allocator.html">std.mem.Allocator</a></code> for memory management.
To manually specify an allocator with each function call see <code><a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_list.ArrayListAligned.Slice" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Slice</span><a href="#src.zig-std.array_list.ArrayListAligned.Slice">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.Slice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">if</span> (alignment) |a| ([]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> []T</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.SentinelSlice" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">SentinelSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.SentinelSlice">[src]</a></h3><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>s: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.SentinelSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SentinelSlice</span>(<span class="tok-kw">comptime</span> s: T) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (alignment) |a| ([:s]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> [:s]T;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.array_list.ArrayListAligned.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for ArrayList(u8) &quot;</span> ++
        <span class="tok-str">&quot;but the given type is ArrayList(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;)&quot;</span>)
<span class="tok-kw">else</span>
    <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAligned.appendWrite">appendWrite</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.FixedWriter" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">FixedWriter</span><a href="#src.zig-std.array_list.ArrayListAligned.FixedWriter">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.FixedWriter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FixedWriter = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAligned.appendWriteFixed">appendWriteFixed</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>items: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a></code></pre><div class="fieldDocs"><p>Contents of the list. This field is intended to be accessed
directly.</p>
<p>Pointers to elements in this slice are invalidated by various
functions of this ArrayList in accordance with the respective
documentation. In all cases, &quot;invalidated&quot; means that the memory
has been passed to this allocator's resize or free function.</p>
</div></div><div><pre><code>capacity: <span class="tok-type">usize</span></code></pre><div class="fieldDocs"><p>How many T values this list can hold without allocating
additional memory.</p>
</div></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_list.ArrayListAligned.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_list.ArrayListAligned.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
        .items = &amp;[_]T{},
        .capacity = <span class="tok-number">0</span>,
        .allocator = allocator,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.initCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.initCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>Initialize with capacity to hold <code>num</code> elements.
The resulting capacity will equal <code>num</code> exactly.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>num: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.initCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
    <span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(num);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_list.ArrayListAligned.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release all allocated memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) &gt; <span class="tok-number">0</span>) {
        self.allocator.free(self.allocatedSlice());
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.fromOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.fromOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, slice: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>ArrayList takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>slice: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.fromOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, slice: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
        .items = slice,
        .capacity = slice.len,
        .allocator = allocator,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.fromOwnedSliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSliceSentinel</span><a href="#src.zig-std.array_list.ArrayListAligned.fromOwnedSliceSentinel">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>ArrayList takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>sentinel: T</code></pre></div><div><pre><code>slice: [:sentinel]T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.fromOwnedSliceSentinel">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
        .items = slice,
        .capacity = slice.len + <span class="tok-number">1</span>,
        .allocator = allocator,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.moveToUnmanaged" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">moveToUnmanaged</span><a href="#src.zig-std.array_list.ArrayListAligned.moveToUnmanaged">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">moveToUnmanaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment)</code></pre></div><div class="tldDocs"><p>Initializes an ArrayListUnmanaged with the <code>items</code> and <code>capacity</code> fields
of this ArrayList. Empties this ArrayList.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.moveToUnmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">moveToUnmanaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment) {
    <span class="tok-kw">const</span> allocator = self.allocator;
    <span class="tok-kw">const</span> result: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment) = .{ .items = self.items, .capacity = self.capacity };
    self.* = <a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.toOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.toOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a></code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. Empties this ArrayList.
Its capacity is cleared, making <code>deinit</code> safe but unnecessary to call.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.toOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a> {
    <span class="tok-kw">const</span> allocator = self.allocator;

    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (allocator.remap(old_memory, self.items.len)) |new_items| {
        self.* = <a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
        <span class="tok-kw">return</span> new_items;
    }

    <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, self.items.len);
    <span class="tok-builtin">@memcpy</span>(new_memory, self.items);
    self.clearAndFree();
    <span class="tok-kw">return</span> new_memory;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.toOwnedSliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSliceSentinel</span><a href="#src.zig-std.array_list.ArrayListAligned.toOwnedSliceSentinel">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.SentinelSlice">SentinelSlice</a>(sentinel)</code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. Empties this ArrayList.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>sentinel: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.toOwnedSliceSentinel">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.SentinelSlice">SentinelSlice</a>(sentinel) {<span class="tok-comment">
    // This addition can never overflow because `self.items` can never occupy the whole address space
    </span><span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(self.items.len + <span class="tok-number">1</span>);
    self.appendAssumeCapacity(sentinel);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.toOwnedSlice();
    <span class="tok-kw">return</span> result[<span class="tok-number">0</span> .. result.len - <span class="tok-number">1</span> :sentinel];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_list.ArrayListAligned.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this ArrayList, using the same allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">var</span> cloned = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAligned.initCapacity">initCapacity</a>(self.allocator, self.capacity);
    cloned.appendSliceAssumeCapacity(self.items);
    <span class="tok-kw">return</span> cloned;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.array_list.ArrayListAligned.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code>. Moves <code>list[i .. list.len]</code> to higher indices to make room.
If <code>i</code> is equal to the length of the list this operation is equivalent to append.
This operation is O(N).
Invalidates element pointers if additional memory is needed.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(i, <span class="tok-number">1</span>);
    dst[<span class="tok-number">0</span>] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.insertAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.insertAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code>. Moves <code>list[i .. list.len]</code> to higher indices to make room.
If <code>i</code> is equal to the length of the list this operation is
equivalent to appendAssumeCapacity.
This operation is O(N).
Asserts that there is enough capacity for the new item.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.insertAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
    self.items.len += <span class="tok-number">1</span>;

    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[i + <span class="tok-number">1</span> .. self.items.len], self.items[i .. self.items.len - <span class="tok-number">1</span>]);
    self.items[i] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAt</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Add <code>count</code> new elements at position <code>index</code>, which have
<code>undefined</code> values. Returns a slice pointing to the newly allocated
elements, which becomes invalid after various <code>ArrayList</code>
operations.
Invalidates pre-existing pointers to elements at and after <code>index</code>.
Invalidates all pre-existing element pointers if capacity must be
increased to accommodate the new elements.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> new_len = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, count);

    <span class="tok-kw">if</span> (self.capacity &gt;= new_len)
        <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned.addManyAtAssumeCapacity">addManyAtAssumeCapacity</a>(self, index, count);<span class="tok-comment">

    // Here we avoid copying allocated but unused bytes by
    // attempting a resize in place, and falling back to allocating
    // a new buffer and doing our own copy. With a realloc() call,
    // the allocator implementation would pointlessly copy our
    // extra capacity.
    </span><span class="tok-kw">const</span> new_capacity = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment).growCapacity(self.capacity, new_len);
    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (self.allocator.remap(old_memory, new_capacity)) |new_memory| {
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
        <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned.addManyAtAssumeCapacity">addManyAtAssumeCapacity</a>(self, index, count);
    }<span class="tok-comment">

    // Make a new allocation, avoiding `ensureTotalCapacity` in order
    // to avoid extra memory copies.
    </span><span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> self.allocator.alignedAlloc(T, alignment, new_capacity);
    <span class="tok-kw">const</span> to_move = self.items[index..];
    <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..index], self.items[<span class="tok-number">0</span>..index]);
    <span class="tok-builtin">@memcpy</span>(new_memory[index + count ..][<span class="tok-number">0</span>..to_move.len], to_move);
    self.allocator.free(old_memory);
    self.items = new_memory[<span class="tok-number">0</span>..new_len];
    self.capacity = new_memory.len;<span class="tok-comment">
    // The inserted elements at `new_memory[index..][0..count]` have
    // already been set to `undefined` by memory allocation.
    </span><span class="tok-kw">return</span> new_memory[index..][<span class="tok-number">0</span>..count];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAtAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAtAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAtAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T</code></pre></div><div class="tldDocs"><p>Add <code>count</code> new elements at position <code>index</code>, which have
<code>undefined</code> values. Returns a slice pointing to the newly allocated
elements, which becomes invalid after various <code>ArrayList</code>
operations.
Asserts that there is enough capacity for the new elements.
Invalidates pre-existing pointers to elements at and after <code>index</code>, but
does not invalidate any before that.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAtAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T {
    <span class="tok-kw">const</span> new_len = self.items.len + count;
    <a href="std.debug.html#std.debug.assert">assert</a>(self.capacity &gt;= new_len);
    <span class="tok-kw">const</span> to_move = self.items[index..];
    self.items.len = new_len;
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[index + count ..], to_move);
    <span class="tok-kw">const</span> result = self.items[index..][<span class="tok-number">0</span>..count];
    <span class="tok-builtin">@memset</span>(result, <span class="tok-null">undefined</span>);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.insertSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.insertSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert slice <code>items</code> at index <code>i</code> by moving <code>list[i .. list.len]</code> to make room.
This operation is O(N).
Invalidates pre-existing pointers to elements at and after <code>index</code>.
Invalidates all pre-existing element pointers if capacity must be
increased to accommodate the new elements.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.insertSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>,
    index: <span class="tok-type">usize</span>,
    items: []<span class="tok-kw">const</span> T,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(index, items.len);
    <span class="tok-builtin">@memcpy</span>(dst, items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.replaceRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRange</span><a href="#src.zig-std.array_list.ArrayListAligned.replaceRange">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks the list as necessary.
Invalidates element pointers if additional capacity is allocated.
Asserts that the range is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.replaceRange">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
    <span class="tok-kw">defer</span> self.* = unmanaged.toManaged(self.allocator);
    <span class="tok-kw">return</span> unmanaged.replaceRange(self.allocator, start, len, new_items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.replaceRangeAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRangeAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.replaceRangeAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks the list as necessary.
Never invalidates element pointers.
Asserts the capacity is enough for additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.replaceRangeAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
    <span class="tok-kw">defer</span> self.* = unmanaged.toManaged(self.allocator);
    <span class="tok-kw">return</span> unmanaged.replaceRangeAssumeCapacity(start, len, new_items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.array_list.ArrayListAligned.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extends the list by 1 element. Allocates more memory as necessary.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne();
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.appendAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extends the list by 1 element.
Never invalidates element pointers.
Asserts that the list can hold one additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <span class="tok-type">void</span> {
    self.addOneAssumeCapacity().* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_list.ArrayListAligned.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove the element at index <code>i</code>, shift elements after index
<code>i</code> forward, and return the removed element.
Invalidates element pointers to end of list.
This operation is O(N).
This preserves item order. Use <code>swapRemove</code> if order preservation is not important.
Asserts that the index is in bounds.
Asserts that the list is not empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">const</span> old_item = self.items[i];
    self.replaceRangeAssumeCapacity(i, <span class="tok-number">1</span>, &amp;.{});
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_list.ArrayListAligned.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Removes the element at the specified index and returns it.
The empty slot is filled from the end of the list.
This operation is O(1).
This may not preserve item order. Use <code>orderedRemove</code> if you need to preserve order.
Asserts that the list is not empty.
Asserts that the index is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">if</span> (self.items.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;

    <span class="tok-kw">const</span> old_item = self.items[i];
    self.items[i] = self.pop().?;
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.appendSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list. Allocates more
memory as necessary.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    self.appendSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.appendSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list.
Never invalidates element pointers.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">const</span> new_len = old_len + items.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    self.items.len = new_len;
    <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendUnalignedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendUnalignedSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.appendUnalignedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append an unaligned slice of items to the list. Allocates more
memory as necessary. Only call this function if calling
<code>appendSlice</code> instead would be a compile error.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendUnalignedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    self.appendUnalignedSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendUnalignedSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendUnalignedSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.appendUnalignedSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list.
Never invalidates element pointers.
This function is only needed when calling
<code>appendSliceAssumeCapacity</code> instead would be a compile error due to the
alignment of the <code>items</code> parameter.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendUnalignedSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">const</span> new_len = old_len + items.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    self.items.len = new_len;
    <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.array_list.ArrayListAligned.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Writer">Writer</a></code></pre></div><div class="tldDocs"><p>Initializes a Writer which will append to the list.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.fixedWriter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fixedWriter</span><a href="#src.zig-std.array_list.ArrayListAligned.fixedWriter">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.FixedWriter">FixedWriter</a></code></pre></div><div class="tldDocs"><p>Initializes a Writer which will append to the list but will return
<code>error.OutOfMemory</code> rather than increasing capacity.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.fixedWriter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.FixedWriter">FixedWriter</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendNTimes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimes</span><a href="#src.zig-std.array_list.ArrayListAligned.appendNTimes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the list <code>n</code> times.
Allocates more memory as necessary.
Invalidates element pointers if additional memory is needed.
The function is inline so that a comptime-known <code>value</code> parameter will
have a more optimal memset codegen in case it has a repeated byte pattern.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendNTimes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(old_len, n));
    <span class="tok-builtin">@memset</span>(self.items[old_len..self.items.len], value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendNTimesAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimesAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.appendNTimesAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the list <code>n</code> times.
Never invalidates element pointers.
The function is inline so that a comptime-known <code>value</code> parameter will
have a more optimal memset codegen in case it has a repeated byte pattern.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendNTimesAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_len = self.items.len + n;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    <span class="tok-builtin">@memset</span>(self.items.ptr[self.items.len..new_len], value);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.array_list.ArrayListAligned.resize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adjust the list length to <code>new_len</code>.
Additional elements contain the value <code>undefined</code>.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.resize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureTotalCapacity(new_len);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_list.ArrayListAligned.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce allocated capacity to <code>new_len</code>.
May invalidate element pointers.
Asserts that the new length is less than or equal to the previous length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
    unmanaged.shrinkAndFree(self.allocator, new_len);
    self.* = unmanaged.toManaged(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce length to <code>new_len</code>.
Invalidates element pointers for the elements <code>items[new_len..]</code>.
Asserts that the new length is less than or equal to the previous length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
    self.items.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_list.ArrayListAligned.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
    self.allocator.free(self.allocatedSlice());
    self.items.len = <span class="tok-number">0</span>;
    self.capacity = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>If the current capacity is less than <code>new_capacity</code>, this function will
modify the array so that it can hold at least <code>new_capacity</code> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> better_capacity = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment).growCapacity(self.capacity, new_capacity);
    <span class="tok-kw">return</span> self.ensureTotalCapacityPrecise(better_capacity);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.ensureTotalCapacityPrecise" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityPrecise</span><a href="#src.zig-std.array_list.ArrayListAligned.ensureTotalCapacityPrecise">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>If the current capacity is less than <code>new_capacity</code>, this function will
modify the array so that it can hold exactly <code>new_capacity</code> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.ensureTotalCapacityPrecise">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;<span class="tok-comment">

    // Here we avoid copying allocated but unused bytes by
    // attempting a resize in place, and falling back to allocating
    // a new buffer and doing our own copy. With a realloc() call,
    // the allocator implementation would pointlessly copy our
    // extra capacity.
    </span><span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (self.allocator.remap(old_memory, new_capacity)) |new_memory| {
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> self.allocator.alignedAlloc(T, alignment, new_capacity);
        <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..self.items.len], self.items);
        self.allocator.free(old_memory);
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold at least <code>additional_count</code> <strong>more</strong> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacity(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, additional_count));
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.expandToCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">expandToCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.expandToCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the array's length to match the full capacity that is already allocated.
The new elements have <code>undefined</code> values.
Never invalidates element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.expandToCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
    self.items.len = self.capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOne</span><a href="#src.zig-std.array_list.ArrayListAligned.addOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
The returned pointer becomes invalid when the list resized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {<span class="tok-comment">
    // This can never overflow because `self.items` can never occupy the whole address space
    </span><span class="tok-kw">const</span> newlen = self.items.len + <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> self.ensureTotalCapacity(newlen);
    <span class="tok-kw">return</span> self.addOneAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addOneAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOneAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.addOneAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) *T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
The returned pointer becomes invalid when the list is resized.
Never invalidates element pointers.
Asserts that the list can hold one additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addOneAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) *T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
    self.items.len += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> &amp;self.items[self.items.len - <span class="tok-number">1</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAsArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArray</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAsArray">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is an array pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.
Resizes list if <code>self.capacity</code> is not large enough.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAsArray">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T {
    <span class="tok-kw">const</span> prev_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAsArrayAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArrayAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAsArrayAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is an array pointing to the newly allocated elements.
Never invalidates element pointers.
The returned pointer becomes invalid when the list is resized.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAsArrayAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
    <span class="tok-kw">const</span> prev_len = self.items.len;
    self.items.len += n;
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAsSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAsSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.
Resizes list if <code>self.capacity</code> is not large enough.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAsSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> prev_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAsSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAsSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) []T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the newly allocated elements.
Never invalidates element pointers.
The returned pointer becomes invalid when the list is resized.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAsSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) []T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
    <span class="tok-kw">const</span> prev_len = self.items.len;
    self.items.len += n;
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_list.ArrayListAligned.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Remove and return the last element from the list, or return <code>null</code> if list is empty.
Invalidates element pointers to the removed element, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
    self.items.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.allocatedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocatedSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.allocatedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a></code></pre></div><div class="tldDocs"><p>Returns a slice of all the items plus the extra capacity, whose memory
contents are <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.allocatedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a> {<span class="tok-comment">
    // `items.len` is the length, not the capacity.
    </span><span class="tok-kw">return</span> self.items.ptr[<span class="tok-number">0</span>..self.capacity];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.unusedCapacitySlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unusedCapacitySlice</span><a href="#src.zig-std.array_list.ArrayListAligned.unusedCapacitySlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) []T</code></pre></div><div class="tldDocs"><p>Returns a slice of only the extra capacity after items.
This can be useful for writing directly into an ArrayList.
Note that such an operation must be followed up with a direct
modification of <code>self.items.len</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.unusedCapacitySlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) []T {
    <span class="tok-kw">return</span> self.allocatedSlice()[self.items.len..];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.getLast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLast</span><a href="#src.zig-std.array_list.ArrayListAligned.getLast">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) T</code></pre></div><div class="tldDocs"><p>Returns the last element from the list.
Asserts that the list is not empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.getLast">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) T {
    <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.getLastOrNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLastOrNull</span><a href="#src.zig-std.array_list.ArrayListAligned.getLastOrNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Returns the last element from the list, or <code>null</code> if list is empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.getLastOrNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.getLast();
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_list.ArrayList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(T, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_list.ArrayListAligned" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayListAligned</span><a href="#src.zig-std.array_list.ArrayListAligned">[src]</a></h2><div class="tldDocs"><p>A contiguous, growable list of arbitrarily aligned items in memory.
This is a wrapper around an array of T values aligned to <code>alignment</code>-byte
addresses. If the specified alignment is <code>null</code>, then <code>@alignOf(T)</code> is used.
Initialize with <code>init</code>.</p>
<p>This struct internally stores a <code><a href="std.mem.Allocator.html">std.mem.Allocator</a></code> for memory management.
To manually specify an allocator with each function call see <code><a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>alignment: ?<span class="tok-type">u29</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_list.ArrayListAligned.Slice" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Slice</span><a href="#src.zig-std.array_list.ArrayListAligned.Slice">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.Slice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">if</span> (alignment) |a| ([]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> []T</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.SentinelSlice" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">SentinelSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.SentinelSlice">[src]</a></h3><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>s: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.SentinelSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SentinelSlice</span>(<span class="tok-kw">comptime</span> s: T) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (alignment) |a| ([:s]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> [:s]T;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.array_list.ArrayListAligned.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for ArrayList(u8) &quot;</span> ++
        <span class="tok-str">&quot;but the given type is ArrayList(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;)&quot;</span>)
<span class="tok-kw">else</span>
    <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAligned.appendWrite">appendWrite</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.FixedWriter" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">FixedWriter</span><a href="#src.zig-std.array_list.ArrayListAligned.FixedWriter">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.FixedWriter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FixedWriter = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAligned.appendWriteFixed">appendWriteFixed</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>items: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a></code></pre><div class="fieldDocs"><p>Contents of the list. This field is intended to be accessed
directly.</p>
<p>Pointers to elements in this slice are invalidated by various
functions of this ArrayList in accordance with the respective
documentation. In all cases, &quot;invalidated&quot; means that the memory
has been passed to this allocator's resize or free function.</p>
</div></div><div><pre><code>capacity: <span class="tok-type">usize</span></code></pre><div class="fieldDocs"><p>How many T values this list can hold without allocating
additional memory.</p>
</div></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_list.ArrayListAligned.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_list.ArrayListAligned.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
        .items = &amp;[_]T{},
        .capacity = <span class="tok-number">0</span>,
        .allocator = allocator,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.initCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.initCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>Initialize with capacity to hold <code>num</code> elements.
The resulting capacity will equal <code>num</code> exactly.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>num: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.initCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
    <span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(num);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_list.ArrayListAligned.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release all allocated memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) &gt; <span class="tok-number">0</span>) {
        self.allocator.free(self.allocatedSlice());
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.fromOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.fromOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, slice: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>ArrayList takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>slice: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.fromOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, slice: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
        .items = slice,
        .capacity = slice.len,
        .allocator = allocator,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.fromOwnedSliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSliceSentinel</span><a href="#src.zig-std.array_list.ArrayListAligned.fromOwnedSliceSentinel">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>ArrayList takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>sentinel: T</code></pre></div><div><pre><code>slice: [:sentinel]T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.fromOwnedSliceSentinel">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
        .items = slice,
        .capacity = slice.len + <span class="tok-number">1</span>,
        .allocator = allocator,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.moveToUnmanaged" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">moveToUnmanaged</span><a href="#src.zig-std.array_list.ArrayListAligned.moveToUnmanaged">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">moveToUnmanaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment)</code></pre></div><div class="tldDocs"><p>Initializes an ArrayListUnmanaged with the <code>items</code> and <code>capacity</code> fields
of this ArrayList. Empties this ArrayList.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.moveToUnmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">moveToUnmanaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment) {
    <span class="tok-kw">const</span> allocator = self.allocator;
    <span class="tok-kw">const</span> result: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment) = .{ .items = self.items, .capacity = self.capacity };
    self.* = <a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.toOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.toOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a></code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. Empties this ArrayList.
Its capacity is cleared, making <code>deinit</code> safe but unnecessary to call.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.toOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a> {
    <span class="tok-kw">const</span> allocator = self.allocator;

    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (allocator.remap(old_memory, self.items.len)) |new_items| {
        self.* = <a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
        <span class="tok-kw">return</span> new_items;
    }

    <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, self.items.len);
    <span class="tok-builtin">@memcpy</span>(new_memory, self.items);
    self.clearAndFree();
    <span class="tok-kw">return</span> new_memory;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.toOwnedSliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSliceSentinel</span><a href="#src.zig-std.array_list.ArrayListAligned.toOwnedSliceSentinel">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.SentinelSlice">SentinelSlice</a>(sentinel)</code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. Empties this ArrayList.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>sentinel: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.toOwnedSliceSentinel">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.SentinelSlice">SentinelSlice</a>(sentinel) {<span class="tok-comment">
    // This addition can never overflow because `self.items` can never occupy the whole address space
    </span><span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(self.items.len + <span class="tok-number">1</span>);
    self.appendAssumeCapacity(sentinel);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.toOwnedSlice();
    <span class="tok-kw">return</span> result[<span class="tok-number">0</span> .. result.len - <span class="tok-number">1</span> :sentinel];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_list.ArrayListAligned.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this ArrayList, using the same allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
    <span class="tok-kw">var</span> cloned = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAligned.initCapacity">initCapacity</a>(self.allocator, self.capacity);
    cloned.appendSliceAssumeCapacity(self.items);
    <span class="tok-kw">return</span> cloned;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.array_list.ArrayListAligned.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code>. Moves <code>list[i .. list.len]</code> to higher indices to make room.
If <code>i</code> is equal to the length of the list this operation is equivalent to append.
This operation is O(N).
Invalidates element pointers if additional memory is needed.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(i, <span class="tok-number">1</span>);
    dst[<span class="tok-number">0</span>] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.insertAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.insertAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code>. Moves <code>list[i .. list.len]</code> to higher indices to make room.
If <code>i</code> is equal to the length of the list this operation is
equivalent to appendAssumeCapacity.
This operation is O(N).
Asserts that there is enough capacity for the new item.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.insertAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
    self.items.len += <span class="tok-number">1</span>;

    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[i + <span class="tok-number">1</span> .. self.items.len], self.items[i .. self.items.len - <span class="tok-number">1</span>]);
    self.items[i] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAt</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Add <code>count</code> new elements at position <code>index</code>, which have
<code>undefined</code> values. Returns a slice pointing to the newly allocated
elements, which becomes invalid after various <code>ArrayList</code>
operations.
Invalidates pre-existing pointers to elements at and after <code>index</code>.
Invalidates all pre-existing element pointers if capacity must be
increased to accommodate the new elements.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> new_len = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, count);

    <span class="tok-kw">if</span> (self.capacity &gt;= new_len)
        <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned.addManyAtAssumeCapacity">addManyAtAssumeCapacity</a>(self, index, count);<span class="tok-comment">

    // Here we avoid copying allocated but unused bytes by
    // attempting a resize in place, and falling back to allocating
    // a new buffer and doing our own copy. With a realloc() call,
    // the allocator implementation would pointlessly copy our
    // extra capacity.
    </span><span class="tok-kw">const</span> new_capacity = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment).growCapacity(self.capacity, new_len);
    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (self.allocator.remap(old_memory, new_capacity)) |new_memory| {
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
        <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned.addManyAtAssumeCapacity">addManyAtAssumeCapacity</a>(self, index, count);
    }<span class="tok-comment">

    // Make a new allocation, avoiding `ensureTotalCapacity` in order
    // to avoid extra memory copies.
    </span><span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> self.allocator.alignedAlloc(T, alignment, new_capacity);
    <span class="tok-kw">const</span> to_move = self.items[index..];
    <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..index], self.items[<span class="tok-number">0</span>..index]);
    <span class="tok-builtin">@memcpy</span>(new_memory[index + count ..][<span class="tok-number">0</span>..to_move.len], to_move);
    self.allocator.free(old_memory);
    self.items = new_memory[<span class="tok-number">0</span>..new_len];
    self.capacity = new_memory.len;<span class="tok-comment">
    // The inserted elements at `new_memory[index..][0..count]` have
    // already been set to `undefined` by memory allocation.
    </span><span class="tok-kw">return</span> new_memory[index..][<span class="tok-number">0</span>..count];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAtAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAtAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAtAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T</code></pre></div><div class="tldDocs"><p>Add <code>count</code> new elements at position <code>index</code>, which have
<code>undefined</code> values. Returns a slice pointing to the newly allocated
elements, which becomes invalid after various <code>ArrayList</code>
operations.
Asserts that there is enough capacity for the new elements.
Invalidates pre-existing pointers to elements at and after <code>index</code>, but
does not invalidate any before that.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAtAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T {
    <span class="tok-kw">const</span> new_len = self.items.len + count;
    <a href="std.debug.html#std.debug.assert">assert</a>(self.capacity &gt;= new_len);
    <span class="tok-kw">const</span> to_move = self.items[index..];
    self.items.len = new_len;
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[index + count ..], to_move);
    <span class="tok-kw">const</span> result = self.items[index..][<span class="tok-number">0</span>..count];
    <span class="tok-builtin">@memset</span>(result, <span class="tok-null">undefined</span>);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.insertSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.insertSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert slice <code>items</code> at index <code>i</code> by moving <code>list[i .. list.len]</code> to make room.
This operation is O(N).
Invalidates pre-existing pointers to elements at and after <code>index</code>.
Invalidates all pre-existing element pointers if capacity must be
increased to accommodate the new elements.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.insertSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>,
    index: <span class="tok-type">usize</span>,
    items: []<span class="tok-kw">const</span> T,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(index, items.len);
    <span class="tok-builtin">@memcpy</span>(dst, items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.replaceRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRange</span><a href="#src.zig-std.array_list.ArrayListAligned.replaceRange">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks the list as necessary.
Invalidates element pointers if additional capacity is allocated.
Asserts that the range is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.replaceRange">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
    <span class="tok-kw">defer</span> self.* = unmanaged.toManaged(self.allocator);
    <span class="tok-kw">return</span> unmanaged.replaceRange(self.allocator, start, len, new_items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.replaceRangeAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRangeAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.replaceRangeAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks the list as necessary.
Never invalidates element pointers.
Asserts the capacity is enough for additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.replaceRangeAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
    <span class="tok-kw">defer</span> self.* = unmanaged.toManaged(self.allocator);
    <span class="tok-kw">return</span> unmanaged.replaceRangeAssumeCapacity(start, len, new_items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.array_list.ArrayListAligned.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extends the list by 1 element. Allocates more memory as necessary.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne();
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.appendAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extends the list by 1 element.
Never invalidates element pointers.
Asserts that the list can hold one additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <span class="tok-type">void</span> {
    self.addOneAssumeCapacity().* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_list.ArrayListAligned.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove the element at index <code>i</code>, shift elements after index
<code>i</code> forward, and return the removed element.
Invalidates element pointers to end of list.
This operation is O(N).
This preserves item order. Use <code>swapRemove</code> if order preservation is not important.
Asserts that the index is in bounds.
Asserts that the list is not empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">const</span> old_item = self.items[i];
    self.replaceRangeAssumeCapacity(i, <span class="tok-number">1</span>, &amp;.{});
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_list.ArrayListAligned.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Removes the element at the specified index and returns it.
The empty slot is filled from the end of the list.
This operation is O(1).
This may not preserve item order. Use <code>orderedRemove</code> if you need to preserve order.
Asserts that the list is not empty.
Asserts that the index is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">if</span> (self.items.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;

    <span class="tok-kw">const</span> old_item = self.items[i];
    self.items[i] = self.pop().?;
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.appendSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list. Allocates more
memory as necessary.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    self.appendSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.appendSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list.
Never invalidates element pointers.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">const</span> new_len = old_len + items.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    self.items.len = new_len;
    <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendUnalignedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendUnalignedSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.appendUnalignedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append an unaligned slice of items to the list. Allocates more
memory as necessary. Only call this function if calling
<code>appendSlice</code> instead would be a compile error.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendUnalignedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    self.appendUnalignedSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendUnalignedSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendUnalignedSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.appendUnalignedSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list.
Never invalidates element pointers.
This function is only needed when calling
<code>appendSliceAssumeCapacity</code> instead would be a compile error due to the
alignment of the <code>items</code> parameter.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendUnalignedSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">const</span> new_len = old_len + items.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    self.items.len = new_len;
    <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.array_list.ArrayListAligned.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Writer">Writer</a></code></pre></div><div class="tldDocs"><p>Initializes a Writer which will append to the list.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.fixedWriter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fixedWriter</span><a href="#src.zig-std.array_list.ArrayListAligned.fixedWriter">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.FixedWriter">FixedWriter</a></code></pre></div><div class="tldDocs"><p>Initializes a Writer which will append to the list but will return
<code>error.OutOfMemory</code> rather than increasing capacity.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.fixedWriter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.FixedWriter">FixedWriter</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendNTimes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimes</span><a href="#src.zig-std.array_list.ArrayListAligned.appendNTimes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the list <code>n</code> times.
Allocates more memory as necessary.
Invalidates element pointers if additional memory is needed.
The function is inline so that a comptime-known <code>value</code> parameter will
have a more optimal memset codegen in case it has a repeated byte pattern.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendNTimes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(old_len, n));
    <span class="tok-builtin">@memset</span>(self.items[old_len..self.items.len], value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.appendNTimesAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimesAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.appendNTimesAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the list <code>n</code> times.
Never invalidates element pointers.
The function is inline so that a comptime-known <code>value</code> parameter will
have a more optimal memset codegen in case it has a repeated byte pattern.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.appendNTimesAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_len = self.items.len + n;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    <span class="tok-builtin">@memset</span>(self.items.ptr[self.items.len..new_len], value);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.array_list.ArrayListAligned.resize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adjust the list length to <code>new_len</code>.
Additional elements contain the value <code>undefined</code>.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.resize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureTotalCapacity(new_len);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_list.ArrayListAligned.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce allocated capacity to <code>new_len</code>.
May invalidate element pointers.
Asserts that the new length is less than or equal to the previous length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
    unmanaged.shrinkAndFree(self.allocator, new_len);
    self.* = unmanaged.toManaged(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce length to <code>new_len</code>.
Invalidates element pointers for the elements <code>items[new_len..]</code>.
Asserts that the new length is less than or equal to the previous length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
    self.items.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_list.ArrayListAligned.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
    self.allocator.free(self.allocatedSlice());
    self.items.len = <span class="tok-number">0</span>;
    self.capacity = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>If the current capacity is less than <code>new_capacity</code>, this function will
modify the array so that it can hold at least <code>new_capacity</code> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> better_capacity = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment).growCapacity(self.capacity, new_capacity);
    <span class="tok-kw">return</span> self.ensureTotalCapacityPrecise(better_capacity);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.ensureTotalCapacityPrecise" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityPrecise</span><a href="#src.zig-std.array_list.ArrayListAligned.ensureTotalCapacityPrecise">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>If the current capacity is less than <code>new_capacity</code>, this function will
modify the array so that it can hold exactly <code>new_capacity</code> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.ensureTotalCapacityPrecise">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;<span class="tok-comment">

    // Here we avoid copying allocated but unused bytes by
    // attempting a resize in place, and falling back to allocating
    // a new buffer and doing our own copy. With a realloc() call,
    // the allocator implementation would pointlessly copy our
    // extra capacity.
    </span><span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (self.allocator.remap(old_memory, new_capacity)) |new_memory| {
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> self.allocator.alignedAlloc(T, alignment, new_capacity);
        <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..self.items.len], self.items);
        self.allocator.free(old_memory);
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold at least <code>additional_count</code> <strong>more</strong> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacity(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, additional_count));
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.expandToCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">expandToCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.expandToCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the array's length to match the full capacity that is already allocated.
The new elements have <code>undefined</code> values.
Never invalidates element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.expandToCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
    self.items.len = self.capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOne</span><a href="#src.zig-std.array_list.ArrayListAligned.addOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
The returned pointer becomes invalid when the list resized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {<span class="tok-comment">
    // This can never overflow because `self.items` can never occupy the whole address space
    </span><span class="tok-kw">const</span> newlen = self.items.len + <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> self.ensureTotalCapacity(newlen);
    <span class="tok-kw">return</span> self.addOneAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addOneAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOneAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.addOneAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) *T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
The returned pointer becomes invalid when the list is resized.
Never invalidates element pointers.
Asserts that the list can hold one additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addOneAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) *T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
    self.items.len += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> &amp;self.items[self.items.len - <span class="tok-number">1</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAsArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArray</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAsArray">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is an array pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.
Resizes list if <code>self.capacity</code> is not large enough.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAsArray">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T {
    <span class="tok-kw">const</span> prev_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAsArrayAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArrayAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAsArrayAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is an array pointing to the newly allocated elements.
Never invalidates element pointers.
The returned pointer becomes invalid when the list is resized.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAsArrayAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
    <span class="tok-kw">const</span> prev_len = self.items.len;
    self.items.len += n;
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAsSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAsSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.
Resizes list if <code>self.capacity</code> is not large enough.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAsSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> prev_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.addManyAsSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAligned.addManyAsSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) []T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the newly allocated elements.
Never invalidates element pointers.
The returned pointer becomes invalid when the list is resized.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.addManyAsSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) []T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
    <span class="tok-kw">const</span> prev_len = self.items.len;
    self.items.len += n;
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_list.ArrayListAligned.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Remove and return the last element from the list, or return <code>null</code> if list is empty.
Invalidates element pointers to the removed element, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
    self.items.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.allocatedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocatedSlice</span><a href="#src.zig-std.array_list.ArrayListAligned.allocatedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a></code></pre></div><div class="tldDocs"><p>Returns a slice of all the items plus the extra capacity, whose memory
contents are <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.allocatedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a> {<span class="tok-comment">
    // `items.len` is the length, not the capacity.
    </span><span class="tok-kw">return</span> self.items.ptr[<span class="tok-number">0</span>..self.capacity];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.unusedCapacitySlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unusedCapacitySlice</span><a href="#src.zig-std.array_list.ArrayListAligned.unusedCapacitySlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) []T</code></pre></div><div class="tldDocs"><p>Returns a slice of only the extra capacity after items.
This can be useful for writing directly into an ArrayList.
Note that such an operation must be followed up with a direct
modification of <code>self.items.len</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.unusedCapacitySlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) []T {
    <span class="tok-kw">return</span> self.allocatedSlice()[self.items.len..];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.getLast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLast</span><a href="#src.zig-std.array_list.ArrayListAligned.getLast">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) T</code></pre></div><div class="tldDocs"><p>Returns the last element from the list.
Asserts that the list is not empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.getLast">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) T {
    <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAligned.getLastOrNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLastOrNull</span><a href="#src.zig-std.array_list.ArrayListAligned.getLastOrNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Returns the last element from the list, or <code>null</code> if list is empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned.getLastOrNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.getLast();
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_list.ArrayListAligned">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayListAligned</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (alignment) |a| {
        <span class="tok-kw">if</span> (a == <span class="tok-builtin">@alignOf</span>(T)) {
            <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(T, <span class="tok-null">null</span>);
        }
    }
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-comment">/// Contents of the list. This field is intended to be accessed</span>
        <span class="tok-comment">/// directly.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Pointers to elements in this slice are invalidated by various</span>
        <span class="tok-comment">/// functions of this ArrayList in accordance with the respective</span>
        <span class="tok-comment">/// documentation. In all cases, &quot;invalidated&quot; means that the memory</span>
        <span class="tok-comment">/// has been passed to this allocator's resize or free function.</span>
        items: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a>,
        <span class="tok-comment">/// How many T values this list can hold without allocating</span>
        <span class="tok-comment">/// additional memory.</span>
        capacity: <span class="tok-type">usize</span>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">if</span> (alignment) |a| ([]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> []T;

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SentinelSlice</span>(<span class="tok-kw">comptime</span> s: T) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (alignment) |a| ([:s]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> [:s]T;
        }

        <span class="tok-comment">/// Deinitialize with `deinit` or use `toOwnedSlice`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
            <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
                .items = &amp;[_]T{},
                .capacity = <span class="tok-number">0</span>,
                .allocator = allocator,
            };
        }

        <span class="tok-comment">/// Initialize with capacity to hold `num` elements.</span>
        <span class="tok-comment">/// The resulting capacity will equal `num` exactly.</span>
        <span class="tok-comment">/// Deinitialize with `deinit` or use `toOwnedSlice`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
            <span class="tok-kw">var</span> self = <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
            <span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(num);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// Release all allocated memory.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) &gt; <span class="tok-number">0</span>) {
                self.allocator.free(self.allocatedSlice());
            }
        }

        <span class="tok-comment">/// ArrayList takes ownership of the passed in slice. The slice must have been</span>
        <span class="tok-comment">/// allocated with `allocator`.</span>
        <span class="tok-comment">/// Deinitialize with `deinit` or use `toOwnedSlice`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, slice: <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
            <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
                .items = slice,
                .capacity = slice.len,
                .allocator = allocator,
            };
        }

        <span class="tok-comment">/// ArrayList takes ownership of the passed in slice. The slice must have been</span>
        <span class="tok-comment">/// allocated with `allocator`.</span>
        <span class="tok-comment">/// Deinitialize with `deinit` or use `toOwnedSlice`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
            <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>{
                .items = slice,
                .capacity = slice.len + <span class="tok-number">1</span>,
                .allocator = allocator,
            };
        }

        <span class="tok-comment">/// Initializes an ArrayListUnmanaged with the `items` and `capacity` fields</span>
        <span class="tok-comment">/// of this ArrayList. Empties this ArrayList.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">moveToUnmanaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment) {
            <span class="tok-kw">const</span> allocator = self.allocator;
            <span class="tok-kw">const</span> result: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment) = .{ .items = self.items, .capacity = self.capacity };
            self.* = <a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// The caller owns the returned memory. Empties this ArrayList.</span>
        <span class="tok-comment">/// Its capacity is cleared, making `deinit` safe but unnecessary to call.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a> {
            <span class="tok-kw">const</span> allocator = self.allocator;

            <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
            <span class="tok-kw">if</span> (allocator.remap(old_memory, self.items.len)) |new_items| {
                self.* = <a href="std.array_list.html#std.array_list.ArrayListAligned.init">init</a>(allocator);
                <span class="tok-kw">return</span> new_items;
            }

            <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, self.items.len);
            <span class="tok-builtin">@memcpy</span>(new_memory, self.items);
            self.clearAndFree();
            <span class="tok-kw">return</span> new_memory;
        }

        <span class="tok-comment">/// The caller owns the returned memory. Empties this ArrayList.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned.SentinelSlice">SentinelSlice</a>(sentinel) {<span class="tok-comment">
            // This addition can never overflow because `self.items` can never occupy the whole address space
            </span><span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(self.items.len + <span class="tok-number">1</span>);
            self.appendAssumeCapacity(sentinel);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.toOwnedSlice();
            <span class="tok-kw">return</span> result[<span class="tok-number">0</span> .. result.len - <span class="tok-number">1</span> :sentinel];
        }

        <span class="tok-comment">/// Creates a copy of this ArrayList, using the same allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a> {
            <span class="tok-kw">var</span> cloned = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAligned.initCapacity">initCapacity</a>(self.allocator, self.capacity);
            cloned.appendSliceAssumeCapacity(self.items);
            <span class="tok-kw">return</span> cloned;
        }

        <span class="tok-comment">/// Insert `item` at index `i`. Moves `list[i .. list.len]` to higher indices to make room.</span>
        <span class="tok-comment">/// If `i` is equal to the length of the list this operation is equivalent to append.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(i, <span class="tok-number">1</span>);
            dst[<span class="tok-number">0</span>] = item;
        }

        <span class="tok-comment">/// Insert `item` at index `i`. Moves `list[i .. list.len]` to higher indices to make room.</span>
        <span class="tok-comment">/// If `i` is equal to the length of the list this operation is</span>
        <span class="tok-comment">/// equivalent to appendAssumeCapacity.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-comment">/// Asserts that there is enough capacity for the new item.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
            self.items.len += <span class="tok-number">1</span>;

            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[i + <span class="tok-number">1</span> .. self.items.len], self.items[i .. self.items.len - <span class="tok-number">1</span>]);
            self.items[i] = item;
        }

        <span class="tok-comment">/// Add `count` new elements at position `index`, which have</span>
        <span class="tok-comment">/// `undefined` values. Returns a slice pointing to the newly allocated</span>
        <span class="tok-comment">/// elements, which becomes invalid after various `ArrayList`</span>
        <span class="tok-comment">/// operations.</span>
        <span class="tok-comment">/// Invalidates pre-existing pointers to elements at and after `index`.</span>
        <span class="tok-comment">/// Invalidates all pre-existing element pointers if capacity must be</span>
        <span class="tok-comment">/// increased to accommodate the new elements.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
            <span class="tok-kw">const</span> new_len = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, count);

            <span class="tok-kw">if</span> (self.capacity &gt;= new_len)
                <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned.addManyAtAssumeCapacity">addManyAtAssumeCapacity</a>(self, index, count);<span class="tok-comment">

            // Here we avoid copying allocated but unused bytes by
            // attempting a resize in place, and falling back to allocating
            // a new buffer and doing our own copy. With a realloc() call,
            // the allocator implementation would pointlessly copy our
            // extra capacity.
            </span><span class="tok-kw">const</span> new_capacity = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment).growCapacity(self.capacity, new_len);
            <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
            <span class="tok-kw">if</span> (self.allocator.remap(old_memory, new_capacity)) |new_memory| {
                self.items.ptr = new_memory.ptr;
                self.capacity = new_memory.len;
                <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAligned.addManyAtAssumeCapacity">addManyAtAssumeCapacity</a>(self, index, count);
            }<span class="tok-comment">

            // Make a new allocation, avoiding `ensureTotalCapacity` in order
            // to avoid extra memory copies.
            </span><span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> self.allocator.alignedAlloc(T, alignment, new_capacity);
            <span class="tok-kw">const</span> to_move = self.items[index..];
            <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..index], self.items[<span class="tok-number">0</span>..index]);
            <span class="tok-builtin">@memcpy</span>(new_memory[index + count ..][<span class="tok-number">0</span>..to_move.len], to_move);
            self.allocator.free(old_memory);
            self.items = new_memory[<span class="tok-number">0</span>..new_len];
            self.capacity = new_memory.len;<span class="tok-comment">
            // The inserted elements at `new_memory[index..][0..count]` have
            // already been set to `undefined` by memory allocation.
            </span><span class="tok-kw">return</span> new_memory[index..][<span class="tok-number">0</span>..count];
        }

        <span class="tok-comment">/// Add `count` new elements at position `index`, which have</span>
        <span class="tok-comment">/// `undefined` values. Returns a slice pointing to the newly allocated</span>
        <span class="tok-comment">/// elements, which becomes invalid after various `ArrayList`</span>
        <span class="tok-comment">/// operations.</span>
        <span class="tok-comment">/// Asserts that there is enough capacity for the new elements.</span>
        <span class="tok-comment">/// Invalidates pre-existing pointers to elements at and after `index`, but</span>
        <span class="tok-comment">/// does not invalidate any before that.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T {
            <span class="tok-kw">const</span> new_len = self.items.len + count;
            <a href="std.debug.html#std.debug.assert">assert</a>(self.capacity &gt;= new_len);
            <span class="tok-kw">const</span> to_move = self.items[index..];
            self.items.len = new_len;
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[index + count ..], to_move);
            <span class="tok-kw">const</span> result = self.items[index..][<span class="tok-number">0</span>..count];
            <span class="tok-builtin">@memset</span>(result, <span class="tok-null">undefined</span>);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Insert slice `items` at index `i` by moving `list[i .. list.len]` to make room.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-comment">/// Invalidates pre-existing pointers to elements at and after `index`.</span>
        <span class="tok-comment">/// Invalidates all pre-existing element pointers if capacity must be</span>
        <span class="tok-comment">/// increased to accommodate the new elements.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(
            self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>,
            index: <span class="tok-type">usize</span>,
            items: []<span class="tok-kw">const</span> T,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(index, items.len);
            <span class="tok-builtin">@memcpy</span>(dst, items);
        }

        <span class="tok-comment">/// Grows or shrinks the list as necessary.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional capacity is allocated.</span>
        <span class="tok-comment">/// Asserts that the range is in bounds.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
            <span class="tok-kw">defer</span> self.* = unmanaged.toManaged(self.allocator);
            <span class="tok-kw">return</span> unmanaged.replaceRange(self.allocator, start, len, new_items);
        }

        <span class="tok-comment">/// Grows or shrinks the list as necessary.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// Asserts the capacity is enough for additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
            <span class="tok-kw">defer</span> self.* = unmanaged.toManaged(self.allocator);
            <span class="tok-kw">return</span> unmanaged.replaceRangeAssumeCapacity(start, len, new_items);
        }

        <span class="tok-comment">/// Extends the list by 1 element. Allocates more memory as necessary.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne();
            new_item_ptr.* = item;
        }

        <span class="tok-comment">/// Extends the list by 1 element.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// Asserts that the list can hold one additional item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, item: T) <span class="tok-type">void</span> {
            self.addOneAssumeCapacity().* = item;
        }

        <span class="tok-comment">/// Remove the element at index `i`, shift elements after index</span>
        <span class="tok-comment">/// `i` forward, and return the removed element.</span>
        <span class="tok-comment">/// Invalidates element pointers to end of list.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-comment">/// This preserves item order. Use `swapRemove` if order preservation is not important.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds.</span>
        <span class="tok-comment">/// Asserts that the list is not empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
            <span class="tok-kw">const</span> old_item = self.items[i];
            self.replaceRangeAssumeCapacity(i, <span class="tok-number">1</span>, &amp;.{});
            <span class="tok-kw">return</span> old_item;
        }

        <span class="tok-comment">/// Removes the element at the specified index and returns it.</span>
        <span class="tok-comment">/// The empty slot is filled from the end of the list.</span>
        <span class="tok-comment">/// This operation is O(1).</span>
        <span class="tok-comment">/// This may not preserve item order. Use `orderedRemove` if you need to preserve order.</span>
        <span class="tok-comment">/// Asserts that the list is not empty.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
            <span class="tok-kw">if</span> (self.items.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;

            <span class="tok-kw">const</span> old_item = self.items[i];
            self.items[i] = self.pop().?;
            <span class="tok-kw">return</span> old_item;
        }

        <span class="tok-comment">/// Append the slice of items to the list. Allocates more</span>
        <span class="tok-comment">/// memory as necessary.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
            self.appendSliceAssumeCapacity(items);
        }

        <span class="tok-comment">/// Append the slice of items to the list.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.items.len;
            <span class="tok-kw">const</span> new_len = old_len + items.len;
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
            self.items.len = new_len;
            <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
        }

        <span class="tok-comment">/// Append an unaligned slice of items to the list. Allocates more</span>
        <span class="tok-comment">/// memory as necessary. Only call this function if calling</span>
        <span class="tok-comment">/// `appendSlice` instead would be a compile error.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
            self.appendUnalignedSliceAssumeCapacity(items);
        }

        <span class="tok-comment">/// Append the slice of items to the list.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// This function is only needed when calling</span>
        <span class="tok-comment">/// `appendSliceAssumeCapacity` instead would be a compile error due to the</span>
        <span class="tok-comment">/// alignment of the `items` parameter.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.items.len;
            <span class="tok-kw">const</span> new_len = old_len + items.len;
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
            self.items.len = new_len;
            <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for ArrayList(u8) &quot;</span> ++
                <span class="tok-str">&quot;but the given type is ArrayList(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;)&quot;</span>)
        <span class="tok-kw">else</span>
            <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAligned.appendWrite">appendWrite</a>);

        <span class="tok-comment">/// Initializes a Writer which will append to the list.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }

        <span class="tok-comment">/// Same as `append` except it returns the number of bytes written, which is always the same</span>
        <span class="tok-comment">/// as `m.len`. The purpose of this function existing is to match `std.io.Writer` API.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">appendWrite</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, m: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">usize</span> {
            <span class="tok-kw">try</span> self.appendSlice(m);
            <span class="tok-kw">return</span> m.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FixedWriter = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAligned.appendWriteFixed">appendWriteFixed</a>);

        <span class="tok-comment">/// Initializes a Writer which will append to the list but will return</span>
        <span class="tok-comment">/// `error.OutOfMemory` rather than increasing capacity.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.FixedWriter">FixedWriter</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }

        <span class="tok-comment">/// The purpose of this function existing is to match `std.io.Writer` API.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">appendWriteFixed</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, m: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> available_capacity = self.capacity - self.items.len;
            <span class="tok-kw">if</span> (m.len &gt; available_capacity)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;

            self.appendSliceAssumeCapacity(m);
            <span class="tok-kw">return</span> m.len;
        }

        <span class="tok-comment">/// Append a value to the list `n` times.</span>
        <span class="tok-comment">/// Allocates more memory as necessary.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-comment">/// The function is inline so that a comptime-known `value` parameter will</span>
        <span class="tok-comment">/// have a more optimal memset codegen in case it has a repeated byte pattern.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.items.len;
            <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(old_len, n));
            <span class="tok-builtin">@memset</span>(self.items[old_len..self.items.len], value);
        }

        <span class="tok-comment">/// Append a value to the list `n` times.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// The function is inline so that a comptime-known `value` parameter will</span>
        <span class="tok-comment">/// have a more optimal memset codegen in case it has a repeated byte pattern.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_len = self.items.len + n;
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
            <span class="tok-builtin">@memset</span>(self.items.ptr[self.items.len..new_len], value);
            self.items.len = new_len;
        }

        <span class="tok-comment">/// Adjust the list length to `new_len`.</span>
        <span class="tok-comment">/// Additional elements contain the value `undefined`.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureTotalCapacity(new_len);
            self.items.len = new_len;
        }

        <span class="tok-comment">/// Reduce allocated capacity to `new_len`.</span>
        <span class="tok-comment">/// May invalidate element pointers.</span>
        <span class="tok-comment">/// Asserts that the new length is less than or equal to the previous length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> unmanaged = self.moveToUnmanaged();
            unmanaged.shrinkAndFree(self.allocator, new_len);
            self.* = unmanaged.toManaged(self.allocator);
        }

        <span class="tok-comment">/// Reduce length to `new_len`.</span>
        <span class="tok-comment">/// Invalidates element pointers for the elements `items[new_len..]`.</span>
        <span class="tok-comment">/// Asserts that the new length is less than or equal to the previous length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);
            self.items.len = new_len;
        }

        <span class="tok-comment">/// Invalidates all element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
            self.items.len = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Invalidates all element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
            self.allocator.free(self.allocatedSlice());
            self.items.len = <span class="tok-number">0</span>;
            self.capacity = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// If the current capacity is less than `new_capacity`, this function will</span>
        <span class="tok-comment">/// modify the array so that it can hold at least `new_capacity` items.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
                self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> better_capacity = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, alignment).growCapacity(self.capacity, new_capacity);
            <span class="tok-kw">return</span> self.ensureTotalCapacityPrecise(better_capacity);
        }

        <span class="tok-comment">/// If the current capacity is less than `new_capacity`, this function will</span>
        <span class="tok-comment">/// modify the array so that it can hold exactly `new_capacity` items.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
                self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;<span class="tok-comment">

            // Here we avoid copying allocated but unused bytes by
            // attempting a resize in place, and falling back to allocating
            // a new buffer and doing our own copy. With a realloc() call,
            // the allocator implementation would pointlessly copy our
            // extra capacity.
            </span><span class="tok-kw">const</span> old_memory = self.allocatedSlice();
            <span class="tok-kw">if</span> (self.allocator.remap(old_memory, new_capacity)) |new_memory| {
                self.items.ptr = new_memory.ptr;
                self.capacity = new_memory.len;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> self.allocator.alignedAlloc(T, alignment, new_capacity);
                <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..self.items.len], self.items);
                self.allocator.free(old_memory);
                self.items.ptr = new_memory.ptr;
                self.capacity = new_memory.len;
            }
        }

        <span class="tok-comment">/// Modify the array so that it can hold at least `additional_count` **more** items.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ensureTotalCapacity(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, additional_count));
        }

        <span class="tok-comment">/// Increases the array's length to match the full capacity that is already allocated.</span>
        <span class="tok-comment">/// The new elements have `undefined` values.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <span class="tok-type">void</span> {
            self.items.len = self.capacity;
        }

        <span class="tok-comment">/// Increase length by 1, returning pointer to the new item.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list resized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {<span class="tok-comment">
            // This can never overflow because `self.items` can never occupy the whole address space
            </span><span class="tok-kw">const</span> newlen = self.items.len + <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> self.ensureTotalCapacity(newlen);
            <span class="tok-kw">return</span> self.addOneAssumeCapacity();
        }

        <span class="tok-comment">/// Increase length by 1, returning pointer to the new item.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// Asserts that the list can hold one additional item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) *T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
            self.items.len += <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> &amp;self.items[self.items.len - <span class="tok-number">1</span>];
        }

        <span class="tok-comment">/// Resize the array, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is an array pointing to the newly allocated elements.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Resizes list if `self.capacity` is not large enough.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T {
            <span class="tok-kw">const</span> prev_len = self.items.len;
            <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
            <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Resize the array, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is an array pointing to the newly allocated elements.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
            <span class="tok-kw">const</span> prev_len = self.items.len;
            self.items.len += n;
            <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Resize the array, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is a slice pointing to the newly allocated elements.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Resizes list if `self.capacity` is not large enough.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
            <span class="tok-kw">const</span> prev_len = self.items.len;
            <span class="tok-kw">try</span> self.resize(<span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
            <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Resize the array, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is a slice pointing to the newly allocated elements.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>, n: <span class="tok-type">usize</span>) []T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
            <span class="tok-kw">const</span> prev_len = self.items.len;
            self.items.len += n;
            <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Remove and return the last element from the list, or return `null` if list is empty.</span>
        <span class="tok-comment">/// Invalidates element pointers to the removed element, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T {
            <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
            self.items.len -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> val;
        }

        <span class="tok-comment">/// Returns a slice of all the items plus the extra capacity, whose memory</span>
        <span class="tok-comment">/// contents are `undefined`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned.Slice">Slice</a> {<span class="tok-comment">
            // `items.len` is the length, not the capacity.
            </span><span class="tok-kw">return</span> self.items.ptr[<span class="tok-number">0</span>..self.capacity];
        }

        <span class="tok-comment">/// Returns a slice of only the extra capacity after items.</span>
        <span class="tok-comment">/// This can be useful for writing directly into an ArrayList.</span>
        <span class="tok-comment">/// Note that such an operation must be followed up with a direct</span>
        <span class="tok-comment">/// modification of `self.items.len`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) []T {
            <span class="tok-kw">return</span> self.allocatedSlice()[self.items.len..];
        }

        <span class="tok-comment">/// Returns the last element from the list.</span>
        <span class="tok-comment">/// Asserts that the list is not empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) T {
            <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
            <span class="tok-kw">return</span> val;
        }

        <span class="tok-comment">/// Returns the last element from the list, or `null` if list is empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAligned">Self</a>) ?T {
            <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.getLast();
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_list.ArrayListAlignedUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayListAlignedUnmanaged</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged">[src]</a></h2><div class="tldDocs"><p>A contiguous, growable list of arbitrarily aligned items in memory.
This is a wrapper around an array of T values aligned to <code>alignment</code>-byte
addresses. If the specified alignment is <code>null</code>, then <code>@alignOf(T)</code> is used.</p>
<p>Functions that potentially allocate memory accept an <code><a href="std.mem.Allocator.html">Allocator</a></code> parameter.
Initialize directly or with <code>initCapacity</code>, and deinitialize with <code>deinit</code>
or use <code>toOwnedSlice</code>.</p>
<p>Default initialization of this struct is deprecated; use <code>.empty</code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>alignment: ?<span class="tok-type">u29</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.array_list.ArrayListAlignedUnmanaged.WriterContext.html">std.array_list.ArrayListAlignedUnmanaged.WriterContext</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.Slice" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Slice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.Slice">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.Slice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">if</span> (alignment) |a| ([]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> []T</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.SentinelSlice" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">SentinelSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">[src]</a></h3><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>s: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SentinelSlice</span>(<span class="tok-kw">comptime</span> s: T) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (alignment) |a| ([:s]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> [:s]T;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for ArrayList(u8) &quot;</span> ++
        <span class="tok-str">&quot;but the given type is ArrayList(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;)&quot;</span>)
<span class="tok-kw">else</span>
    <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(<a href="std.array_list.ArrayListAlignedUnmanaged.WriterContext.html">WriterContext</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.appendWrite">appendWrite</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.FixedWriter" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">FixedWriter</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.FixedWriter">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.FixedWriter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FixedWriter = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.appendWriteFixed">appendWriteFixed</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>items: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> = &amp;[_]T{}</code></pre><div class="fieldDocs"><p>Contents of the list. This field is intended to be accessed
directly.</p>
<p>Pointers to elements in this slice are invalidated by various
functions of this ArrayList in accordance with the respective
documentation. In all cases, &quot;invalidated&quot; means that the memory
has been passed to an allocator's resize or free function.</p>
</div></div><div><pre><code>capacity: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>How many T values this list can hold without allocating
additional memory.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>An ArrayList containing no elements.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> = .{
    .items = &amp;.{},
    .capacity = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.initCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.initCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Initialize with capacity to hold <code>num</code> elements.
The resulting capacity will equal <code>num</code> exactly.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>num: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.initCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{};
    <span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(allocator, num);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.initBuffer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initBuffer</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.initBuffer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initBuffer</span>(buffer: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Initialize with externally-managed memory. The buffer determines the
capacity, and the length is set to zero.
When initialized this way, all functions that accept an Allocator
argument cause illegal behavior.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>buffer: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.initBuffer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initBuffer</span>(buffer: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">return</span> .{
        .items = buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],
        .capacity = buffer.len,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release all allocated memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    allocator.free(self.allocatedSlice());
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.toManaged" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toManaged</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.toManaged">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(T, alignment)</code></pre></div><div class="tldDocs"><p>Convert this list into an analogous memory-managed one.
The returned list has ownership of the underlying memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.toManaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(T, alignment) {
    <span class="tok-kw">return</span> .{ .items = self.items, .capacity = self.capacity, .allocator = allocator };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.fromOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.fromOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(slice: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>ArrayListUnmanaged takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>slice: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.fromOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(slice: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{
        .items = slice,
        .capacity = slice.len,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.fromOwnedSliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSliceSentinel</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.fromOwnedSliceSentinel">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(<span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>ArrayListUnmanaged takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>sentinel: T</code></pre></div><div><pre><code>slice: [:sentinel]T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.fromOwnedSliceSentinel">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(<span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{
        .items = slice,
        .capacity = slice.len + <span class="tok-number">1</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.toOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.toOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a></code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. Empties this ArrayList.
Its capacity is cleared, making deinit() safe but unnecessary to call.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.toOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> {
    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (allocator.remap(old_memory, self.items.len)) |new_items| {
        self.* = .empty;
        <span class="tok-kw">return</span> new_items;
    }

    <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, self.items.len);
    <span class="tok-builtin">@memcpy</span>(new_memory, self.items);
    self.clearAndFree(allocator);
    <span class="tok-kw">return</span> new_memory;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.toOwnedSliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSliceSentinel</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.toOwnedSliceSentinel">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">SentinelSlice</a>(sentinel)</code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. ArrayList becomes empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>sentinel: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.toOwnedSliceSentinel">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">SentinelSlice</a>(sentinel) {<span class="tok-comment">
    // This addition can never overflow because `self.items` can never occupy the whole address space
    </span><span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(allocator, self.items.len + <span class="tok-number">1</span>);
    self.appendAssumeCapacity(sentinel);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.toOwnedSlice(allocator);
    <span class="tok-kw">return</span> result[<span class="tok-number">0</span> .. result.len - <span class="tok-number">1</span> :sentinel];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this ArrayList.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">var</span> cloned = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.initCapacity">initCapacity</a>(allocator, self.capacity);
    cloned.appendSliceAssumeCapacity(self.items);
    <span class="tok-kw">return</span> cloned;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code>. Moves <code>list[i .. list.len]</code> to higher indices to make room.
If <code>i</code> is equal to the length of the list this operation is equivalent to append.
This operation is O(N).
Invalidates element pointers if additional memory is needed.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(allocator, i, <span class="tok-number">1</span>);
    dst[<span class="tok-number">0</span>] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.insertAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.insertAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code>. Moves <code>list[i .. list.len]</code> to higher indices to make room.
If in<code> is equal to the length of the list this operation is equivalent to append.
This operation is O(N).
Asserts that the list has capacity for one additional item.
Asserts that the index is in bounds or equal to the length.</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.insertAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
    self.items.len += <span class="tok-number">1</span>;

    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[i + <span class="tok-number">1</span> .. self.items.len], self.items[i .. self.items.len - <span class="tok-number">1</span>]);
    self.items[i] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAt</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Add <code>count</code> new elements at position <code>index</code>, which have
<code>undefined</code> values. Returns a slice pointing to the newly allocated
elements, which becomes invalid after various <code>ArrayList</code>
operations.
Invalidates pre-existing pointers to elements at and after <code>index</code>.
Invalidates all pre-existing element pointers if capacity must be
increased to accommodate the new elements.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    index: <span class="tok-type">usize</span>,
    count: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">var</span> managed = self.toManaged(allocator);
    <span class="tok-kw">defer</span> self.* = managed.moveToUnmanaged();
    <span class="tok-kw">return</span> managed.addManyAt(index, count);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAtAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAtAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAtAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T</code></pre></div><div class="tldDocs"><p>Add <code>count</code> new elements at position <code>index</code>, which have
<code>undefined</code> values. Returns a slice pointing to the newly allocated
elements, which becomes invalid after various <code>ArrayList</code>
operations.
Invalidates pre-existing pointers to elements at and after <code>index</code>, but
does not invalidate any before that.
Asserts that the list has capacity for the additional items.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAtAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T {
    <span class="tok-kw">const</span> new_len = self.items.len + count;
    <a href="std.debug.html#std.debug.assert">assert</a>(self.capacity &gt;= new_len);
    <span class="tok-kw">const</span> to_move = self.items[index..];
    self.items.len = new_len;
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[index + count ..], to_move);
    <span class="tok-kw">const</span> result = self.items[index..][<span class="tok-number">0</span>..count];
    <span class="tok-builtin">@memset</span>(result, <span class="tok-null">undefined</span>);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.insertSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.insertSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert slice <code>items</code> at index <code>i</code> by moving <code>list[i .. list.len]</code> to make room.
This operation is O(N).
Invalidates pre-existing pointers to elements at and after <code>index</code>.
Invalidates all pre-existing element pointers if capacity must be
increased to accommodate the new elements.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.insertSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    index: <span class="tok-type">usize</span>,
    items: []<span class="tok-kw">const</span> T,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(
        allocator,
        index,
        items.len,
    );
    <span class="tok-builtin">@memcpy</span>(dst, items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.replaceRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRange</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.replaceRange">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks the list as necessary.
Invalidates element pointers if additional capacity is allocated.
Asserts that the range is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.replaceRange">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    start: <span class="tok-type">usize</span>,
    len: <span class="tok-type">usize</span>,
    new_items: []<span class="tok-kw">const</span> T,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> after_range = start + len;
    <span class="tok-kw">const</span> range = self.items[start..after_range];
    <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
        <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
        <span class="tok-kw">const</span> rest = new_items[range.len..];
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
        <span class="tok-kw">try</span> self.insertSlice(allocator, after_range, rest);
    } <span class="tok-kw">else</span> {
        self.replaceRangeAssumeCapacity(start, len, new_items);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.replaceRangeAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRangeAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.replaceRangeAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks the list as necessary.
Never invalidates element pointers.
Asserts the capacity is enough for additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.replaceRangeAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> after_range = start + len;
    <span class="tok-kw">const</span> range = self.items[start..after_range];

    <span class="tok-kw">if</span> (range.len == new_items.len)
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items)
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
        <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
        <span class="tok-kw">const</span> rest = new_items[range.len..];
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
        <span class="tok-kw">const</span> dst = self.addManyAtAssumeCapacity(after_range, rest.len);
        <span class="tok-builtin">@memcpy</span>(dst, rest);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> extra = range.len - new_items.len;
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(
            T,
            self.items[after_range - extra ..],
            self.items[after_range..],
        );
        <span class="tok-builtin">@memset</span>(self.items[self.items.len - extra ..], <span class="tok-null">undefined</span>);
        self.items.len -= extra;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the list by 1 element. Allocates more memory as necessary.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne(allocator);
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the list by 1 element.
Never invalidates element pointers.
Asserts that the list can hold one additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, item: T) <span class="tok-type">void</span> {
    self.addOneAssumeCapacity().* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove the element at index <code>i</code> from the list and return its value.
Invalidates pointers to the last element.
This operation is O(N).
Asserts that the list is not empty.
Asserts that the index is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">const</span> old_item = self.items[i];
    self.replaceRangeAssumeCapacity(i, <span class="tok-number">1</span>, &amp;.{});
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Removes the element at the specified index and returns it.
The empty slot is filled from the end of the list.
Invalidates pointers to last element.
This operation is O(1).
Asserts that the list is not empty.
Asserts that the index is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">if</span> (self.items.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;

    <span class="tok-kw">const</span> old_item = self.items[i];
    self.items[i] = self.pop().?;
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list. Allocates more
memory as necessary.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(allocator, items.len);
    self.appendSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">const</span> new_len = old_len + items.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    self.items.len = new_len;
    <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendUnalignedSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list. Allocates more
memory as necessary. Only call this function if a call to <code>appendSlice</code> instead would
be a compile error.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(allocator, items.len);
    self.appendUnalignedSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendUnalignedSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append an unaligned slice of items to the list.
Only call this function if a call to <code>appendSliceAssumeCapacity</code>
instead would be a compile error.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">const</span> new_len = old_len + items.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    self.items.len = new_len;
    <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Writer">Writer</a></code></pre></div><div class="tldDocs"><p>Initializes a Writer which will append to the list.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = .{ .self = self, .allocator = allocator } };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.fixedWriter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fixedWriter</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.fixedWriter">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.FixedWriter">FixedWriter</a></code></pre></div><div class="tldDocs"><p>Initializes a Writer which will append to the list but will return
<code>error.OutOfMemory</code> rather than increasing capacity.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.fixedWriter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.FixedWriter">FixedWriter</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendNTimes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimes</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendNTimes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the list <code>n</code> times.
Allocates more memory as necessary.
Invalidates element pointers if additional memory is needed.
The function is inline so that a comptime-known <code>value</code> parameter will
have a more optimal memset codegen in case it has a repeated byte pattern.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendNTimes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(old_len, n));
    <span class="tok-builtin">@memset</span>(self.items[old_len..self.items.len], value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendNTimesAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimesAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendNTimesAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the list <code>n</code> times.
Never invalidates element pointers.
The function is inline so that a comptime-known <code>value</code> parameter will
have better memset codegen in case it has a repeated byte pattern.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendNTimesAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_len = self.items.len + n;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    <span class="tok-builtin">@memset</span>(self.items.ptr[self.items.len..new_len], value);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.resize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adjust the list length to <code>new_len</code>.
Additional elements contain the value <code>undefined</code>.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.resize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureTotalCapacity(allocator, new_len);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce allocated capacity to <code>new_len</code>.
May invalidate element pointers.
Asserts that the new length is less than or equal to the previous length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);

    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        self.items.len = new_len;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (allocator.remap(old_memory, new_len)) |new_items| {
        self.capacity = new_items.len;
        self.items = new_items;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> new_memory = allocator.alignedAlloc(T, alignment, new_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; {<span class="tok-comment">
            // No problem, capacity is still correct then.
            </span>self.items.len = new_len;
            <span class="tok-kw">return</span>;
        },
    };

    <span class="tok-builtin">@memcpy</span>(new_memory, self.items[<span class="tok-number">0</span>..new_len]);
    allocator.free(old_memory);
    self.items = new_memory;
    self.capacity = new_memory.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce length to <code>new_len</code>.
Invalidates pointers to elements <code>items[new_len..]</code>.
Keeps capacity the same.
Asserts that the new length is less than or equal to the previous length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.items.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    allocator.free(self.allocatedSlice());
    self.items.len = <span class="tok-number">0</span>;
    self.capacity = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold at least <code>new_capacity</code> items.
Implements super-linear growth to achieve amortized O(1) append operations.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
    <span class="tok-kw">return</span> self.ensureTotalCapacityPrecise(gpa, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.growCapacity">growCapacity</a>(self.capacity, new_capacity));
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacityPrecise" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityPrecise</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacityPrecise">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>If the current capacity is less than <code>new_capacity</code>, this function will
modify the array so that it can hold exactly <code>new_capacity</code> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacityPrecise">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;<span class="tok-comment">

    // Here we avoid copying allocated but unused bytes by
    // attempting a resize in place, and falling back to allocating
    // a new buffer and doing our own copy. With a realloc() call,
    // the allocator implementation would pointlessly copy our
    // extra capacity.
    </span><span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (allocator.remap(old_memory, new_capacity)) |new_memory| {
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, new_capacity);
        <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..self.items.len], self.items);
        allocator.free(old_memory);
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_count: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold at least <code>additional_count</code> <strong>more</strong> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_count: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacity(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, additional_count));
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.expandToCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">expandToCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.expandToCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the array's length to match the full capacity that is already allocated.
The new elements have <code>undefined</code> values.
Never invalidates element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.expandToCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.items.len = self.capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOne</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
The returned element pointer becomes invalid when the list is resized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {<span class="tok-comment">
    // This can never overflow because `self.items` can never occupy the whole address space
    </span><span class="tok-kw">const</span> newlen = self.items.len + <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> self.ensureTotalCapacity(allocator, newlen);
    <span class="tok-kw">return</span> self.addOneAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addOneAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOneAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addOneAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) *T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
Never invalidates element pointers.
The returned element pointer becomes invalid when the list is resized.
Asserts that the list can hold one additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addOneAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) *T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);

    self.items.len += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> &amp;self.items[self.items.len - <span class="tok-number">1</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAsArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArray</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsArray">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is an array pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsArray">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T {
    <span class="tok-kw">const</span> prev_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAsArrayAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArrayAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsArrayAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is an array pointing to the newly allocated elements.
Never invalidates element pointers.
The returned pointer becomes invalid when the list is resized.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsArrayAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
    <span class="tok-kw">const</span> prev_len = self.items.len;
    self.items.len += n;
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAsSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.
Resizes list if <code>self.capacity</code> is not large enough.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> prev_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAsSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, n: <span class="tok-type">usize</span>) []T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the newly allocated elements.
Never invalidates element pointers.
The returned pointer becomes invalid when the list is resized.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, n: <span class="tok-type">usize</span>) []T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
    <span class="tok-kw">const</span> prev_len = self.items.len;
    self.items.len += n;
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Remove and return the last element from the list.
If the list is empty, returns <code>null</code>.
Invalidates pointers to last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
    self.items.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.allocatedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocatedSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.allocatedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a></code></pre></div><div class="tldDocs"><p>Returns a slice of all the items plus the extra capacity, whose memory
contents are <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.allocatedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> {
    <span class="tok-kw">return</span> self.items.ptr[<span class="tok-number">0</span>..self.capacity];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.unusedCapacitySlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unusedCapacitySlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.unusedCapacitySlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) []T</code></pre></div><div class="tldDocs"><p>Returns a slice of only the extra capacity after items.
This can be useful for writing directly into an ArrayList.
Note that such an operation must be followed up with a direct
modification of <code>self.items.len</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.unusedCapacitySlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) []T {
    <span class="tok-kw">return</span> self.allocatedSlice()[self.items.len..];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.getLast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLast</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.getLast">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) T</code></pre></div><div class="tldDocs"><p>Return the last element from the list.
Asserts that the list is not empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.getLast">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) T {
    <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.getLastOrNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLastOrNull</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.getLastOrNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Return the last element from the list, or
return <code>null</code> if list is empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.getLastOrNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.getLast();
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayListAlignedUnmanaged</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (alignment) |a| {
        <span class="tok-kw">if</span> (a == <span class="tok-builtin">@alignOf</span>(T)) {
            <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, <span class="tok-null">null</span>);
        }
    }
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-comment">/// Contents of the list. This field is intended to be accessed</span>
        <span class="tok-comment">/// directly.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Pointers to elements in this slice are invalidated by various</span>
        <span class="tok-comment">/// functions of this ArrayList in accordance with the respective</span>
        <span class="tok-comment">/// documentation. In all cases, &quot;invalidated&quot; means that the memory</span>
        <span class="tok-comment">/// has been passed to an allocator's resize or free function.</span>
        items: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> = &amp;[_]T{},
        <span class="tok-comment">/// How many T values this list can hold without allocating</span>
        <span class="tok-comment">/// additional memory.</span>
        capacity: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-comment">/// An ArrayList containing no elements.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> = .{
            .items = &amp;.{},
            .capacity = <span class="tok-number">0</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">if</span> (alignment) |a| ([]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> []T;

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SentinelSlice</span>(<span class="tok-kw">comptime</span> s: T) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (alignment) |a| ([:s]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> [:s]T;
        }

        <span class="tok-comment">/// Initialize with capacity to hold `num` elements.</span>
        <span class="tok-comment">/// The resulting capacity will equal `num` exactly.</span>
        <span class="tok-comment">/// Deinitialize with `deinit` or use `toOwnedSlice`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
            <span class="tok-kw">var</span> self = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{};
            <span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(allocator, num);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// Initialize with externally-managed memory. The buffer determines the</span>
        <span class="tok-comment">/// capacity, and the length is set to zero.</span>
        <span class="tok-comment">/// When initialized this way, all functions that accept an Allocator</span>
        <span class="tok-comment">/// argument cause illegal behavior.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initBuffer</span>(buffer: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
            <span class="tok-kw">return</span> .{
                .items = buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],
                .capacity = buffer.len,
            };
        }

        <span class="tok-comment">/// Release all allocated memory.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            allocator.free(self.allocatedSlice());
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Convert this list into an analogous memory-managed one.</span>
        <span class="tok-comment">/// The returned list has ownership of the underlying memory.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(T, alignment) {
            <span class="tok-kw">return</span> .{ .items = self.items, .capacity = self.capacity, .allocator = allocator };
        }

        <span class="tok-comment">/// ArrayListUnmanaged takes ownership of the passed in slice. The slice must have been</span>
        <span class="tok-comment">/// allocated with `allocator`.</span>
        <span class="tok-comment">/// Deinitialize with `deinit` or use `toOwnedSlice`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(slice: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
            <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{
                .items = slice,
                .capacity = slice.len,
            };
        }

        <span class="tok-comment">/// ArrayListUnmanaged takes ownership of the passed in slice. The slice must have been</span>
        <span class="tok-comment">/// allocated with `allocator`.</span>
        <span class="tok-comment">/// Deinitialize with `deinit` or use `toOwnedSlice`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(<span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
            <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{
                .items = slice,
                .capacity = slice.len + <span class="tok-number">1</span>,
            };
        }

        <span class="tok-comment">/// The caller owns the returned memory. Empties this ArrayList.</span>
        <span class="tok-comment">/// Its capacity is cleared, making deinit() safe but unnecessary to call.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> {
            <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
            <span class="tok-kw">if</span> (allocator.remap(old_memory, self.items.len)) |new_items| {
                self.* = .empty;
                <span class="tok-kw">return</span> new_items;
            }

            <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, self.items.len);
            <span class="tok-builtin">@memcpy</span>(new_memory, self.items);
            self.clearAndFree(allocator);
            <span class="tok-kw">return</span> new_memory;
        }

        <span class="tok-comment">/// The caller owns the returned memory. ArrayList becomes empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">SentinelSlice</a>(sentinel) {<span class="tok-comment">
            // This addition can never overflow because `self.items` can never occupy the whole address space
            </span><span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(allocator, self.items.len + <span class="tok-number">1</span>);
            self.appendAssumeCapacity(sentinel);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.toOwnedSlice(allocator);
            <span class="tok-kw">return</span> result[<span class="tok-number">0</span> .. result.len - <span class="tok-number">1</span> :sentinel];
        }

        <span class="tok-comment">/// Creates a copy of this ArrayList.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
            <span class="tok-kw">var</span> cloned = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.initCapacity">initCapacity</a>(allocator, self.capacity);
            cloned.appendSliceAssumeCapacity(self.items);
            <span class="tok-kw">return</span> cloned;
        }

        <span class="tok-comment">/// Insert `item` at index `i`. Moves `list[i .. list.len]` to higher indices to make room.</span>
        <span class="tok-comment">/// If `i` is equal to the length of the list this operation is equivalent to append.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(allocator, i, <span class="tok-number">1</span>);
            dst[<span class="tok-number">0</span>] = item;
        }

        <span class="tok-comment">/// Insert `item` at index `i`. Moves `list[i .. list.len]` to higher indices to make room.</span>
        <span class="tok-comment">/// If in` is equal to the length of the list this operation is equivalent to append.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-comment">/// Asserts that the list has capacity for one additional item.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
            self.items.len += <span class="tok-number">1</span>;

            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[i + <span class="tok-number">1</span> .. self.items.len], self.items[i .. self.items.len - <span class="tok-number">1</span>]);
            self.items[i] = item;
        }

        <span class="tok-comment">/// Add `count` new elements at position `index`, which have</span>
        <span class="tok-comment">/// `undefined` values. Returns a slice pointing to the newly allocated</span>
        <span class="tok-comment">/// elements, which becomes invalid after various `ArrayList`</span>
        <span class="tok-comment">/// operations.</span>
        <span class="tok-comment">/// Invalidates pre-existing pointers to elements at and after `index`.</span>
        <span class="tok-comment">/// Invalidates all pre-existing element pointers if capacity must be</span>
        <span class="tok-comment">/// increased to accommodate the new elements.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>(
            self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
            allocator: <a href="std.mem.Allocator.html">Allocator</a>,
            index: <span class="tok-type">usize</span>,
            count: <span class="tok-type">usize</span>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
            <span class="tok-kw">var</span> managed = self.toManaged(allocator);
            <span class="tok-kw">defer</span> self.* = managed.moveToUnmanaged();
            <span class="tok-kw">return</span> managed.addManyAt(index, count);
        }

        <span class="tok-comment">/// Add `count` new elements at position `index`, which have</span>
        <span class="tok-comment">/// `undefined` values. Returns a slice pointing to the newly allocated</span>
        <span class="tok-comment">/// elements, which becomes invalid after various `ArrayList`</span>
        <span class="tok-comment">/// operations.</span>
        <span class="tok-comment">/// Invalidates pre-existing pointers to elements at and after `index`, but</span>
        <span class="tok-comment">/// does not invalidate any before that.</span>
        <span class="tok-comment">/// Asserts that the list has capacity for the additional items.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T {
            <span class="tok-kw">const</span> new_len = self.items.len + count;
            <a href="std.debug.html#std.debug.assert">assert</a>(self.capacity &gt;= new_len);
            <span class="tok-kw">const</span> to_move = self.items[index..];
            self.items.len = new_len;
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[index + count ..], to_move);
            <span class="tok-kw">const</span> result = self.items[index..][<span class="tok-number">0</span>..count];
            <span class="tok-builtin">@memset</span>(result, <span class="tok-null">undefined</span>);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Insert slice `items` at index `i` by moving `list[i .. list.len]` to make room.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-comment">/// Invalidates pre-existing pointers to elements at and after `index`.</span>
        <span class="tok-comment">/// Invalidates all pre-existing element pointers if capacity must be</span>
        <span class="tok-comment">/// increased to accommodate the new elements.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds or equal to the length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(
            self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
            allocator: <a href="std.mem.Allocator.html">Allocator</a>,
            index: <span class="tok-type">usize</span>,
            items: []<span class="tok-kw">const</span> T,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(
                allocator,
                index,
                items.len,
            );
            <span class="tok-builtin">@memcpy</span>(dst, items);
        }

        <span class="tok-comment">/// Grows or shrinks the list as necessary.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional capacity is allocated.</span>
        <span class="tok-comment">/// Asserts that the range is in bounds.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(
            self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
            allocator: <a href="std.mem.Allocator.html">Allocator</a>,
            start: <span class="tok-type">usize</span>,
            len: <span class="tok-type">usize</span>,
            new_items: []<span class="tok-kw">const</span> T,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> after_range = start + len;
            <span class="tok-kw">const</span> range = self.items[start..after_range];
            <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
                <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
                <span class="tok-kw">const</span> rest = new_items[range.len..];
                <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
                <span class="tok-kw">try</span> self.insertSlice(allocator, after_range, rest);
            } <span class="tok-kw">else</span> {
                self.replaceRangeAssumeCapacity(start, len, new_items);
            }
        }

        <span class="tok-comment">/// Grows or shrinks the list as necessary.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// Asserts the capacity is enough for additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> after_range = start + len;
            <span class="tok-kw">const</span> range = self.items[start..after_range];

            <span class="tok-kw">if</span> (range.len == new_items.len)
                <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items)
            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
                <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
                <span class="tok-kw">const</span> rest = new_items[range.len..];
                <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
                <span class="tok-kw">const</span> dst = self.addManyAtAssumeCapacity(after_range, rest.len);
                <span class="tok-builtin">@memcpy</span>(dst, rest);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> extra = range.len - new_items.len;
                <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(
                    T,
                    self.items[after_range - extra ..],
                    self.items[after_range..],
                );
                <span class="tok-builtin">@memset</span>(self.items[self.items.len - extra ..], <span class="tok-null">undefined</span>);
                self.items.len -= extra;
            }
        }

        <span class="tok-comment">/// Extend the list by 1 element. Allocates more memory as necessary.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne(allocator);
            new_item_ptr.* = item;
        }

        <span class="tok-comment">/// Extend the list by 1 element.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// Asserts that the list can hold one additional item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, item: T) <span class="tok-type">void</span> {
            self.addOneAssumeCapacity().* = item;
        }

        <span class="tok-comment">/// Remove the element at index `i` from the list and return its value.</span>
        <span class="tok-comment">/// Invalidates pointers to the last element.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-comment">/// Asserts that the list is not empty.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T {
            <span class="tok-kw">const</span> old_item = self.items[i];
            self.replaceRangeAssumeCapacity(i, <span class="tok-number">1</span>, &amp;.{});
            <span class="tok-kw">return</span> old_item;
        }

        <span class="tok-comment">/// Removes the element at the specified index and returns it.</span>
        <span class="tok-comment">/// The empty slot is filled from the end of the list.</span>
        <span class="tok-comment">/// Invalidates pointers to last element.</span>
        <span class="tok-comment">/// This operation is O(1).</span>
        <span class="tok-comment">/// Asserts that the list is not empty.</span>
        <span class="tok-comment">/// Asserts that the index is in bounds.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T {
            <span class="tok-kw">if</span> (self.items.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;

            <span class="tok-kw">const</span> old_item = self.items[i];
            self.items[i] = self.pop().?;
            <span class="tok-kw">return</span> old_item;
        }

        <span class="tok-comment">/// Append the slice of items to the list. Allocates more</span>
        <span class="tok-comment">/// memory as necessary.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(allocator, items.len);
            self.appendSliceAssumeCapacity(items);
        }

        <span class="tok-comment">/// Append the slice of items to the list.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.items.len;
            <span class="tok-kw">const</span> new_len = old_len + items.len;
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
            self.items.len = new_len;
            <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
        }

        <span class="tok-comment">/// Append the slice of items to the list. Allocates more</span>
        <span class="tok-comment">/// memory as necessary. Only call this function if a call to `appendSlice` instead would</span>
        <span class="tok-comment">/// be a compile error.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(allocator, items.len);
            self.appendUnalignedSliceAssumeCapacity(items);
        }

        <span class="tok-comment">/// Append an unaligned slice of items to the list.</span>
        <span class="tok-comment">/// Only call this function if a call to `appendSliceAssumeCapacity`</span>
        <span class="tok-comment">/// instead would be a compile error.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.items.len;
            <span class="tok-kw">const</span> new_len = old_len + items.len;
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
            self.items.len = new_len;
            <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriterContext = <span class="tok-kw">struct</span> {
            self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
            allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for ArrayList(u8) &quot;</span> ++
                <span class="tok-str">&quot;but the given type is ArrayList(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;)&quot;</span>)
        <span class="tok-kw">else</span>
            <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(<a href="std.array_list.ArrayListAlignedUnmanaged.WriterContext.html">WriterContext</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.appendWrite">appendWrite</a>);

        <span class="tok-comment">/// Initializes a Writer which will append to the list.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = .{ .self = self, .allocator = allocator } };
        }

        <span class="tok-comment">/// Same as `append` except it returns the number of bytes written,</span>
        <span class="tok-comment">/// which is always the same as `m.len`. The purpose of this function</span>
        <span class="tok-comment">/// existing is to match `std.io.Writer` API.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">appendWrite</span>(context: <a href="std.array_list.ArrayListAlignedUnmanaged.WriterContext.html">WriterContext</a>, m: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">usize</span> {
            <span class="tok-kw">try</span> context.self.appendSlice(context.allocator, m);
            <span class="tok-kw">return</span> m.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FixedWriter = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.appendWriteFixed">appendWriteFixed</a>);

        <span class="tok-comment">/// Initializes a Writer which will append to the list but will return</span>
        <span class="tok-comment">/// `error.OutOfMemory` rather than increasing capacity.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.FixedWriter">FixedWriter</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }

        <span class="tok-comment">/// The purpose of this function existing is to match `std.io.Writer` API.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">appendWriteFixed</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, m: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> available_capacity = self.capacity - self.items.len;
            <span class="tok-kw">if</span> (m.len &gt; available_capacity)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;

            self.appendSliceAssumeCapacity(m);
            <span class="tok-kw">return</span> m.len;
        }

        <span class="tok-comment">/// Append a value to the list `n` times.</span>
        <span class="tok-comment">/// Allocates more memory as necessary.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-comment">/// The function is inline so that a comptime-known `value` parameter will</span>
        <span class="tok-comment">/// have a more optimal memset codegen in case it has a repeated byte pattern.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.items.len;
            <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(old_len, n));
            <span class="tok-builtin">@memset</span>(self.items[old_len..self.items.len], value);
        }

        <span class="tok-comment">/// Append a value to the list `n` times.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// The function is inline so that a comptime-known `value` parameter will</span>
        <span class="tok-comment">/// have better memset codegen in case it has a repeated byte pattern.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_len = self.items.len + n;
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
            <span class="tok-builtin">@memset</span>(self.items.ptr[self.items.len..new_len], value);
            self.items.len = new_len;
        }

        <span class="tok-comment">/// Adjust the list length to `new_len`.</span>
        <span class="tok-comment">/// Additional elements contain the value `undefined`.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureTotalCapacity(allocator, new_len);
            self.items.len = new_len;
        }

        <span class="tok-comment">/// Reduce allocated capacity to `new_len`.</span>
        <span class="tok-comment">/// May invalidate element pointers.</span>
        <span class="tok-comment">/// Asserts that the new length is less than or equal to the previous length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);

            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
                self.items.len = new_len;
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
            <span class="tok-kw">if</span> (allocator.remap(old_memory, new_len)) |new_items| {
                self.capacity = new_items.len;
                self.items = new_items;
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">const</span> new_memory = allocator.alignedAlloc(T, alignment, new_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; {<span class="tok-comment">
                    // No problem, capacity is still correct then.
                    </span>self.items.len = new_len;
                    <span class="tok-kw">return</span>;
                },
            };

            <span class="tok-builtin">@memcpy</span>(new_memory, self.items[<span class="tok-number">0</span>..new_len]);
            allocator.free(old_memory);
            self.items = new_memory;
            self.capacity = new_memory.len;
        }

        <span class="tok-comment">/// Reduce length to `new_len`.</span>
        <span class="tok-comment">/// Invalidates pointers to elements `items[new_len..]`.</span>
        <span class="tok-comment">/// Keeps capacity the same.</span>
        <span class="tok-comment">/// Asserts that the new length is less than or equal to the previous length.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);
            self.items.len = new_len;
        }

        <span class="tok-comment">/// Invalidates all element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.items.len = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Invalidates all element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            allocator.free(self.allocatedSlice());
            self.items.len = <span class="tok-number">0</span>;
            self.capacity = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Modify the array so that it can hold at least `new_capacity` items.</span>
        <span class="tok-comment">/// Implements super-linear growth to achieve amortized O(1) append operations.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span> self.ensureTotalCapacityPrecise(gpa, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.growCapacity">growCapacity</a>(self.capacity, new_capacity));
        }

        <span class="tok-comment">/// If the current capacity is less than `new_capacity`, this function will</span>
        <span class="tok-comment">/// modify the array so that it can hold exactly `new_capacity` items.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
                self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;<span class="tok-comment">

            // Here we avoid copying allocated but unused bytes by
            // attempting a resize in place, and falling back to allocating
            // a new buffer and doing our own copy. With a realloc() call,
            // the allocator implementation would pointlessly copy our
            // extra capacity.
            </span><span class="tok-kw">const</span> old_memory = self.allocatedSlice();
            <span class="tok-kw">if</span> (allocator.remap(old_memory, new_capacity)) |new_memory| {
                self.items.ptr = new_memory.ptr;
                self.capacity = new_memory.len;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, new_capacity);
                <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..self.items.len], self.items);
                allocator.free(old_memory);
                self.items.ptr = new_memory.ptr;
                self.capacity = new_memory.len;
            }
        }

        <span class="tok-comment">/// Modify the array so that it can hold at least `additional_count` **more** items.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
            self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
            allocator: <a href="std.mem.Allocator.html">Allocator</a>,
            additional_count: <span class="tok-type">usize</span>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ensureTotalCapacity(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, additional_count));
        }

        <span class="tok-comment">/// Increases the array's length to match the full capacity that is already allocated.</span>
        <span class="tok-comment">/// The new elements have `undefined` values.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.items.len = self.capacity;
        }

        <span class="tok-comment">/// Increase length by 1, returning pointer to the new item.</span>
        <span class="tok-comment">/// The returned element pointer becomes invalid when the list is resized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {<span class="tok-comment">
            // This can never overflow because `self.items` can never occupy the whole address space
            </span><span class="tok-kw">const</span> newlen = self.items.len + <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> self.ensureTotalCapacity(allocator, newlen);
            <span class="tok-kw">return</span> self.addOneAssumeCapacity();
        }

        <span class="tok-comment">/// Increase length by 1, returning pointer to the new item.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// The returned element pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Asserts that the list can hold one additional item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) *T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);

            self.items.len += <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> &amp;self.items[self.items.len - <span class="tok-number">1</span>];
        }

        <span class="tok-comment">/// Resize the array, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is an array pointing to the newly allocated elements.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T {
            <span class="tok-kw">const</span> prev_len = self.items.len;
            <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
            <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Resize the array, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is an array pointing to the newly allocated elements.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
            <span class="tok-kw">const</span> prev_len = self.items.len;
            self.items.len += n;
            <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Resize the array, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is a slice pointing to the newly allocated elements.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Resizes list if `self.capacity` is not large enough.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
            <span class="tok-kw">const</span> prev_len = self.items.len;
            <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
            <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Resize the array, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is a slice pointing to the newly allocated elements.</span>
        <span class="tok-comment">/// Never invalidates element pointers.</span>
        <span class="tok-comment">/// The returned pointer becomes invalid when the list is resized.</span>
        <span class="tok-comment">/// Asserts that the list can hold the additional items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, n: <span class="tok-type">usize</span>) []T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
            <span class="tok-kw">const</span> prev_len = self.items.len;
            self.items.len += n;
            <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Remove and return the last element from the list.</span>
        <span class="tok-comment">/// If the list is empty, returns `null`.</span>
        <span class="tok-comment">/// Invalidates pointers to last element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T {
            <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
            self.items.len -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> val;
        }

        <span class="tok-comment">/// Returns a slice of all the items plus the extra capacity, whose memory</span>
        <span class="tok-comment">/// contents are `undefined`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> {
            <span class="tok-kw">return</span> self.items.ptr[<span class="tok-number">0</span>..self.capacity];
        }

        <span class="tok-comment">/// Returns a slice of only the extra capacity after items.</span>
        <span class="tok-comment">/// This can be useful for writing directly into an ArrayList.</span>
        <span class="tok-comment">/// Note that such an operation must be followed up with a direct</span>
        <span class="tok-comment">/// modification of `self.items.len`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) []T {
            <span class="tok-kw">return</span> self.allocatedSlice()[self.items.len..];
        }

        <span class="tok-comment">/// Return the last element from the list.</span>
        <span class="tok-comment">/// Asserts that the list is not empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) T {
            <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
            <span class="tok-kw">return</span> val;
        }

        <span class="tok-comment">/// Return the last element from the list, or</span>
        <span class="tok-comment">/// return `null` if list is empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T {
            <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.getLast();
        }

        <span class="tok-kw">const</span> init_capacity = <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.cache_line">cache_line</a> / <span class="tok-builtin">@sizeOf</span>(T)));

        <span class="tok-comment">/// Called when memory growth is necessary. Returns a capacity larger than</span>
        <span class="tok-comment">/// minimum that grows super-linearly.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">growCapacity</span>(current: <span class="tok-type">usize</span>, minimum: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> new = current;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                new +|= new / <span class="tok-number">2</span> + <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.init_capacity">init_capacity</a>;
                <span class="tok-kw">if</span> (new &gt;= minimum)
                    <span class="tok-kw">return</span> new;
            }
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_list.ArrayListUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayListUnmanaged</span><a href="#src.zig-std.array_list.ArrayListUnmanaged">[src]</a></h2><div class="tldDocs"><p>An ArrayList, but the allocator is passed as a parameter to the relevant functions
rather than stored in the struct itself. The same allocator must be used throughout
the entire lifetime of an ArrayListUnmanaged. Initialize directly or with
<code>initCapacity</code>, and deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.array_list.ArrayListAlignedUnmanaged.WriterContext.html">std.array_list.ArrayListAlignedUnmanaged.WriterContext</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.Slice" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Slice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.Slice">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.Slice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">if</span> (alignment) |a| ([]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> []T</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.SentinelSlice" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">SentinelSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">[src]</a></h3><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>s: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SentinelSlice</span>(<span class="tok-kw">comptime</span> s: T) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (alignment) |a| ([:s]<span class="tok-kw">align</span>(a) T) <span class="tok-kw">else</span> [:s]T;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for ArrayList(u8) &quot;</span> ++
        <span class="tok-str">&quot;but the given type is ArrayList(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;)&quot;</span>)
<span class="tok-kw">else</span>
    <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(<a href="std.array_list.ArrayListAlignedUnmanaged.WriterContext.html">WriterContext</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.appendWrite">appendWrite</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.FixedWriter" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">FixedWriter</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.FixedWriter">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.FixedWriter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FixedWriter = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.appendWriteFixed">appendWriteFixed</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>items: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> = &amp;[_]T{}</code></pre><div class="fieldDocs"><p>Contents of the list. This field is intended to be accessed
directly.</p>
<p>Pointers to elements in this slice are invalidated by various
functions of this ArrayList in accordance with the respective
documentation. In all cases, &quot;invalidated&quot; means that the memory
has been passed to an allocator's resize or free function.</p>
</div></div><div><pre><code>capacity: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>How many T values this list can hold without allocating
additional memory.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>An ArrayList containing no elements.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> = .{
    .items = &amp;.{},
    .capacity = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.initCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.initCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Initialize with capacity to hold <code>num</code> elements.
The resulting capacity will equal <code>num</code> exactly.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>num: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.initCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, num: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{};
    <span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(allocator, num);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.initBuffer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initBuffer</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.initBuffer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initBuffer</span>(buffer: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Initialize with externally-managed memory. The buffer determines the
capacity, and the length is set to zero.
When initialized this way, all functions that accept an Allocator
argument cause illegal behavior.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>buffer: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.initBuffer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initBuffer</span>(buffer: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">return</span> .{
        .items = buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],
        .capacity = buffer.len,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release all allocated memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    allocator.free(self.allocatedSlice());
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.toManaged" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toManaged</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.toManaged">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(T, alignment)</code></pre></div><div class="tldDocs"><p>Convert this list into an analogous memory-managed one.
The returned list has ownership of the underlying memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.toManaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(T, alignment) {
    <span class="tok-kw">return</span> .{ .items = self.items, .capacity = self.capacity, .allocator = allocator };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.fromOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.fromOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(slice: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>ArrayListUnmanaged takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>slice: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.fromOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(slice: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{
        .items = slice,
        .capacity = slice.len,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.fromOwnedSliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSliceSentinel</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.fromOwnedSliceSentinel">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(<span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>ArrayListUnmanaged takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code> or use <code>toOwnedSlice</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>sentinel: T</code></pre></div><div><pre><code>slice: [:sentinel]T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.fromOwnedSliceSentinel">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSliceSentinel</span>(<span class="tok-kw">comptime</span> sentinel: T, slice: [:sentinel]T) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>{
        .items = slice,
        .capacity = slice.len + <span class="tok-number">1</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.toOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.toOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a></code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. Empties this ArrayList.
Its capacity is cleared, making deinit() safe but unnecessary to call.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.toOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> {
    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (allocator.remap(old_memory, self.items.len)) |new_items| {
        self.* = .empty;
        <span class="tok-kw">return</span> new_items;
    }

    <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, self.items.len);
    <span class="tok-builtin">@memcpy</span>(new_memory, self.items);
    self.clearAndFree(allocator);
    <span class="tok-kw">return</span> new_memory;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.toOwnedSliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSliceSentinel</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.toOwnedSliceSentinel">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">SentinelSlice</a>(sentinel)</code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. ArrayList becomes empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>sentinel: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.toOwnedSliceSentinel">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSliceSentinel</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> sentinel: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.SentinelSlice">SentinelSlice</a>(sentinel) {<span class="tok-comment">
    // This addition can never overflow because `self.items` can never occupy the whole address space
    </span><span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(allocator, self.items.len + <span class="tok-number">1</span>);
    self.appendAssumeCapacity(sentinel);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.toOwnedSlice(allocator);
    <span class="tok-kw">return</span> result[<span class="tok-number">0</span> .. result.len - <span class="tok-number">1</span> :sentinel];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this ArrayList.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a> {
    <span class="tok-kw">var</span> cloned = <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>.<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.initCapacity">initCapacity</a>(allocator, self.capacity);
    cloned.appendSliceAssumeCapacity(self.items);
    <span class="tok-kw">return</span> cloned;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code>. Moves <code>list[i .. list.len]</code> to higher indices to make room.
If <code>i</code> is equal to the length of the list this operation is equivalent to append.
This operation is O(N).
Invalidates element pointers if additional memory is needed.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, i: <span class="tok-type">usize</span>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(allocator, i, <span class="tok-number">1</span>);
    dst[<span class="tok-number">0</span>] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.insertAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.insertAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code>. Moves <code>list[i .. list.len]</code> to higher indices to make room.
If in<code> is equal to the length of the list this operation is equivalent to append.
This operation is O(N).
Asserts that the list has capacity for one additional item.
Asserts that the index is in bounds or equal to the length.</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.insertAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);
    self.items.len += <span class="tok-number">1</span>;

    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[i + <span class="tok-number">1</span> .. self.items.len], self.items[i .. self.items.len - <span class="tok-number">1</span>]);
    self.items[i] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAt</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Add <code>count</code> new elements at position <code>index</code>, which have
<code>undefined</code> values. Returns a slice pointing to the newly allocated
elements, which becomes invalid after various <code>ArrayList</code>
operations.
Invalidates pre-existing pointers to elements at and after <code>index</code>.
Invalidates all pre-existing element pointers if capacity must be
increased to accommodate the new elements.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAt</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    index: <span class="tok-type">usize</span>,
    count: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">var</span> managed = self.toManaged(allocator);
    <span class="tok-kw">defer</span> self.* = managed.moveToUnmanaged();
    <span class="tok-kw">return</span> managed.addManyAt(index, count);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAtAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAtAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAtAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T</code></pre></div><div class="tldDocs"><p>Add <code>count</code> new elements at position <code>index</code>, which have
<code>undefined</code> values. Returns a slice pointing to the newly allocated
elements, which becomes invalid after various <code>ArrayList</code>
operations.
Invalidates pre-existing pointers to elements at and after <code>index</code>, but
does not invalidate any before that.
Asserts that the list has capacity for the additional items.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAtAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAtAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, count: <span class="tok-type">usize</span>) []T {
    <span class="tok-kw">const</span> new_len = self.items.len + count;
    <a href="std.debug.html#std.debug.assert">assert</a>(self.capacity &gt;= new_len);
    <span class="tok-kw">const</span> to_move = self.items[index..];
    self.items.len = new_len;
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.items[index + count ..], to_move);
    <span class="tok-kw">const</span> result = self.items[index..][<span class="tok-number">0</span>..count];
    <span class="tok-builtin">@memset</span>(result, <span class="tok-null">undefined</span>);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.insertSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.insertSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert slice <code>items</code> at index <code>i</code> by moving <code>list[i .. list.len]</code> to make room.
This operation is O(N).
Invalidates pre-existing pointers to elements at and after <code>index</code>.
Invalidates all pre-existing element pointers if capacity must be
increased to accommodate the new elements.
Asserts that the index is in bounds or equal to the length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.insertSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    index: <span class="tok-type">usize</span>,
    items: []<span class="tok-kw">const</span> T,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dst = <span class="tok-kw">try</span> self.addManyAt(
        allocator,
        index,
        items.len,
    );
    <span class="tok-builtin">@memcpy</span>(dst, items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.replaceRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRange</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.replaceRange">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks the list as necessary.
Invalidates element pointers if additional capacity is allocated.
Asserts that the range is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.replaceRange">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    start: <span class="tok-type">usize</span>,
    len: <span class="tok-type">usize</span>,
    new_items: []<span class="tok-kw">const</span> T,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> after_range = start + len;
    <span class="tok-kw">const</span> range = self.items[start..after_range];
    <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
        <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
        <span class="tok-kw">const</span> rest = new_items[range.len..];
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
        <span class="tok-kw">try</span> self.insertSlice(allocator, after_range, rest);
    } <span class="tok-kw">else</span> {
        self.replaceRangeAssumeCapacity(start, len, new_items);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.replaceRangeAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRangeAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.replaceRangeAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks the list as necessary.
Never invalidates element pointers.
Asserts the capacity is enough for additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.replaceRangeAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRangeAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> after_range = start + len;
    <span class="tok-kw">const</span> range = self.items[start..after_range];

    <span class="tok-kw">if</span> (range.len == new_items.len)
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items)
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
        <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
        <span class="tok-kw">const</span> rest = new_items[range.len..];
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
        <span class="tok-kw">const</span> dst = self.addManyAtAssumeCapacity(after_range, rest.len);
        <span class="tok-builtin">@memcpy</span>(dst, rest);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> extra = range.len - new_items.len;
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(
            T,
            self.items[after_range - extra ..],
            self.items[after_range..],
        );
        <span class="tok-builtin">@memset</span>(self.items[self.items.len - extra ..], <span class="tok-null">undefined</span>);
        self.items.len -= extra;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the list by 1 element. Allocates more memory as necessary.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne(allocator);
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the list by 1 element.
Never invalidates element pointers.
Asserts that the list can hold one additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, item: T) <span class="tok-type">void</span> {
    self.addOneAssumeCapacity().* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove the element at index <code>i</code> from the list and return its value.
Invalidates pointers to the last element.
This operation is O(N).
Asserts that the list is not empty.
Asserts that the index is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">const</span> old_item = self.items[i];
    self.replaceRangeAssumeCapacity(i, <span class="tok-number">1</span>, &amp;.{});
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Removes the element at the specified index and returns it.
The empty slot is filled from the end of the list.
Invalidates pointers to last element.
This operation is O(1).
Asserts that the list is not empty.
Asserts that the index is in bounds.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">if</span> (self.items.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;

    <span class="tok-kw">const</span> old_item = self.items[i];
    self.items[i] = self.pop().?;
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list. Allocates more
memory as necessary.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(allocator, items.len);
    self.appendSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">const</span> new_len = old_len + items.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    self.items.len = new_len;
    <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendUnalignedSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the list. Allocates more
memory as necessary. Only call this function if a call to <code>appendSlice</code> instead would
be a compile error.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(allocator, items.len);
    self.appendUnalignedSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendUnalignedSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append an unaligned slice of items to the list.
Only call this function if a call to <code>appendSliceAssumeCapacity</code>
instead would be a compile error.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendUnalignedSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendUnalignedSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, items: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">const</span> new_len = old_len + items.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    self.items.len = new_len;
    <span class="tok-builtin">@memcpy</span>(self.items[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Writer">Writer</a></code></pre></div><div class="tldDocs"><p>Initializes a Writer which will append to the list.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = .{ .self = self, .allocator = allocator } };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.fixedWriter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fixedWriter</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.fixedWriter">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.FixedWriter">FixedWriter</a></code></pre></div><div class="tldDocs"><p>Initializes a Writer which will append to the list but will return
<code>error.OutOfMemory</code> rather than increasing capacity.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.fixedWriter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fixedWriter</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.FixedWriter">FixedWriter</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendNTimes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimes</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendNTimes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the list <code>n</code> times.
Allocates more memory as necessary.
Invalidates element pointers if additional memory is needed.
The function is inline so that a comptime-known <code>value</code> parameter will
have a more optimal memset codegen in case it has a repeated byte pattern.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendNTimes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: T, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(old_len, n));
    <span class="tok-builtin">@memset</span>(self.items[old_len..self.items.len], value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.appendNTimesAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimesAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.appendNTimesAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the list <code>n</code> times.
Never invalidates element pointers.
The function is inline so that a comptime-known <code>value</code> parameter will
have better memset codegen in case it has a repeated byte pattern.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.appendNTimesAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_len = self.items.len + n;
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    <span class="tok-builtin">@memset</span>(self.items.ptr[self.items.len..new_len], value);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.resize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adjust the list length to <code>new_len</code>.
Additional elements contain the value <code>undefined</code>.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.resize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureTotalCapacity(allocator, new_len);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce allocated capacity to <code>new_len</code>.
May invalidate element pointers.
Asserts that the new length is less than or equal to the previous length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);

    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        self.items.len = new_len;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (allocator.remap(old_memory, new_len)) |new_items| {
        self.capacity = new_items.len;
        self.items = new_items;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> new_memory = allocator.alignedAlloc(T, alignment, new_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; {<span class="tok-comment">
            // No problem, capacity is still correct then.
            </span>self.items.len = new_len;
            <span class="tok-kw">return</span>;
        },
    };

    <span class="tok-builtin">@memcpy</span>(new_memory, self.items[<span class="tok-number">0</span>..new_len]);
    allocator.free(old_memory);
    self.items = new_memory;
    self.capacity = new_memory.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce length to <code>new_len</code>.
Invalidates pointers to elements <code>items[new_len..]</code>.
Keeps capacity the same.
Asserts that the new length is less than or equal to the previous length.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);
    self.items.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.items.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    allocator.free(self.allocatedSlice());
    self.items.len = <span class="tok-number">0</span>;
    self.capacity = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold at least <code>new_capacity</code> items.
Implements super-linear growth to achieve amortized O(1) append operations.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
    <span class="tok-kw">return</span> self.ensureTotalCapacityPrecise(gpa, <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.growCapacity">growCapacity</a>(self.capacity, new_capacity));
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacityPrecise" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityPrecise</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacityPrecise">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>If the current capacity is less than <code>new_capacity</code>, this function will
modify the array so that it can hold exactly <code>new_capacity</code> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureTotalCapacityPrecise">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        self.capacity = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;<span class="tok-comment">

    // Here we avoid copying allocated but unused bytes by
    // attempting a resize in place, and falling back to allocating
    // a new buffer and doing our own copy. With a realloc() call,
    // the allocator implementation would pointlessly copy our
    // extra capacity.
    </span><span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">if</span> (allocator.remap(old_memory, new_capacity)) |new_memory| {
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> allocator.alignedAlloc(T, alignment, new_capacity);
        <span class="tok-builtin">@memcpy</span>(new_memory[<span class="tok-number">0</span>..self.items.len], self.items);
        allocator.free(old_memory);
        self.items.ptr = new_memory.ptr;
        self.capacity = new_memory.len;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>( self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_count: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold at least <code>additional_count</code> <strong>more</strong> items.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
    self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_count: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacity(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, additional_count));
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.expandToCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">expandToCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.expandToCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases the array's length to match the full capacity that is already allocated.
The new elements have <code>undefined</code> values.
Never invalidates element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.expandToCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">expandToCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.items.len = self.capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOne</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
The returned element pointer becomes invalid when the list is resized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {<span class="tok-comment">
    // This can never overflow because `self.items` can never occupy the whole address space
    </span><span class="tok-kw">const</span> newlen = self.items.len + <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> self.ensureTotalCapacity(allocator, newlen);
    <span class="tok-kw">return</span> self.addOneAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addOneAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOneAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addOneAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) *T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
Never invalidates element pointers.
The returned element pointer becomes invalid when the list is resized.
Asserts that the list can hold one additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addOneAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) *T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &lt; self.capacity);

    self.items.len += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> &amp;self.items[self.items.len - <span class="tok-number">1</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAsArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArray</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsArray">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is an array pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsArray">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*[n]T {
    <span class="tok-kw">const</span> prev_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAsArrayAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArrayAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsArrayAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is an array pointing to the newly allocated elements.
Never invalidates element pointers.
The returned pointer becomes invalid when the list is resized.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsArrayAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArrayAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) *[n]T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
    <span class="tok-kw">const</span> prev_len = self.items.len;
    self.items.len += n;
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAsSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.
Resizes list if <code>self.capacity</code> is not large enough.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> prev_len = self.items.len;
    <span class="tok-kw">try</span> self.resize(allocator, <span class="tok-kw">try</span> <a href="std.array_list.html#std.array_list.addOrOom">addOrOom</a>(self.items.len, n));
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.addManyAsSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSliceAssumeCapacity</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, n: <span class="tok-type">usize</span>) []T</code></pre></div><div class="tldDocs"><p>Resize the array, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the newly allocated elements.
Never invalidates element pointers.
The returned pointer becomes invalid when the list is resized.
Asserts that the list can hold the additional items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.addManyAsSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSliceAssumeCapacity</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>, n: <span class="tok-type">usize</span>) []T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len + n &lt;= self.capacity);
    <span class="tok-kw">const</span> prev_len = self.items.len;
    self.items.len += n;
    <span class="tok-kw">return</span> self.items[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Remove and return the last element from the list.
If the list is empty, returns <code>null</code>.
Invalidates pointers to last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
    self.items.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.allocatedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocatedSlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.allocatedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a></code></pre></div><div class="tldDocs"><p>Returns a slice of all the items plus the extra capacity, whose memory
contents are <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.allocatedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged.Slice">Slice</a> {
    <span class="tok-kw">return</span> self.items.ptr[<span class="tok-number">0</span>..self.capacity];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.unusedCapacitySlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unusedCapacitySlice</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.unusedCapacitySlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) []T</code></pre></div><div class="tldDocs"><p>Returns a slice of only the extra capacity after items.
This can be useful for writing directly into an ArrayList.
Note that such an operation must be followed up with a direct
modification of <code>self.items.len</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.unusedCapacitySlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) []T {
    <span class="tok-kw">return</span> self.allocatedSlice()[self.items.len..];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.getLast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLast</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.getLast">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) T</code></pre></div><div class="tldDocs"><p>Return the last element from the list.
Asserts that the list is not empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.getLast">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLast</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) T {
    <span class="tok-kw">const</span> val = self.items[self.items.len - <span class="tok-number">1</span>];
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_list.ArrayListAlignedUnmanaged.getLastOrNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLastOrNull</span><a href="#src.zig-std.array_list.ArrayListAlignedUnmanaged.getLastOrNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Return the last element from the list, or
return <code>null</code> if list is empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_list.ArrayListAlignedUnmanaged.getLastOrNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastOrNull</span>(self: <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.getLast();
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_list.ArrayListUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayListUnmanaged</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_list.html#std.array_list.ArrayListAlignedUnmanaged">ArrayListAlignedUnmanaged</a>(T, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.AutoArrayHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoArrayHashMap</span><a href="#src.zig-std.array_hash_map.AutoArrayHashMap">[src]</a></h2><div class="tldDocs"><p>An <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a></code> with default hash and equal functions.</p>
<p>See <code><a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a></code> for a description of the hash and equal implementations.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.AutoArrayHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoArrayHashMap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(K), !<a href="std.array_hash_map.html#std.array_hash_map.autoEqlIsCheap">autoEqlIsCheap</a>(K));
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.AutoArrayHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoArrayHashMapUnmanaged</span><a href="#src.zig-std.array_hash_map.AutoArrayHashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>An <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> with default hash and equal functions.</p>
<p>See <code><a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a></code> for a description of the hash and equal implementations.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">std.array_hash_map.ArrayHashMapUnmanaged.Entry</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">std.array_hash_map.ArrayHashMapUnmanaged.KV</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">std.array_hash_map.ArrayHashMapUnmanaged.Data</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">std.array_hash_map.ArrayHashMapUnmanaged.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.DataList" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMap type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{}</code></pre><div class="fieldDocs"><p>It is permitted to access this field directly.
After any modification to the keys, consider calling <code>reIndex</code>.</p>
</div></div><div><pre><code>index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>When entries length is less than <code>linear_scan_max</code>, this remains <code>null</code>.
Once entries length grows big enough, this field is allocated. There is
an IndexHeader followed by an array of Index(I) structs, where I is defined
by how many total indexes there are.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
    .entries = .{},
    .index_header = <span class="tok-null">null</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="tldDocs"><p>Convert from an unmanaged map to a managed map.  After calling this,
the promoted map should no longer be used.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = gpa,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    <span class="tok-kw">errdefer</span> self.deinit(gpa);
    <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>An empty <code>value_list</code> may be passed, in which case the values array becomes <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
    <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
    <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
        <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
        <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
    }
    <span class="tok-kw">try</span> self.reIndex(gpa);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.entries.deinit(gpa);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
    }
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.len = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">switch</span> (header.capacityIndexType()) {
            .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
            .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
            .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
        self.index_header = <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.entries.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
    <span class="tok-kw">return</span> self.entries.items(.key);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
    <span class="tok-kw">return</span> self.entries.items(.value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> .{
        .keys = slice.items(.key).ptr,
        .values = slice.items(.value).ptr,
        .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // &quot;If key exists this function cannot fail.&quot;
        </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            .found_existing = <span class="tok-null">true</span>,
            .index = index,
        };
    };
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
both the key and the value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = item_key,<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = i,
                };
            }
        }

        <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
        // The slice length changed, so we directly index the pointer.
        </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
            .found_existing = <span class="tok-null">false</span>,
            .index = index,
        };
    };

    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> res;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
        <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">return</span>;
        }
    }

    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
    <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
    <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

    <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
    self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
    self.index_header = new_header;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ctx: Context, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
    ctx: Context,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
    <span class="tok-kw">const</span> indexes_cap = header.capacity();
    <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
        .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
        // workaround for #6974
        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> i;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    };
    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // workaround for #6974
    </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> &amp;self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but is allocated
with the provided allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
    <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

    <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
        // TODO: I'm pretty sure this could be memcpy'd instead of
        // doing all this work.
        </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
        other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
        other.index_header = new_header;
    }
    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Recompute all hashes.
    </span><span class="tok-kw">if</span> (store_hash) {
        <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            hash.* = h;
        }
    }
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify an entry's key without reordering any entries.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
    key_ptr.* = new_key;
    <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses a stable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstable</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses an unstable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstableContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkRetainingCapacity(new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFreeContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacityContext</code> can be used
instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkAndFree(gpa, new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.popContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (self.index_header) |header|
        self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    self.entries.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> .{
        .key = item.key,
        .value = item.value,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.AutoArrayHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoArrayHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(K), !<a href="std.array_hash_map.html#std.array_hash_map.autoEqlIsCheap">autoEqlIsCheap</a>(K));
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.AutoHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoHashMap</span><a href="#src.zig-std.hash_map.AutoHashMap">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMap.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.hash_map.HashMap.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The type of the unmanaged hash map underlying this wrapper</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMap.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.hash_map.HashMap.Entry">[src]</a></h3><div class="tldDocs"><p>An entry, containing pointers to a key and value stored in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.hash_map.HashMap.KV">[src]</a></h3><div class="tldDocs"><p>A copy of a key and value which are no longer in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMap.Hash">[src]</a></h3><div class="tldDocs"><p>The integer type that is the result of hashing</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.hash_map.HashMap.Iterator">[src]</a></h3><div class="tldDocs"><p>The iterator type returned by iterator()</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KeyIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMap.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ValueIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMap.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Size" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMap.Size">[src]</a></h3><div class="tldDocs"><p>The integer type used to store the size of the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.hash_map.HashMap.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>The type returned from getOrPut and variants</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMap.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.hash_map.HashMap.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with an empty context.
If the context is not zero-sized, you must use
initContext(allocator, ctx) instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
    }
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
    </span>};
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.hash_map.HashMap.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with a context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMap.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMap.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMap.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release the backing array and invalidate this map.
This does <em>not</em> deinit keys, values, or the context!
If your keys or values need to be released, ensure
that that is done before calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMap.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map, but keep the backing allocation for future use.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMap.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map and release the backing allocation.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMap.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Return the number of items in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMap.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the entries in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMap.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the keys in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.keyIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMap.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the values in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.valueIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMap.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMap.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMap.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMap.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMap.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMap.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes a value from the map and returns the removed kv pair.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMap.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMap.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Finds the value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMap.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMap.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMap.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Finds the actual key associated with an adapted key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMap.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds the key and value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMap.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMap.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check if the map contains a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMap.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMap.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMap.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMap.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
    self.unmanaged.removeByPtr(key_ptr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMap.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using the same allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>( self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
    self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
    new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    new_ctx: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMap.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMap.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.rehash(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.AutoHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoHashMap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <a href="std.hash_map.html#std.hash_map.AutoContext">AutoContext</a>(K), <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.AutoHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoHashMapUnmanaged</span><a href="#src.zig-std.hash_map.AutoHashMapUnmanaged">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.hash_map.HashMapUnmanaged.Entry.html">std.hash_map.HashMapUnmanaged.Entry</a></li><li><a href="std.hash_map.HashMapUnmanaged.KV.html">std.hash_map.HashMapUnmanaged.KV</a></li><li><a href="std.hash_map.HashMapUnmanaged.Iterator.html">std.hash_map.HashMapUnmanaged.Iterator</a></li><li><a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">std.hash_map.HashMapUnmanaged.GetOrPutResult</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Size" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Size">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Hash">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.KeyIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ValueIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Managed">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Pointer to the metadata.</p>
</div></div><div><pre><code>size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Current number of elements in the hashmap.</p>
</div></div><div><pre><code>available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Number of available slots before a grow is needed to satisfy the
<code>max_load_percentage</code>.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
    .metadata = <span class="tok-null">null</span>,
    .size = <span class="tok-number">0</span>,
    .available = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.deallocate(allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (new_size &gt; self.size)
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (self.metadata) |_| {
        self.initMetadatas();
        self.size = <span class="tok-number">0</span>;
        self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    self.deallocate(allocator);
    self.size = <span class="tok-number">0</span>;
    self.available = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">return</span> self.size;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">return</span> self.header().capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{ .hm = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.keys(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.values(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
    }
    self.putAssumeCapacityNoClobberContext(key, value, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    gop.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present,
and that no allocation is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

    <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

    <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
    self.available -= <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    self.keys()[idx] = key;
    self.values()[idx] = value;

    self.size += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
        <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
        <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = old_key.*,
            .value = old_val.*,
        };
        self.metadata.?[idx].remove();
        old_key.* = <span class="tok-null">undefined</span>;
        old_val.* = <span class="tok-null">undefined</span>;
        self.size -= <span class="tok-number">1</span>;
        self.available += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
            .key_ptr = &amp;self.keys()[idx],
            .value_ptr = &amp;self.values()[idx],
        };
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry if the associated key is not already present, otherwise update preexisting value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Get a copy of the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Get a copy of the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // If allocation fails, try to do the lookup anyway.
            // If we find an existing item, we can return it.
            // Otherwise return the error, we could not add another.
            </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = &amp;self.keys()[index],
                .value_ptr = &amp;self.values()[index],
                .found_existing = <span class="tok-null">true</span>,
            };
        };
    }
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!result.found_existing) {
        result.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

    // If you get a compile error on this line, it means that your generic hash
    // function is invalid for these parameters.
    </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    <span class="tok-kw">var</span> limit = self.capacity();
    <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

    <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
    </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
            <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
            // If you get a compile error on this line, it means that your generic eql
            // function is invalid for these parameters.

            </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = test_key,
                    .value_ptr = &amp;self.values()[idx],
                    .found_existing = <span class="tok-null">true</span>,
                };
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
            first_tombstone_idx = idx;
        }

        limit -= <span class="tok-number">1</span>;
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
        // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
        </span>idx = first_tombstone_idx;
        metadata = self.metadata.? + idx;
    }<span class="tok-comment">
    // We're using a slot previously free or a tombstone.
    </span>self.available -= <span class="tok-number">1</span>;

    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
    <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
    new_key.* = <span class="tok-null">undefined</span>;
    new_value.* = <span class="tok-null">undefined</span>;
    self.size += <span class="tok-number">1</span>;

    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
        .key_ptr = new_key,
        .value_ptr = new_value,
        .found_existing = <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Return true if there is a value associated with key in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        self.removeByIndex(idx);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
    // TODO: replace with pointer subtraction once supported by zig
    // if @sizeOf(K) == 0 then there is at most one item in the hash
    // map, which is assumed to exist as key_ptr must be valid.  This
    // item must be at index 0.
    </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
        (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;

    self.removeByIndex(idx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
    <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> other;

    <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
    <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
    other.initMetadatas();
    other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

    <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">const</span> keys_ptr = self.keys();
    <span class="tok-kw">const</span> values_ptr = self.values();
    <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (metadata[i].isUsed()) {
            other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
            <span class="tok-kw">if</span> (other.size == self.size)
                <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">var</span> keys_ptr = self.keys();
    <span class="tok-kw">var</span> values_ptr = self.values();
    <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

    // While we are re-hashing every slot, we will use the
    // fingerprint to mark used buckets as being used and either free
    // (needing to be rehashed) or tombstone (already rehashed).

    </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
    }<span class="tok-comment">

    // Now iterate over all the buckets, rehashing them

    </span>curr = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
        <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            curr += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
        <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
        <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

        // For each bucket, rehash to an index:
        // 1) before the cursor, probed into a free slot, or
        // 2) equal to the cursor, no need to move, or
        // 3) ahead of the cursor, probing over already rehashed

        </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
            (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
        {
            idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        }

        <span class="tok-kw">if</span> (idx &lt; curr) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
            metadata[idx].fill(fingerprint);
            keys_ptr[idx] = keys_ptr[curr];
            values_ptr[idx] = values_ptr[curr];

            metadata[curr].used = <span class="tok-number">0</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            keys_ptr[curr] = <span class="tok-null">undefined</span>;
            values_ptr[curr] = <span class="tok-null">undefined</span>;

            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
            metadata[idx].fingerprint = fingerprint;
            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
            metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
            } <span class="tok-kw">else</span> {
                metadata[idx].used = <span class="tok-number">1</span>;
                keys_ptr[idx] = keys_ptr[curr];
                values_ptr[idx] = values_ptr[curr];

                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                metadata[curr].used = <span class="tok-number">0</span>;
                keys_ptr[curr] = <span class="tok-null">undefined</span>;
                values_ptr[curr] = <span class="tok-null">undefined</span>;

                curr += <span class="tok-number">1</span>;
            }
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.AutoHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <a href="std.hash_map.html#std.hash_map.AutoContext">AutoContext</a>(K), <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.bounded_array.BoundedArray" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">BoundedArray</span><a href="#src.zig-std.bounded_array.BoundedArray">[src]</a></h2><div class="tldDocs"><p>A structure with an array and a length, that can be used as a slice.</p>
<p>Useful to pass around small arrays whose exact size is only known at
runtime, but whose maximum size is known at comptime, without requiring
an <code>Allocator</code>.</p>
<pre><code>var actual_size = 32;
var a = try BoundedArray(u8, 64).init(actual_size);
var slice = a.slice(); // a slice of the 64-byte array
var a_clone = a; // creates a copy - the structure doesn't use any internal pointers
</code></pre>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for BoundedArray(u8, ...) &quot;</span> ++
        <span class="tok-str">&quot;but the given type is BoundedArray(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;, ...)&quot;</span>)
<span class="tok-kw">else</span>
    <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, <span class="tok-kw">error</span>{Overflow}, <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.appendWrite">appendWrite</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>buffer: [buffer_capacity]T <span class="tok-kw">align</span>(alignment) = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div class="tldDocs"><p>Set the actual length of the slice.
Returns error.Overflow if it exceeds the length of the backing array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a> {
    <span class="tok-kw">if</span> (len &gt; buffer_capacity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    <span class="tok-kw">return</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>{ .len = len };
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.slice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">slice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.slice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <span class="tok-kw">anytype</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(&amp;self.buffer)) { *<span class="tok-kw">align</span>(alignment) [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) T, *<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T, <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>, }</code></pre></div><div class="tldDocs"><p>View the internal array as a slice whose size was previously set.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.slice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <span class="tok-kw">anytype</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(&amp;self.buffer)) {
    *<span class="tok-kw">align</span>(alignment) [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) T,
    *<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
} {
    <span class="tok-kw">return</span> self.buffer[<span class="tok-number">0</span>..self.len];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.constSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">constSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.constSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constSlice</span>(self: *<span class="tok-kw">const</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>View the internal array as a constant slice whose size was previously set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.constSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constSlice</span>(self: *<span class="tok-kw">const</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T {
    <span class="tok-kw">return</span> self.slice();
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.resize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adjust the slice's length to <code>len</code>.
Does not initialize added items if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.resize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (len &gt; buffer_capacity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    self.len = len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.clear" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clear</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.clear">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clear</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Remove all elements from the slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.clear">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clear</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">void</span> {
    self.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.fromSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.fromSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSlice</span>(m: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div class="tldDocs"><p>Copy the content of an existing slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>m: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.fromSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSlice</span>(m: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a> {
    <span class="tok-kw">var</span> list = <span class="tok-kw">try</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.init">init</a>(m.len);
    <span class="tok-builtin">@memcpy</span>(list.slice(), m);
    <span class="tok-kw">return</span> list;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Return the element at index <code>i</code> of the slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">return</span> self.constSlice()[i];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.set">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set the value of the element at index <code>i</code> of the slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.set">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
    self.slice()[i] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Return the maximum length of a slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.buffer.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Check that the slice can hold at least <code>additional_count</code> items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.len + additional_count &gt; buffer_capacity) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.addOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOne</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.addOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-kw">error</span>{Overflow}!*T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning a pointer to the new item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.addOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-kw">error</span>{Overflow}!*T {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(<span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addOneAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.addOneAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOneAssumeCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.addOneAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) *T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
Asserts that there is space for the new item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.addOneAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) *T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; buffer_capacity);
    self.len += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> &amp;self.slice()[self.len - <span class="tok-number">1</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.addManyAsArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArray</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.addManyAsArray">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!*<span class="tok-kw">align</span>(alignment) [n]T</code></pre></div><div class="tldDocs"><p>Resize the slice, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a pointer to the array of uninitialized elements.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.addManyAsArray">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!*<span class="tok-kw">align</span>(alignment) [n]T {
    <span class="tok-kw">const</span> prev_len = self.len;
    <span class="tok-kw">try</span> self.resize(self.len + n);
    <span class="tok-kw">return</span> self.slice()[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.addManyAsSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.addManyAsSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">align</span>(alignment) T</code></pre></div><div class="tldDocs"><p>Resize the slice, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the uninitialized elements.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.addManyAsSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">align</span>(alignment) T {
    <span class="tok-kw">const</span> prev_len = self.len;
    <span class="tok-kw">try</span> self.resize(self.len + n);
    <span class="tok-kw">return</span> self.slice()[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Remove and return the last element from the slice, or return <code>null</code> if the slice is empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> item = self.get(self.len - <span class="tok-number">1</span>);
    self.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.unusedCapacitySlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unusedCapacitySlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.unusedCapacitySlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) T</code></pre></div><div class="tldDocs"><p>Return a slice of only the extra capacity after items.
This can be useful for writing directly into it.
Note that such an operation must be followed up with a
call to <code>resize()</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.unusedCapacitySlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) T {
    <span class="tok-kw">return</span> self.buffer[self.len..];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>( self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T, ) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code> by moving <code>slice[n .. slice.len]</code> to make room.
This operation is O(N).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(
    self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>,
    i: <span class="tok-type">usize</span>,
    item: T,
) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (i &gt; self.len) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    }
    _ = <span class="tok-kw">try</span> self.addOne();
    <span class="tok-kw">var</span> s = self.slice();
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, s[i + <span class="tok-number">1</span> .. s.len], s[i .. s.len - <span class="tok-number">1</span>]);
    self.buffer[i] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.insertSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.insertSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert slice <code>items</code> at index <code>i</code> by moving <code>slice[i .. slice.len]</code> to make room.
This operation is O(N).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.insertSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    self.len += items.len;
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.slice()[i + items.len .. self.len], self.constSlice()[i .. self.len - items.len]);
    <span class="tok-builtin">@memcpy</span>(self.slice()[i..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.replaceRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRange</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.replaceRange">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>( self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T, ) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Replace range of elements <code>slice[start..][0..len]</code> with <code>new_items</code>.
Grows slice if <code>len &lt; new_items.len</code>.
Shrinks slice if <code>len &gt; new_items.len</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.replaceRange">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(
    self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>,
    start: <span class="tok-type">usize</span>,
    len: <span class="tok-type">usize</span>,
    new_items: []<span class="tok-kw">const</span> T,
) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> after_range = start + len;
    <span class="tok-kw">var</span> range = self.slice()[start..after_range];

    <span class="tok-kw">if</span> (range.len == new_items.len) {
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
        <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
        <span class="tok-kw">const</span> rest = new_items[range.len..];
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
        <span class="tok-kw">try</span> self.insertSlice(after_range, rest);
    } <span class="tok-kw">else</span> {
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
        <span class="tok-kw">const</span> after_subrange = start + new_items.len;
        <span class="tok-kw">for</span> (self.constSlice()[after_range..], <span class="tok-number">0</span>..) |item, i| {
            self.slice()[after_subrange..][i] = item;
        }
        self.len -= len - new_items.len;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the slice by 1 element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne();
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendAssumeCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the slice by 1 element, asserting the capacity is already
enough to store the new item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = self.addOneAssumeCapacity();
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove the element at index <code>i</code>, shift elements after index
<code>i</code> forward, and return the removed element.
Asserts the slice has at least one item.
This operation is O(N).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">const</span> newlen = self.len - <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (newlen == i) <span class="tok-kw">return</span> self.pop().?;
    <span class="tok-kw">const</span> old_item = self.get(i);
    <span class="tok-kw">for</span> (self.slice()[i..newlen], <span class="tok-number">0</span>..) |*b, j| b.* = self.get(i + <span class="tok-number">1</span> + j);
    self.set(newlen, <span class="tok-null">undefined</span>);
    self.len = newlen;
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove the element at the specified index and return it.
The empty slot is filled from the end of the slice.
This operation is O(1).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">if</span> (self.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;
    <span class="tok-kw">const</span> old_item = self.get(i);
    self.set(i, self.pop().?);
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    self.appendSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSliceAssumeCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the slice, asserting the capacity is already
enough to store the new items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.len;
    self.len += items.len;
    <span class="tok-builtin">@memcpy</span>(self.slice()[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendNTimes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimes</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendNTimes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the slice <code>n</code> times.
Allocates more memory as necessary.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendNTimes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.len;
    <span class="tok-kw">try</span> self.resize(old_len + n);
    <span class="tok-builtin">@memset</span>(self.slice()[old_len..self.len], value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendNTimesAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimesAssumeCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendNTimesAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the slice <code>n</code> times.
Asserts the capacity is enough.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendNTimesAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.len;
    self.len += n;
    <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt;= buffer_capacity);
    <span class="tok-builtin">@memset</span>(self.slice()[old_len..self.len], value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.Writer">Writer</a></code></pre></div><div class="tldDocs"><p>Initializes a writer which will write into the array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> BoundedArray {
    <span class="tok-kw">var</span> a = <span class="tok-kw">try</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArray">BoundedArray</a>(<span class="tok-type">u8</span>, <span class="tok-number">64</span>).init(<span class="tok-number">32</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.capacity(), <span class="tok-number">64</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.slice().len, <span class="tok-number">32</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.constSlice().len, <span class="tok-number">32</span>);

    <span class="tok-kw">try</span> a.resize(<span class="tok-number">48</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">48</span>);

    <span class="tok-kw">const</span> x = [_]<span class="tok-type">u8</span>{<span class="tok-number">1</span>} ** <span class="tok-number">10</span>;
    a = <span class="tok-kw">try</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArray">BoundedArray</a>(<span class="tok-type">u8</span>, <span class="tok-number">64</span>).fromSlice(&amp;x);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;x, a.constSlice());

    <span class="tok-kw">var</span> a2 = a;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, a.constSlice(), a2.constSlice());
    a2.set(<span class="tok-number">0</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.get(<span class="tok-number">0</span>) != a2.get(<span class="tok-number">0</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, a.resize(<span class="tok-number">100</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, <a href="std.bounded_array.html#std.bounded_array.BoundedArray">BoundedArray</a>(<span class="tok-type">u8</span>, x.len - <span class="tok-number">1</span>).fromSlice(&amp;x));

    <span class="tok-kw">try</span> a.resize(<span class="tok-number">0</span>);
    <span class="tok-kw">try</span> a.ensureUnusedCapacity(a.capacity());
    (<span class="tok-kw">try</span> a.addOne()).* = <span class="tok-number">0</span>;
    <span class="tok-kw">try</span> a.ensureUnusedCapacity(a.capacity() - <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> uninitialized = <span class="tok-kw">try</span> a.addManyAsArray(<span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(uninitialized.len, <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">5</span>);

    <span class="tok-kw">try</span> a.append(<span class="tok-number">0xff</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.pop(), <span class="tok-number">0xff</span>);

    a.appendAssumeCapacity(<span class="tok-number">0xff</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.pop(), <span class="tok-number">0xff</span>);

    <span class="tok-kw">try</span> a.resize(<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.pop(), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.pop(), <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> unused = a.unusedCapacitySlice();
    <span class="tok-builtin">@memset</span>(unused[<span class="tok-number">0</span>..<span class="tok-number">8</span>], <span class="tok-number">2</span>);
    unused[<span class="tok-number">8</span>] = <span class="tok-number">3</span>;
    unused[<span class="tok-number">9</span>] = <span class="tok-number">4</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(unused.len, a.capacity());
    <span class="tok-kw">try</span> a.resize(<span class="tok-number">10</span>);

    <span class="tok-kw">try</span> a.insert(<span class="tok-number">5</span>, <span class="tok-number">0xaa</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">11</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.get(<span class="tok-number">5</span>), <span class="tok-number">0xaa</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.get(<span class="tok-number">9</span>), <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.get(<span class="tok-number">10</span>), <span class="tok-number">4</span>);

    <span class="tok-kw">try</span> a.insert(<span class="tok-number">11</span>, <span class="tok-number">0xbb</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">12</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.pop(), <span class="tok-number">0xbb</span>);

    <span class="tok-kw">try</span> a.appendSlice(&amp;x);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">11</span> + x.len);

    <span class="tok-kw">try</span> a.appendNTimes(<span class="tok-number">0xbb</span>, <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">11</span> + x.len + <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.pop(), <span class="tok-number">0xbb</span>);

    a.appendNTimesAssumeCapacity(<span class="tok-number">0xcc</span>, <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">11</span> + x.len + <span class="tok-number">5</span> - <span class="tok-number">1</span> + <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.pop(), <span class="tok-number">0xcc</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">29</span>);
    <span class="tok-kw">try</span> a.replaceRange(<span class="tok-number">1</span>, <span class="tok-number">20</span>, &amp;x);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">29</span> + x.len - <span class="tok-number">20</span>);

    <span class="tok-kw">try</span> a.insertSlice(<span class="tok-number">0</span>, &amp;x);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">29</span> + x.len - <span class="tok-number">20</span> + x.len);

    <span class="tok-kw">try</span> a.replaceRange(<span class="tok-number">1</span>, <span class="tok-number">5</span>, &amp;x);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">29</span> + x.len - <span class="tok-number">20</span> + x.len + x.len - <span class="tok-number">5</span>);

    <span class="tok-kw">try</span> a.append(<span class="tok-number">10</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.pop(), <span class="tok-number">10</span>);

    <span class="tok-kw">try</span> a.append(<span class="tok-number">20</span>);
    <span class="tok-kw">const</span> removed = a.orderedRemove(<span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(removed, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">34</span>);

    a.set(<span class="tok-number">0</span>, <span class="tok-number">0xdd</span>);
    a.set(a.len - <span class="tok-number">1</span>, <span class="tok-number">0xee</span>);
    <span class="tok-kw">const</span> swapped = a.swapRemove(<span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(swapped, <span class="tok-number">0xdd</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.get(<span class="tok-number">0</span>), <span class="tok-number">0xee</span>);

    <span class="tok-kw">const</span> added_slice = <span class="tok-kw">try</span> a.addManyAsSlice(<span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(added_slice.len, <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.len, <span class="tok-number">36</span>);

    <span class="tok-kw">while</span> (a.pop()) |_| {}
    <span class="tok-kw">const</span> w = a.writer();
    <span class="tok-kw">const</span> s = <span class="tok-str">&quot;hello, this is a test string&quot;</span>;
    <span class="tok-kw">try</span> w.writeAll(s);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(s, a.constSlice());
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArray">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">BoundedArray</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> buffer_capacity: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">BoundedArrayAligned</a>(T, <span class="tok-builtin">@alignOf</span>(T), buffer_capacity);
}</code></pre></details></div></div><div class="decl"><h2 id="std.bounded_array.BoundedArrayAligned" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">BoundedArrayAligned</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned">[src]</a></h2><div class="tldDocs"><p>A structure with an array, length and alignment, that can be used as a
slice.</p>
<p>Useful to pass around small explicitly-aligned arrays whose exact size is
only known at runtime, but whose maximum size is known at comptime, without
requiring an <code>Allocator</code>.</p>
<pre><code></code></pre>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>alignment: <span class="tok-type">u29</span></code></pre></div><div><pre><code>buffer_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.Writer">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.Writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for BoundedArray(u8, ...) &quot;</span> ++
        <span class="tok-str">&quot;but the given type is BoundedArray(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;, ...)&quot;</span>)
<span class="tok-kw">else</span>
    <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, <span class="tok-kw">error</span>{Overflow}, <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.appendWrite">appendWrite</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>buffer: [buffer_capacity]T <span class="tok-kw">align</span>(alignment) = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div class="tldDocs"><p>Set the actual length of the slice.
Returns error.Overflow if it exceeds the length of the backing array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a> {
    <span class="tok-kw">if</span> (len &gt; buffer_capacity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    <span class="tok-kw">return</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>{ .len = len };
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.slice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">slice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.slice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <span class="tok-kw">anytype</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(&amp;self.buffer)) { *<span class="tok-kw">align</span>(alignment) [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) T, *<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T, <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>, }</code></pre></div><div class="tldDocs"><p>View the internal array as a slice whose size was previously set.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.slice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <span class="tok-kw">anytype</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(&amp;self.buffer)) {
    *<span class="tok-kw">align</span>(alignment) [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) T,
    *<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
} {
    <span class="tok-kw">return</span> self.buffer[<span class="tok-number">0</span>..self.len];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.constSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">constSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.constSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constSlice</span>(self: *<span class="tok-kw">const</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>View the internal array as a constant slice whose size was previously set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.constSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constSlice</span>(self: *<span class="tok-kw">const</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T {
    <span class="tok-kw">return</span> self.slice();
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.resize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adjust the slice's length to <code>len</code>.
Does not initialize added items if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.resize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (len &gt; buffer_capacity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    self.len = len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.clear" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clear</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.clear">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clear</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Remove all elements from the slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.clear">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clear</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">void</span> {
    self.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.fromSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.fromSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSlice</span>(m: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div class="tldDocs"><p>Copy the content of an existing slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>m: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.fromSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSlice</span>(m: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a> {
    <span class="tok-kw">var</span> list = <span class="tok-kw">try</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.init">init</a>(m.len);
    <span class="tok-builtin">@memcpy</span>(list.slice(), m);
    <span class="tok-kw">return</span> list;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Return the element at index <code>i</code> of the slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">return</span> self.constSlice()[i];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.set">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set the value of the element at index <code>i</code> of the slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.set">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
    self.slice()[i] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Return the maximum length of a slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.buffer.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Check that the slice can hold at least <code>additional_count</code> items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.len + additional_count &gt; buffer_capacity) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.addOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOne</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.addOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-kw">error</span>{Overflow}!*T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning a pointer to the new item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.addOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-kw">error</span>{Overflow}!*T {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(<span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addOneAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.addOneAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOneAssumeCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.addOneAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) *T</code></pre></div><div class="tldDocs"><p>Increase length by 1, returning pointer to the new item.
Asserts that there is space for the new item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.addOneAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) *T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; buffer_capacity);
    self.len += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> &amp;self.slice()[self.len - <span class="tok-number">1</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.addManyAsArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsArray</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.addManyAsArray">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!*<span class="tok-kw">align</span>(alignment) [n]T</code></pre></div><div class="tldDocs"><p>Resize the slice, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a pointer to the array of uninitialized elements.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.addManyAsArray">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!*<span class="tok-kw">align</span>(alignment) [n]T {
    <span class="tok-kw">const</span> prev_len = self.len;
    <span class="tok-kw">try</span> self.resize(self.len + n);
    <span class="tok-kw">return</span> self.slice()[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.addManyAsSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addManyAsSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.addManyAsSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">align</span>(alignment) T</code></pre></div><div class="tldDocs"><p>Resize the slice, adding <code>n</code> new elements, which have <code>undefined</code> values.
The return value is a slice pointing to the uninitialized elements.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.addManyAsSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">align</span>(alignment) T {
    <span class="tok-kw">const</span> prev_len = self.len;
    <span class="tok-kw">try</span> self.resize(self.len + n);
    <span class="tok-kw">return</span> self.slice()[prev_len..][<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Remove and return the last element from the slice, or return <code>null</code> if the slice is empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> item = self.get(self.len - <span class="tok-number">1</span>);
    self.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.unusedCapacitySlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unusedCapacitySlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.unusedCapacitySlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) T</code></pre></div><div class="tldDocs"><p>Return a slice of only the extra capacity after items.
This can be useful for writing directly into it.
Note that such an operation must be followed up with a
call to <code>resize()</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.unusedCapacitySlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) T {
    <span class="tok-kw">return</span> self.buffer[self.len..];
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>( self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T, ) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert <code>item</code> at index <code>i</code> by moving <code>slice[n .. slice.len]</code> to make room.
This operation is O(N).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(
    self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>,
    i: <span class="tok-type">usize</span>,
    item: T,
) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (i &gt; self.len) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    }
    _ = <span class="tok-kw">try</span> self.addOne();
    <span class="tok-kw">var</span> s = self.slice();
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, s[i + <span class="tok-number">1</span> .. s.len], s[i .. s.len - <span class="tok-number">1</span>]);
    self.buffer[i] = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.insertSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.insertSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert slice <code>items</code> at index <code>i</code> by moving <code>slice[i .. slice.len]</code> to make room.
This operation is O(N).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.insertSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    self.len += items.len;
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.slice()[i + items.len .. self.len], self.constSlice()[i .. self.len - items.len]);
    <span class="tok-builtin">@memcpy</span>(self.slice()[i..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.replaceRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceRange</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.replaceRange">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>( self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>, new_items: []<span class="tok-kw">const</span> T, ) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Replace range of elements <code>slice[start..][0..len]</code> with <code>new_items</code>.
Grows slice if <code>len &lt; new_items.len</code>.
Shrinks slice if <code>len &gt; new_items.len</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.replaceRange">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(
    self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>,
    start: <span class="tok-type">usize</span>,
    len: <span class="tok-type">usize</span>,
    new_items: []<span class="tok-kw">const</span> T,
) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> after_range = start + len;
    <span class="tok-kw">var</span> range = self.slice()[start..after_range];

    <span class="tok-kw">if</span> (range.len == new_items.len) {
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
        <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
        <span class="tok-kw">const</span> rest = new_items[range.len..];
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
        <span class="tok-kw">try</span> self.insertSlice(after_range, rest);
    } <span class="tok-kw">else</span> {
        <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
        <span class="tok-kw">const</span> after_subrange = start + new_items.len;
        <span class="tok-kw">for</span> (self.constSlice()[after_range..], <span class="tok-number">0</span>..) |item, i| {
            self.slice()[after_subrange..][i] = item;
        }
        self.len -= len - new_items.len;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the slice by 1 element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne();
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendAssumeCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the slice by 1 element, asserting the capacity is already
enough to store the new item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = self.addOneAssumeCapacity();
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove the element at index <code>i</code>, shift elements after index
<code>i</code> forward, and return the removed element.
Asserts the slice has at least one item.
This operation is O(N).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">const</span> newlen = self.len - <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (newlen == i) <span class="tok-kw">return</span> self.pop().?;
    <span class="tok-kw">const</span> old_item = self.get(i);
    <span class="tok-kw">for</span> (self.slice()[i..newlen], <span class="tok-number">0</span>..) |*b, j| b.* = self.get(i + <span class="tok-number">1</span> + j);
    self.set(newlen, <span class="tok-null">undefined</span>);
    self.len = newlen;
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove the element at the specified index and return it.
The empty slot is filled from the end of the slice.
This operation is O(1).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">if</span> (self.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;
    <span class="tok-kw">const</span> old_item = self.get(i);
    self.set(i, self.pop().?);
    <span class="tok-kw">return</span> old_item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSlice</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    self.appendSliceAssumeCapacity(items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSliceAssumeCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendSliceAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append the slice of items to the slice, asserting the capacity is already
enough to store the new items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendSliceAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.len;
    self.len += items.len;
    <span class="tok-builtin">@memcpy</span>(self.slice()[old_len..][<span class="tok-number">0</span>..items.len], items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendNTimes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimes</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendNTimes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the slice <code>n</code> times.
Allocates more memory as necessary.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendNTimes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.len;
    <span class="tok-kw">try</span> self.resize(old_len + n);
    <span class="tok-builtin">@memset</span>(self.slice()[old_len..self.len], value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.appendNTimesAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendNTimesAssumeCapacity</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.appendNTimesAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Append a value to the slice <code>n</code> times.
Asserts the capacity is enough.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.appendNTimesAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.len;
    self.len += n;
    <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt;= buffer_capacity);
    <span class="tok-builtin">@memset</span>(self.slice()[old_len..self.len], value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.bounded_array.BoundedArrayAligned.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.bounded_array.BoundedArrayAligned.writer">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.Writer">Writer</a></code></pre></div><div class="tldDocs"><p>Initializes a writer which will write into the array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned.writer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = self };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bounded_array.BoundedArrayAligned">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">BoundedArrayAligned</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> buffer_capacity: <span class="tok-type">usize</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        buffer: [buffer_capacity]T <span class="tok-kw">align</span>(alignment) = <span class="tok-null">undefined</span>,
        len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-comment">/// Set the actual length of the slice.</span>
        <span class="tok-comment">/// Returns error.Overflow if it exceeds the length of the backing array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a> {
            <span class="tok-kw">if</span> (len &gt; buffer_capacity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            <span class="tok-kw">return</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>{ .len = len };
        }

        <span class="tok-comment">/// View the internal array as a slice whose size was previously set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <span class="tok-kw">anytype</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(&amp;self.buffer)) {
            *<span class="tok-kw">align</span>(alignment) [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) T,
            *<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> [buffer_capacity]T =&gt; []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        } {
            <span class="tok-kw">return</span> self.buffer[<span class="tok-number">0</span>..self.len];
        }

        <span class="tok-comment">/// View the internal array as a constant slice whose size was previously set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constSlice</span>(self: *<span class="tok-kw">const</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) <span class="tok-kw">const</span> T {
            <span class="tok-kw">return</span> self.slice();
        }

        <span class="tok-comment">/// Adjust the slice's length to `len`.</span>
        <span class="tok-comment">/// Does not initialize added items if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, len: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (len &gt; buffer_capacity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            self.len = len;
        }

        <span class="tok-comment">/// Remove all elements from the slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clear</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">void</span> {
            self.len = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Copy the content of an existing slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSlice</span>(m: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a> {
            <span class="tok-kw">var</span> list = <span class="tok-kw">try</span> <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.init">init</a>(m.len);
            <span class="tok-builtin">@memcpy</span>(list.slice(), m);
            <span class="tok-kw">return</span> list;
        }

        <span class="tok-comment">/// Return the element at index `i` of the slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
            <span class="tok-kw">return</span> self.constSlice()[i];
        }

        <span class="tok-comment">/// Set the value of the element at index `i` of the slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, item: T) <span class="tok-type">void</span> {
            self.slice()[i] = item;
        }

        <span class="tok-comment">/// Return the maximum length of a slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.buffer.len;
        }

        <span class="tok-comment">/// Check that the slice can hold at least `additional_count` items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, additional_count: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.len + additional_count &gt; buffer_capacity) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            }
        }

        <span class="tok-comment">/// Increase length by 1, returning a pointer to the new item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <span class="tok-kw">error</span>{Overflow}!*T {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(<span class="tok-number">1</span>);
            <span class="tok-kw">return</span> self.addOneAssumeCapacity();
        }

        <span class="tok-comment">/// Increase length by 1, returning pointer to the new item.</span>
        <span class="tok-comment">/// Asserts that there is space for the new item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) *T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; buffer_capacity);
            self.len += <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> &amp;self.slice()[self.len - <span class="tok-number">1</span>];
        }

        <span class="tok-comment">/// Resize the slice, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is a pointer to the array of uninitialized elements.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsArray</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!*<span class="tok-kw">align</span>(alignment) [n]T {
            <span class="tok-kw">const</span> prev_len = self.len;
            <span class="tok-kw">try</span> self.resize(self.len + n);
            <span class="tok-kw">return</span> self.slice()[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Resize the slice, adding `n` new elements, which have `undefined` values.</span>
        <span class="tok-comment">/// The return value is a slice pointing to the uninitialized elements.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addManyAsSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}![]<span class="tok-kw">align</span>(alignment) T {
            <span class="tok-kw">const</span> prev_len = self.len;
            <span class="tok-kw">try</span> self.resize(self.len + n);
            <span class="tok-kw">return</span> self.slice()[prev_len..][<span class="tok-number">0</span>..n];
        }

        <span class="tok-comment">/// Remove and return the last element from the slice, or return `null` if the slice is empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) ?T {
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> item = self.get(self.len - <span class="tok-number">1</span>);
            self.len -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> item;
        }

        <span class="tok-comment">/// Return a slice of only the extra capacity after items.</span>
        <span class="tok-comment">/// This can be useful for writing directly into it.</span>
        <span class="tok-comment">/// Note that such an operation must be followed up with a</span>
        <span class="tok-comment">/// call to `resize()`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unusedCapacitySlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) []<span class="tok-kw">align</span>(alignment) T {
            <span class="tok-kw">return</span> self.buffer[self.len..];
        }

        <span class="tok-comment">/// Insert `item` at index `i` by moving `slice[n .. slice.len]` to make room.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(
            self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>,
            i: <span class="tok-type">usize</span>,
            item: T,
        ) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (i &gt; self.len) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            }
            _ = <span class="tok-kw">try</span> self.addOne();
            <span class="tok-kw">var</span> s = self.slice();
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, s[i + <span class="tok-number">1</span> .. s.len], s[i .. s.len - <span class="tok-number">1</span>]);
            self.buffer[i] = item;
        }

        <span class="tok-comment">/// Insert slice `items` at index `i` by moving `slice[i .. slice.len]` to make room.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
            self.len += items.len;
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(T, self.slice()[i + items.len .. self.len], self.constSlice()[i .. self.len - items.len]);
            <span class="tok-builtin">@memcpy</span>(self.slice()[i..][<span class="tok-number">0</span>..items.len], items);
        }

        <span class="tok-comment">/// Replace range of elements `slice[start..][0..len]` with `new_items`.</span>
        <span class="tok-comment">/// Grows slice if `len &lt; new_items.len`.</span>
        <span class="tok-comment">/// Shrinks slice if `len &gt; new_items.len`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceRange</span>(
            self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>,
            start: <span class="tok-type">usize</span>,
            len: <span class="tok-type">usize</span>,
            new_items: []<span class="tok-kw">const</span> T,
        ) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> after_range = start + len;
            <span class="tok-kw">var</span> range = self.slice()[start..after_range];

            <span class="tok-kw">if</span> (range.len == new_items.len) {
                <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (range.len &lt; new_items.len) {
                <span class="tok-kw">const</span> first = new_items[<span class="tok-number">0</span>..range.len];
                <span class="tok-kw">const</span> rest = new_items[range.len..];
                <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..first.len], first);
                <span class="tok-kw">try</span> self.insertSlice(after_range, rest);
            } <span class="tok-kw">else</span> {
                <span class="tok-builtin">@memcpy</span>(range[<span class="tok-number">0</span>..new_items.len], new_items);
                <span class="tok-kw">const</span> after_subrange = start + new_items.len;
                <span class="tok-kw">for</span> (self.constSlice()[after_range..], <span class="tok-number">0</span>..) |item, i| {
                    self.slice()[after_subrange..][i] = item;
                }
                self.len -= len - new_items.len;
            }
        }

        <span class="tok-comment">/// Extend the slice by 1 element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne();
            new_item_ptr.* = item;
        }

        <span class="tok-comment">/// Extend the slice by 1 element, asserting the capacity is already</span>
        <span class="tok-comment">/// enough to store the new item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, item: T) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_item_ptr = self.addOneAssumeCapacity();
            new_item_ptr.* = item;
        }

        <span class="tok-comment">/// Remove the element at index `i`, shift elements after index</span>
        <span class="tok-comment">/// `i` forward, and return the removed element.</span>
        <span class="tok-comment">/// Asserts the slice has at least one item.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
            <span class="tok-kw">const</span> newlen = self.len - <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (newlen == i) <span class="tok-kw">return</span> self.pop().?;
            <span class="tok-kw">const</span> old_item = self.get(i);
            <span class="tok-kw">for</span> (self.slice()[i..newlen], <span class="tok-number">0</span>..) |*b, j| b.* = self.get(i + <span class="tok-number">1</span> + j);
            self.set(newlen, <span class="tok-null">undefined</span>);
            self.len = newlen;
            <span class="tok-kw">return</span> old_item;
        }

        <span class="tok-comment">/// Remove the element at the specified index and return it.</span>
        <span class="tok-comment">/// The empty slot is filled from the end of the slice.</span>
        <span class="tok-comment">/// This operation is O(1).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, i: <span class="tok-type">usize</span>) T {
            <span class="tok-kw">if</span> (self.len - <span class="tok-number">1</span> == i) <span class="tok-kw">return</span> self.pop().?;
            <span class="tok-kw">const</span> old_item = self.get(i);
            self.set(i, self.pop().?);
            <span class="tok-kw">return</span> old_item;
        }

        <span class="tok-comment">/// Append the slice of items to the slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
            self.appendSliceAssumeCapacity(items);
        }

        <span class="tok-comment">/// Append the slice of items to the slice, asserting the capacity is already</span>
        <span class="tok-comment">/// enough to store the new items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSliceAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, items: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.len;
            self.len += items.len;
            <span class="tok-builtin">@memcpy</span>(self.slice()[old_len..][<span class="tok-number">0</span>..items.len], items);
        }

        <span class="tok-comment">/// Append a value to the slice `n` times.</span>
        <span class="tok-comment">/// Allocates more memory as necessary.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimes</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.len;
            <span class="tok-kw">try</span> self.resize(old_len + n);
            <span class="tok-builtin">@memset</span>(self.slice()[old_len..self.len], value);
        }

        <span class="tok-comment">/// Append a value to the slice `n` times.</span>
        <span class="tok-comment">/// Asserts the capacity is enough.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendNTimesAssumeCapacity</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, value: T, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_len = self.len;
            self.len += n;
            <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt;= buffer_capacity);
            <span class="tok-builtin">@memset</span>(self.slice()[old_len..self.len], value);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <span class="tok-kw">if</span> (T != <span class="tok-type">u8</span>)
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The Writer interface is only defined for BoundedArray(u8, ...) &quot;</span> ++
                <span class="tok-str">&quot;but the given type is BoundedArray(&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;, ...)&quot;</span>)
        <span class="tok-kw">else</span>
            <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, <span class="tok-kw">error</span>{Overflow}, <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.appendWrite">appendWrite</a>);

        <span class="tok-comment">/// Initializes a writer which will write into the array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>) <a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }

        <span class="tok-comment">/// Same as `appendSlice` except it returns the number of bytes written, which is always the same</span>
        <span class="tok-comment">/// as `m.len`. The purpose of this function existing is to match `std.io.Writer` API.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">appendWrite</span>(self: *<a href="std.bounded_array.html#std.bounded_array.BoundedArrayAligned">Self</a>, m: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{Overflow}!<span class="tok-type">usize</span> {
            <span class="tok-kw">try</span> self.appendSlice(m);
            <span class="tok-kw">return</span> m.len;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.static_string_map.StaticStringMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StaticStringMap</span><a href="#src.zig-std.static_string_map.StaticStringMap">[src]</a></h2><div class="tldDocs"><p>Static string map optimized for small sets of disparate string keys.
Works by separating the keys by length at initialization and only checking
strings of equal length at runtime.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.static_string_map.StaticStringMapWithEql.KV.html">std.static_string_map.StaticStringMapWithEql.KV</a></li></ul></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>kvs: *<span class="tok-kw">const</span> <a href="std.static_string_map.StaticStringMapWithEql.KVs.html">KVs</a> = &amp;<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql.empty_kvs">empty_kvs</a></code></pre></div><div><pre><code>len_indexes: [*]<span class="tok-kw">const</span> <span class="tok-type">u32</span> = &amp;<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql.empty_len_indexes">empty_len_indexes</a></code></pre></div><div><pre><code>len_indexes_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>min_len: <span class="tok-type">u32</span> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>max_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.initComptime" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initComptime</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.initComptime">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">initComptime</span>(<span class="tok-kw">comptime</span> kvs_list: <span class="tok-kw">anytype</span>) <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div class="tldDocs"><p>Returns a map backed by static, comptime allocated memory.</p>
<p><code>kvs_list</code> must be either a list of <code>struct { []const u8, V }</code>
(key-value pair) tuples, or a list of <code>struct { []const u8 }</code>
(only keys) tuples if <code>V</code> is <code>void</code>.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.initComptime">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">initComptime</span>(<span class="tok-kw">comptime</span> kvs_list: <span class="tok-kw">anytype</span>) <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> self = <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>{};
        <span class="tok-kw">if</span> (kvs_list.len == <span class="tok-number">0</span>)
            <span class="tok-kw">return</span> self;<span class="tok-comment">

        // Since the KVs are sorted, a linearly-growing bound will never
        // be sufficient for extreme cases. So we grow proportional to
        // N*log2(N).
        </span><span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">10</span> * kvs_list.len * <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, kvs_list.len));

        <span class="tok-kw">var</span> sorted_keys: [kvs_list.len][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> sorted_vals: [kvs_list.len]V = <span class="tok-null">undefined</span>;

        self.initSortedKVs(kvs_list, &amp;sorted_keys, &amp;sorted_vals);
        <span class="tok-kw">const</span> final_keys = sorted_keys;
        <span class="tok-kw">const</span> final_vals = sorted_vals;
        self.kvs = &amp;.{
            .keys = &amp;final_keys,
            .values = &amp;final_vals,
            .len = <span class="tok-builtin">@intCast</span>(kvs_list.len),
        };

        <span class="tok-kw">var</span> len_indexes: [self.max_len + <span class="tok-number">1</span>]<span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
        self.initLenIndexes(&amp;len_indexes);
        <span class="tok-kw">const</span> final_len_indexes = len_indexes;
        self.len_indexes = &amp;final_len_indexes;
        self.len_indexes_len = <span class="tok-builtin">@intCast</span>(len_indexes.len);
        <span class="tok-kw">return</span> self;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(kvs_list: <span class="tok-kw">anytype</span>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div class="tldDocs"><p>Returns a map backed by memory allocated with <code>allocator</code>.</p>
<p>Handles <code>kvs_list</code> the same way as <code>initComptime()</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(kvs_list: <span class="tok-kw">anytype</span>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>{};
    <span class="tok-kw">if</span> (kvs_list.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> self;

    <span class="tok-kw">const</span> sorted_keys = <span class="tok-kw">try</span> allocator.alloc([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kvs_list.len);
    <span class="tok-kw">errdefer</span> allocator.free(sorted_keys);
    <span class="tok-kw">const</span> sorted_vals = <span class="tok-kw">try</span> allocator.alloc(V, kvs_list.len);
    <span class="tok-kw">errdefer</span> allocator.free(sorted_vals);
    <span class="tok-kw">const</span> kvs = <span class="tok-kw">try</span> allocator.create(<a href="std.static_string_map.StaticStringMapWithEql.KVs.html">KVs</a>);
    <span class="tok-kw">errdefer</span> allocator.destroy(kvs);

    self.initSortedKVs(kvs_list, sorted_keys, sorted_vals);
    kvs.* = .{
        .keys = sorted_keys.ptr,
        .values = sorted_vals.ptr,
        .len = <span class="tok-builtin">@intCast</span>(kvs_list.len),
    };
    self.kvs = kvs;

    <span class="tok-kw">const</span> len_indexes = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u32</span>, self.max_len + <span class="tok-number">1</span>);
    self.initLenIndexes(len_indexes);
    self.len_indexes = len_indexes.ptr;
    self.len_indexes_len = <span class="tok-builtin">@intCast</span>(len_indexes.len);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>this method should only be used with init() and not with initComptime().</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    allocator.free(self.len_indexes[<span class="tok-number">0</span>..self.len_indexes_len]);
    allocator.free(self.kvs.keys[<span class="tok-number">0</span>..self.kvs.len]);
    allocator.free(self.kvs.values[<span class="tok-number">0</span>..self.kvs.len]);
    allocator.destroy(self.kvs);
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.has" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">has</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.has">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">has</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Checks if the map has a value for the key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.has">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">has</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.get(str) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?V</code></pre></div><div class="tldDocs"><p>Returns the value for the key if any, else null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?V {
    <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">return</span> self.kvs.values[self.getIndex(str) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> kvs = self.kvs.*;
    <span class="tok-kw">if</span> (kvs.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (str.len &lt; self.min_len <span class="tok-kw">or</span> str.len &gt; self.max_len)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> i = self.len_indexes[str.len];
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> key = kvs.keys[i];
        <span class="tok-kw">if</span> (key.len != str.len)
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">if</span> (eql(key, str))
            <span class="tok-kw">return</span> i;
        i += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (i &gt;= kvs.len)
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.getLongestPrefix" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLongestPrefix</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.getLongestPrefix">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefix</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.static_string_map.StaticStringMapWithEql.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Returns the key-value pair where key is the longest prefix of <code>str</code>
else null.</p>
<p>This is effectively an O(N) algorithm which loops from <code>max_len</code> to
<code>min_len</code> and calls <code>getIndex()</code> to check all keys with the given
len.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.getLongestPrefix">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefix</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.static_string_map.StaticStringMapWithEql.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> i = self.getLongestPrefixIndex(str) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> kvs = self.kvs.*;
    <span class="tok-kw">return</span> .{
        .key = kvs.keys[i],
        .value = kvs.values[i],
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.getLongestPrefixIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLongestPrefixIndex</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.getLongestPrefixIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefixIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.getLongestPrefixIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefixIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (str.len &lt; self.min_len)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> len = <span class="tok-builtin">@min</span>(self.max_len, str.len);
    <span class="tok-kw">while</span> (len &gt;= self.min_len) : (len -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (self.getIndex(str[<span class="tok-number">0</span>..len])) |i|
            <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> kvs = self.kvs.*;
    <span class="tok-kw">return</span> kvs.keys[<span class="tok-number">0</span>..kvs.len];
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> V {
    <span class="tok-kw">const</span> kvs = self.kvs.*;
    <span class="tok-kw">return</span> kvs.values[<span class="tok-number">0</span>..kvs.len];
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StaticStringMap</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">StaticStringMapWithEql</a>(V, <a href="std.static_string_map.html#std.static_string_map.defaultEql">defaultEql</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.static_string_map.StaticStringMapWithEql" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StaticStringMapWithEql</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql">[src]</a></h2><div class="tldDocs"><p>StaticStringMap, but accepts an equality function (<code>eql</code>).
The <code>eql</code> function is only called to determine the equality
of equal length strings. Any strings that are not equal length
are never compared using the <code>eql</code> function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>eql: <span class="tok-kw">fn</span> (a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.static_string_map.StaticStringMapWithEql.KV.html">std.static_string_map.StaticStringMapWithEql.KV</a></li></ul></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>kvs: *<span class="tok-kw">const</span> <a href="std.static_string_map.StaticStringMapWithEql.KVs.html">KVs</a> = &amp;<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql.empty_kvs">empty_kvs</a></code></pre></div><div><pre><code>len_indexes: [*]<span class="tok-kw">const</span> <span class="tok-type">u32</span> = &amp;<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql.empty_len_indexes">empty_len_indexes</a></code></pre></div><div><pre><code>len_indexes_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>min_len: <span class="tok-type">u32</span> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>max_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.initComptime" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initComptime</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.initComptime">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">initComptime</span>(<span class="tok-kw">comptime</span> kvs_list: <span class="tok-kw">anytype</span>) <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div class="tldDocs"><p>Returns a map backed by static, comptime allocated memory.</p>
<p><code>kvs_list</code> must be either a list of <code>struct { []const u8, V }</code>
(key-value pair) tuples, or a list of <code>struct { []const u8 }</code>
(only keys) tuples if <code>V</code> is <code>void</code>.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.initComptime">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">initComptime</span>(<span class="tok-kw">comptime</span> kvs_list: <span class="tok-kw">anytype</span>) <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> self = <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>{};
        <span class="tok-kw">if</span> (kvs_list.len == <span class="tok-number">0</span>)
            <span class="tok-kw">return</span> self;<span class="tok-comment">

        // Since the KVs are sorted, a linearly-growing bound will never
        // be sufficient for extreme cases. So we grow proportional to
        // N*log2(N).
        </span><span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">10</span> * kvs_list.len * <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, kvs_list.len));

        <span class="tok-kw">var</span> sorted_keys: [kvs_list.len][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> sorted_vals: [kvs_list.len]V = <span class="tok-null">undefined</span>;

        self.initSortedKVs(kvs_list, &amp;sorted_keys, &amp;sorted_vals);
        <span class="tok-kw">const</span> final_keys = sorted_keys;
        <span class="tok-kw">const</span> final_vals = sorted_vals;
        self.kvs = &amp;.{
            .keys = &amp;final_keys,
            .values = &amp;final_vals,
            .len = <span class="tok-builtin">@intCast</span>(kvs_list.len),
        };

        <span class="tok-kw">var</span> len_indexes: [self.max_len + <span class="tok-number">1</span>]<span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
        self.initLenIndexes(&amp;len_indexes);
        <span class="tok-kw">const</span> final_len_indexes = len_indexes;
        self.len_indexes = &amp;final_len_indexes;
        self.len_indexes_len = <span class="tok-builtin">@intCast</span>(len_indexes.len);
        <span class="tok-kw">return</span> self;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(kvs_list: <span class="tok-kw">anytype</span>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div class="tldDocs"><p>Returns a map backed by memory allocated with <code>allocator</code>.</p>
<p>Handles <code>kvs_list</code> the same way as <code>initComptime()</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(kvs_list: <span class="tok-kw">anytype</span>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>{};
    <span class="tok-kw">if</span> (kvs_list.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> self;

    <span class="tok-kw">const</span> sorted_keys = <span class="tok-kw">try</span> allocator.alloc([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kvs_list.len);
    <span class="tok-kw">errdefer</span> allocator.free(sorted_keys);
    <span class="tok-kw">const</span> sorted_vals = <span class="tok-kw">try</span> allocator.alloc(V, kvs_list.len);
    <span class="tok-kw">errdefer</span> allocator.free(sorted_vals);
    <span class="tok-kw">const</span> kvs = <span class="tok-kw">try</span> allocator.create(<a href="std.static_string_map.StaticStringMapWithEql.KVs.html">KVs</a>);
    <span class="tok-kw">errdefer</span> allocator.destroy(kvs);

    self.initSortedKVs(kvs_list, sorted_keys, sorted_vals);
    kvs.* = .{
        .keys = sorted_keys.ptr,
        .values = sorted_vals.ptr,
        .len = <span class="tok-builtin">@intCast</span>(kvs_list.len),
    };
    self.kvs = kvs;

    <span class="tok-kw">const</span> len_indexes = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u32</span>, self.max_len + <span class="tok-number">1</span>);
    self.initLenIndexes(len_indexes);
    self.len_indexes = len_indexes.ptr;
    self.len_indexes_len = <span class="tok-builtin">@intCast</span>(len_indexes.len);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>this method should only be used with init() and not with initComptime().</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    allocator.free(self.len_indexes[<span class="tok-number">0</span>..self.len_indexes_len]);
    allocator.free(self.kvs.keys[<span class="tok-number">0</span>..self.kvs.len]);
    allocator.free(self.kvs.values[<span class="tok-number">0</span>..self.kvs.len]);
    allocator.destroy(self.kvs);
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.has" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">has</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.has">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">has</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Checks if the map has a value for the key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.has">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">has</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.get(str) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?V</code></pre></div><div class="tldDocs"><p>Returns the value for the key if any, else null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?V {
    <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">return</span> self.kvs.values[self.getIndex(str) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> kvs = self.kvs.*;
    <span class="tok-kw">if</span> (kvs.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (str.len &lt; self.min_len <span class="tok-kw">or</span> str.len &gt; self.max_len)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> i = self.len_indexes[str.len];
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> key = kvs.keys[i];
        <span class="tok-kw">if</span> (key.len != str.len)
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">if</span> (eql(key, str))
            <span class="tok-kw">return</span> i;
        i += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (i &gt;= kvs.len)
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.getLongestPrefix" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLongestPrefix</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.getLongestPrefix">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefix</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.static_string_map.StaticStringMapWithEql.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Returns the key-value pair where key is the longest prefix of <code>str</code>
else null.</p>
<p>This is effectively an O(N) algorithm which loops from <code>max_len</code> to
<code>min_len</code> and calls <code>getIndex()</code> to check all keys with the given
len.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.getLongestPrefix">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefix</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.static_string_map.StaticStringMapWithEql.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> i = self.getLongestPrefixIndex(str) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> kvs = self.kvs.*;
    <span class="tok-kw">return</span> .{
        .key = kvs.keys[i],
        .value = kvs.values[i],
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.getLongestPrefixIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getLongestPrefixIndex</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.getLongestPrefixIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefixIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div><div><pre><code>str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.getLongestPrefixIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefixIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (str.len &lt; self.min_len)
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> len = <span class="tok-builtin">@min</span>(self.max_len, str.len);
    <span class="tok-kw">while</span> (len &gt;= self.min_len) : (len -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (self.getIndex(str[<span class="tok-number">0</span>..len])) |i|
            <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> kvs = self.kvs.*;
    <span class="tok-kw">return</span> kvs.keys[<span class="tok-number">0</span>..kvs.len];
}</code></pre></details></div></div><div class="decl"><h3 id="std.static_string_map.StaticStringMapWithEql.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.static_string_map.StaticStringMapWithEql.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> V {
    <span class="tok-kw">const</span> kvs = self.kvs.*;
    <span class="tok-kw">return</span> kvs.values[<span class="tok-number">0</span>..kvs.len];
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.static_string_map.StaticStringMapWithEql">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StaticStringMapWithEql</span>(
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> eql: <span class="tok-kw">fn</span> (a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        kvs: *<span class="tok-kw">const</span> <a href="std.static_string_map.StaticStringMapWithEql.KVs.html">KVs</a> = &amp;<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql.empty_kvs">empty_kvs</a>,
        len_indexes: [*]<span class="tok-kw">const</span> <span class="tok-type">u32</span> = &amp;<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql.empty_len_indexes">empty_len_indexes</a>,
        len_indexes_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
        min_len: <span class="tok-type">u32</span> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
        max_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <span class="tok-kw">struct</span> {
            key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            value: V,
        };

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-kw">const</span> KVs = <span class="tok-kw">struct</span> {
            keys: [*]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            values: [*]<span class="tok-kw">const</span> V,
            len: <span class="tok-type">u32</span>,
        };
        <span class="tok-kw">const</span> empty_kvs = <a href="std.static_string_map.StaticStringMapWithEql.KVs.html">KVs</a>{
            .keys = &amp;<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql.empty_keys">empty_keys</a>,
            .values = &amp;<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql.empty_vals">empty_vals</a>,
            .len = <span class="tok-number">0</span>,
        };
        <span class="tok-kw">const</span> empty_len_indexes = [<span class="tok-number">0</span>]<span class="tok-type">u32</span>{};
        <span class="tok-kw">const</span> empty_keys = [<span class="tok-number">0</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{};
        <span class="tok-kw">const</span> empty_vals = [<span class="tok-number">0</span>]V{};

        <span class="tok-comment">/// Returns a map backed by static, comptime allocated memory.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `kvs_list` must be either a list of `struct { []const u8, V }`</span>
        <span class="tok-comment">/// (key-value pair) tuples, or a list of `struct { []const u8 }`</span>
        <span class="tok-comment">/// (only keys) tuples if `V` is `void`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">initComptime</span>(<span class="tok-kw">comptime</span> kvs_list: <span class="tok-kw">anytype</span>) <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a> {
            <span class="tok-kw">comptime</span> {
                <span class="tok-kw">var</span> self = <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>{};
                <span class="tok-kw">if</span> (kvs_list.len == <span class="tok-number">0</span>)
                    <span class="tok-kw">return</span> self;<span class="tok-comment">

                // Since the KVs are sorted, a linearly-growing bound will never
                // be sufficient for extreme cases. So we grow proportional to
                // N*log2(N).
                </span><span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">10</span> * kvs_list.len * <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, kvs_list.len));

                <span class="tok-kw">var</span> sorted_keys: [kvs_list.len][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">var</span> sorted_vals: [kvs_list.len]V = <span class="tok-null">undefined</span>;

                self.initSortedKVs(kvs_list, &amp;sorted_keys, &amp;sorted_vals);
                <span class="tok-kw">const</span> final_keys = sorted_keys;
                <span class="tok-kw">const</span> final_vals = sorted_vals;
                self.kvs = &amp;.{
                    .keys = &amp;final_keys,
                    .values = &amp;final_vals,
                    .len = <span class="tok-builtin">@intCast</span>(kvs_list.len),
                };

                <span class="tok-kw">var</span> len_indexes: [self.max_len + <span class="tok-number">1</span>]<span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
                self.initLenIndexes(&amp;len_indexes);
                <span class="tok-kw">const</span> final_len_indexes = len_indexes;
                self.len_indexes = &amp;final_len_indexes;
                self.len_indexes_len = <span class="tok-builtin">@intCast</span>(len_indexes.len);
                <span class="tok-kw">return</span> self;
            }
        }

        <span class="tok-comment">/// Returns a map backed by memory allocated with `allocator`.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Handles `kvs_list` the same way as `initComptime()`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(kvs_list: <span class="tok-kw">anytype</span>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a> {
            <span class="tok-kw">var</span> self = <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>{};
            <span class="tok-kw">if</span> (kvs_list.len == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> self;

            <span class="tok-kw">const</span> sorted_keys = <span class="tok-kw">try</span> allocator.alloc([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kvs_list.len);
            <span class="tok-kw">errdefer</span> allocator.free(sorted_keys);
            <span class="tok-kw">const</span> sorted_vals = <span class="tok-kw">try</span> allocator.alloc(V, kvs_list.len);
            <span class="tok-kw">errdefer</span> allocator.free(sorted_vals);
            <span class="tok-kw">const</span> kvs = <span class="tok-kw">try</span> allocator.create(<a href="std.static_string_map.StaticStringMapWithEql.KVs.html">KVs</a>);
            <span class="tok-kw">errdefer</span> allocator.destroy(kvs);

            self.initSortedKVs(kvs_list, sorted_keys, sorted_vals);
            kvs.* = .{
                .keys = sorted_keys.ptr,
                .values = sorted_vals.ptr,
                .len = <span class="tok-builtin">@intCast</span>(kvs_list.len),
            };
            self.kvs = kvs;

            <span class="tok-kw">const</span> len_indexes = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u32</span>, self.max_len + <span class="tok-number">1</span>);
            self.initLenIndexes(len_indexes);
            self.len_indexes = len_indexes.ptr;
            self.len_indexes_len = <span class="tok-builtin">@intCast</span>(len_indexes.len);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// this method should only be used with init() and not with initComptime().</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            allocator.free(self.len_indexes[<span class="tok-number">0</span>..self.len_indexes_len]);
            allocator.free(self.kvs.keys[<span class="tok-number">0</span>..self.kvs.len]);
            allocator.free(self.kvs.values[<span class="tok-number">0</span>..self.kvs.len]);
            allocator.destroy(self.kvs);
        }

        <span class="tok-kw">const</span> SortContext = <span class="tok-kw">struct</span> {
            keys: [][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            vals: []V,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> ctx.keys[a].len &lt; ctx.keys[b].len;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;ctx.keys[a], &amp;ctx.keys[b]);
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;ctx.vals[a], &amp;ctx.vals[b]);
            }
        };

        <span class="tok-kw">fn</span> <span class="tok-fn">initSortedKVs</span>(
            self: *<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>,
            kvs_list: <span class="tok-kw">anytype</span>,
            sorted_keys: [][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            sorted_vals: []V,
        ) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (kvs_list, <span class="tok-number">0</span>..) |kv, i| {
                sorted_keys[i] = kv.@&quot;0&quot;;
                sorted_vals[i] = <span class="tok-kw">if</span> (V == <span class="tok-type">void</span>) {} <span class="tok-kw">else</span> kv.@&quot;1&quot;;
                self.min_len = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@min</span>(self.min_len, kv.@&quot;0&quot;.len));
                self.max_len = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@max</span>(self.max_len, kv.@&quot;0&quot;.len));
            }
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortUnstableContext">sortUnstableContext</a>(<span class="tok-number">0</span>, sorted_keys.len, <a href="std.static_string_map.StaticStringMapWithEql.SortContext.html">SortContext</a>{
                .keys = sorted_keys,
                .vals = sorted_vals,
            });
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">initLenIndexes</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, len_indexes: []<span class="tok-type">u32</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (len &lt;= self.max_len) : (len += <span class="tok-number">1</span>) {<span class="tok-comment">
                // find the first keyword len == len
                </span><span class="tok-kw">while</span> (len &gt; self.kvs.keys[i].len) {
                    i += <span class="tok-number">1</span>;
                }
                len_indexes[len] = i;
            }
        }

        <span class="tok-comment">/// Checks if the map has a value for the key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">has</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.get(str) != <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Returns the value for the key if any, else null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?V {
            <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;

            <span class="tok-kw">return</span> self.kvs.values[self.getIndex(str) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> kvs = self.kvs.*;
            <span class="tok-kw">if</span> (kvs.len == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;

            <span class="tok-kw">if</span> (str.len &lt; self.min_len <span class="tok-kw">or</span> str.len &gt; self.max_len)
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;

            <span class="tok-kw">var</span> i = self.len_indexes[str.len];
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> key = kvs.keys[i];
                <span class="tok-kw">if</span> (key.len != str.len)
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                <span class="tok-kw">if</span> (eql(key, str))
                    <span class="tok-kw">return</span> i;
                i += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (i &gt;= kvs.len)
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        }

        <span class="tok-comment">/// Returns the key-value pair where key is the longest prefix of `str`</span>
        <span class="tok-comment">/// else null.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// This is effectively an O(N) algorithm which loops from `max_len` to</span>
        <span class="tok-comment">/// `min_len` and calls `getIndex()` to check all keys with the given</span>
        <span class="tok-comment">/// len.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefix</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.static_string_map.StaticStringMapWithEql.KV.html">KV</a> {
            <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> i = self.getLongestPrefixIndex(str) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> kvs = self.kvs.*;
            <span class="tok-kw">return</span> .{
                .key = kvs.keys[i],
                .value = kvs.values[i],
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLongestPrefixIndex</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>, str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (self.kvs.len == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;

            <span class="tok-kw">if</span> (str.len &lt; self.min_len)
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;

            <span class="tok-kw">var</span> len = <span class="tok-builtin">@min</span>(self.max_len, str.len);
            <span class="tok-kw">while</span> (len &gt;= self.min_len) : (len -= <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (self.getIndex(str[<span class="tok-number">0</span>..len])) |i|
                    <span class="tok-kw">return</span> i;
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">const</span> kvs = self.kvs.*;
            <span class="tok-kw">return</span> kvs.keys[<span class="tok-number">0</span>..kvs.len];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">Self</a>) []<span class="tok-kw">const</span> V {
            <span class="tok-kw">const</span> kvs = self.kvs.*;
            <span class="tok-kw">return</span> kvs.values[<span class="tok-number">0</span>..kvs.len];
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.linked_list.DoublyLinkedList" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">DoublyLinkedList</span><a href="#src.zig-std.linked_list.DoublyLinkedList">[src]</a></h2><div class="tldDocs"><p>A doubly-linked list has a pair of pointers to both the head and
tail of the list. List elements have pointers to both the previous
and next elements in the sequence. The list can be traversed both
forward and backward. Some operations that take linear O(n) time
with a singly-linked list can be done without traversal in constant
O(1) time with a doubly-linked list:</p>
<ul>
<li>Removing an element.</li>
<li>Inserting a new element before an existing element.</li>
<li>Pushing or popping an element from the end of the list.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.linked_list.DoublyLinkedList.Node.html">std.linked_list.DoublyLinkedList.Node</a></li></ul></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>first: ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>last: ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.linked_list.DoublyLinkedList.insertAfter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertAfter</span><a href="#src.zig-std.linked_list.DoublyLinkedList.insertAfter">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAfter</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert a new node after an existing one.</p>
<p>Arguments:
node: Pointer to a node in the list.
new_node: Pointer to the new node to insert.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div><div><pre><code>node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div><div><pre><code>new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList.insertAfter">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAfter</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
    new_node.prev = node;
    <span class="tok-kw">if</span> (node.next) |next_node| {<span class="tok-comment">
        // Intermediate node.
        </span>new_node.next = next_node;
        next_node.prev = new_node;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // Last element of the list.
        </span>new_node.next = <span class="tok-null">null</span>;
        list.last = new_node;
    }
    node.next = new_node;

    list.len += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.DoublyLinkedList.insertBefore" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertBefore</span><a href="#src.zig-std.linked_list.DoublyLinkedList.insertBefore">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertBefore</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert a new node before an existing one.</p>
<p>Arguments:
node: Pointer to a node in the list.
new_node: Pointer to the new node to insert.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div><div><pre><code>node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div><div><pre><code>new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList.insertBefore">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertBefore</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
    new_node.next = node;
    <span class="tok-kw">if</span> (node.prev) |prev_node| {<span class="tok-comment">
        // Intermediate node.
        </span>new_node.prev = prev_node;
        prev_node.next = new_node;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // First element of the list.
        </span>new_node.prev = <span class="tok-null">null</span>;
        list.first = new_node;
    }
    node.prev = new_node;

    list.len += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.DoublyLinkedList.concatByMoving" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">concatByMoving</span><a href="#src.zig-std.linked_list.DoublyLinkedList.concatByMoving">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatByMoving</span>(list1: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, list2: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Concatenate list2 onto the end of list1, removing all entries from the former.</p>
<p>Arguments:
list1: the list to concatenate onto
list2: the list to be concatenated</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list1: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div><div><pre><code>list2: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList.concatByMoving">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatByMoving</span>(list1: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, list2: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> l2_first = list2.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    <span class="tok-kw">if</span> (list1.last) |l1_last| {
        l1_last.next = list2.first;
        l2_first.prev = list1.last;
        list1.len += list2.len;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // list1 was empty
        </span>list1.first = list2.first;
        list1.len = list2.len;
    }
    list1.last = list2.last;
    list2.first = <span class="tok-null">null</span>;
    list2.last = <span class="tok-null">null</span>;
    list2.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.DoublyLinkedList.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.linked_list.DoublyLinkedList.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert a new node at the end of the list.</p>
<p>Arguments:
new_node: Pointer to the new node to insert.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div><div><pre><code>new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (list.last) |last| {<span class="tok-comment">
        // Insert after last.
        </span>list.insertAfter(last, new_node);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // Empty list.
        </span>list.prepend(new_node);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.DoublyLinkedList.prepend" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">prepend</span><a href="#src.zig-std.linked_list.DoublyLinkedList.prepend">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepend</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert a new node at the beginning of the list.</p>
<p>Arguments:
new_node: Pointer to the new node to insert.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div><div><pre><code>new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList.prepend">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepend</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (list.first) |first| {<span class="tok-comment">
        // Insert before first.
        </span>list.insertBefore(first, new_node);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // Empty list.
        </span>list.first = new_node;
        list.last = new_node;
        new_node.prev = <span class="tok-null">null</span>;
        new_node.next = <span class="tok-null">null</span>;

        list.len = <span class="tok-number">1</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.DoublyLinkedList.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.linked_list.DoublyLinkedList.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Remove a node from the list.</p>
<p>Arguments:
node: Pointer to the node to be removed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div><div><pre><code>node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (node.prev) |prev_node| {<span class="tok-comment">
        // Intermediate node.
        </span>prev_node.next = node.next;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // First element of the list.
        </span>list.first = node.next;
    }

    <span class="tok-kw">if</span> (node.next) |next_node| {<span class="tok-comment">
        // Intermediate node.
        </span>next_node.prev = node.prev;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // Last element of the list.
        </span>list.last = node.prev;
    }

    list.len -= <span class="tok-number">1</span>;
    <a href="std.debug.html#std.debug.assert">assert</a>(list.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> (list.first != <span class="tok-null">null</span> <span class="tok-kw">and</span> list.last != <span class="tok-null">null</span>));
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.DoublyLinkedList.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.linked_list.DoublyLinkedList.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div><div class="tldDocs"><p>Remove and return the last node in the list.</p>
<p>Returns:
A pointer to the last node in the list.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> {
    <span class="tok-kw">const</span> last = list.last <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    list.remove(last);
    <span class="tok-kw">return</span> last;
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.DoublyLinkedList.popFirst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popFirst</span><a href="#src.zig-std.linked_list.DoublyLinkedList.popFirst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popFirst</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a></code></pre></div><div class="tldDocs"><p>Remove and return the first node in the list.</p>
<p>Returns:
A pointer to the first node in the list.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList.popFirst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popFirst</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> {
    <span class="tok-kw">const</span> first = list.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    list.remove(first);
    <span class="tok-kw">return</span> first;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.linked_list.DoublyLinkedList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">DoublyLinkedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Node inside the linked list wrapping the actual data.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            prev: ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span>,
            next: ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span>,
            data: T,
        };

        first: ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span>,
        last: ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span>,
        len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-comment">/// Insert a new node after an existing one.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Arguments:</span>
        <span class="tok-comment">///     node: Pointer to a node in the list.</span>
        <span class="tok-comment">///     new_node: Pointer to the new node to insert.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAfter</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
            new_node.prev = node;
            <span class="tok-kw">if</span> (node.next) |next_node| {<span class="tok-comment">
                // Intermediate node.
                </span>new_node.next = next_node;
                next_node.prev = new_node;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Last element of the list.
                </span>new_node.next = <span class="tok-null">null</span>;
                list.last = new_node;
            }
            node.next = new_node;

            list.len += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Insert a new node before an existing one.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Arguments:</span>
        <span class="tok-comment">///     node: Pointer to a node in the list.</span>
        <span class="tok-comment">///     new_node: Pointer to the new node to insert.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertBefore</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
            new_node.next = node;
            <span class="tok-kw">if</span> (node.prev) |prev_node| {<span class="tok-comment">
                // Intermediate node.
                </span>new_node.prev = prev_node;
                prev_node.next = new_node;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // First element of the list.
                </span>new_node.prev = <span class="tok-null">null</span>;
                list.first = new_node;
            }
            node.prev = new_node;

            list.len += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Concatenate list2 onto the end of list1, removing all entries from the former.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Arguments:</span>
        <span class="tok-comment">///     list1: the list to concatenate onto</span>
        <span class="tok-comment">///     list2: the list to be concatenated</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatByMoving</span>(list1: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, list2: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> l2_first = list2.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">if</span> (list1.last) |l1_last| {
                l1_last.next = list2.first;
                l2_first.prev = list1.last;
                list1.len += list2.len;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // list1 was empty
                </span>list1.first = list2.first;
                list1.len = list2.len;
            }
            list1.last = list2.last;
            list2.first = <span class="tok-null">null</span>;
            list2.last = <span class="tok-null">null</span>;
            list2.len = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Insert a new node at the end of the list.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Arguments:</span>
        <span class="tok-comment">///     new_node: Pointer to the new node to insert.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (list.last) |last| {<span class="tok-comment">
                // Insert after last.
                </span>list.insertAfter(last, new_node);
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Empty list.
                </span>list.prepend(new_node);
            }
        }

        <span class="tok-comment">/// Insert a new node at the beginning of the list.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Arguments:</span>
        <span class="tok-comment">///     new_node: Pointer to the new node to insert.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepend</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, new_node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (list.first) |first| {<span class="tok-comment">
                // Insert before first.
                </span>list.insertBefore(first, new_node);
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Empty list.
                </span>list.first = new_node;
                list.last = new_node;
                new_node.prev = <span class="tok-null">null</span>;
                new_node.next = <span class="tok-null">null</span>;

                list.len = <span class="tok-number">1</span>;
            }
        }

        <span class="tok-comment">/// Remove a node from the list.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Arguments:</span>
        <span class="tok-comment">///     node: Pointer to the node to be removed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>, node: *<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (node.prev) |prev_node| {<span class="tok-comment">
                // Intermediate node.
                </span>prev_node.next = node.next;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // First element of the list.
                </span>list.first = node.next;
            }

            <span class="tok-kw">if</span> (node.next) |next_node| {<span class="tok-comment">
                // Intermediate node.
                </span>next_node.prev = node.prev;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Last element of the list.
                </span>list.last = node.prev;
            }

            list.len -= <span class="tok-number">1</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(list.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> (list.first != <span class="tok-null">null</span> <span class="tok-kw">and</span> list.last != <span class="tok-null">null</span>));
        }

        <span class="tok-comment">/// Remove and return the last node in the list.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Returns:</span>
        <span class="tok-comment">///     A pointer to the last node in the list.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> {
            <span class="tok-kw">const</span> last = list.last <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            list.remove(last);
            <span class="tok-kw">return</span> last;
        }

        <span class="tok-comment">/// Remove and return the first node in the list.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Returns:</span>
        <span class="tok-comment">///     A pointer to the first node in the list.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popFirst</span>(list: *<a href="std.linked_list.html#std.linked_list.DoublyLinkedList">Self</a>) ?*<a href="std.linked_list.DoublyLinkedList.Node.html">Node</a> {
            <span class="tok-kw">const</span> first = list.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            list.remove(first);
            <span class="tok-kw">return</span> first;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.EnumArray" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumArray</span><a href="#src.zig-std.enums.EnumArray">[src]</a></h2><div class="tldDocs"><p>An array keyed by an enum, backed by a dense array.
If the enum is not dense, a mapping will be constructed from
enum values to dense indices.  This type does no dynamic
allocation and can be copied by value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.enums.EnumArray.Entry.html">std.enums.EnumArray.Entry</a></li><li><a href="std.enums.EnumArray.Iterator.html">std.enums.EnumArray.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.enums.EnumArray.Indexer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Indexer</span><a href="#src.zig-std.enums.EnumArray.Indexer">[src]</a></h3><div class="tldDocs"><p>The index mapping for this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.Indexer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>values: [<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.EnumArray.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumArray.Key">[src]</a></h3><div class="tldDocs"><p>The key type used to index this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">Key</a></code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.Value" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Value</span><a href="#src.zig-std.enums.EnumArray.Value">[src]</a></h3><div class="tldDocs"><p>The value type stored in this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.Value">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.enums.EnumArray.len">[src]</a></h3><div class="tldDocs"><p>The number of possible keys in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.len">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.EnumArray.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.enums.EnumArray.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray.initDefault">initDefault</a>(<span class="tok-null">null</span>, init_values);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.initDefault" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initDefault</span><a href="#src.zig-std.enums.EnumArray.initDefault">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div class="tldDocs"><p>Initializes values in the enum array, with the specified default.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.initDefault">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumArray">Self</a> = .{ .values = <span class="tok-null">undefined</span> };
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumArray">Self</a>.<a href="std.enums.html#std.enums.EnumArray.len">len</a>) |i| {
        <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
        <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
        result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.initUndefined" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initUndefined</span><a href="#src.zig-std.enums.EnumArray.initUndefined">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initUndefined</span>() <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.initUndefined">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initUndefined</span>() <a href="std.enums.html#std.enums.EnumArray">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>{ .values = <span class="tok-null">undefined</span> };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.initFill" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFill</span><a href="#src.zig-std.enums.EnumArray.initFill">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFill</span>(v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.initFill">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFill</span>(v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.enums.html#std.enums.EnumArray">Self</a> = <span class="tok-null">undefined</span>;
    <span class="tok-builtin">@memset</span>(&amp;self.values, v);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.enums.EnumArray.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) <a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div><div class="tldDocs"><p>Returns the value in the array associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
    <span class="tok-kw">return</span> self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.enums.EnumArray.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div><div class="tldDocs"><p>Returns a pointer to the slot in the array associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
    <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.getPtrConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrConst</span><a href="#src.zig-std.enums.EnumArray.getPtrConst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div><div class="tldDocs"><p>Returns a const pointer to the slot in the array associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.getPtrConst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
    <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.enums.EnumArray.set">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets the value in the slot associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a></code></pre></div><div><pre><code>value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.set">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <span class="tok-type">void</span> {
    self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)] = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumArray.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.enums.EnumArray.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>) <a href="std.enums.EnumArray.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Iterates over the items in the array, in index order.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumArray">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumArray.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>) <a href="std.enums.EnumArray.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{
        .values = &amp;self.values,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumArray">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumArray</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The index mapping for this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The key type used to index this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">Key</a>;
        <span class="tok-comment">/// The value type stored in this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V;
        <span class="tok-comment">/// The number of possible keys in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>;

        values: [<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray.initDefault">initDefault</a>(<span class="tok-null">null</span>, init_values);
        }

        <span class="tok-comment">/// Initializes values in the enum array, with the specified default.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumArray">Self</a> = .{ .values = <span class="tok-null">undefined</span> };
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumArray">Self</a>.<a href="std.enums.html#std.enums.EnumArray.len">len</a>) |i| {
                <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initUndefined</span>() <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>{ .values = <span class="tok-null">undefined</span> };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFill</span>(v: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <a href="std.enums.html#std.enums.EnumArray">Self</a> {
            <span class="tok-kw">var</span> self: <a href="std.enums.html#std.enums.EnumArray">Self</a> = <span class="tok-null">undefined</span>;
            <span class="tok-builtin">@memset</span>(&amp;self.values, v);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// Returns the value in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Returns a pointer to the slot in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Returns a const pointer to the slot in the array associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumArray.Value">Value</a> {
            <span class="tok-kw">return</span> &amp;self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)];
        }

        <span class="tok-comment">/// Sets the value in the slot associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>, key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumArray.Value">Value</a>) <span class="tok-type">void</span> {
            self.values[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">indexOf</a>(key)] = value;
        }

        <span class="tok-comment">/// Iterates over the items in the array, in index order.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumArray">Self</a>) <a href="std.enums.EnumArray.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{
                .values = &amp;self.values,
            };
        }

        <span class="tok-comment">/// An entry in the array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The key associated with this entry.</span>
            <span class="tok-comment">/// Modifying this key will not change the array.</span>
            key: <a href="std.enums.html#std.enums.EnumArray.Key">Key</a>,

            <span class="tok-comment">/// A pointer to the value in the array associated</span>
            <span class="tok-comment">/// with this key.  Modifications through this</span>
            <span class="tok-comment">/// pointer will modify the underlying data.</span>
            value: *<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
            values: *[<a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumArray.Value">Value</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumArray.Iterator.html">Iterator</a>) ?<a href="std.enums.EnumArray.Entry.html">Entry</a> {
                <span class="tok-kw">const</span> index = self.index;
                <span class="tok-kw">if</span> (index &lt; <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">count</a>) {
                    self.index += <span class="tok-number">1</span>;
                    <span class="tok-kw">return</span> <a href="std.enums.EnumArray.Entry.html">Entry</a>{
                        .key = <a href="std.enums.html#std.enums.EnumArray.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index),
                        .value = &amp;self.values[index],
                    };
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        };
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.EnumMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumMap</span><a href="#src.zig-std.enums.EnumMap">[src]</a></h2><div class="tldDocs"><p>A map keyed by an enum, backed by a bitfield and a dense array.
If the enum is exhaustive but not dense, a mapping will be constructed from
enum values to dense indices.  This type does no dynamic
allocation and can be copied by value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.enums.EnumMap.Entry.html">std.enums.EnumMap.Entry</a></li><li><a href="std.enums.EnumMap.Iterator.html">std.enums.EnumMap.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.enums.EnumMap.Indexer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Indexer</span><a href="#src.zig-std.enums.EnumMap.Indexer">[src]</a></h3><div class="tldDocs"><p>The index mapping for this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.Indexer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>bits: <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initEmpty</a>()</code></pre><div class="fieldDocs"><p>Bits determining whether items are in the map</p>
</div></div><div><pre><code>values: [<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-null">undefined</span></code></pre><div class="fieldDocs"><p>Values of items in the map.  If the associated
bit is zero, the value is undefined.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.EnumMap.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumMap.Key">[src]</a></h3><div class="tldDocs"><p>The key type used to index this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">Key</a></code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.Value" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Value</span><a href="#src.zig-std.enums.EnumMap.Value">[src]</a></h3><div class="tldDocs"><p>The value type stored in this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.Value">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.enums.EnumMap.len">[src]</a></h3><div class="tldDocs"><p>The number of possible keys in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.len">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.EnumMap.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.enums.EnumMap.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))) <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the map using a sparse struct of optionals</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{};
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
            <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
            <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) |*v| {
                result.bits.set(i);
                result.values[i] = v.*;
            }
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
            <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) |*v| {
                <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                result.bits.set(i);
                result.values[i] = v.*;
            }
        }
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.initFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFull</span><a href="#src.zig-std.enums.EnumMap.initFull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div class="tldDocs"><p>Initializes a full mapping with all keys set to value.
Consider using EnumArray instead if the map will remain full.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.initFull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
        .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
        .values = <span class="tok-null">undefined</span>,
    };
    <span class="tok-builtin">@memset</span>(&amp;result.values, value);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.initFullWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFullWith</span><a href="#src.zig-std.enums.EnumMap.initFullWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWith</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div class="tldDocs"><p>Initializes a full mapping with supplied values.
Consider using EnumArray instead if the map will remain full.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.initFullWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWith</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumMap.initFullWithDefault">initFullWithDefault</a>(<span class="tok-null">null</span>, init_values);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.initFullWithDefault" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFullWithDefault</span><a href="#src.zig-std.enums.EnumMap.initFullWithDefault">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWithDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div class="tldDocs"><p>Initializes a full mapping with a provided default.
Consider using EnumArray instead if the map will remain full.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.initFullWithDefault">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWithDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
        .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
        .values = <span class="tok-null">undefined</span>,
    };
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
        <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
        <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
        result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.EnumMap.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>The number of items in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.bits.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.enums.EnumMap.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Checks if the map contains an item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.enums.EnumMap.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the value associated with a key.
If the key is not in the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getAssertContains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAssertContains</span><a href="#src.zig-std.enums.EnumMap.getAssertContains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAssertContains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the value associated with a key, which must
exist in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getAssertContains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAssertContains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
    <span class="tok-kw">return</span> self.values[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.enums.EnumMap.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the address of the value associated with a key.
If the key is not in the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getPtrConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrConst</span><a href="#src.zig-std.enums.EnumMap.getPtrConst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the address of the const value associated with a key.
If the key is not in the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getPtrConst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getPtrAssertContains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAssertContains</span><a href="#src.zig-std.enums.EnumMap.getPtrAssertContains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAssertContains</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the address of the value associated with a key.
The key must be present in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getPtrAssertContains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAssertContains</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
    <span class="tok-kw">return</span> &amp;self.values[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.getPtrConstAssertContains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrConstAssertContains</span><a href="#src.zig-std.enums.EnumMap.getPtrConstAssertContains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConstAssertContains</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Gets the address of the const value associated with a key.
The key must be present in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.getPtrConstAssertContains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConstAssertContains</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
    <span class="tok-kw">return</span> &amp;self.values[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.enums.EnumMap.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds the key to the map with the supplied value.
If the key is already in the map, overwrites the value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div><div><pre><code>value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    self.bits.set(index);
    self.values[index] = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.putUninitialized" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putUninitialized</span><a href="#src.zig-std.enums.EnumMap.putUninitialized">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putUninitialized</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Adds the key to the map with an undefined value.
If the key is already in the map, the value becomes undefined.
A pointer to the value is returned, which should be
used to initialize the value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.putUninitialized">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putUninitialized</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    self.bits.set(index);
    self.values[index] = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> &amp;self.values[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.enums.EnumMap.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Sets the value associated with the key in the map,
and returns the old value.  If the key was not in
the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div><div><pre><code>value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    self.bits.set(index);
    self.values[index] = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.enums.EnumMap.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes a key from the map.  If the key was not in the map,
does nothing.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    self.bits.unset(index);
    self.values[index] = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.enums.EnumMap.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a></code></pre></div><div class="tldDocs"><p>Removes a key from the map, and returns the old value.
If the key was not in the map, returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
    <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
    <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    self.bits.unset(index);
    self.values[index] = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumMap.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.enums.EnumMap.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>) <a href="std.enums.EnumMap.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the map, which visits items in index order.
Modifications to the underlying map may or may not be observed by
the iterator, but will not invalidate it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumMap.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>) <a href="std.enums.EnumMap.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{
        .inner = self.bits.iterator(.{}),
        .values = &amp;self.values,
    };
}</code></pre></details></div></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> EnumMap {
    <span class="tok-kw">const</span> Ball = <span class="tok-kw">enum</span> { red, green, blue };

    <span class="tok-kw">const</span> some = <a href="std.enums.html#std.enums.EnumMap">EnumMap</a>(Ball, <span class="tok-type">u8</span>).init(.{
        .green = <span class="tok-number">0xff</span>,
        .blue = <span class="tok-number">0x80</span>,
    });
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, some.count());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, some.get(.red));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0xff</span>, some.get(.green));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0x80</span>, some.get(.blue));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumMap</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The index mapping for this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The key type used to index this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">Key</a>;
        <span class="tok-comment">/// The value type stored in this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = V;
        <span class="tok-comment">/// The number of possible keys in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>;

        <span class="tok-kw">const</span> BitSet = <a href="std.html">std</a>.<a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>);

        <span class="tok-comment">/// Bits determining whether items are in the map</span>
        bits: <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initEmpty</a>(),
        <span class="tok-comment">/// Values of items in the map.  If the associated</span>
        <span class="tok-comment">/// bit is zero, the value is undefined.</span>
        values: [<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-null">undefined</span>,

        <span class="tok-comment">/// Initializes the map using a sparse struct of optionals</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-builtin">@as</span>(?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>))) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{};
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
                    <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                    <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) |*v| {
                        result.bits.set(i);
                        result.values[i] = v.*;
                    }
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
                    <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) |*v| {
                        <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                        result.bits.set(i);
                        result.values[i] = v.*;
                    }
                }
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Initializes a full mapping with all keys set to value.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
                .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
                .values = <span class="tok-null">undefined</span>,
            };
            <span class="tok-builtin">@memset</span>(&amp;result.values, value);
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Initializes a full mapping with supplied values.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWith</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, <span class="tok-null">null</span>)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumMap.initFullWithDefault">initFullWithDefault</a>(<span class="tok-null">null</span>, init_values);
        }

        <span class="tok-comment">/// Initializes a full mapping with a provided default.</span>
        <span class="tok-comment">/// Consider using EnumArray instead if the map will remain full.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFullWithDefault</span>(<span class="tok-kw">comptime</span> default: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>, default)) <a href="std.enums.html#std.enums.EnumMap">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumMap">Self</a> = .{
                .bits = <a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">initFull</a>(),
                .values = <span class="tok-null">undefined</span>,
            };
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumMap">Self</a>.<a href="std.enums.html#std.enums.EnumMap.len">len</a>) |i| {
                <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                result.values[i] = <span class="tok-builtin">@field</span>(init_values, tag);
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// The number of items in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.bits.count();
        }

        <span class="tok-comment">/// Checks if the map contains an item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Gets the value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the value associated with a key, which must</span>
        <span class="tok-comment">/// exist in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAssertContains</span>(self: <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> self.values[index];
        }

        <span class="tok-comment">/// Gets the address of the value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the address of the const value associated with a key.</span>
        <span class="tok-comment">/// If the key is not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConst</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?*<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.bits.isSet(index)) &amp;self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Gets the address of the value associated with a key.</span>
        <span class="tok-comment">/// The key must be present in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAssertContains</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Gets the address of the const value associated with a key.</span>
        <span class="tok-comment">/// The key must be present in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrConstAssertContains</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.bits.isSet(index));
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Adds the key to the map with the supplied value.</span>
        <span class="tok-comment">/// If the key is already in the map, overwrites the value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.set(index);
            self.values[index] = value;
        }

        <span class="tok-comment">/// Adds the key to the map with an undefined value.</span>
        <span class="tok-comment">/// If the key is already in the map, the value becomes undefined.</span>
        <span class="tok-comment">/// A pointer to the value is returned, which should be</span>
        <span class="tok-comment">/// used to initialize the value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putUninitialized</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.set(index);
            self.values[index] = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> &amp;self.values[index];
        }

        <span class="tok-comment">/// Sets the value associated with the key in the map,</span>
        <span class="tok-comment">/// and returns the old value.  If the key was not in</span>
        <span class="tok-comment">/// the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>, value: <a href="std.enums.html#std.enums.EnumMap.Value">Value</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            self.bits.set(index);
            self.values[index] = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Removes a key from the map.  If the key was not in the map,</span>
        <span class="tok-comment">/// does nothing.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            self.bits.unset(index);
            self.values[index] = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Removes a key from the map, and returns the old value.</span>
        <span class="tok-comment">/// If the key was not in the map, returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>, key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>) ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> {
            <span class="tok-kw">const</span> index = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
            <span class="tok-kw">const</span> result: ?<a href="std.enums.html#std.enums.EnumMap.Value">Value</a> = <span class="tok-kw">if</span> (self.bits.isSet(index)) self.values[index] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            self.bits.unset(index);
            self.values[index] = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns an iterator over the map, which visits items in index order.</span>
        <span class="tok-comment">/// Modifications to the underlying map may or may not be observed by</span>
        <span class="tok-comment">/// the iterator, but will not invalidate it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.enums.html#std.enums.EnumMap">Self</a>) <a href="std.enums.EnumMap.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{
                .inner = self.bits.iterator(.{}),
                .values = &amp;self.values,
            };
        }

        <span class="tok-comment">/// An entry in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The key associated with this entry.</span>
            <span class="tok-comment">/// Modifying this key will not change the map.</span>
            key: <a href="std.enums.html#std.enums.EnumMap.Key">Key</a>,

            <span class="tok-comment">/// A pointer to the value in the map associated</span>
            <span class="tok-comment">/// with this key.  Modifications through this</span>
            <span class="tok-comment">/// pointer will modify the underlying data.</span>
            value: *<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            inner: <a href="std.enums.html#std.enums.EnumMap.BitSet">BitSet</a>.<a href="#">Iterator</a>(.{}),
            values: *[<a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">count</a>]<a href="std.enums.html#std.enums.EnumMap.Value">Value</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumMap.Iterator.html">Iterator</a>) ?<a href="std.enums.EnumMap.Entry.html">Entry</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.inner.next()) |index|
                    <a href="std.enums.EnumMap.Entry.html">Entry</a>{
                        .key = <a href="std.enums.html#std.enums.EnumMap.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index),
                        .value = &amp;self.values[index],
                    }
                <span class="tok-kw">else</span>
                    <span class="tok-null">null</span>;
            }
        };
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.enums.EnumSet" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">EnumSet</span><a href="#src.zig-std.enums.EnumSet">[src]</a></h2><div class="tldDocs"><p>A set of enum elements, backed by a bitfield.  If the enum
is exhaustive but not dense, a mapping will be constructed from enum values
to dense indices.  This type does no dynamic allocation and
can be copied by value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>E: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.enums.EnumSet.Iterator.html">std.enums.EnumSet.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.enums.EnumSet.Indexer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Indexer</span><a href="#src.zig-std.enums.EnumSet.Indexer">[src]</a></h3><div class="tldDocs"><p>The indexing rules for converting between keys and indices.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.Indexer">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>bits: <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>()</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.enums.EnumSet.Key" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Key</span><a href="#src.zig-std.enums.EnumSet.Key">[src]</a></h3><div class="tldDocs"><p>The element type for this set.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.Key">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">Key</a></code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.enums.EnumSet.len">[src]</a></h3><div class="tldDocs"><p>The maximum number of items in this set.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.len">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">count</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.enums.EnumSet.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.enums.EnumSet.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Initializes the set using a struct of bools</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
    <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumSet">Self</a> = .{};
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumSet">Self</a>.<a href="std.enums.html#std.enums.EnumSet.len">len</a>) |i| {
            <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
            <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) {
                result.bits.set(i);
            }
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
            <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) {
                <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                result.bits.set(i);
            }
        }
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.initEmpty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initEmpty</span><a href="#src.zig-std.enums.EnumSet.initEmpty">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set containing no keys.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.initEmpty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>() };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.initFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFull</span><a href="#src.zig-std.enums.EnumSet.initFull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set containing all possible keys.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.initFull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initFull</a>() };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.initMany" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initMany</span><a href="#src.zig-std.enums.EnumSet.initMany">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initMany</span>(keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set containing multiple keys.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.initMany">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initMany</span>(keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">var</span> set = <a href="std.enums.html#std.enums.EnumSet.initEmpty">initEmpty</a>();
    <span class="tok-kw">for</span> (keys) |key| set.insert(key);
    <span class="tok-kw">return</span> set;
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.initOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initOne</span><a href="#src.zig-std.enums.EnumSet.initOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initOne</span>(key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set containing a single key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.initOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initOne</span>(key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumSet.initMany">initMany</a>(&amp;[_]<a href="std.enums.html#std.enums.EnumSet.Key">Key</a>{key});
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.enums.EnumSet.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of keys in the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.bits.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.enums.EnumSet.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Checks if a key is in the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.enums.EnumSet.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts a key in the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
    self.bits.set(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.enums.EnumSet.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes a key from the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
    self.bits.unset(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.setPresent" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setPresent</span><a href="#src.zig-std.enums.EnumSet.setPresent">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPresent</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>, present: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the presence of a key in the set to match the passed bool.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div><div><pre><code>present: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.setPresent">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPresent</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>, present: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    self.bits.setValue(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key), present);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.toggle" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggle</span><a href="#src.zig-std.enums.EnumSet.toggle">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Toggles the presence of a key in the set.  If the key is in
the set, removes it.  Otherwise adds it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.toggle">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
    self.bits.toggle(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.toggleSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleSet</span><a href="#src.zig-std.enums.EnumSet.toggleSet">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Toggles the presence of all keys in the passed set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.toggleSet">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
    self.bits.toggleSet(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.toggleAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleAll</span><a href="#src.zig-std.enums.EnumSet.toggleAll">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Toggles all possible keys in the set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.toggleAll">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
    self.bits.toggleAll();
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.setUnion" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setUnion</span><a href="#src.zig-std.enums.EnumSet.setUnion">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds all keys in the passed set to this set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.setUnion">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
    self.bits.setUnion(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.setIntersection" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setIntersection</span><a href="#src.zig-std.enums.EnumSet.setIntersection">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes all keys which are not in the passed set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.setIntersection">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
    self.bits.setIntersection(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.enums.EnumSet.eql">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff both sets have the same keys.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.eql(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.subsetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subsetOf</span><a href="#src.zig-std.enums.EnumSet.subsetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff all the keys in this set are
in the other set. The other set may have keys
not found in this set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.subsetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.subsetOf(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.supersetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supersetOf</span><a href="#src.zig-std.enums.EnumSet.supersetOf">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff this set contains all the keys
in the other set. This set may have keys not
found in the other set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.supersetOf">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.bits.supersetOf(other.bits);
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.complement" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">complement</span><a href="#src.zig-std.enums.EnumSet.complement">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with all the keys not in this set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.complement">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.complement() };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.unionWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unionWith</span><a href="#src.zig-std.enums.EnumSet.unionWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with keys that are in either this
set or the other set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.unionWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.unionWith(other.bits) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.intersectWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intersectWith</span><a href="#src.zig-std.enums.EnumSet.intersectWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with keys that are in both this
set and the other set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.intersectWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.intersectWith(other.bits) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.xorWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">xorWith</span><a href="#src.zig-std.enums.EnumSet.xorWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with keys that are in either this
set or the other set, but not both.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.xorWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.xorWith(other.bits) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.differenceWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">differenceWith</span><a href="#src.zig-std.enums.EnumSet.differenceWith">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div class="tldDocs"><p>Returns a set with keys that are in this set
except for keys in the other set.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div><div><pre><code>other: <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.differenceWith">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
    <span class="tok-kw">return</span> .{ .bits = self.bits.differenceWith(other.bits) };
}</code></pre></details></div></div><div class="decl"><h3 id="std.enums.EnumSet.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.enums.EnumSet.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.EnumSet.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over this set, which iterates in
index order.  Modifications to the set during iteration
may or may not be observed by the iterator, but will
not invalidate it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.enums.EnumSet.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.EnumSet.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{ .inner = self.bits.iterator(.{}) };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.enums.EnumSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">EnumSet</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The indexing rules for converting between keys and indices.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Indexer = <a href="std.enums.html#std.enums.EnumIndexer">EnumIndexer</a>(E);
        <span class="tok-comment">/// The element type for this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Key = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">Key</a>;

        <span class="tok-kw">const</span> BitSet = <a href="std.html">std</a>.<a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">count</a>);

        <span class="tok-comment">/// The maximum number of items in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">count</a>;

        bits: <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a> = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>(),

        <span class="tok-comment">/// Initializes the set using a struct of bools</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(init_values: <a href="std.enums.html#std.enums.EnumFieldStruct">EnumFieldStruct</a>(E, <span class="tok-type">bool</span>, <span class="tok-null">false</span>)) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2</span> * <span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.fields.len);
            <span class="tok-kw">var</span> result: <a href="std.enums.html#std.enums.EnumSet">Self</a> = .{};
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(E).@&quot;enum&quot;.is_exhaustive) {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<a href="std.enums.html#std.enums.EnumSet">Self</a>.<a href="std.enums.html#std.enums.EnumSet.len">len</a>) |i| {
                    <span class="tok-kw">const</span> key = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(i);
                    <span class="tok-kw">const</span> tag = <span class="tok-builtin">@tagName</span>(key);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, tag)) {
                        result.bits.set(i);
                    }
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(E)) |field| {
                    <span class="tok-kw">const</span> key = <span class="tok-builtin">@field</span>(E, field.name);
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(init_values, field.name)) {
                        <span class="tok-kw">const</span> i = <span class="tok-kw">comptime</span> <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key);
                        result.bits.set(i);
                    }
                }
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a set containing no keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initEmpty</a>() };
        }

        <span class="tok-comment">/// Returns a set containing all possible keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>() <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">initFull</a>() };
        }

        <span class="tok-comment">/// Returns a set containing multiple keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initMany</span>(keys: []<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">var</span> set = <a href="std.enums.html#std.enums.EnumSet.initEmpty">initEmpty</a>();
            <span class="tok-kw">for</span> (keys) |key| set.insert(key);
            <span class="tok-kw">return</span> set;
        }

        <span class="tok-comment">/// Returns a set containing a single key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initOne</span>(key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> <a href="std.enums.html#std.enums.EnumSet.initMany">initMany</a>(&amp;[_]<a href="std.enums.html#std.enums.EnumSet.Key">Key</a>{key});
        }

        <span class="tok-comment">/// Returns the number of keys in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.bits.count();
        }

        <span class="tok-comment">/// Checks if a key is in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.isSet(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Puts a key in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.set(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Removes a key from the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.unset(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Changes the presence of a key in the set to match the passed bool.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPresent</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>, present: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
            self.bits.setValue(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key), present);
        }

        <span class="tok-comment">/// Toggles the presence of a key in the set.  If the key is in</span>
        <span class="tok-comment">/// the set, removes it.  Otherwise adds it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, key: <a href="std.enums.html#std.enums.EnumSet.Key">Key</a>) <span class="tok-type">void</span> {
            self.bits.toggle(<a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">indexOf</a>(key));
        }

        <span class="tok-comment">/// Toggles the presence of all keys in the passed set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.toggleSet(other.bits);
        }

        <span class="tok-comment">/// Toggles all possible keys in the set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.toggleAll();
        }

        <span class="tok-comment">/// Adds all keys in the passed set to this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.setUnion(other.bits);
        }

        <span class="tok-comment">/// Removes all keys which are not in the passed set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">void</span> {
            self.bits.setIntersection(other.bits);
        }

        <span class="tok-comment">/// Returns true iff both sets have the same keys.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.eql(other.bits);
        }

        <span class="tok-comment">/// Returns true iff all the keys in this set are</span>
        <span class="tok-comment">/// in the other set. The other set may have keys</span>
        <span class="tok-comment">/// not found in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.subsetOf(other.bits);
        }

        <span class="tok-comment">/// Returns true iff this set contains all the keys</span>
        <span class="tok-comment">/// in the other set. This set may have keys not</span>
        <span class="tok-comment">/// found in the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.bits.supersetOf(other.bits);
        }

        <span class="tok-comment">/// Returns a set with all the keys not in this set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">complement</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.complement() };
        }

        <span class="tok-comment">/// Returns a set with keys that are in either this</span>
        <span class="tok-comment">/// set or the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unionWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.unionWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in both this</span>
        <span class="tok-comment">/// set and the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intersectWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.intersectWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in either this</span>
        <span class="tok-comment">/// set or the other set, but not both.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">xorWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.xorWith(other.bits) };
        }

        <span class="tok-comment">/// Returns a set with keys that are in this set</span>
        <span class="tok-comment">/// except for keys in the other set.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">differenceWith</span>(self: <a href="std.enums.html#std.enums.EnumSet">Self</a>, other: <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.html#std.enums.EnumSet">Self</a> {
            <span class="tok-kw">return</span> .{ .bits = self.bits.differenceWith(other.bits) };
        }

        <span class="tok-comment">/// Returns an iterator over this set, which iterates in</span>
        <span class="tok-comment">/// index order.  Modifications to the set during iteration</span>
        <span class="tok-comment">/// may or may not be observed by the iterator, but will</span>
        <span class="tok-comment">/// not invalidate it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.enums.html#std.enums.EnumSet">Self</a>) <a href="std.enums.EnumSet.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{ .inner = self.bits.iterator(.{}) };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            inner: <a href="std.enums.html#std.enums.EnumSet.BitSet">BitSet</a>.<a href="#">Iterator</a>(.{}),

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.enums.EnumSet.Iterator.html">Iterator</a>) ?<a href="std.enums.html#std.enums.EnumSet.Key">Key</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.inner.next()) |index|
                    <a href="std.enums.html#std.enums.EnumSet.Indexer">Indexer</a>.<a href="#">keyForIndex</a>(index)
                <span class="tok-kw">else</span>
                    <span class="tok-null">null</span>;
            }
        };
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.HashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">HashMap</span><a href="#src.zig-std.hash_map.HashMap">[src]</a></h2><div class="tldDocs"><p>General purpose hash table.
No order is guaranteed and any modification invalidates live iterators.
It provides fast operations (lookup, insertion, deletion) with quite high
load factors (up to 80% by default) for low memory usage.
For a hash map that can be initialized directly that does not store an Allocator
field, see <code><a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a></code>.
If iterating over the table entries is a strong usecase and needs to be fast,
prefer the alternative <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">std.ArrayHashMap</a></code>.
Context must be a struct type with two member functions:
hash(self, K) u64
eql(self, K, K) bool
Adapted variants of many functions are provided.  These variants
take a pseudo key instead of a key.  Their context must have the functions:
hash(self, PseudoKey) u64
eql(self, PseudoKey, K) bool</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div><div><pre><code>max_load_percentage: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMap.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.hash_map.HashMap.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The type of the unmanaged hash map underlying this wrapper</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMap.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.hash_map.HashMap.Entry">[src]</a></h3><div class="tldDocs"><p>An entry, containing pointers to a key and value stored in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.hash_map.HashMap.KV">[src]</a></h3><div class="tldDocs"><p>A copy of a key and value which are no longer in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMap.Hash">[src]</a></h3><div class="tldDocs"><p>The integer type that is the result of hashing</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.hash_map.HashMap.Iterator">[src]</a></h3><div class="tldDocs"><p>The iterator type returned by iterator()</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KeyIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMap.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ValueIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMap.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Size" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMap.Size">[src]</a></h3><div class="tldDocs"><p>The integer type used to store the size of the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.hash_map.HashMap.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>The type returned from getOrPut and variants</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMap.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.hash_map.HashMap.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with an empty context.
If the context is not zero-sized, you must use
initContext(allocator, ctx) instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
    }
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
    </span>};
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.hash_map.HashMap.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with a context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMap.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMap.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMap.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release the backing array and invalidate this map.
This does <em>not</em> deinit keys, values, or the context!
If your keys or values need to be released, ensure
that that is done before calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMap.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map, but keep the backing allocation for future use.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMap.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map and release the backing allocation.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMap.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Return the number of items in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMap.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the entries in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMap.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the keys in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.keyIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMap.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the values in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.valueIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMap.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMap.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMap.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMap.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMap.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMap.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes a value from the map and returns the removed kv pair.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMap.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMap.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Finds the value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMap.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMap.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMap.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Finds the actual key associated with an adapted key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMap.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds the key and value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMap.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMap.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check if the map contains a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMap.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMap.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMap.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMap.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
    self.unmanaged.removeByPtr(key_ptr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMap.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using the same allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>( self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
    self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
    new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    new_ctx: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMap.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMap.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.rehash(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.HashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">HashMap</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> max_load_percentage: <span class="tok-type">u64</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        ctx: Context,

        <span class="tok-comment">/// The type of the unmanaged hash map underlying this wrapper</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage);
        <span class="tok-comment">/// An entry, containing pointers to a key and value stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a>;
        <span class="tok-comment">/// A copy of a key and value which are no longer in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a>;
        <span class="tok-comment">/// The integer type that is the result of hashing</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a>;
        <span class="tok-comment">/// The iterator type returned by iterator()</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a>;

        <span class="tok-comment">/// The integer type used to store the size of the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a>;
        <span class="tok-comment">/// The type returned from getOrPut and variants</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a>;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Create a managed hash map with an empty context.</span>
        <span class="tok-comment">/// If the context is not zero-sized, you must use</span>
        <span class="tok-comment">/// initContext(allocator, ctx) instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
            }
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
            </span>};
        }

        <span class="tok-comment">/// Create a managed hash map with a context</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.lockPointers();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.unlockPointers();
        }

        <span class="tok-comment">/// Release the backing array and invalidate this map.</span>
        <span class="tok-comment">/// This does *not* deinit keys, values, or the context!</span>
        <span class="tok-comment">/// If your keys or values need to be released, ensure</span>
        <span class="tok-comment">/// that that is done before calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.deinit(self.allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Empty the map, but keep the backing allocation for future use.</span>
        <span class="tok-comment">/// This does *not* free keys or values! Be sure to</span>
        <span class="tok-comment">/// release them if they need deinitialization before</span>
        <span class="tok-comment">/// calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
        }

        <span class="tok-comment">/// Empty the map and release the backing allocation.</span>
        <span class="tok-comment">/// This does *not* free keys or values! Be sure to</span>
        <span class="tok-comment">/// release them if they need deinitialization before</span>
        <span class="tok-comment">/// calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
        }

        <span class="tok-comment">/// Return the number of items in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
            <span class="tok-kw">return</span> self.unmanaged.count();
        }

        <span class="tok-comment">/// Create an iterator over the entries in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.iterator();
        }

        <span class="tok-comment">/// Create an iterator over the keys in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.keyIterator();
        }

        <span class="tok-comment">/// Create an iterator over the values in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.valueIterator();
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined key and value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// the key and value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// the key and value.</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
            <span class="tok-kw">return</span> self.unmanaged.capacity();
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Removes a value from the map and returns the removed kv pair.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the value associated with a key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the actual key associated with an adapted key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the key and value associated with a key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
        }

        <span class="tok-comment">/// Check if the map contains a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and this function returns true.  Otherwise this</span>
        <span class="tok-comment">/// function returns false.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
        }

        <span class="tok-comment">/// Delete the entry with key pointed to by key_ptr from the hash map.</span>
        <span class="tok-comment">/// key_ptr is assumed to be a valid pointer to a key that is present</span>
        <span class="tok-comment">/// in the hash map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
            self.unmanaged.removeByPtr(key_ptr);
        }

        <span class="tok-comment">/// Creates a copy of this map, using the same allocator</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified allocator</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified context</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified allocator and context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
            self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
            new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
            new_ctx: <span class="tok-kw">anytype</span>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
            <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            self.unmanaged.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.unmanaged = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Rehash the map, in-place.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Over time, due to the current tombstone-based implementation, a</span>
        <span class="tok-comment">/// HashMap could become fragmented due to the buildup of tombstone</span>
        <span class="tok-comment">/// entries that causes a performance degradation due to excessive</span>
        <span class="tok-comment">/// probing. The kind of pattern that might cause this is a long-lived</span>
        <span class="tok-comment">/// HashMap with repeated inserts and deletes.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// After this function is called, there will be no tombstones in</span>
        <span class="tok-comment">/// the HashMap, each of the entries is rehashed and any existing</span>
        <span class="tok-comment">/// key/value pointers into the HashMap are invalidated.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.rehash(self.ctx);
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.HashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">HashMapUnmanaged</span><a href="#src.zig-std.hash_map.HashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>A HashMap based on open addressing and linear probing.
A lookup or modification typically incurs only 2 cache misses.
No order is guaranteed and any modification invalidates live iterators.
It achieves good performance with quite high load factors (by default,
grow is triggered at 80% full) and only one byte of overhead per element.
The struct itself is only 16 bytes for a small footprint. This comes at
the price of handling size with u32, which should be reasonable enough
for almost all uses.
Deletions are achieved with tombstones.</p>
<p>Default initialization of this struct is deprecated; use <code>.empty</code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div><div><pre><code>max_load_percentage: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.hash_map.HashMapUnmanaged.Entry.html">std.hash_map.HashMapUnmanaged.Entry</a></li><li><a href="std.hash_map.HashMapUnmanaged.KV.html">std.hash_map.HashMapUnmanaged.KV</a></li><li><a href="std.hash_map.HashMapUnmanaged.Iterator.html">std.hash_map.HashMapUnmanaged.Iterator</a></li><li><a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">std.hash_map.HashMapUnmanaged.GetOrPutResult</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Size" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Size">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Hash">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.KeyIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ValueIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Managed">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Pointer to the metadata.</p>
</div></div><div><pre><code>size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Current number of elements in the hashmap.</p>
</div></div><div><pre><code>available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Number of available slots before a grow is needed to satisfy the
<code>max_load_percentage</code>.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
    .metadata = <span class="tok-null">null</span>,
    .size = <span class="tok-number">0</span>,
    .available = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.deallocate(allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (new_size &gt; self.size)
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (self.metadata) |_| {
        self.initMetadatas();
        self.size = <span class="tok-number">0</span>;
        self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    self.deallocate(allocator);
    self.size = <span class="tok-number">0</span>;
    self.available = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">return</span> self.size;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">return</span> self.header().capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{ .hm = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.keys(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.values(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
    }
    self.putAssumeCapacityNoClobberContext(key, value, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    gop.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present,
and that no allocation is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

    <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

    <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
    self.available -= <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    self.keys()[idx] = key;
    self.values()[idx] = value;

    self.size += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
        <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
        <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = old_key.*,
            .value = old_val.*,
        };
        self.metadata.?[idx].remove();
        old_key.* = <span class="tok-null">undefined</span>;
        old_val.* = <span class="tok-null">undefined</span>;
        self.size -= <span class="tok-number">1</span>;
        self.available += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
            .key_ptr = &amp;self.keys()[idx],
            .value_ptr = &amp;self.values()[idx],
        };
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry if the associated key is not already present, otherwise update preexisting value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Get a copy of the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Get a copy of the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // If allocation fails, try to do the lookup anyway.
            // If we find an existing item, we can return it.
            // Otherwise return the error, we could not add another.
            </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = &amp;self.keys()[index],
                .value_ptr = &amp;self.values()[index],
                .found_existing = <span class="tok-null">true</span>,
            };
        };
    }
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!result.found_existing) {
        result.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

    // If you get a compile error on this line, it means that your generic hash
    // function is invalid for these parameters.
    </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    <span class="tok-kw">var</span> limit = self.capacity();
    <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

    <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
    </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
            <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
            // If you get a compile error on this line, it means that your generic eql
            // function is invalid for these parameters.

            </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = test_key,
                    .value_ptr = &amp;self.values()[idx],
                    .found_existing = <span class="tok-null">true</span>,
                };
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
            first_tombstone_idx = idx;
        }

        limit -= <span class="tok-number">1</span>;
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
        // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
        </span>idx = first_tombstone_idx;
        metadata = self.metadata.? + idx;
    }<span class="tok-comment">
    // We're using a slot previously free or a tombstone.
    </span>self.available -= <span class="tok-number">1</span>;

    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
    <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
    new_key.* = <span class="tok-null">undefined</span>;
    new_value.* = <span class="tok-null">undefined</span>;
    self.size += <span class="tok-number">1</span>;

    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
        .key_ptr = new_key,
        .value_ptr = new_value,
        .found_existing = <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Return true if there is a value associated with key in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        self.removeByIndex(idx);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
    // TODO: replace with pointer subtraction once supported by zig
    // if @sizeOf(K) == 0 then there is at most one item in the hash
    // map, which is assumed to exist as key_ptr must be valid.  This
    // item must be at index 0.
    </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
        (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;

    self.removeByIndex(idx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
    <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> other;

    <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
    <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
    other.initMetadatas();
    other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

    <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">const</span> keys_ptr = self.keys();
    <span class="tok-kw">const</span> values_ptr = self.values();
    <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (metadata[i].isUsed()) {
            other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
            <span class="tok-kw">if</span> (other.size == self.size)
                <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">var</span> keys_ptr = self.keys();
    <span class="tok-kw">var</span> values_ptr = self.values();
    <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

    // While we are re-hashing every slot, we will use the
    // fingerprint to mark used buckets as being used and either free
    // (needing to be rehashed) or tombstone (already rehashed).

    </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
    }<span class="tok-comment">

    // Now iterate over all the buckets, rehashing them

    </span>curr = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
        <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            curr += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
        <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
        <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

        // For each bucket, rehash to an index:
        // 1) before the cursor, probed into a free slot, or
        // 2) equal to the cursor, no need to move, or
        // 3) ahead of the cursor, probing over already rehashed

        </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
            (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
        {
            idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        }

        <span class="tok-kw">if</span> (idx &lt; curr) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
            metadata[idx].fill(fingerprint);
            keys_ptr[idx] = keys_ptr[curr];
            values_ptr[idx] = values_ptr[curr];

            metadata[curr].used = <span class="tok-number">0</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            keys_ptr[curr] = <span class="tok-null">undefined</span>;
            values_ptr[curr] = <span class="tok-null">undefined</span>;

            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
            metadata[idx].fingerprint = fingerprint;
            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
            metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
            } <span class="tok-kw">else</span> {
                metadata[idx].used = <span class="tok-number">1</span>;
                keys_ptr[idx] = keys_ptr[curr];
                values_ptr[idx] = values_ptr[curr];

                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                metadata[curr].used = <span class="tok-number">0</span>;
                keys_ptr[curr] = <span class="tok-null">undefined</span>;
                values_ptr[curr] = <span class="tok-null">undefined</span>;

                curr += <span class="tok-number">1</span>;
            }
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">HashMapUnmanaged</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> max_load_percentage: <span class="tok-type">u64</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (max_load_percentage &lt;= <span class="tok-number">0</span> <span class="tok-kw">or</span> max_load_percentage &gt;= <span class="tok-number">100</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;max_load_percentage must be between 0 and 100.&quot;</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // This is actually a midway pointer to the single buffer containing
        // a `Header` field, the `Metadata`s and `Entry`s.
        // At `-@sizeOf(Header)` is the Header field.
        // At `sizeOf(Metadata) * capacity + offset`, which is pointed to by
        // self.header().entries, is the array of entries.
        // This means that the hashmap only holds one live allocation, to
        // reduce memory fragmentation and struct size.
        </span><span class="tok-comment">/// Pointer to the metadata.</span>
        metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span>,

        <span class="tok-comment">/// Current number of elements in the hashmap.</span>
        size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,<span class="tok-comment">

        // Having a countdown to grow reduces the number of instructions to
        // execute when determining if the hashmap has enough capacity already.
        </span><span class="tok-comment">/// Number of available slots before a grow is needed to satisfy the</span>
        <span class="tok-comment">/// `max_load_percentage`.</span>
        available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,

        <span class="tok-comment">/// Used to detect memory safety violations.</span>
        pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{},<span class="tok-comment">

        // This is purely empirical and not a /very smart magic constant/.
        </span><span class="tok-comment">/// Capacity of the first grow when bootstrapping the hashmap.</span>
        <span class="tok-kw">const</span> minimal_capacity = <span class="tok-number">8</span>;

        <span class="tok-comment">/// A map containing no keys or values.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
            .metadata = <span class="tok-null">null</span>,
            .size = <span class="tok-number">0</span>,
            .available = <span class="tok-number">0</span>,
        };<span class="tok-comment">

        // This hashmap is specially designed for sizes that fit in a u32.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span>;<span class="tok-comment">

        // u64 hashes guarantee us that the fingerprint bits will never be used
        // to compute the index of a slot, maximizing the use of entropy.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <span class="tok-kw">struct</span> {
            key: K,
            value: V,
        };

        <span class="tok-kw">const</span> Header = <span class="tok-kw">struct</span> {
            values: [*]V,
            keys: [*]K,
            capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>,
        };

        <span class="tok-comment">/// Metadata for a slot. It can be in three states: empty, used or</span>
        <span class="tok-comment">/// tombstone. Tombstones indicate that an entry was previously used,</span>
        <span class="tok-comment">/// they are a simple way to handle removal.</span>
        <span class="tok-comment">/// To this state, we add 7 bits from the slot's key hash. These are</span>
        <span class="tok-comment">/// used as a fast way to disambiguate between entries without</span>
        <span class="tok-comment">/// having to use the equality function. If two fingerprints are</span>
        <span class="tok-comment">/// different, we know that we don't have to compare the keys at all.</span>
        <span class="tok-comment">/// The 7 bits are the highest ones from a 64 bit hash. This way, not</span>
        <span class="tok-comment">/// only we use the `log2(capacity)` lowest bits from the hash to determine</span>
        <span class="tok-comment">/// a slot index, but we use 7 more bits to quickly resolve collisions</span>
        <span class="tok-comment">/// when multiple elements with different hashes end up wanting to be in the same slot.</span>
        <span class="tok-comment">/// Not using the equality function means we don't have to read into</span>
        <span class="tok-comment">/// the entries array, likely avoiding a cache miss and a potentially</span>
        <span class="tok-comment">/// costly function call.</span>
        <span class="tok-kw">const</span> Metadata = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">const</span> FingerPrint = <span class="tok-type">u7</span>;

            <span class="tok-kw">const</span> free: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> tombstone: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <span class="tok-number">1</span>;

            fingerprint: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>,
            used: <span class="tok-type">u1</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">const</span> slot_free = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>{ .fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a> }));
            <span class="tok-kw">const</span> slot_tombstone = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>{ .fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a> }));

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isUsed</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> self.used == <span class="tok-number">1</span>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isTombstone</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(self)) == <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.slot_tombstone">slot_tombstone</a>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isFree</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(self)) == <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.slot_free">slot_free</a>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">takeFingerprint</span>(hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a>) <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> {
                <span class="tok-kw">const</span> hash_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a>).int.bits;
                <span class="tok-kw">const</span> fp_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>).int.bits;
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>, <span class="tok-builtin">@truncate</span>(hash &gt;&gt; (hash_bits - fp_bits)));
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fill</span>(self: *<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>, fp: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>) <span class="tok-type">void</span> {
                self.used = <span class="tok-number">1</span>;
                self.fingerprint = fp;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">void</span> {
                self.used = <span class="tok-number">0</span>;
                self.fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            }
        };

        <span class="tok-kw">comptime</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            hm: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>,
            index: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
                <a href="std.debug.html#std.debug.assert">assert</a>(it.index &lt;= it.hm.capacity());
                <span class="tok-kw">if</span> (it.hm.size == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                <span class="tok-kw">const</span> cap = it.hm.capacity();
                <span class="tok-kw">const</span> end = it.hm.metadata.? + cap;
                <span class="tok-kw">var</span> metadata = it.hm.metadata.? + it.index;

                <span class="tok-kw">while</span> (metadata != end) : ({
                    metadata += <span class="tok-number">1</span>;
                    it.index += <span class="tok-number">1</span>;
                }) {
                    <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
                        <span class="tok-kw">const</span> key = &amp;it.hm.keys()[it.index];
                        <span class="tok-kw">const</span> value = &amp;it.hm.values()[it.index];
                        it.index += <span class="tok-number">1</span>;
                        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = key, .value_ptr = value };
                    }
                }

                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V);

        <span class="tok-kw">fn</span> <span class="tok-fn">FieldIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
                len: <span class="tok-type">usize</span>,
                metadata: [*]<span class="tok-kw">const</span> <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>,
                items: [*]T,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) ?*T {
                    <span class="tok-kw">while</span> (self.len &gt; <span class="tok-number">0</span>) {
                        self.len -= <span class="tok-number">1</span>;
                        <span class="tok-kw">const</span> used = self.metadata[<span class="tok-number">0</span>].isUsed();
                        <span class="tok-kw">const</span> item = &amp;self.items[<span class="tok-number">0</span>];
                        self.metadata += <span class="tok-number">1</span>;
                        self.items += <span class="tok-number">1</span>;
                        <span class="tok-kw">if</span> (used) {
                            <span class="tok-kw">return</span> item;
                        }
                    }
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
            found_existing: <span class="tok-type">bool</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage);

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = self,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.unlock();
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">isUnderMaxLoadPercentage</span>(size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, cap: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> size * <span class="tok-number">100</span> &lt; max_load_percentage * cap;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.assertUnlocked();
            self.deallocate(allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">capacityForSize</span>(size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">var</span> new_cap: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, size) * <span class="tok-number">100</span>) / max_load_percentage + <span class="tok-number">1</span>);
            new_cap = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwo">ceilPowerOfTwo</a>(<span class="tok-type">u32</span>, new_cap) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> new_cap;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            <span class="tok-kw">if</span> (new_size &gt; self.size)
                <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            <span class="tok-kw">if</span> (self.metadata) |_| {
                self.initMetadatas();
                self.size = <span class="tok-number">0</span>;
                self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            self.deallocate(allocator);
            self.size = <span class="tok-number">0</span>;
            self.available = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">return</span> self.size;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">header</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) *<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@as</span>([*]<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(self.metadata.?))) - <span class="tok-number">1</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) [*]K {
            <span class="tok-kw">return</span> self.header().keys;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) [*]V {
            <span class="tok-kw">return</span> self.header().values;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

            <span class="tok-kw">return</span> self.header().capacity;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{ .hm = self };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
            <span class="tok-kw">if</span> (self.metadata) |metadata| {
                <span class="tok-kw">return</span> .{
                    .len = self.capacity(),
                    .metadata = metadata,
                    .items = self.keys(),
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{
                    .len = <span class="tok-number">0</span>,
                    .metadata = <span class="tok-null">undefined</span>,
                    .items = <span class="tok-null">undefined</span>,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
            <span class="tok-kw">if</span> (self.metadata) |metadata| {
                <span class="tok-kw">return</span> .{
                    .len = self.capacity(),
                    .metadata = metadata,
                    .items = self.values(),
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{
                    .len = <span class="tok-number">0</span>,
                    .metadata = <span class="tok-null">undefined</span>,
                    .items = <span class="tok-null">undefined</span>,
                };
            }
        }

        <span class="tok-comment">/// Insert an entry in the map. Assumes it is not already present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            {
                self.pointer_stability.lock();
                <span class="tok-kw">defer</span> self.pointer_stability.unlock();
                <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
            }
            self.putAssumeCapacityNoClobberContext(key, value, ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            gop.value_ptr.* = value;
        }

        <span class="tok-comment">/// Insert an entry in the map. Assumes it is not already present,</span>
        <span class="tok-comment">/// and that no allocation is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

            <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

            <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
            self.available -= <span class="tok-number">1</span>;

            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
            metadata[<span class="tok-number">0</span>].fill(fingerprint);
            self.keys()[idx] = key;
            self.values()[idx] = value;

            self.size += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
                <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
                <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = old_key.*,
                    .value = old_val.*,
                };
                self.metadata.?[idx].remove();
                old_key.* = <span class="tok-null">undefined</span>;
                old_val.* = <span class="tok-null">undefined</span>;
                self.size -= <span class="tok-number">1</span>;
                self.available += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Find the index containing the data for the given key.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>) {<span class="tok-comment">
                // We use cold instead of unlikely to force a jump to this case,
                // no matter the weight of the opposing side.
                </span><span class="tok-builtin">@branchHint</span>(.cold);
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }<span class="tok-comment">

            // If you get a compile error on this line, it means that your generic hash
            // function is invalid for these parameters.
            </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);<span class="tok-comment">
            // Don't loop indefinitely when there are no empty slots.
            </span><span class="tok-kw">var</span> limit = self.capacity();
            <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

            <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
                    <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];

                    <span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                        <span class="tok-kw">return</span> idx;
                    }
                }

                limit -= <span class="tok-number">1</span>;
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
                    .key_ptr = &amp;self.keys()[idx],
                    .value_ptr = &amp;self.values()[idx],
                };
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Insert an entry if the associated key is not already present, otherwise update preexisting value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Get an optional pointer to the actual key associated with adapted key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
            <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> &amp;self.keys()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get a copy of the actual key associated with adapted key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
            <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> self.keys()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get an optional pointer to the value associated with key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
            <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> &amp;self.values()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get a copy of the value associated with key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
            <span class="tok-kw">return</span> self.getAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> self.values()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            {
                self.pointer_stability.lock();
                <span class="tok-kw">defer</span> self.pointer_stability.unlock();
                self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
                    // If allocation fails, try to do the lookup anyway.
                    // If we find an existing item, we can return it.
                    // Otherwise return the error, we could not add another.
                    </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                        .key_ptr = &amp;self.keys()[index],
                        .value_ptr = &amp;self.values()[index],
                        .found_existing = <span class="tok-null">true</span>,
                    };
                };
            }
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
            <span class="tok-kw">if</span> (!result.found_existing) {
                result.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> result;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

            // If you get a compile error on this line, it means that your generic hash
            // function is invalid for these parameters.
            </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
            <span class="tok-kw">var</span> limit = self.capacity();
            <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

            <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
            </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
                    <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
                    // If you get a compile error on this line, it means that your generic eql
                    // function is invalid for these parameters.

                    </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                            .key_ptr = test_key,
                            .value_ptr = &amp;self.values()[idx],
                            .found_existing = <span class="tok-null">true</span>,
                        };
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
                    first_tombstone_idx = idx;
                }

                limit -= <span class="tok-number">1</span>;
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
                // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
                </span>idx = first_tombstone_idx;
                metadata = self.metadata.? + idx;
            }<span class="tok-comment">
            // We're using a slot previously free or a tombstone.
            </span>self.available -= <span class="tok-number">1</span>;

            metadata[<span class="tok-number">0</span>].fill(fingerprint);
            <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
            <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
            new_key.* = <span class="tok-null">undefined</span>;
            new_value.* = <span class="tok-null">undefined</span>;
            self.size += <span class="tok-number">1</span>;

            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = new_key,
                .value_ptr = new_value,
                .found_existing = <span class="tok-null">false</span>,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
            <span class="tok-kw">if</span> (!res.found_existing) {
                res.key_ptr.* = key;
                res.value_ptr.* = value;
            }
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
        }

        <span class="tok-comment">/// Return true if there is a value associated with key in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndex</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, idx: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.metadata.?[idx].remove();
            self.keys()[idx] = <span class="tok-null">undefined</span>;
            self.values()[idx] = <span class="tok-null">undefined</span>;
            self.size -= <span class="tok-number">1</span>;
            self.available += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and this function returns true.  Otherwise this</span>
        <span class="tok-comment">/// function returns false.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                self.removeByIndex(idx);
                <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            }

            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }

        <span class="tok-comment">/// Delete the entry with key pointed to by key_ptr from the hash map.</span>
        <span class="tok-comment">/// key_ptr is assumed to be a valid pointer to a key that is present</span>
        <span class="tok-comment">/// in the hash map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
            // TODO: replace with pointer subtraction once supported by zig
            // if @sizeOf(K) == 0 then there is at most one item in the hash
            // map, which is assumed to exist as key_ptr must be valid.  This
            // item must be at index 0.
            </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
                (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
            <span class="tok-kw">else</span>
                <span class="tok-number">0</span>;

            self.removeByIndex(idx);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">initMetadatas</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-builtin">@memset</span>(<span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(self.metadata.?))[<span class="tok-number">0</span> .. <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) * self.capacity()], <span class="tok-number">0</span>);
        }<span class="tok-comment">

        // This counts the number of occupied slots (not counting tombstones), which is
        // what has to stay under the max_load_percentage of capacity.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">load</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">const</span> max_load = (self.capacity() * max_load_percentage) / <span class="tok-number">100</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(max_load &gt;= self.available);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, <span class="tok-builtin">@truncate</span>(max_load - self.available));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">growIfNeeded</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_count: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (new_count &gt; self.available) {
                <span class="tok-kw">try</span> self.grow(allocator, <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.load() + new_count), ctx);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
            <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> other;

            <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
            <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
            other.initMetadatas();
            other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

            <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> metadata = self.metadata.?;
            <span class="tok-kw">const</span> keys_ptr = self.keys();
            <span class="tok-kw">const</span> values_ptr = self.values();
            <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (metadata[i].isUsed()) {
                    other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
                    <span class="tok-kw">if</span> (other.size == self.size)
                        <span class="tok-kw">break</span>;
                }
            }

            <span class="tok-kw">return</span> other;
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
            self.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.* = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Rehash the map, in-place.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Over time, due to the current tombstone-based implementation, a</span>
        <span class="tok-comment">/// HashMap could become fragmented due to the buildup of tombstone</span>
        <span class="tok-comment">/// entries that causes a performance degradation due to excessive</span>
        <span class="tok-comment">/// probing. The kind of pattern that might cause this is a long-lived</span>
        <span class="tok-comment">/// HashMap with repeated inserts and deletes.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// After this function is called, there will be no tombstones in</span>
        <span class="tok-comment">/// the HashMap, each of the entries is rehashed and any existing</span>
        <span class="tok-comment">/// key/value pointers into the HashMap are invalidated.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

            <span class="tok-kw">var</span> metadata = self.metadata.?;
            <span class="tok-kw">var</span> keys_ptr = self.keys();
            <span class="tok-kw">var</span> values_ptr = self.values();
            <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

            // While we are re-hashing every slot, we will use the
            // fingerprint to mark used buckets as being used and either free
            // (needing to be rehashed) or tombstone (already rehashed).

            </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
            }<span class="tok-comment">

            // Now iterate over all the buckets, rehashing them

            </span>curr = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
                <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
                    curr += <span class="tok-number">1</span>;
                    <span class="tok-kw">continue</span>;
                }

                <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
                <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
                <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

                // For each bucket, rehash to an index:
                // 1) before the cursor, probed into a free slot, or
                // 2) equal to the cursor, no need to move, or
                // 3) ahead of the cursor, probing over already rehashed

                </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
                    (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
                {
                    idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                }

                <span class="tok-kw">if</span> (idx &lt; curr) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
                    metadata[idx].fill(fingerprint);
                    keys_ptr[idx] = keys_ptr[curr];
                    values_ptr[idx] = values_ptr[curr];

                    metadata[curr].used = <span class="tok-number">0</span>;
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
                    keys_ptr[curr] = <span class="tok-null">undefined</span>;
                    values_ptr[curr] = <span class="tok-null">undefined</span>;

                    curr += <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
                    metadata[idx].fingerprint = fingerprint;
                    curr += <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
                    metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
                    <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
                    } <span class="tok-kw">else</span> {
                        metadata[idx].used = <span class="tok-number">1</span>;
                        keys_ptr[idx] = keys_ptr[curr];
                        values_ptr[idx] = values_ptr[curr];

                        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                        metadata[curr].used = <span class="tok-number">0</span>;
                        keys_ptr[curr] = <span class="tok-null">undefined</span>;
                        values_ptr[curr] = <span class="tok-null">undefined</span>;

                        curr += <span class="tok-number">1</span>;
                    }
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">grow</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <span class="tok-kw">const</span> new_cap = <span class="tok-builtin">@max</span>(new_capacity, <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.minimal_capacity">minimal_capacity</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(new_cap &gt; self.capacity());
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(new_cap));

            <span class="tok-kw">var</span> map: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{};
            <span class="tok-kw">try</span> map.allocate(allocator, new_cap);
            <span class="tok-kw">errdefer</span> <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;
            map.pointer_stability.lock();
            map.initMetadatas();
            map.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

            <span class="tok-kw">if</span> (self.size != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> old_capacity = self.capacity();
                <span class="tok-kw">for</span> (
                    self.metadata.?[<span class="tok-number">0</span>..old_capacity],
                    self.keys()[<span class="tok-number">0</span>..old_capacity],
                    self.values()[<span class="tok-number">0</span>..old_capacity],
                ) |m, k, v| {
                    <span class="tok-kw">if</span> (!m.isUsed()) <span class="tok-kw">continue</span>;
                    map.putAssumeCapacityNoClobberContext(k, v, ctx);
                    <span class="tok-kw">if</span> (map.size == self.size) <span class="tok-kw">break</span>;
                }
            }

            self.size = <span class="tok-number">0</span>;
            self.pointer_stability = .{};
            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, self, &amp;map);
            map.deinit(allocator);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">allocate</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> header_align = <span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);
            <span class="tok-kw">const</span> key_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(K);
            <span class="tok-kw">const</span> val_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(V) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(V);
            <span class="tok-kw">const</span> max_align = <span class="tok-kw">comptime</span> <span class="tok-builtin">@max</span>(header_align, key_align, val_align);

            <span class="tok-kw">const</span> new_cap: <span class="tok-type">usize</span> = new_capacity;
            <span class="tok-kw">const</span> meta_size = <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>) + new_cap * <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>);
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);

            <span class="tok-kw">const</span> keys_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, meta_size, key_align);
            <span class="tok-kw">const</span> keys_end = keys_start + new_cap * <span class="tok-builtin">@sizeOf</span>(K);

            <span class="tok-kw">const</span> vals_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, keys_end, val_align);
            <span class="tok-kw">const</span> vals_end = vals_start + new_cap * <span class="tok-builtin">@sizeOf</span>(V);

            <span class="tok-kw">const</span> total_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, vals_end, max_align);

            <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> allocator.alignedAlloc(<span class="tok-type">u8</span>, max_align, total_size);
            <span class="tok-kw">const</span> ptr: [*]<span class="tok-type">u8</span> = <span class="tok-builtin">@ptrCast</span>(slice.ptr);

            <span class="tok-kw">const</span> metadata = ptr + <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);

            <span class="tok-kw">const</span> hdr = <span class="tok-builtin">@as</span>(*<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr)));
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>([*]V) != <span class="tok-number">0</span>) {
                hdr.values = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>((ptr + vals_start)));
            }
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>([*]K) != <span class="tok-number">0</span>) {
                hdr.keys = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>((ptr + keys_start)));
            }
            hdr.capacity = new_capacity;
            self.metadata = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(metadata));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">deallocate</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> header_align = <span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);
            <span class="tok-kw">const</span> key_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(K);
            <span class="tok-kw">const</span> val_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(V) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(V);
            <span class="tok-kw">const</span> max_align = <span class="tok-kw">comptime</span> <span class="tok-builtin">@max</span>(header_align, key_align, val_align);

            <span class="tok-kw">const</span> cap: <span class="tok-type">usize</span> = self.capacity();
            <span class="tok-kw">const</span> meta_size = <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>) + cap * <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>);
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);

            <span class="tok-kw">const</span> keys_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, meta_size, key_align);
            <span class="tok-kw">const</span> keys_end = keys_start + cap * <span class="tok-builtin">@sizeOf</span>(K);

            <span class="tok-kw">const</span> vals_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, keys_end, val_align);
            <span class="tok-kw">const</span> vals_end = vals_start + cap * <span class="tok-builtin">@sizeOf</span>(V);

            <span class="tok-kw">const</span> total_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, vals_end, max_align);

            <span class="tok-kw">const</span> slice = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(max_align) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(self.header())))[<span class="tok-number">0</span>..total_size];
            allocator.free(slice);

            self.metadata = <span class="tok-null">null</span>;
            self.available = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// This function is used in the debugger pretty formatters in tools/ to fetch the</span>
        <span class="tok-comment">/// header type to facilitate fancy debug printing for this type.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">dbHelper</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, hdr: *<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, entry: *<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>) <span class="tok-type">void</span> {
            _ = self;
            _ = hdr;
            _ = entry;
        }

        <span class="tok-kw">comptime</span> {
            <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) _ = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a>) {
                .stage2_llvm =&gt; &amp;<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.dbHelper">dbHelper</a>,
                .stage2_x86_64 =&gt; <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>,
                <span class="tok-kw">else</span> =&gt; {},
            };
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.multi_array_list.MultiArrayList" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">MultiArrayList</span><a href="#src.zig-std.multi_array_list.MultiArrayList">[src]</a></h2><div class="tldDocs"><p>A MultiArrayList stores a list of a struct or tagged union type.
Instead of storing a single list of items, MultiArrayList
stores separate lists for each field of the struct or
lists of tags and bare unions.
This allows for memory savings if the struct or union has padding,
and also improves cache usage if only some fields or just tags
are needed for a computation.  The primary API for accessing fields is
the <code>slice()</code> function, which computes the start pointers
for the array of each field.  From the slice you can call
<code>.items(.&lt;field_name&gt;)</code> to obtain a slice of field values.
For unions you can call <code>.items(.tags)</code> or <code>.items(.data)</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.multi_array_list.MultiArrayList.Slice.html">std.multi_array_list.MultiArrayList.Slice</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.Field" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Field</span><a href="#src.zig-std.multi_array_list.MultiArrayList.Field">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.Field">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Field = <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>bytes: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(T)) <span class="tok-type">u8</span> = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>capacity: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.multi_array_list.MultiArrayList.empty">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a> = .{
    .bytes = <span class="tok-null">undefined</span>,
    .len = <span class="tok-number">0</span>,
    .capacity = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.multi_array_list.MultiArrayList.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release all allocated memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    gpa.free(self.allocatedBytes());
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.toOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toOwnedSlice</span><a href="#src.zig-std.multi_array_list.MultiArrayList.toOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a></code></pre></div><div class="tldDocs"><p>The caller owns the returned memory. Empties this MultiArrayList.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.toOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a> {
    <span class="tok-kw">const</span> result = self.slice();
    self.* = .{};
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.slice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">slice</span><a href="#src.zig-std.multi_array_list.MultiArrayList.slice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a></code></pre></div><div class="tldDocs"><p>Compute pointers to the start of each field of the array.
If you need to access multiple fields, calling this may
be more efficient than calling <code>items()</code> multiple times.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.slice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a> {
    <span class="tok-kw">var</span> result: <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a> = .{
        .ptrs = <span class="tok-null">undefined</span>,
        .len = self.len,
        .capacity = self.capacity,
    };
    <span class="tok-kw">var</span> ptr: [*]<span class="tok-type">u8</span> = self.bytes;
    <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.sizes">sizes</a>.<a href="#">bytes</a>, <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.sizes">sizes</a>.<a href="#">fields</a>) |field_size, i| {
        result.ptrs[i] = ptr;
        ptr += field_size * self.capacity;
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.items" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">items</span><a href="#src.zig-std.multi_array_list.MultiArrayList.items">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">items</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>) []<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.FieldType">FieldType</a>(field)</code></pre></div><div class="tldDocs"><p>Get the slice of values for a specified field.
If you need multiple fields, consider calling slice()
instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>field: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.items">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">items</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>) []<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.FieldType">FieldType</a>(field) {
    <span class="tok-kw">return</span> self.slice().items(field);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.multi_array_list.MultiArrayList.set">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>, elem: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Overwrite one array element with new data.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.set">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>, elem: T) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> slices = self.slice();
    slices.set(index, elem);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.multi_array_list.MultiArrayList.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Obtain all the data for one array element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">return</span> self.slice().get(index);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.multi_array_list.MultiArrayList.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, elem: T) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the list by 1 element. Allocates more memory as necessary.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, elem: T) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
    self.appendAssumeCapacity(elem);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.appendAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendAssumeCapacity</span><a href="#src.zig-std.multi_array_list.MultiArrayList.appendAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, elem: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Extend the list by 1 element, but asserting <code>self.capacity</code>
is sufficient to hold an additional item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.appendAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, elem: T) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; self.capacity);
    self.len += <span class="tok-number">1</span>;
    self.set(self.len - <span class="tok-number">1</span>, elem);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.addOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOne</span><a href="#src.zig-std.multi_array_list.MultiArrayList.addOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Extend the list by 1 element, returning the newly reserved
index with uninitialized data.
Allocates more memory as necesasry.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.addOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(allocator, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addOneAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.addOneAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOneAssumeCapacity</span><a href="#src.zig-std.multi_array_list.MultiArrayList.addOneAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Extend the list by 1 element, asserting <code>self.capacity</code>
is sufficient to hold an additional item.  Returns the
newly reserved index with uninitialized data.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.addOneAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; self.capacity);
    <span class="tok-kw">const</span> index = self.len;
    self.len += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> index;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.multi_array_list.MultiArrayList.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Remove and return the last element from the list, or return <code>null</code> if list is empty.
Invalidates pointers to fields of the removed element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> val = self.get(self.len - <span class="tok-number">1</span>);
    self.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> val;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.insert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insert</span><a href="#src.zig-std.multi_array_list.MultiArrayList.insert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, elem: T) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts an item into an ordered list.  Shifts all elements
after and including the specified index back by one and
sets the given index to the specified element.  May reallocate
and invalidate iterators.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.insert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, elem: T) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
    self.insertAssumeCapacity(index, elem);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.insertAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertAssumeCapacity</span><a href="#src.zig-std.multi_array_list.MultiArrayList.insertAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>, elem: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts an item into an ordered list which has room for it.
Shifts all elements after and including the specified index
back by one and sets the given index to the specified element.
Will not reallocate the array, does not invalidate iterators.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.insertAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>, elem: T) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; self.capacity);
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt;= self.len);
    self.len += <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> entry = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; elem,
        .@&quot;union&quot; =&gt; <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.fromT">fromT</a>(elem),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
    <span class="tok-kw">const</span> slices = self.slice();
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, field_index| {
        <span class="tok-kw">const</span> field_slice = slices.items(<span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(field_index)));
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = self.len - <span class="tok-number">1</span>;
        <span class="tok-kw">while</span> (i &gt; index) : (i -= <span class="tok-number">1</span>) {
            field_slice[i] = field_slice[i - <span class="tok-number">1</span>];
        }
        field_slice[index] = <span class="tok-builtin">@field</span>(entry, field_info.name);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.multi_array_list.MultiArrayList.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Remove the specified item from the list, swapping the last
item in the list into its position.  Fast, but does not
retain list ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> slices = self.slice();
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |_, i| {
        <span class="tok-kw">const</span> field_slice = slices.items(<span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i)));
        field_slice[index] = field_slice[self.len - <span class="tok-number">1</span>];
        field_slice[self.len - <span class="tok-number">1</span>] = <span class="tok-null">undefined</span>;
    }
    self.len -= <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.multi_array_list.MultiArrayList.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Remove the specified item from the list, shifting items
after it to preserve order.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> slices = self.slice();
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |_, field_index| {
        <span class="tok-kw">const</span> field_slice = slices.items(<span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(field_index)));
        <span class="tok-kw">var</span> i = index;
        <span class="tok-kw">while</span> (i &lt; self.len - <span class="tok-number">1</span>) : (i += <span class="tok-number">1</span>) {
            field_slice[i] = field_slice[i + <span class="tok-number">1</span>];
        }
        field_slice[i] = <span class="tok-null">undefined</span>;
    }
    self.len -= <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.multi_array_list.MultiArrayList.resize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adjust the list's length to <code>new_len</code>.
Does not initialize added items, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.resize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureTotalCapacity(gpa, new_len);
    self.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.multi_array_list.MultiArrayList.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Attempt to reduce allocated capacity to <code>new_len</code>.
If <code>new_len</code> is greater than zero, this may fail to reduce the capacity,
but the data remains intact and the length is updated to new_len.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (new_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.clearAndFree">clearAndFree</a>(self, gpa);

    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.len);

    <span class="tok-kw">const</span> other_bytes = gpa.alignedAlloc(
        <span class="tok-type">u8</span>,
        <span class="tok-builtin">@alignOf</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>),
        <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.capacityInBytes">capacityInBytes</a>(new_len),
    ) <span class="tok-kw">catch</span> {
        <span class="tok-kw">const</span> self_slice = self.slice();
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> field = <span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i));
                <span class="tok-kw">const</span> dest_slice = self_slice.items(field)[new_len..];<span class="tok-comment">
                // We use memset here for more efficient codegen in safety-checked,
                // valgrind-enabled builds. Otherwise the valgrind client request
                // will be repeated for every element.
                </span><span class="tok-builtin">@memset</span>(dest_slice, <span class="tok-null">undefined</span>);
            }
        }
        self.len = new_len;
        <span class="tok-kw">return</span>;
    };
    <span class="tok-kw">var</span> other = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>{
        .bytes = other_bytes.ptr,
        .capacity = new_len,
        .len = new_len,
    };
    self.len = new_len;
    <span class="tok-kw">const</span> self_slice = self.slice();
    <span class="tok-kw">const</span> other_slice = other.slice();
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> field = <span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i));
            <span class="tok-builtin">@memcpy</span>(other_slice.items(field), self_slice.items(field));
        }
    }
    gpa.free(self.allocatedBytes());
    self.* = other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.multi_array_list.MultiArrayList.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    gpa.free(self.allocatedBytes());
    self.* = .{};
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.multi_array_list.MultiArrayList.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce length to <code>new_len</code>.
Invalidates pointers to elements <code>items[new_len..]</code>.
Keeps capacity the same.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.multi_array_list.MultiArrayList.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <span class="tok-type">void</span> {
    self.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.multi_array_list.MultiArrayList.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold at least <code>new_capacity</code> items.
Implements super-linear growth to achieve amortized O(1) append operations.
Invalidates element pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
    <span class="tok-kw">return</span> self.setCapacity(gpa, <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.growCapacity">growCapacity</a>(self.capacity, new_capacity));
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.multi_array_list.MultiArrayList.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold at least <code>additional_count</code> <strong>more</strong> items.
Invalidates pointers if additional memory is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacity(gpa, self.len + additional_count);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.setCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setCapacity</span><a href="#src.zig-std.multi_array_list.MultiArrayList.setCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify the array so that it can hold exactly <code>new_capacity</code> items.
Invalidates pointers if additional memory is needed.
<code>new_capacity</code> must be greater or equal to <code>len</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.setCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_capacity &gt;= self.len);
    <span class="tok-kw">const</span> new_bytes = <span class="tok-kw">try</span> gpa.alignedAlloc(
        <span class="tok-type">u8</span>,
        <span class="tok-builtin">@alignOf</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>),
        <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.capacityInBytes">capacityInBytes</a>(new_capacity),
    );
    <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) {
        gpa.free(self.allocatedBytes());
        self.bytes = new_bytes.ptr;
        self.capacity = new_capacity;
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">var</span> other = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>{
        .bytes = new_bytes.ptr,
        .capacity = new_capacity,
        .len = self.len,
    };
    <span class="tok-kw">const</span> self_slice = self.slice();
    <span class="tok-kw">const</span> other_slice = other.slice();
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> field = <span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i));
            <span class="tok-builtin">@memcpy</span>(other_slice.items(field), self_slice.items(field));
        }
    }
    gpa.free(self.allocatedBytes());
    self.* = other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.multi_array_list.MultiArrayList.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of this list with a new backing store,
using the specified allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a> {
    <span class="tok-kw">var</span> result = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>{};
    <span class="tok-kw">errdefer</span> result.deinit(gpa);
    <span class="tok-kw">try</span> result.ensureTotalCapacity(gpa, self.len);
    result.len = self.len;
    <span class="tok-kw">const</span> self_slice = self.slice();
    <span class="tok-kw">const</span> result_slice = result.slice();
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> field = <span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i));
            <span class="tok-builtin">@memcpy</span>(result_slice.items(field), self_slice.items(field));
        }
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.multi_array_list.MultiArrayList.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>This function guarantees a stable sort, i.e the relative order of equal elements is preserved during sorting.
Read more about stable sorting here: <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">https://en.wikipedia.org/wiki/Sorting_algorithm#Stability</a>
If this guarantee does not matter, <code>sortUnstable</code> might be a faster alternative.
<code>ctx</code> has the following method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    self.sortInternal(<span class="tok-number">0</span>, self.len, ctx, .stable);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.sortSpan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortSpan</span><a href="#src.zig-std.multi_array_list.MultiArrayList.sortSpan">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortSpan</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts only the subsection of items between indices <code>a</code> and <code>b</code> (excluding <code>b</code>)
This function guarantees a stable sort, i.e the relative order of equal elements is preserved during sorting.
Read more about stable sorting here: <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">https://en.wikipedia.org/wiki/Sorting_algorithm#Stability</a>
If this guarantee does not matter, <code>sortSpanUnstable</code> might be a faster alternative.
<code>ctx</code> has the following method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.sortSpan">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortSpan</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    self.sortInternal(a, b, ctx, .stable);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.sortUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstable</span><a href="#src.zig-std.multi_array_list.MultiArrayList.sortUnstable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>This function does NOT guarantee a stable sort, i.e the relative order of equal elements may change during sorting.
Due to the weaker guarantees of this function, this may be faster than the stable <code>sort</code> method.
Read more about stable sorting here: <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">https://en.wikipedia.org/wiki/Sorting_algorithm#Stability</a>
<code>ctx</code> has the following method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.sortUnstable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    self.sortInternal(<span class="tok-number">0</span>, self.len, ctx, .unstable);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.sortSpanUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortSpanUnstable</span><a href="#src.zig-std.multi_array_list.MultiArrayList.sortSpanUnstable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortSpanUnstable</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts only the subsection of items between indices <code>a</code> and <code>b</code> (excluding <code>b</code>)
This function does NOT guarantee a stable sort, i.e the relative order of equal elements may change during sorting.
Due to the weaker guarantees of this function, this may be faster than the stable <code>sortSpan</code> method.
Read more about stable sorting here: <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">https://en.wikipedia.org/wiki/Sorting_algorithm#Stability</a>
<code>ctx</code> has the following method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a></code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.sortSpanUnstable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortSpanUnstable</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    self.sortInternal(a, b, ctx, .unstable);
}</code></pre></details></div></div><div class="decl"><h3 id="std.multi_array_list.MultiArrayList.capacityInBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacityInBytes</span><a href="#src.zig-std.multi_array_list.MultiArrayList.capacityInBytes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacityInBytes</span>(capacity: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList.capacityInBytes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacityInBytes</span>(capacity: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> elem_bytes: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.sizes">sizes</a>.<a href="#">bytes</a>) |size| elem_bytes += size;
    <span class="tok-kw">return</span> elem_bytes * capacity;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.multi_array_list.MultiArrayList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">MultiArrayList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        bytes: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(T)) <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,
        len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        capacity: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a> = .{
            .bytes = <span class="tok-null">undefined</span>,
            .len = <span class="tok-number">0</span>,
            .capacity = <span class="tok-number">0</span>,
        };

        <span class="tok-kw">const</span> Elem = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            .@&quot;struct&quot; =&gt; T,
            .@&quot;union&quot; =&gt; |u| <span class="tok-kw">struct</span> {
                <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bare = <span class="tok-builtin">@Type</span>(.{ .@&quot;union&quot; = .{
                    .layout = u.layout,
                    .tag_type = <span class="tok-null">null</span>,
                    .fields = u.fields,
                    .decls = &amp;.{},
                } });
                <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag =
                    u.tag_type <span class="tok-kw">orelse</span> <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;MultiArrayList does not support untagged unions&quot;</span>);
                tags: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.Tag">Tag</a>,
                data: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.Bare">Bare</a>,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromT</span>(outer: T) <span class="tok-builtin">@This</span>() {
                    <span class="tok-kw">const</span> tag = <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.activeTag">activeTag</a>(outer);
                    <span class="tok-kw">return</span> .{
                        .tags = tag,
                        .data = <span class="tok-kw">switch</span> (tag) {
                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |t| <span class="tok-builtin">@unionInit</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.Bare">Bare</a>, <span class="tok-builtin">@tagName</span>(t), <span class="tok-builtin">@field</span>(outer, <span class="tok-builtin">@tagName</span>(t))),
                        },
                    };
                }
                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toT</span>(tag: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.Tag">Tag</a>, bare: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.Bare">Bare</a>) T {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {
                        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |t| <span class="tok-builtin">@unionInit</span>(T, <span class="tok-builtin">@tagName</span>(t), <span class="tok-builtin">@field</span>(bare, <span class="tok-builtin">@tagName</span>(t))),
                    };
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;MultiArrayList only supports structs and tagged unions&quot;</span>),
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Field = <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.FieldEnum">FieldEnum</a>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>);

        <span class="tok-comment">/// A MultiArrayList.Slice contains cached start pointers for each field in the list.</span>
        <span class="tok-comment">/// These pointers are not normally stored to reduce the size of the list in memory.</span>
        <span class="tok-comment">/// If you are accessing multiple fields, call slice() first to compute the pointers,</span>
        <span class="tok-comment">/// and then get the field arrays from the slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// This array is indexed by the field index which can be obtained</span>
            <span class="tok-comment">/// by using @intFromEnum() on the Field enum</span>
            ptrs: [<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>.<a href="#">len</a>][*]<span class="tok-type">u8</span>,
            len: <span class="tok-type">usize</span>,
            capacity: <span class="tok-type">usize</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a> = .{
                .ptrs = <span class="tok-null">undefined</span>,
                .len = <span class="tok-number">0</span>,
                .capacity = <span class="tok-number">0</span>,
            };

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">items</span>(self: <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a>, <span class="tok-kw">comptime</span> field: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>) []<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.FieldType">FieldType</a>(field) {
                <span class="tok-kw">const</span> F = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.FieldType">FieldType</a>(field);
                <span class="tok-kw">if</span> (self.capacity == <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> &amp;[_]F{};
                }
                <span class="tok-kw">const</span> byte_ptr = self.ptrs[<span class="tok-builtin">@intFromEnum</span>(field)];
                <span class="tok-kw">const</span> casted_ptr: [*]F = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(F) == <span class="tok-number">0</span>)
                    <span class="tok-null">undefined</span>
                <span class="tok-kw">else</span>
                    <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(byte_ptr));
                <span class="tok-kw">return</span> casted_ptr[<span class="tok-number">0</span>..self.len];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a>, index: <span class="tok-type">usize</span>, elem: T) <span class="tok-type">void</span> {
                <span class="tok-kw">const</span> e = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
                    .@&quot;struct&quot; =&gt; elem,
                    .@&quot;union&quot; =&gt; <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.fromT">fromT</a>(elem),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
                    self.items(<span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i)))[index] = <span class="tok-builtin">@field</span>(e, field_info.name);
                }
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a>, index: <span class="tok-type">usize</span>) T {
                <span class="tok-kw">var</span> result: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
                    <span class="tok-builtin">@field</span>(result, field_info.name) = self.items(<span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i)))[index];
                }
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
                    .@&quot;struct&quot; =&gt; result,
                    .@&quot;union&quot; =&gt; <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.toT">toT</a>(result.tags, result.data),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMultiArrayList</span>(self: <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a>) <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a> {
                <span class="tok-kw">if</span> (self.ptrs.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> self.capacity == <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> .{};
                }
                <span class="tok-kw">const</span> unaligned_ptr = self.ptrs[<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.sizes">sizes</a>.<a href="#">fields</a>[<span class="tok-number">0</span>]];
                <span class="tok-kw">const</span> aligned_ptr: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>)) <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(unaligned_ptr);
                <span class="tok-kw">return</span> .{
                    .bytes = aligned_ptr,
                    .len = self.len,
                    .capacity = self.capacity,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
                <span class="tok-kw">var</span> other = self.toMultiArrayList();
                other.deinit(gpa);
                self.* = <span class="tok-null">undefined</span>;
            }

            <span class="tok-comment">/// This function is used in the debugger pretty formatters in tools/ to fetch the</span>
            <span class="tok-comment">/// child field order and entry type to facilitate fancy debug printing for this type.</span>
            <span class="tok-kw">fn</span> <span class="tok-fn">dbHelper</span>(self: *<a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a>, child: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>, field: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, entry: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Entry">Entry</a>) <span class="tok-type">void</span> {
                _ = self;
                _ = child;
                _ = field;
                _ = entry;
            }
        };

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">const</span> fields = <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>);
        <span class="tok-comment">/// `sizes.bytes` is an array of @sizeOf each T field. Sorted by alignment, descending.</span>
        <span class="tok-comment">/// `sizes.fields` is an array mapping from `sizes.bytes` array index to field index.</span>
        <span class="tok-kw">const</span> sizes = blk: {
            <span class="tok-kw">const</span> Data = <span class="tok-kw">struct</span> {
                size: <span class="tok-type">usize</span>,
                size_index: <span class="tok-type">usize</span>,
                alignment: <span class="tok-type">usize</span>,
            };
            <span class="tok-kw">var</span> data: [<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>.<a href="#">len</a>]Data = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
                data[i] = .{
                    .size = <span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>),
                    .size_index = i,
                    .alignment = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> field_info.alignment,
                };
            }
            <span class="tok-kw">const</span> Sort = <span class="tok-kw">struct</span> {
                <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(context: <span class="tok-type">void</span>, lhs: Data, rhs: Data) <span class="tok-type">bool</span> {
                    _ = context;
                    <span class="tok-kw">return</span> lhs.alignment &gt; rhs.alignment;
                }
            };
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">3</span> * <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>.<a href="#">len</a> * <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.log2.html#std.math.log2.log2">log2</a>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>.<a href="#">len</a>));
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(Data, &amp;data, {}, Sort.lessThan);
            <span class="tok-kw">var</span> sizes_bytes: [<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>.<a href="#">len</a>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> field_indexes: [<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>.<a href="#">len</a>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (data, <span class="tok-number">0</span>..) |elem, i| {
                sizes_bytes[i] = elem.size;
                field_indexes[i] = elem.size_index;
            }
            <span class="tok-kw">break</span> :blk .{
                .bytes = sizes_bytes,
                .fields = field_indexes,
            };
        };

        <span class="tok-comment">/// Release all allocated memory.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            gpa.free(self.allocatedBytes());
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// The caller owns the returned memory. Empties this MultiArrayList.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedSlice</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a> {
            <span class="tok-kw">const</span> result = self.slice();
            self.* = .{};
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Compute pointers to the start of each field of the array.</span>
        <span class="tok-comment">/// If you need to access multiple fields, calling this may</span>
        <span class="tok-comment">/// be more efficient than calling `items()` multiple times.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a> {
            <span class="tok-kw">var</span> result: <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a> = .{
                .ptrs = <span class="tok-null">undefined</span>,
                .len = self.len,
                .capacity = self.capacity,
            };
            <span class="tok-kw">var</span> ptr: [*]<span class="tok-type">u8</span> = self.bytes;
            <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.sizes">sizes</a>.<a href="#">bytes</a>, <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.sizes">sizes</a>.<a href="#">fields</a>) |field_size, i| {
                result.ptrs[i] = ptr;
                ptr += field_size * self.capacity;
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Get the slice of values for a specified field.</span>
        <span class="tok-comment">/// If you need multiple fields, consider calling slice()</span>
        <span class="tok-comment">/// instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">items</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, <span class="tok-kw">comptime</span> field: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>) []<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.FieldType">FieldType</a>(field) {
            <span class="tok-kw">return</span> self.slice().items(field);
        }

        <span class="tok-comment">/// Overwrite one array element with new data.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>, elem: T) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> slices = self.slice();
            slices.set(index, elem);
        }

        <span class="tok-comment">/// Obtain all the data for one array element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) T {
            <span class="tok-kw">return</span> self.slice().get(index);
        }

        <span class="tok-comment">/// Extend the list by 1 element. Allocates more memory as necessary.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, elem: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
            self.appendAssumeCapacity(elem);
        }

        <span class="tok-comment">/// Extend the list by 1 element, but asserting `self.capacity`</span>
        <span class="tok-comment">/// is sufficient to hold an additional item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, elem: T) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; self.capacity);
            self.len += <span class="tok-number">1</span>;
            self.set(self.len - <span class="tok-number">1</span>, elem);
        }

        <span class="tok-comment">/// Extend the list by 1 element, returning the newly reserved</span>
        <span class="tok-comment">/// index with uninitialized data.</span>
        <span class="tok-comment">/// Allocates more memory as necesasry.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">usize</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(allocator, <span class="tok-number">1</span>);
            <span class="tok-kw">return</span> self.addOneAssumeCapacity();
        }

        <span class="tok-comment">/// Extend the list by 1 element, asserting `self.capacity`</span>
        <span class="tok-comment">/// is sufficient to hold an additional item.  Returns the</span>
        <span class="tok-comment">/// newly reserved index with uninitialized data.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOneAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <span class="tok-type">usize</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; self.capacity);
            <span class="tok-kw">const</span> index = self.len;
            self.len += <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> index;
        }

        <span class="tok-comment">/// Remove and return the last element from the list, or return `null` if list is empty.</span>
        <span class="tok-comment">/// Invalidates pointers to fields of the removed element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) ?T {
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> val = self.get(self.len - <span class="tok-number">1</span>);
            self.len -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> val;
        }

        <span class="tok-comment">/// Inserts an item into an ordered list.  Shifts all elements</span>
        <span class="tok-comment">/// after and including the specified index back by one and</span>
        <span class="tok-comment">/// sets the given index to the specified element.  May reallocate</span>
        <span class="tok-comment">/// and invalidate iterators.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, elem: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
            self.insertAssumeCapacity(index, elem);
        }

        <span class="tok-comment">/// Inserts an item into an ordered list which has room for it.</span>
        <span class="tok-comment">/// Shifts all elements after and including the specified index</span>
        <span class="tok-comment">/// back by one and sets the given index to the specified element.</span>
        <span class="tok-comment">/// Will not reallocate the array, does not invalidate iterators.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAssumeCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>, elem: T) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.len &lt; self.capacity);
            <a href="std.debug.html#std.debug.assert">assert</a>(index &lt;= self.len);
            self.len += <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> entry = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
                .@&quot;struct&quot; =&gt; elem,
                .@&quot;union&quot; =&gt; <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem.fromT">fromT</a>(elem),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            };
            <span class="tok-kw">const</span> slices = self.slice();
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, field_index| {
                <span class="tok-kw">const</span> field_slice = slices.items(<span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(field_index)));
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = self.len - <span class="tok-number">1</span>;
                <span class="tok-kw">while</span> (i &gt; index) : (i -= <span class="tok-number">1</span>) {
                    field_slice[i] = field_slice[i - <span class="tok-number">1</span>];
                }
                field_slice[index] = <span class="tok-builtin">@field</span>(entry, field_info.name);
            }
        }

        <span class="tok-comment">/// Remove the specified item from the list, swapping the last</span>
        <span class="tok-comment">/// item in the list into its position.  Fast, but does not</span>
        <span class="tok-comment">/// retain list ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slices = self.slice();
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |_, i| {
                <span class="tok-kw">const</span> field_slice = slices.items(<span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i)));
                field_slice[index] = field_slice[self.len - <span class="tok-number">1</span>];
                field_slice[self.len - <span class="tok-number">1</span>] = <span class="tok-null">undefined</span>;
            }
            self.len -= <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Remove the specified item from the list, shifting items</span>
        <span class="tok-comment">/// after it to preserve order.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slices = self.slice();
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |_, field_index| {
                <span class="tok-kw">const</span> field_slice = slices.items(<span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(field_index)));
                <span class="tok-kw">var</span> i = index;
                <span class="tok-kw">while</span> (i &lt; self.len - <span class="tok-number">1</span>) : (i += <span class="tok-number">1</span>) {
                    field_slice[i] = field_slice[i + <span class="tok-number">1</span>];
                }
                field_slice[i] = <span class="tok-null">undefined</span>;
            }
            self.len -= <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Adjust the list's length to `new_len`.</span>
        <span class="tok-comment">/// Does not initialize added items, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureTotalCapacity(gpa, new_len);
            self.len = new_len;
        }

        <span class="tok-comment">/// Attempt to reduce allocated capacity to `new_len`.</span>
        <span class="tok-comment">/// If `new_len` is greater than zero, this may fail to reduce the capacity,</span>
        <span class="tok-comment">/// but the data remains intact and the length is updated to new_len.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (new_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.clearAndFree">clearAndFree</a>(self, gpa);

            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.capacity);
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.len);

            <span class="tok-kw">const</span> other_bytes = gpa.alignedAlloc(
                <span class="tok-type">u8</span>,
                <span class="tok-builtin">@alignOf</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>),
                <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.capacityInBytes">capacityInBytes</a>(new_len),
            ) <span class="tok-kw">catch</span> {
                <span class="tok-kw">const</span> self_slice = self.slice();
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
                        <span class="tok-kw">const</span> field = <span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i));
                        <span class="tok-kw">const</span> dest_slice = self_slice.items(field)[new_len..];<span class="tok-comment">
                        // We use memset here for more efficient codegen in safety-checked,
                        // valgrind-enabled builds. Otherwise the valgrind client request
                        // will be repeated for every element.
                        </span><span class="tok-builtin">@memset</span>(dest_slice, <span class="tok-null">undefined</span>);
                    }
                }
                self.len = new_len;
                <span class="tok-kw">return</span>;
            };
            <span class="tok-kw">var</span> other = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>{
                .bytes = other_bytes.ptr,
                .capacity = new_len,
                .len = new_len,
            };
            self.len = new_len;
            <span class="tok-kw">const</span> self_slice = self.slice();
            <span class="tok-kw">const</span> other_slice = other.slice();
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> field = <span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i));
                    <span class="tok-builtin">@memcpy</span>(other_slice.items(field), self_slice.items(field));
                }
            }
            gpa.free(self.allocatedBytes());
            self.* = other;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            gpa.free(self.allocatedBytes());
            self.* = .{};
        }

        <span class="tok-comment">/// Reduce length to `new_len`.</span>
        <span class="tok-comment">/// Invalidates pointers to elements `items[new_len..]`.</span>
        <span class="tok-comment">/// Keeps capacity the same.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.len = new_len;
        }

        <span class="tok-comment">/// Invalidates all element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) <span class="tok-type">void</span> {
            self.len = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Modify the array so that it can hold at least `new_capacity` items.</span>
        <span class="tok-comment">/// Implements super-linear growth to achieve amortized O(1) append operations.</span>
        <span class="tok-comment">/// Invalidates element pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span> self.setCapacity(gpa, <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.growCapacity">growCapacity</a>(self.capacity, new_capacity));
        }

        <span class="tok-kw">const</span> init_capacity = init: {
            <span class="tok-kw">var</span> max = <span class="tok-number">1</span>;
            <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>) |field| max = <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(max, <span class="tok-builtin">@sizeOf</span>(field.<span class="tok-type">type</span>)));
            <span class="tok-kw">break</span> :init <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.cache_line">cache_line</a> / max));
        };

        <span class="tok-comment">/// Called when memory growth is necessary. Returns a capacity larger than</span>
        <span class="tok-comment">/// minimum that grows super-linearly.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">growCapacity</span>(current: <span class="tok-type">usize</span>, minimum: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">var</span> new = current;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                new +|= new / <span class="tok-number">2</span> + <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.init_capacity">init_capacity</a>;
                <span class="tok-kw">if</span> (new &gt;= minimum)
                    <span class="tok-kw">return</span> new;
            }
        }

        <span class="tok-comment">/// Modify the array so that it can hold at least `additional_count` **more** items.</span>
        <span class="tok-comment">/// Invalidates pointers if additional memory is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ensureTotalCapacity(gpa, self.len + additional_count);
        }

        <span class="tok-comment">/// Modify the array so that it can hold exactly `new_capacity` items.</span>
        <span class="tok-comment">/// Invalidates pointers if additional memory is needed.</span>
        <span class="tok-comment">/// `new_capacity` must be greater or equal to `len`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCapacity</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_capacity &gt;= self.len);
            <span class="tok-kw">const</span> new_bytes = <span class="tok-kw">try</span> gpa.alignedAlloc(
                <span class="tok-type">u8</span>,
                <span class="tok-builtin">@alignOf</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>),
                <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.capacityInBytes">capacityInBytes</a>(new_capacity),
            );
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) {
                gpa.free(self.allocatedBytes());
                self.bytes = new_bytes.ptr;
                self.capacity = new_capacity;
                <span class="tok-kw">return</span>;
            }
            <span class="tok-kw">var</span> other = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>{
                .bytes = new_bytes.ptr,
                .capacity = new_capacity,
                .len = self.len,
            };
            <span class="tok-kw">const</span> self_slice = self.slice();
            <span class="tok-kw">const</span> other_slice = other.slice();
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> field = <span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i));
                    <span class="tok-builtin">@memcpy</span>(other_slice.items(field), self_slice.items(field));
                }
            }
            gpa.free(self.allocatedBytes());
            self.* = other;
        }

        <span class="tok-comment">/// Create a copy of this list with a new backing store,</span>
        <span class="tok-comment">/// using the specified allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a> {
            <span class="tok-kw">var</span> result = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>{};
            <span class="tok-kw">errdefer</span> result.deinit(gpa);
            <span class="tok-kw">try</span> result.ensureTotalCapacity(gpa, self.len);
            result.len = self.len;
            <span class="tok-kw">const</span> self_slice = self.slice();
            <span class="tok-kw">const</span> result_slice = result.slice();
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> field = <span class="tok-builtin">@as</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, <span class="tok-builtin">@enumFromInt</span>(i));
                    <span class="tok-builtin">@memcpy</span>(result_slice.items(field), self_slice.items(field));
                }
            }
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// `ctx` has the following method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">sortInternal</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, ctx: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> mode: <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.Mode.html">Mode</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> sort_context: <span class="tok-kw">struct</span> {
                sub_ctx: <span class="tok-builtin">@TypeOf</span>(ctx),
                slice: <a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a>,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(sc: <span class="tok-builtin">@This</span>(), a_index: <span class="tok-type">usize</span>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>, <span class="tok-number">0</span>..) |field_info, i| {
                        <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(field_info.<span class="tok-type">type</span>) != <span class="tok-number">0</span>) {
                            <span class="tok-kw">const</span> field: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a> = <span class="tok-builtin">@enumFromInt</span>(i);
                            <span class="tok-kw">const</span> ptr = sc.slice.items(field);
                            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(field_info.<span class="tok-type">type</span>, &amp;ptr[a_index], &amp;ptr[b_index]);
                        }
                    }
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(sc: <span class="tok-builtin">@This</span>(), a_index: <span class="tok-type">usize</span>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
                    <span class="tok-kw">return</span> sc.sub_ctx.lessThan(a_index, b_index);
                }
            } = .{
                .sub_ctx = ctx,
                .slice = self.slice(),
            };

            <span class="tok-kw">switch</span> (mode) {
                .stable =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortContext">sortContext</a>(a, b, sort_context),
                .unstable =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortUnstableContext">sortUnstableContext</a>(a, b, sort_context),
            }
        }

        <span class="tok-comment">/// This function guarantees a stable sort, i.e the relative order of equal elements is preserved during sorting.</span>
        <span class="tok-comment">/// Read more about stable sorting here: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability</span>
        <span class="tok-comment">/// If this guarantee does not matter, `sortUnstable` might be a faster alternative.</span>
        <span class="tok-comment">/// `ctx` has the following method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            self.sortInternal(<span class="tok-number">0</span>, self.len, ctx, .stable);
        }

        <span class="tok-comment">/// Sorts only the subsection of items between indices `a` and `b` (excluding `b`)</span>
        <span class="tok-comment">/// This function guarantees a stable sort, i.e the relative order of equal elements is preserved during sorting.</span>
        <span class="tok-comment">/// Read more about stable sorting here: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability</span>
        <span class="tok-comment">/// If this guarantee does not matter, `sortSpanUnstable` might be a faster alternative.</span>
        <span class="tok-comment">/// `ctx` has the following method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortSpan</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            self.sortInternal(a, b, ctx, .stable);
        }

        <span class="tok-comment">/// This function does NOT guarantee a stable sort, i.e the relative order of equal elements may change during sorting.</span>
        <span class="tok-comment">/// Due to the weaker guarantees of this function, this may be faster than the stable `sort` method.</span>
        <span class="tok-comment">/// Read more about stable sorting here: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability</span>
        <span class="tok-comment">/// `ctx` has the following method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            self.sortInternal(<span class="tok-number">0</span>, self.len, ctx, .unstable);
        }

        <span class="tok-comment">/// Sorts only the subsection of items between indices `a` and `b` (excluding `b`)</span>
        <span class="tok-comment">/// This function does NOT guarantee a stable sort, i.e the relative order of equal elements may change during sorting.</span>
        <span class="tok-comment">/// Due to the weaker guarantees of this function, this may be faster than the stable `sortSpan` method.</span>
        <span class="tok-comment">/// Read more about stable sorting here: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability</span>
        <span class="tok-comment">/// `ctx` has the following method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortSpanUnstable</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            self.sortInternal(a, b, ctx, .unstable);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacityInBytes</span>(capacity: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> elem_bytes: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.sizes">sizes</a>.<a href="#">bytes</a>) |size| elem_bytes += size;
            <span class="tok-kw">return</span> elem_bytes * capacity;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">allocatedBytes</span>(self: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>) []<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>)) <span class="tok-type">u8</span> {
            <span class="tok-kw">return</span> self.bytes[<span class="tok-number">0</span>..<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.capacityInBytes">capacityInBytes</a>(self.capacity)];
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">FieldType</span>(<span class="tok-kw">comptime</span> field: <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@FieldType</span>(<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>, <span class="tok-builtin">@tagName</span>(field));
        }

        <span class="tok-kw">const</span> Entry = entry: {
            <span class="tok-kw">var</span> entry_fields: [<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>.<a href="#">len</a>]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (&amp;entry_fields, <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.sizes">sizes</a>.<a href="#">fields</a>) |*entry_field, i| entry_field.* = .{
                .name = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>[i].name ++ <span class="tok-str">&quot;_ptr&quot;</span>,
                .<span class="tok-type">type</span> = *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>[i].<span class="tok-type">type</span>,
                .default_value_ptr = <span class="tok-null">null</span>,
                .is_comptime = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>[i].is_comptime,
                .alignment = <a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.fields">fields</a>[i].alignment,
            };
            <span class="tok-kw">break</span> :entry <span class="tok-builtin">@Type</span>(.{ .@&quot;struct&quot; = .{
                .layout = .@&quot;extern&quot;,
                .fields = &amp;entry_fields,
                .decls = &amp;.{},
                .is_tuple = <span class="tok-null">false</span>,
            } });
        };
        <span class="tok-comment">/// This function is used in the debugger pretty formatters in tools/ to fetch the</span>
        <span class="tok-comment">/// child field order and entry type to facilitate fancy debug printing for this type.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">dbHelper</span>(self: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">Self</a>, child: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Elem">Elem</a>, field: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Field">Field</a>, entry: *<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.Entry">Entry</a>) <span class="tok-type">void</span> {
            _ = self;
            _ = child;
            _ = field;
            _ = entry;
        }

        <span class="tok-kw">comptime</span> {
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_llvm <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) {
                _ = &amp;<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList.dbHelper">dbHelper</a>;
                _ = &amp;<a href="std.multi_array_list.MultiArrayList.Slice.html">Slice</a>.<a href="std.multi_array_list.MultiArrayList.Slice.html#std.multi_array_list.MultiArrayList.Slice.dbHelper">dbHelper</a>;
            }
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.priority_queue.PriorityQueue" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">PriorityQueue</span><a href="#src.zig-std.priority_queue.PriorityQueue">[src]</a></h2><div class="tldDocs"><p>Priority queue for storing generic data. Initialize with <code>init</code>.
Provide <code>compareFn</code> that returns <code>Order.lt</code> when its second
argument should get popped before its third argument,
<code>Order.eq</code> if the arguments are of equal priority, or <code>Order.gt</code>
if the third argument should be popped first.
For example, to make <code>pop</code> return the smallest number, provide
<code>fn lessThan(context: void, a: T, b: T) Order { _ = context; return std.math.order(a, b); }</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div><div><pre><code>compareFn: <span class="tok-kw">fn</span> (context: Context, a: T, b: T) <a href="std.math.Order.html">Order</a></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.priority_queue.PriorityQueue.Iterator.html">std.priority_queue.PriorityQueue.Iterator</a></li></ul></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>items: []T</code></pre></div><div><pre><code>cap: <span class="tok-type">usize</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>context: Context</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.priority_queue.PriorityQueue.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.priority_queue.PriorityQueue.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, context: Context) <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div class="tldDocs"><p>Initialize and return a priority queue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>context: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, context: Context) <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a> {
    <span class="tok-kw">return</span> <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>{
        .items = &amp;[_]T{},
        .cap = <span class="tok-number">0</span>,
        .allocator = allocator,
        .context = context,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.priority_queue.PriorityQueue.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Free memory used by the queue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span> {
    self.allocator.free(self.allocatedSlice());
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.priority_queue.PriorityQueue.add">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, elem: T) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert a new element, maintaining priority.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.add">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, elem: T) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(<span class="tok-number">1</span>);
    <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.addUnchecked">addUnchecked</a>(self, elem);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.addSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSlice</span><a href="#src.zig-std.priority_queue.PriorityQueue.addSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSlice</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, items: []<span class="tok-kw">const</span> T) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Add each element in <code>items</code> to the queue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.addSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSlice</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, items: []<span class="tok-kw">const</span> T) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    <span class="tok-kw">for</span> (items) |e| {
        self.addUnchecked(e);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.peek" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">peek</span><a href="#src.zig-std.priority_queue.PriorityQueue.peek">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Look at the highest priority element in the queue. Returns
<code>null</code> if empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.peek">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) ?T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.items.len &gt; <span class="tok-number">0</span>) self.items[<span class="tok-number">0</span>] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.removeOrNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeOrNull</span><a href="#src.zig-std.priority_queue.PriorityQueue.removeOrNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeOrNull</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Pop the highest priority element from the queue. Returns
<code>null</code> if empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.removeOrNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeOrNull</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) ?T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.items.len &gt; <span class="tok-number">0</span>) self.remove() <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.priority_queue.PriorityQueue.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) T</code></pre></div><div class="tldDocs"><p>Remove and return the highest priority element from the
queue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) T {
    <span class="tok-kw">return</span> self.removeIndex(<span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.removeIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeIndex</span><a href="#src.zig-std.priority_queue.PriorityQueue.removeIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeIndex</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, index: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove and return element at index. Indices are in the
same order as iterator, which is not necessarily priority
order.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.removeIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeIndex</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, index: <span class="tok-type">usize</span>) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &gt; index);
    <span class="tok-kw">const</span> last = self.items[self.items.len - <span class="tok-number">1</span>];
    <span class="tok-kw">const</span> item = self.items[index];
    self.items[index] = last;
    self.items.len -= <span class="tok-number">1</span>;

    <span class="tok-kw">if</span> (index == self.items.len) {<span class="tok-comment">
        // Last element removed, nothing more to do.
    </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (index == <span class="tok-number">0</span>) {
        <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftDown">siftDown</a>(self, index);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> parent_index = ((index - <span class="tok-number">1</span>) &gt;&gt; <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> parent = self.items[parent_index];
        <span class="tok-kw">if</span> (compareFn(self.context, last, parent) == .gt) {
            <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftDown">siftDown</a>(self, index);
        } <span class="tok-kw">else</span> {
            <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftUp">siftUp</a>(self, index);
        }
    }

    <span class="tok-kw">return</span> item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.priority_queue.PriorityQueue.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Return the number of elements remaining in the priority
queue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.items.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.priority_queue.PriorityQueue.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Return the number of elements that can be added to the
queue before more memory is allocated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.cap;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.fromOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSlice</span><a href="#src.zig-std.priority_queue.PriorityQueue.fromOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []T, context: Context) <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div class="tldDocs"><p>PriorityQueue takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
Deinitialize with <code>deinit</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>context: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.fromOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []T, context: Context) <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>{
        .items = items,
        .cap = items.len,
        .allocator = allocator,
        .context = context,
    };

    <span class="tok-kw">var</span> i = self.items.len &gt;&gt; <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        self.siftDown(i);
    }
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.priority_queue.PriorityQueue.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Ensure that the queue can fit at least <code>new_capacity</code> items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> better_capacity = self.cap;
    <span class="tok-kw">if</span> (better_capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        better_capacity += better_capacity / <span class="tok-number">2</span> + <span class="tok-number">8</span>;
        <span class="tok-kw">if</span> (better_capacity &gt;= new_capacity) <span class="tok-kw">break</span>;
    }
    <span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(better_capacity);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.ensureTotalCapacityPrecise" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityPrecise</span><a href="#src.zig-std.priority_queue.PriorityQueue.ensureTotalCapacityPrecise">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.ensureTotalCapacityPrecise">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.capacity() &gt;= new_capacity) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> self.allocator.realloc(old_memory, new_capacity);
    self.items.ptr = new_memory.ptr;
    self.cap = new_memory.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.priority_queue.PriorityQueue.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Ensure that the queue can fit at least <code>additional_count</code> <strong>more</strong> item.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacity(self.items.len + additional_count);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.priority_queue.PriorityQueue.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce allocated capacity to <code>new_capacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_capacity &lt;= self.cap);<span class="tok-comment">

    // Cannot shrink to smaller than the current queue size without invalidating the heap property
    </span><a href="std.debug.html#std.debug.assert">assert</a>(new_capacity &gt;= self.items.len);

    <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
    <span class="tok-kw">const</span> new_memory = self.allocator.realloc(old_memory, new_capacity) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; {<span class="tok-comment"> // no problem, capacity is still correct then.
            </span><span class="tok-kw">return</span>;
        },
    };

    self.items.ptr = new_memory.ptr;
    self.cap = new_memory.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.priority_queue.PriorityQueue.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span> {
    self.items.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.priority_queue.PriorityQueue.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span> {
    self.allocator.free(self.allocatedSlice());
    self.items.len = <span class="tok-number">0</span>;
    self.cap = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">update</span><a href="#src.zig-std.priority_queue.PriorityQueue.update">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, elem: T, new_elem: T) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div><div><pre><code>elem: T</code></pre></div><div><pre><code>new_elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.update">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, elem: T, new_elem: T) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> update_index = blk: {
        <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (idx &lt; self.items.len) : (idx += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> item = self.items[idx];
            <span class="tok-kw">if</span> (compareFn(self.context, item, elem) == .eq) <span class="tok-kw">break</span> :blk idx;
        }
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ElementNotFound;
    };
    <span class="tok-kw">const</span> old_elem: T = self.items[update_index];
    self.items[update_index] = new_elem;
    <span class="tok-kw">switch</span> (compareFn(self.context, new_elem, old_elem)) {
        .lt =&gt; <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftUp">siftUp</a>(self, update_index),
        .gt =&gt; <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftDown">siftDown</a>(self, update_index),
        .eq =&gt; {},<span class="tok-comment"> // Nothing to do as the items have equal priority
    </span>}
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_queue.PriorityQueue.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.priority_queue.PriorityQueue.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <a href="std.priority_queue.PriorityQueue.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Return an iterator that walks the queue without consuming
it. The iteration order may differ from the priority order.
Invalidated if the heap is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <a href="std.priority_queue.PriorityQueue.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> <a href="std.priority_queue.PriorityQueue.Iterator.html">Iterator</a>{
        .queue = self,
        .count = <span class="tok-number">0</span>,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.priority_queue.PriorityQueue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">PriorityQueue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (context: Context, a: T, b: T) <a href="std.math.Order.html">Order</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        items: []T,
        cap: <span class="tok-type">usize</span>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        context: Context,

        <span class="tok-comment">/// Initialize and return a priority queue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, context: Context) <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a> {
            <span class="tok-kw">return</span> <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>{
                .items = &amp;[_]T{},
                .cap = <span class="tok-number">0</span>,
                .allocator = allocator,
                .context = context,
            };
        }

        <span class="tok-comment">/// Free memory used by the queue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span> {
            self.allocator.free(self.allocatedSlice());
        }

        <span class="tok-comment">/// Insert a new element, maintaining priority.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, elem: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(<span class="tok-number">1</span>);
            <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.addUnchecked">addUnchecked</a>(self, elem);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">addUnchecked</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, elem: T) <span class="tok-type">void</span> {
            self.items.len += <span class="tok-number">1</span>;
            self.items[self.items.len - <span class="tok-number">1</span>] = elem;
            <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftUp">siftUp</a>(self, self.items.len - <span class="tok-number">1</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">siftUp</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, start_index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> child = self.items[start_index];
            <span class="tok-kw">var</span> child_index = start_index;
            <span class="tok-kw">while</span> (child_index &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> parent_index = ((child_index - <span class="tok-number">1</span>) &gt;&gt; <span class="tok-number">1</span>);
                <span class="tok-kw">const</span> parent = self.items[parent_index];
                <span class="tok-kw">if</span> (compareFn(self.context, child, parent) != .lt) <span class="tok-kw">break</span>;
                self.items[child_index] = parent;
                child_index = parent_index;
            }
            self.items[child_index] = child;
        }

        <span class="tok-comment">/// Add each element in `items` to the queue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSlice</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, items: []<span class="tok-kw">const</span> T) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
            <span class="tok-kw">for</span> (items) |e| {
                self.addUnchecked(e);
            }
        }

        <span class="tok-comment">/// Look at the highest priority element in the queue. Returns</span>
        <span class="tok-comment">/// `null` if empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) ?T {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.items.len &gt; <span class="tok-number">0</span>) self.items[<span class="tok-number">0</span>] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Pop the highest priority element from the queue. Returns</span>
        <span class="tok-comment">/// `null` if empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeOrNull</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) ?T {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.items.len &gt; <span class="tok-number">0</span>) self.remove() <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Remove and return the highest priority element from the</span>
        <span class="tok-comment">/// queue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) T {
            <span class="tok-kw">return</span> self.removeIndex(<span class="tok-number">0</span>);
        }

        <span class="tok-comment">/// Remove and return element at index. Indices are in the</span>
        <span class="tok-comment">/// same order as iterator, which is not necessarily priority</span>
        <span class="tok-comment">/// order.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeIndex</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, index: <span class="tok-type">usize</span>) T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.items.len &gt; index);
            <span class="tok-kw">const</span> last = self.items[self.items.len - <span class="tok-number">1</span>];
            <span class="tok-kw">const</span> item = self.items[index];
            self.items[index] = last;
            self.items.len -= <span class="tok-number">1</span>;

            <span class="tok-kw">if</span> (index == self.items.len) {<span class="tok-comment">
                // Last element removed, nothing more to do.
            </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (index == <span class="tok-number">0</span>) {
                <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftDown">siftDown</a>(self, index);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> parent_index = ((index - <span class="tok-number">1</span>) &gt;&gt; <span class="tok-number">1</span>);
                <span class="tok-kw">const</span> parent = self.items[parent_index];
                <span class="tok-kw">if</span> (compareFn(self.context, last, parent) == .gt) {
                    <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftDown">siftDown</a>(self, index);
                } <span class="tok-kw">else</span> {
                    <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftUp">siftUp</a>(self, index);
                }
            }

            <span class="tok-kw">return</span> item;
        }

        <span class="tok-comment">/// Return the number of elements remaining in the priority</span>
        <span class="tok-comment">/// queue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.items.len;
        }

        <span class="tok-comment">/// Return the number of elements that can be added to the</span>
        <span class="tok-comment">/// queue before more memory is allocated.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.cap;
        }

        <span class="tok-comment">/// Returns a slice of all the items plus the extra capacity, whose memory</span>
        <span class="tok-comment">/// contents are `undefined`.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">allocatedSlice</span>(self: <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) []T {<span class="tok-comment">
            // `items.len` is the length, not the capacity.
            </span><span class="tok-kw">return</span> self.items.ptr[<span class="tok-number">0</span>..self.cap];
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">siftDown</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, target_index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> target_element = self.items[target_index];
            <span class="tok-kw">var</span> index = target_index;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">var</span> lesser_child_i = (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, index, <span class="tok-number">2</span>) <span class="tok-kw">catch</span> <span class="tok-kw">break</span>) | <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (!(lesser_child_i &lt; self.items.len)) <span class="tok-kw">break</span>;

                <span class="tok-kw">const</span> next_child_i = lesser_child_i + <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (next_child_i &lt; self.items.len <span class="tok-kw">and</span> compareFn(self.context, self.items[next_child_i], self.items[lesser_child_i]) == .lt) {
                    lesser_child_i = next_child_i;
                }

                <span class="tok-kw">if</span> (compareFn(self.context, target_element, self.items[lesser_child_i]) == .lt) <span class="tok-kw">break</span>;

                self.items[index] = self.items[lesser_child_i];
                index = lesser_child_i;
            }
            self.items[index] = target_element;
        }

        <span class="tok-comment">/// PriorityQueue takes ownership of the passed in slice. The slice must have been</span>
        <span class="tok-comment">/// allocated with `allocator`.</span>
        <span class="tok-comment">/// Deinitialize with `deinit`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []T, context: Context) <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a> {
            <span class="tok-kw">var</span> self = <a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>{
                .items = items,
                .cap = items.len,
                .allocator = allocator,
                .context = context,
            };

            <span class="tok-kw">var</span> i = self.items.len &gt;&gt; <span class="tok-number">1</span>;
            <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
                i -= <span class="tok-number">1</span>;
                self.siftDown(i);
            }
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// Ensure that the queue can fit at least `new_capacity` items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> better_capacity = self.cap;
            <span class="tok-kw">if</span> (better_capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                better_capacity += better_capacity / <span class="tok-number">2</span> + <span class="tok-number">8</span>;
                <span class="tok-kw">if</span> (better_capacity &gt;= new_capacity) <span class="tok-kw">break</span>;
            }
            <span class="tok-kw">try</span> self.ensureTotalCapacityPrecise(better_capacity);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityPrecise</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.capacity() &gt;= new_capacity) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
            <span class="tok-kw">const</span> new_memory = <span class="tok-kw">try</span> self.allocator.realloc(old_memory, new_capacity);
            self.items.ptr = new_memory.ptr;
            self.cap = new_memory.len;
        }

        <span class="tok-comment">/// Ensure that the queue can fit at least `additional_count` **more** item.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ensureTotalCapacity(self.items.len + additional_count);
        }

        <span class="tok-comment">/// Reduce allocated capacity to `new_capacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, new_capacity: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_capacity &lt;= self.cap);<span class="tok-comment">

            // Cannot shrink to smaller than the current queue size without invalidating the heap property
            </span><a href="std.debug.html#std.debug.assert">assert</a>(new_capacity &gt;= self.items.len);

            <span class="tok-kw">const</span> old_memory = self.allocatedSlice();
            <span class="tok-kw">const</span> new_memory = self.allocator.realloc(old_memory, new_capacity) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; {<span class="tok-comment"> // no problem, capacity is still correct then.
                    </span><span class="tok-kw">return</span>;
                },
            };

            self.items.ptr = new_memory.ptr;
            self.cap = new_memory.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span> {
            self.items.len = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span> {
            self.allocator.free(self.allocatedSlice());
            self.items.len = <span class="tok-number">0</span>;
            self.cap = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>, elem: T, new_elem: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> update_index = blk: {
                <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (idx &lt; self.items.len) : (idx += <span class="tok-number">1</span>) {
                    <span class="tok-kw">const</span> item = self.items[idx];
                    <span class="tok-kw">if</span> (compareFn(self.context, item, elem) == .eq) <span class="tok-kw">break</span> :blk idx;
                }
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ElementNotFound;
            };
            <span class="tok-kw">const</span> old_elem: T = self.items[update_index];
            self.items[update_index] = new_elem;
            <span class="tok-kw">switch</span> (compareFn(self.context, new_elem, old_elem)) {
                .lt =&gt; <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftUp">siftUp</a>(self, update_index),
                .gt =&gt; <a href="std.priority_queue.html#std.priority_queue.PriorityQueue.siftDown">siftDown</a>(self, update_index),
                .eq =&gt; {},<span class="tok-comment"> // Nothing to do as the items have equal priority
            </span>}
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            queue: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">PriorityQueue</a>(T, Context, compareFn),
            count: <span class="tok-type">usize</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.priority_queue.PriorityQueue.Iterator.html">Iterator</a>) ?T {
                <span class="tok-kw">if</span> (it.count &gt;= it.queue.items.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                <span class="tok-kw">const</span> out = it.count;
                it.count += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> it.queue.items[out];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(it: *<a href="std.priority_queue.PriorityQueue.Iterator.html">Iterator</a>) <span class="tok-type">void</span> {
                it.count = <span class="tok-number">0</span>;
            }
        };

        <span class="tok-comment">/// Return an iterator that walks the queue without consuming</span>
        <span class="tok-comment">/// it. The iteration order may differ from the priority order.</span>
        <span class="tok-comment">/// Invalidated if the heap is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <a href="std.priority_queue.PriorityQueue.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> <a href="std.priority_queue.PriorityQueue.Iterator.html">Iterator</a>{
                .queue = self,
                .count = <span class="tok-number">0</span>,
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: *<a href="std.priority_queue.html#std.priority_queue.PriorityQueue">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> print = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>;
            print(<span class="tok-str">&quot;{{ &quot;</span>, .{});
            print(<span class="tok-str">&quot;items: &quot;</span>, .{});
            <span class="tok-kw">for</span> (self.items) |e| {
                print(<span class="tok-str">&quot;{}, &quot;</span>, .{e});
            }
            print(<span class="tok-str">&quot;array: &quot;</span>, .{});
            <span class="tok-kw">for</span> (self.items) |e| {
                print(<span class="tok-str">&quot;{}, &quot;</span>, .{e});
            }
            print(<span class="tok-str">&quot;len: {} &quot;</span>, .{self.items.len});
            print(<span class="tok-str">&quot;capacity: {}&quot;</span>, .{self.cap});
            print(<span class="tok-str">&quot; }}\n&quot;</span>, .{});
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.priority_dequeue.PriorityDequeue" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">PriorityDequeue</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue">[src]</a></h2><div class="tldDocs"><p>Priority Dequeue for storing generic data. Initialize with <code>init</code>.
Provide <code>compareFn</code> that returns <code>Order.lt</code> when its second
argument should get min-popped before its third argument,
<code>Order.eq</code> if the arguments are of equal priority, or <code>Order.gt</code>
if the third argument should be min-popped second.
Popping the max element works in reverse. For example,
to make <code>popMin</code> return the smallest number, provide
<code>fn lessThan(context: void, a: T, b: T) Order { _ = context; return std.math.order(a, b); }</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div><div><pre><code>compareFn: <span class="tok-kw">fn</span> (context: Context, a: T, b: T) <a href="std.math.Order.html">Order</a></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.priority_dequeue.PriorityDequeue.Iterator.html">std.priority_dequeue.PriorityDequeue.Iterator</a></li></ul></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>items: []T</code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>context: Context</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, context: Context) <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div class="tldDocs"><p>Initialize and return a new priority dequeue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>context: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, context: Context) <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a> {
    <span class="tok-kw">return</span> <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>{
        .items = &amp;[_]T{},
        .len = <span class="tok-number">0</span>,
        .allocator = allocator,
        .context = context,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Free memory used by the dequeue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">void</span> {
    self.allocator.free(self.items);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.add">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, elem: T) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert a new element, maintaining priority.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.add">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, elem: T) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(<span class="tok-number">1</span>);
    <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.addUnchecked">addUnchecked</a>(self, elem);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.addSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSlice</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.addSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSlice</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, items: []<span class="tok-kw">const</span> T) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Add each element in <code>items</code> to the dequeue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.addSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSlice</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, items: []<span class="tok-kw">const</span> T) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
    <span class="tok-kw">for</span> (items) |e| {
        self.addUnchecked(e);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.peekMin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">peekMin</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.peekMin">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekMin</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Look at the smallest element in the dequeue. Returns
<code>null</code> if empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.peekMin">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekMin</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.len &gt; <span class="tok-number">0</span>) self.items[<span class="tok-number">0</span>] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.peekMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">peekMax</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.peekMax">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekMax</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Look at the largest element in the dequeue. Returns
<code>null</code> if empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.peekMax">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekMax</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (self.len == <span class="tok-number">1</span>) <span class="tok-kw">return</span> self.items[<span class="tok-number">0</span>];
    <span class="tok-kw">if</span> (self.len == <span class="tok-number">2</span>) <span class="tok-kw">return</span> self.items[<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> self.bestItemAtIndices(<span class="tok-number">1</span>, <span class="tok-number">2</span>, .gt).item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.removeMinOrNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeMinOrNull</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.removeMinOrNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMinOrNull</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Pop the smallest element from the dequeue. Returns
<code>null</code> if empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.removeMinOrNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMinOrNull</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.len &gt; <span class="tok-number">0</span>) self.removeMin() <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.removeMin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeMin</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.removeMin">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMin</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) T</code></pre></div><div class="tldDocs"><p>Remove and return the smallest element from the
dequeue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.removeMin">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMin</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) T {
    <span class="tok-kw">return</span> self.removeIndex(<span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.removeMaxOrNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeMaxOrNull</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.removeMaxOrNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMaxOrNull</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T</code></pre></div><div class="tldDocs"><p>Pop the largest element from the dequeue. Returns
<code>null</code> if empty.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.removeMaxOrNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMaxOrNull</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.len &gt; <span class="tok-number">0</span>) self.removeMax() <span class="tok-kw">else</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.removeMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeMax</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.removeMax">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMax</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) T</code></pre></div><div class="tldDocs"><p>Remove and return the largest element from the
dequeue.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.removeMax">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMax</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) T {
    <span class="tok-kw">return</span> self.removeIndex(self.maxIndex().?);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.removeIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeIndex</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.removeIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeIndex</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, index: <span class="tok-type">usize</span>) T</code></pre></div><div class="tldDocs"><p>Remove and return element at index. Indices are in the
same order as iterator, which is not necessarily priority
order.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.removeIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeIndex</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, index: <span class="tok-type">usize</span>) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.len &gt; index);
    <span class="tok-kw">const</span> item = self.items[index];
    <span class="tok-kw">const</span> last = self.items[self.len - <span class="tok-number">1</span>];

    self.items[index] = last;
    self.len -= <span class="tok-number">1</span>;
    <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.siftDown">siftDown</a>(self, index);

    <span class="tok-kw">return</span> item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Return the number of elements remaining in the dequeue</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Return the number of elements that can be added to the
dequeue before more memory is allocated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.items.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.fromOwnedSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromOwnedSlice</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.fromOwnedSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []T, context: Context) <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div class="tldDocs"><p>Dequeue takes ownership of the passed in slice. The slice must have been
allocated with <code>allocator</code>.
De-initialize with <code>deinit</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>context: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.fromOwnedSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []T, context: Context) <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a> {
    <span class="tok-kw">var</span> queue = <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>{
        .items = items,
        .len = items.len,
        .allocator = allocator,
        .context = context,
    };

    <span class="tok-kw">if</span> (queue.len &lt;= <span class="tok-number">1</span>) <span class="tok-kw">return</span> queue;

    <span class="tok-kw">const</span> half = (queue.len &gt;&gt; <span class="tok-number">1</span>) - <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt;= half) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> index = half - i;
        queue.siftDown(index);
    }
    <span class="tok-kw">return</span> queue;
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Ensure that the dequeue can fit at least <code>new_capacity</code> items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> better_capacity = self.capacity();
    <span class="tok-kw">if</span> (better_capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        better_capacity += better_capacity / <span class="tok-number">2</span> + <span class="tok-number">8</span>;
        <span class="tok-kw">if</span> (better_capacity &gt;= new_capacity) <span class="tok-kw">break</span>;
    }
    self.items = <span class="tok-kw">try</span> self.allocator.realloc(self.items, better_capacity);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Ensure that the dequeue can fit at least <code>additional_count</code> <strong>more</strong> items.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacity(self.len + additional_count);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce allocated capacity to <code>new_len</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);<span class="tok-comment">

    // Cannot shrink to smaller than the current queue size without invalidating the heap property
    </span><a href="std.debug.html#std.debug.assert">assert</a>(new_len &gt;= self.len);

    self.items = self.allocator.realloc(self.items[<span class="tok-number">0</span>..], new_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; {<span class="tok-comment"> // no problem, capacity is still correct then.
            </span>self.items.len = new_len;
            <span class="tok-kw">return</span>;
        },
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">update</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.update">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, elem: T, new_elem: T) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div><div><pre><code>elem: T</code></pre></div><div><pre><code>new_elem: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.update">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, elem: T, new_elem: T) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_index = blk: {
        <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (idx &lt; self.len) : (idx += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> item = self.items[idx];
            <span class="tok-kw">if</span> (compareFn(self.context, item, elem) == .eq) <span class="tok-kw">break</span> :blk idx;
        }
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ElementNotFound;
    };
    _ = self.removeIndex(old_index);
    self.addUnchecked(new_elem);
}</code></pre></details></div></div><div class="decl"><h3 id="std.priority_dequeue.PriorityDequeue.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.priority_dequeue.PriorityDequeue.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <a href="std.priority_dequeue.PriorityDequeue.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Return an iterator that walks the queue without consuming
it. The iteration order may differ from the priority order.
Invalidated if the queue is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <a href="std.priority_dequeue.PriorityDequeue.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> <a href="std.priority_dequeue.PriorityDequeue.Iterator.html">Iterator</a>{
        .queue = self,
        .count = <span class="tok-number">0</span>,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.priority_dequeue.PriorityDequeue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">PriorityDequeue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (context: Context, a: T, b: T) <a href="std.math.Order.html">Order</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        items: []T,
        len: <span class="tok-type">usize</span>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        context: Context,

        <span class="tok-comment">/// Initialize and return a new priority dequeue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, context: Context) <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a> {
            <span class="tok-kw">return</span> <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>{
                .items = &amp;[_]T{},
                .len = <span class="tok-number">0</span>,
                .allocator = allocator,
                .context = context,
            };
        }

        <span class="tok-comment">/// Free memory used by the dequeue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">void</span> {
            self.allocator.free(self.items);
        }

        <span class="tok-comment">/// Insert a new element, maintaining priority.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, elem: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(<span class="tok-number">1</span>);
            <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.addUnchecked">addUnchecked</a>(self, elem);
        }

        <span class="tok-comment">/// Add each element in `items` to the dequeue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSlice</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, items: []<span class="tok-kw">const</span> T) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.ensureUnusedCapacity(items.len);
            <span class="tok-kw">for</span> (items) |e| {
                self.addUnchecked(e);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">addUnchecked</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, elem: T) <span class="tok-type">void</span> {
            self.items[self.len] = elem;

            <span class="tok-kw">if</span> (self.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = self.getStartForSiftUp(elem, self.len);
                self.siftUp(start);
            }

            self.len += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">isMinLayer</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {<span class="tok-comment">
            // In the min-max heap structure:
            // The first element is on a min layer;
            // next two are on a max layer;
            // next four are on a min layer, and so on.
            </span><span class="tok-kw">return</span> <span class="tok-number">1</span> == <span class="tok-builtin">@clz</span>(index +% <span class="tok-number">1</span>) &amp; <span class="tok-number">1</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">nextIsMinLayer</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.isMinLayer">isMinLayer</a>(self.len);
        }

        <span class="tok-kw">const</span> StartIndexAndLayer = <span class="tok-kw">struct</span> {
            index: <span class="tok-type">usize</span>,
            min_layer: <span class="tok-type">bool</span>,
        };

        <span class="tok-kw">fn</span> <span class="tok-fn">getStartForSiftUp</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, child: T, index: <span class="tok-type">usize</span>) <a href="std.priority_dequeue.PriorityDequeue.StartIndexAndLayer.html">StartIndexAndLayer</a> {
            <span class="tok-kw">const</span> child_index = index;
            <span class="tok-kw">const</span> parent_index = <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.parentIndex">parentIndex</a>(child_index);
            <span class="tok-kw">const</span> parent = self.items[parent_index];

            <span class="tok-kw">const</span> min_layer = self.nextIsMinLayer();
            <span class="tok-kw">const</span> order = compareFn(self.context, child, parent);
            <span class="tok-kw">if</span> ((min_layer <span class="tok-kw">and</span> order == .gt) <span class="tok-kw">or</span> (!min_layer <span class="tok-kw">and</span> order == .lt)) {<span class="tok-comment">
                // We must swap the item with it's parent if it is on the &quot;wrong&quot; layer
                </span>self.items[parent_index] = child;
                self.items[child_index] = parent;
                <span class="tok-kw">return</span> .{
                    .index = parent_index,
                    .min_layer = !min_layer,
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{
                    .index = child_index,
                    .min_layer = min_layer,
                };
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">siftUp</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, start: <a href="std.priority_dequeue.PriorityDequeue.StartIndexAndLayer.html">StartIndexAndLayer</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (start.min_layer) {
                <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.doSiftUp">doSiftUp</a>(self, start.index, .lt);
            } <span class="tok-kw">else</span> {
                <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.doSiftUp">doSiftUp</a>(self, start.index, .gt);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">doSiftUp</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, start_index: <span class="tok-type">usize</span>, target_order: <a href="std.math.Order.html">Order</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> child_index = start_index;
            <span class="tok-kw">while</span> (child_index &gt; <span class="tok-number">2</span>) {
                <span class="tok-kw">const</span> grandparent_index = <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.grandparentIndex">grandparentIndex</a>(child_index);
                <span class="tok-kw">const</span> child = self.items[child_index];
                <span class="tok-kw">const</span> grandparent = self.items[grandparent_index];<span class="tok-comment">

                // If the grandparent is already better or equal, we have gone as far as we need to
                </span><span class="tok-kw">if</span> (compareFn(self.context, child, grandparent) != target_order) <span class="tok-kw">break</span>;<span class="tok-comment">

                // Otherwise swap the item with it's grandparent
                </span>self.items[grandparent_index] = child;
                self.items[child_index] = grandparent;
                child_index = grandparent_index;
            }
        }

        <span class="tok-comment">/// Look at the smallest element in the dequeue. Returns</span>
        <span class="tok-comment">/// `null` if empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekMin</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.len &gt; <span class="tok-number">0</span>) self.items[<span class="tok-number">0</span>] <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Look at the largest element in the dequeue. Returns</span>
        <span class="tok-comment">/// `null` if empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekMax</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T {
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">1</span>) <span class="tok-kw">return</span> self.items[<span class="tok-number">0</span>];
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">2</span>) <span class="tok-kw">return</span> self.items[<span class="tok-number">1</span>];
            <span class="tok-kw">return</span> self.bestItemAtIndices(<span class="tok-number">1</span>, <span class="tok-number">2</span>, .gt).item;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">maxIndex</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> self.bestItemAtIndices(<span class="tok-number">1</span>, <span class="tok-number">2</span>, .gt).index;
        }

        <span class="tok-comment">/// Pop the smallest element from the dequeue. Returns</span>
        <span class="tok-comment">/// `null` if empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMinOrNull</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.len &gt; <span class="tok-number">0</span>) self.removeMin() <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Remove and return the smallest element from the</span>
        <span class="tok-comment">/// dequeue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMin</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) T {
            <span class="tok-kw">return</span> self.removeIndex(<span class="tok-number">0</span>);
        }

        <span class="tok-comment">/// Pop the largest element from the dequeue. Returns</span>
        <span class="tok-comment">/// `null` if empty.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMaxOrNull</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) ?T {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.len &gt; <span class="tok-number">0</span>) self.removeMax() <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Remove and return the largest element from the</span>
        <span class="tok-comment">/// dequeue.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeMax</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) T {
            <span class="tok-kw">return</span> self.removeIndex(self.maxIndex().?);
        }

        <span class="tok-comment">/// Remove and return element at index. Indices are in the</span>
        <span class="tok-comment">/// same order as iterator, which is not necessarily priority</span>
        <span class="tok-comment">/// order.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeIndex</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, index: <span class="tok-type">usize</span>) T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.len &gt; index);
            <span class="tok-kw">const</span> item = self.items[index];
            <span class="tok-kw">const</span> last = self.items[self.len - <span class="tok-number">1</span>];

            self.items[index] = last;
            self.len -= <span class="tok-number">1</span>;
            <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.siftDown">siftDown</a>(self, index);

            <span class="tok-kw">return</span> item;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">siftDown</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.isMinLayer">isMinLayer</a>(index)) {
                self.doSiftDown(index, .lt);
            } <span class="tok-kw">else</span> {
                self.doSiftDown(index, .gt);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">doSiftDown</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, start_index: <span class="tok-type">usize</span>, target_order: <a href="std.math.Order.html">Order</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">const</span> half = self.len &gt;&gt; <span class="tok-number">1</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> first_grandchild_index = <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.firstGrandchildIndex">firstGrandchildIndex</a>(index);
                <span class="tok-kw">const</span> last_grandchild_index = first_grandchild_index + <span class="tok-number">3</span>;

                <span class="tok-kw">const</span> elem = self.items[index];

                <span class="tok-kw">if</span> (last_grandchild_index &lt; self.len) {<span class="tok-comment">
                    // All four grandchildren exist
                    </span><span class="tok-kw">const</span> index2 = first_grandchild_index + <span class="tok-number">1</span>;
                    <span class="tok-kw">const</span> index3 = index2 + <span class="tok-number">1</span>;<span class="tok-comment">

                    // Find the best grandchild
                    </span><span class="tok-kw">const</span> best_left = self.bestItemAtIndices(first_grandchild_index, index2, target_order);
                    <span class="tok-kw">const</span> best_right = self.bestItemAtIndices(index3, last_grandchild_index, target_order);
                    <span class="tok-kw">const</span> best_grandchild = self.bestItem(best_left, best_right, target_order);<span class="tok-comment">

                    // If the item is better than or equal to its best grandchild, we are done
                    </span><span class="tok-kw">if</span> (compareFn(self.context, best_grandchild.item, elem) != target_order) <span class="tok-kw">return</span>;<span class="tok-comment">

                    // Otherwise, swap them
                    </span>self.items[best_grandchild.index] = elem;
                    self.items[index] = best_grandchild.item;
                    index = best_grandchild.index;<span class="tok-comment">

                    // We might need to swap the element with it's parent
                    </span>self.swapIfParentIsBetter(elem, index, target_order);
                } <span class="tok-kw">else</span> {<span class="tok-comment">
                    // The children or grandchildren are the last layer
                    </span><span class="tok-kw">const</span> first_child_index = <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.firstChildIndex">firstChildIndex</a>(index);
                    <span class="tok-kw">if</span> (first_child_index &gt;= self.len) <span class="tok-kw">return</span>;

                    <span class="tok-kw">const</span> best_descendent = self.bestDescendent(first_child_index, first_grandchild_index, target_order);<span class="tok-comment">

                    // If the item is better than or equal to its best descendant, we are done
                    </span><span class="tok-kw">if</span> (compareFn(self.context, best_descendent.item, elem) != target_order) <span class="tok-kw">return</span>;<span class="tok-comment">

                    // Otherwise swap them
                    </span>self.items[best_descendent.index] = elem;
                    self.items[index] = best_descendent.item;
                    index = best_descendent.index;<span class="tok-comment">

                    // If we didn't swap a grandchild, we are done
                    </span><span class="tok-kw">if</span> (index &lt; first_grandchild_index) <span class="tok-kw">return</span>;<span class="tok-comment">

                    // We might need to swap the element with it's parent
                    </span>self.swapIfParentIsBetter(elem, index, target_order);
                    <span class="tok-kw">return</span>;
                }<span class="tok-comment">

                // If we are now in the last layer, we are done
                </span><span class="tok-kw">if</span> (index &gt;= half) <span class="tok-kw">return</span>;
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">swapIfParentIsBetter</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, child: T, child_index: <span class="tok-type">usize</span>, target_order: <a href="std.math.Order.html">Order</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> parent_index = <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.parentIndex">parentIndex</a>(child_index);
            <span class="tok-kw">const</span> parent = self.items[parent_index];

            <span class="tok-kw">if</span> (compareFn(self.context, parent, child) == target_order) {
                self.items[parent_index] = child;
                self.items[child_index] = parent;
            }
        }

        <span class="tok-kw">const</span> ItemAndIndex = <span class="tok-kw">struct</span> {
            item: T,
            index: <span class="tok-type">usize</span>,
        };

        <span class="tok-kw">fn</span> <span class="tok-fn">getItem</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, index: <span class="tok-type">usize</span>) <a href="std.priority_dequeue.PriorityDequeue.ItemAndIndex.html">ItemAndIndex</a> {
            <span class="tok-kw">return</span> .{
                .item = self.items[index],
                .index = index,
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">bestItem</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, item1: <a href="std.priority_dequeue.PriorityDequeue.ItemAndIndex.html">ItemAndIndex</a>, item2: <a href="std.priority_dequeue.PriorityDequeue.ItemAndIndex.html">ItemAndIndex</a>, target_order: <a href="std.math.Order.html">Order</a>) <a href="std.priority_dequeue.PriorityDequeue.ItemAndIndex.html">ItemAndIndex</a> {
            <span class="tok-kw">if</span> (compareFn(self.context, item1.item, item2.item) == target_order) {
                <span class="tok-kw">return</span> item1;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> item2;
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">bestItemAtIndices</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, index1: <span class="tok-type">usize</span>, index2: <span class="tok-type">usize</span>, target_order: <a href="std.math.Order.html">Order</a>) <a href="std.priority_dequeue.PriorityDequeue.ItemAndIndex.html">ItemAndIndex</a> {
            <span class="tok-kw">const</span> item1 = self.getItem(index1);
            <span class="tok-kw">const</span> item2 = self.getItem(index2);
            <span class="tok-kw">return</span> self.bestItem(item1, item2, target_order);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">bestDescendent</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, first_child_index: <span class="tok-type">usize</span>, first_grandchild_index: <span class="tok-type">usize</span>, target_order: <a href="std.math.Order.html">Order</a>) <a href="std.priority_dequeue.PriorityDequeue.ItemAndIndex.html">ItemAndIndex</a> {
            <span class="tok-kw">const</span> second_child_index = first_child_index + <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (first_grandchild_index &gt;= self.len) {<span class="tok-comment">
                // No grandchildren, find the best child (second may not exist)
                </span><span class="tok-kw">if</span> (second_child_index &gt;= self.len) {
                    <span class="tok-kw">return</span> .{
                        .item = self.items[first_child_index],
                        .index = first_child_index,
                    };
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> self.bestItemAtIndices(first_child_index, second_child_index, target_order);
                }
            }

            <span class="tok-kw">const</span> second_grandchild_index = first_grandchild_index + <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (second_grandchild_index &gt;= self.len) {<span class="tok-comment">
                // One grandchild, so we know there is a second child. Compare first grandchild and second child
                </span><span class="tok-kw">return</span> self.bestItemAtIndices(first_grandchild_index, second_child_index, target_order);
            }

            <span class="tok-kw">const</span> best_left_grandchild_index = self.bestItemAtIndices(first_grandchild_index, second_grandchild_index, target_order).index;
            <span class="tok-kw">const</span> third_grandchild_index = second_grandchild_index + <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (third_grandchild_index &gt;= self.len) {<span class="tok-comment">
                // Two grandchildren, and we know the best. Compare this to second child.
                </span><span class="tok-kw">return</span> self.bestItemAtIndices(best_left_grandchild_index, second_child_index, target_order);
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Three grandchildren, compare the min of the first two with the third
                </span><span class="tok-kw">return</span> self.bestItemAtIndices(best_left_grandchild_index, third_grandchild_index, target_order);
            }
        }

        <span class="tok-comment">/// Return the number of elements remaining in the dequeue</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.len;
        }

        <span class="tok-comment">/// Return the number of elements that can be added to the</span>
        <span class="tok-comment">/// dequeue before more memory is allocated.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.items.len;
        }

        <span class="tok-comment">/// Dequeue takes ownership of the passed in slice. The slice must have been</span>
        <span class="tok-comment">/// allocated with `allocator`.</span>
        <span class="tok-comment">/// De-initialize with `deinit`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromOwnedSlice</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []T, context: Context) <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a> {
            <span class="tok-kw">var</span> queue = <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>{
                .items = items,
                .len = items.len,
                .allocator = allocator,
                .context = context,
            };

            <span class="tok-kw">if</span> (queue.len &lt;= <span class="tok-number">1</span>) <span class="tok-kw">return</span> queue;

            <span class="tok-kw">const</span> half = (queue.len &gt;&gt; <span class="tok-number">1</span>) - <span class="tok-number">1</span>;
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (i &lt;= half) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> index = half - i;
                queue.siftDown(index);
            }
            <span class="tok-kw">return</span> queue;
        }

        <span class="tok-comment">/// Ensure that the dequeue can fit at least `new_capacity` items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> better_capacity = self.capacity();
            <span class="tok-kw">if</span> (better_capacity &gt;= new_capacity) <span class="tok-kw">return</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                better_capacity += better_capacity / <span class="tok-number">2</span> + <span class="tok-number">8</span>;
                <span class="tok-kw">if</span> (better_capacity &gt;= new_capacity) <span class="tok-kw">break</span>;
            }
            self.items = <span class="tok-kw">try</span> self.allocator.realloc(self.items, better_capacity);
        }

        <span class="tok-comment">/// Ensure that the dequeue can fit at least `additional_count` **more** items.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ensureTotalCapacity(self.len + additional_count);
        }

        <span class="tok-comment">/// Reduce allocated capacity to `new_len`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.items.len);<span class="tok-comment">

            // Cannot shrink to smaller than the current queue size without invalidating the heap property
            </span><a href="std.debug.html#std.debug.assert">assert</a>(new_len &gt;= self.len);

            self.items = self.allocator.realloc(self.items[<span class="tok-number">0</span>..], new_len) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; {<span class="tok-comment"> // no problem, capacity is still correct then.
                    </span>self.items.len = new_len;
                    <span class="tok-kw">return</span>;
                },
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">update</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>, elem: T, new_elem: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_index = blk: {
                <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (idx &lt; self.len) : (idx += <span class="tok-number">1</span>) {
                    <span class="tok-kw">const</span> item = self.items[idx];
                    <span class="tok-kw">if</span> (compareFn(self.context, item, elem) == .eq) <span class="tok-kw">break</span> :blk idx;
                }
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ElementNotFound;
            };
            _ = self.removeIndex(old_index);
            self.addUnchecked(new_elem);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            queue: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">PriorityDequeue</a>(T, Context, compareFn),
            count: <span class="tok-type">usize</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.priority_dequeue.PriorityDequeue.Iterator.html">Iterator</a>) ?T {
                <span class="tok-kw">if</span> (it.count &gt;= it.queue.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                <span class="tok-kw">const</span> out = it.count;
                it.count += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> it.queue.items[out];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(it: *<a href="std.priority_dequeue.PriorityDequeue.Iterator.html">Iterator</a>) <span class="tok-type">void</span> {
                it.count = <span class="tok-number">0</span>;
            }
        };

        <span class="tok-comment">/// Return an iterator that walks the queue without consuming</span>
        <span class="tok-comment">/// it. The iteration order may differ from the priority order.</span>
        <span class="tok-comment">/// Invalidated if the queue is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <a href="std.priority_dequeue.PriorityDequeue.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> <a href="std.priority_dequeue.PriorityDequeue.Iterator.html">Iterator</a>{
                .queue = self,
                .count = <span class="tok-number">0</span>,
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: *<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> print = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>;
            print(<span class="tok-str">&quot;{{ &quot;</span>, .{});
            print(<span class="tok-str">&quot;items: &quot;</span>, .{});
            <span class="tok-kw">for</span> (self.items, <span class="tok-number">0</span>..) |e, i| {
                <span class="tok-kw">if</span> (i &gt;= self.len) <span class="tok-kw">break</span>;
                print(<span class="tok-str">&quot;{}, &quot;</span>, .{e});
            }
            print(<span class="tok-str">&quot;array: &quot;</span>, .{});
            <span class="tok-kw">for</span> (self.items) |e| {
                print(<span class="tok-str">&quot;{}, &quot;</span>, .{e});
            }
            print(<span class="tok-str">&quot;len: {} &quot;</span>, .{self.len});
            print(<span class="tok-str">&quot;capacity: {}&quot;</span>, .{self.capacity()});
            print(<span class="tok-str">&quot; }}\n&quot;</span>, .{});
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">parentIndex</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> (index - <span class="tok-number">1</span>) &gt;&gt; <span class="tok-number">1</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">grandparentIndex</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.parentIndex">parentIndex</a>(<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.parentIndex">parentIndex</a>(index));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">firstChildIndex</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> (index &lt;&lt; <span class="tok-number">1</span>) + <span class="tok-number">1</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">firstGrandchildIndex</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> <a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.firstChildIndex">firstChildIndex</a>(<a href="std.priority_dequeue.html#std.priority_dequeue.PriorityDequeue.firstChildIndex">firstChildIndex</a>(index));
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.segmented_list.SegmentedList" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">SegmentedList</span><a href="#src.zig-std.segmented_list.SegmentedList">[src]</a></h2><div class="tldDocs"><p>This is a stack data structure where pointers to indexes have the same lifetime as the data structure
itself, unlike ArrayList where append() invalidates all existing element pointers.
The tradeoff is that elements are not guaranteed to be contiguous. For that, use ArrayList.
Note however that most elements are contiguous, making this data structure cache-friendly.</p>
<p>Because it never has to copy elements from an old location to a new location, it does not require
its elements to be copyable, and it avoids wasting memory when backed by an ArenaAllocator.
Note that the append() and pop() convenience methods perform a copy, but you can instead use
addOne(), at(), setCapacity(), and shrinkCapacity() to avoid copying items.</p>
<p>This data structure has O(1) append and O(1) pop.</p>
<p>It supports preallocated elements, making it especially well suited when the expected maximum
size is small. <code>prealloc_item_count</code> must be 0, or a power of 2.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>prealloc_item_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.segmented_list.SegmentedList.Iterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.segmented_list.SegmentedList.Iterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.BaseIterator">BaseIterator</a>(*<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, *T)</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.ConstIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ConstIterator</span><a href="#src.zig-std.segmented_list.SegmentedList.ConstIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.ConstIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConstIterator = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.BaseIterator">BaseIterator</a>(*<span class="tok-kw">const</span> <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, *<span class="tok-kw">const</span> T)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>prealloc_segment: [prealloc_item_count]T = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>dynamic_segments: [][*]T = &amp;[_][*]T{}</code></pre></div><div><pre><code>len: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.segmented_list.SegmentedList.prealloc_count" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">prealloc_count</span><a href="#src.zig-std.segmented_list.SegmentedList.prealloc_count">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.prealloc_count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> prealloc_count = prealloc_item_count</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.segmented_list.SegmentedList.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.segmented_list.SegmentedList.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.freeShelves(allocator, <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len)), <span class="tok-number">0</span>);
    allocator.free(self.dynamic_segments);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.at" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">at</span><a href="#src.zig-std.segmented_list.SegmentedList.at">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">at</span>(self: <span class="tok-kw">anytype</span>, i: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.AtType">AtType</a>(<span class="tok-builtin">@TypeOf</span>(self))</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.at">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">at</span>(self: <span class="tok-kw">anytype</span>, i: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.AtType">AtType</a>(<span class="tok-builtin">@TypeOf</span>(self)) {
    <a href="std.debug.html#std.debug.assert">assert</a>(i &lt; self.len);
    <span class="tok-kw">return</span> self.uncheckedAt(i);
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.segmented_list.SegmentedList.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.append" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">append</span><a href="#src.zig-std.segmented_list.SegmentedList.append">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>item: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.append">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne(allocator);
    new_item_ptr.* = item;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.appendSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendSlice</span><a href="#src.zig-std.segmented_list.SegmentedList.appendSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.appendSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (items) |item| {
        <span class="tok-kw">try</span> self.append(allocator, item);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.segmented_list.SegmentedList.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) ?T</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) ?T {
    <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> index = self.len - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> result = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.uncheckedAt">uncheckedAt</a>(self, index).*;
    self.len = index;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.addOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOne</span><a href="#src.zig-std.segmented_list.SegmentedList.addOne">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.addOne">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {
    <span class="tok-kw">const</span> new_length = self.len + <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> self.growCapacity(allocator, new_length);
    <span class="tok-kw">const</span> result = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.uncheckedAt">uncheckedAt</a>(self, self.len);
    self.len = new_length;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.segmented_list.SegmentedList.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reduce length to <code>new_len</code>.
Invalidates pointers for the elements at index new_len and beyond.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.len);
    self.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.segmented_list.SegmentedList.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) <span class="tok-type">void</span> {
    self.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.segmented_list.SegmentedList.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invalidates all element pointers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.setCapacity(allocator, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    self.len = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.setCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setCapacity</span><a href="#src.zig-std.segmented_list.SegmentedList.setCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Grows or shrinks capacity to match usage.
TODO update this and related methods to match the conventions set by ArrayList</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.setCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (prealloc_item_count != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (new_capacity &lt;= <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; (<a href="std.segmented_list.html#std.segmented_list.SegmentedList.prealloc_exp">prealloc_exp</a> + <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len)))) {
            <span class="tok-kw">return</span> self.shrinkCapacity(allocator, new_capacity);
        }
    }
    <span class="tok-kw">return</span> self.growCapacity(allocator, new_capacity);
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.growCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">growCapacity</span><a href="#src.zig-std.segmented_list.SegmentedList.growCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">growCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Only grows capacity, or retains current capacity.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.growCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">growCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> new_cap_shelf_count = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfCount">shelfCount</a>(new_capacity);
    <span class="tok-kw">const</span> old_shelf_count = <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len));
    <span class="tok-kw">if</span> (new_cap_shelf_count &lt;= old_shelf_count) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> new_dynamic_segments = <span class="tok-kw">try</span> allocator.alloc([*]T, new_cap_shelf_count);
    <span class="tok-kw">errdefer</span> allocator.free(new_dynamic_segments);

    <span class="tok-kw">var</span> i: <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; old_shelf_count) : (i += <span class="tok-number">1</span>) {
        new_dynamic_segments[i] = self.dynamic_segments[i];
    }
    <span class="tok-kw">errdefer</span> <span class="tok-kw">while</span> (i &gt; old_shelf_count) : (i -= <span class="tok-number">1</span>) {
        allocator.free(new_dynamic_segments[i][<span class="tok-number">0</span>..<a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfSize">shelfSize</a>(i)]);
    };
    <span class="tok-kw">while</span> (i &lt; new_cap_shelf_count) : (i += <span class="tok-number">1</span>) {
        new_dynamic_segments[i] = (<span class="tok-kw">try</span> allocator.alloc(T, <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfSize">shelfSize</a>(i))).ptr;
    }

    allocator.free(self.dynamic_segments);
    self.dynamic_segments = new_dynamic_segments;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.shrinkCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkCapacity</span><a href="#src.zig-std.segmented_list.SegmentedList.shrinkCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Only shrinks capacity or retains current capacity.
It may fail to reduce the capacity in which case the capacity will remain unchanged.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.shrinkCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (new_capacity &lt;= prealloc_item_count) {
        <span class="tok-kw">const</span> len = <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len));
        self.freeShelves(allocator, len, <span class="tok-number">0</span>);
        allocator.free(self.dynamic_segments);
        self.dynamic_segments = &amp;[_][*]T{};
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> new_cap_shelf_count = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfCount">shelfCount</a>(new_capacity);
    <span class="tok-kw">const</span> old_shelf_count = <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len));
    <a href="std.debug.html#std.debug.assert">assert</a>(new_cap_shelf_count &lt;= old_shelf_count);
    <span class="tok-kw">if</span> (new_cap_shelf_count == old_shelf_count) <span class="tok-kw">return</span>;<span class="tok-comment">

    // freeShelves() must be called before resizing the dynamic
    // segments, but we don't know if resizing the dynamic segments
    // will work until we try it. So we must allocate a fresh memory
    // buffer in order to reduce capacity.
    </span><span class="tok-kw">const</span> new_dynamic_segments = allocator.alloc([*]T, new_cap_shelf_count) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
    self.freeShelves(allocator, old_shelf_count, new_cap_shelf_count);
    <span class="tok-kw">if</span> (allocator.resize(self.dynamic_segments, new_cap_shelf_count)) {<span class="tok-comment">
        // We didn't need the new memory allocation after all.
        </span>self.dynamic_segments = self.dynamic_segments[<span class="tok-number">0</span>..new_cap_shelf_count];
        allocator.free(new_dynamic_segments);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // Good thing we allocated that new memory slice.
        </span><span class="tok-builtin">@memcpy</span>(new_dynamic_segments, self.dynamic_segments[<span class="tok-number">0</span>..new_cap_shelf_count]);
        allocator.free(self.dynamic_segments);
        self.dynamic_segments = new_dynamic_segments;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.shrink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrink</span><a href="#src.zig-std.segmented_list.SegmentedList.shrink">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrink</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.shrink">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrink</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.len);<span class="tok-comment">
    // TODO take advantage of the new realloc semantics
    </span>self.len = new_len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.writeToSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeToSlice</span><a href="#src.zig-std.segmented_list.SegmentedList.writeToSlice">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeToSlice</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, dest: []T, start: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>dest: []T</code></pre></div><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.writeToSlice">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeToSlice</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, dest: []T, start: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> end = start + dest.len;
    <a href="std.debug.html#std.debug.assert">assert</a>(end &lt;= self.len);

    <span class="tok-kw">var</span> i = start;
    <span class="tok-kw">if</span> (end &lt;= prealloc_item_count) {
        <span class="tok-kw">const</span> src = self.prealloc_segment[i..end];
        <span class="tok-builtin">@memcpy</span>(dest[i - start ..][<span class="tok-number">0</span>..src.len], src);
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (i &lt; prealloc_item_count) {
        <span class="tok-kw">const</span> src = self.prealloc_segment[i..];
        <span class="tok-builtin">@memcpy</span>(dest[i - start ..][<span class="tok-number">0</span>..src.len], src);
        i = prealloc_item_count;
    }

    <span class="tok-kw">while</span> (i &lt; end) {
        <span class="tok-kw">const</span> shelf_index = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfIndex">shelfIndex</a>(i);
        <span class="tok-kw">const</span> copy_start = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.boxIndex">boxIndex</a>(i, shelf_index);
        <span class="tok-kw">const</span> copy_end = <span class="tok-builtin">@min</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfSize">shelfSize</a>(shelf_index), copy_start + end - i);
        <span class="tok-kw">const</span> src = self.dynamic_segments[shelf_index][copy_start..copy_end];
        <span class="tok-builtin">@memcpy</span>(dest[i - start ..][<span class="tok-number">0</span>..src.len], src);
        i += (copy_end - copy_start);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.uncheckedAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">uncheckedAt</span><a href="#src.zig-std.segmented_list.SegmentedList.uncheckedAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uncheckedAt</span>(self: <span class="tok-kw">anytype</span>, index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.AtType">AtType</a>(<span class="tok-builtin">@TypeOf</span>(self))</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.uncheckedAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uncheckedAt</span>(self: <span class="tok-kw">anytype</span>, index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.AtType">AtType</a>(<span class="tok-builtin">@TypeOf</span>(self)) {
    <span class="tok-kw">if</span> (index &lt; prealloc_item_count) {
        <span class="tok-kw">return</span> &amp;self.prealloc_segment[index];
    }
    <span class="tok-kw">const</span> shelf_index = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfIndex">shelfIndex</a>(index);
    <span class="tok-kw">const</span> box_index = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.boxIndex">boxIndex</a>(index, shelf_index);
    <span class="tok-kw">return</span> &amp;self.dynamic_segments[shelf_index][box_index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.segmented_list.SegmentedList.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, start_index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.Iterator">Iterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>start_index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, start_index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.Iterator">Iterator</a> {
    <span class="tok-kw">var</span> it = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.Iterator">Iterator</a>{
        .list = self,
        .index = <span class="tok-null">undefined</span>,
        .shelf_index = <span class="tok-null">undefined</span>,
        .box_index = <span class="tok-null">undefined</span>,
        .shelf_size = <span class="tok-null">undefined</span>,
    };
    it.set(start_index);
    <span class="tok-kw">return</span> it;
}</code></pre></details></div></div><div class="decl"><h3 id="std.segmented_list.SegmentedList.constIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">constIterator</span><a href="#src.zig-std.segmented_list.SegmentedList.constIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constIterator</span>(self: *<span class="tok-kw">const</span> <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, start_index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ConstIterator">ConstIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a></code></pre></div><div><pre><code>start_index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList.constIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constIterator</span>(self: *<span class="tok-kw">const</span> <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, start_index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ConstIterator">ConstIterator</a> {
    <span class="tok-kw">var</span> it = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ConstIterator">ConstIterator</a>{
        .list = self,
        .index = <span class="tok-null">undefined</span>,
        .shelf_index = <span class="tok-null">undefined</span>,
        .box_index = <span class="tok-null">undefined</span>,
        .shelf_size = <span class="tok-null">undefined</span>,
    };
    it.set(start_index);
    <span class="tok-kw">return</span> it;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.segmented_list.SegmentedList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SegmentedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> prealloc_item_count: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-kw">const</span> ShelfIndex = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<span class="tok-type">usize</span>);

        <span class="tok-kw">const</span> prealloc_exp: <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a> = blk: {<span class="tok-comment">
            // we don't use the prealloc_exp constant when prealloc_item_count is 0
            // but lazy-init may still be triggered by other code so supply a value
            </span><span class="tok-kw">if</span> (prealloc_item_count == <span class="tok-number">0</span>) {
                <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {
                <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(prealloc_item_count));
                <span class="tok-kw">const</span> value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int">log2_int</a>(<span class="tok-type">usize</span>, prealloc_item_count);
                <span class="tok-kw">break</span> :blk value;
            }
        };

        prealloc_segment: [prealloc_item_count]T = <span class="tok-null">undefined</span>,
        dynamic_segments: [][*]T = &amp;[_][*]T{},
        len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> prealloc_count = prealloc_item_count;

        <span class="tok-kw">fn</span> <span class="tok-fn">AtType</span>(<span class="tok-kw">comptime</span> SelfType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(SelfType).pointer.is_const) {
                <span class="tok-kw">return</span> *<span class="tok-kw">const</span> T;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> *T;
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.freeShelves(allocator, <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len)), <span class="tok-number">0</span>);
            allocator.free(self.dynamic_segments);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">at</span>(self: <span class="tok-kw">anytype</span>, i: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.AtType">AtType</a>(<span class="tok-builtin">@TypeOf</span>(self)) {
            <a href="std.debug.html#std.debug.assert">assert</a>(i &lt; self.len);
            <span class="tok-kw">return</span> self.uncheckedAt(i);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">append</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, item: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_item_ptr = <span class="tok-kw">try</span> self.addOne(allocator);
            new_item_ptr.* = item;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, items: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (items) |item| {
                <span class="tok-kw">try</span> self.append(allocator, item);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) ?T {
            <span class="tok-kw">if</span> (self.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

            <span class="tok-kw">const</span> index = self.len - <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> result = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.uncheckedAt">uncheckedAt</a>(self, index).*;
            self.len = index;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {
            <span class="tok-kw">const</span> new_length = self.len + <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> self.growCapacity(allocator, new_length);
            <span class="tok-kw">const</span> result = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.uncheckedAt">uncheckedAt</a>(self, self.len);
            self.len = new_length;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Reduce length to `new_len`.</span>
        <span class="tok-comment">/// Invalidates pointers for the elements at index new_len and beyond.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.len);
            self.len = new_len;
        }

        <span class="tok-comment">/// Invalidates all element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>) <span class="tok-type">void</span> {
            self.len = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Invalidates all element pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.setCapacity(allocator, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            self.len = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Grows or shrinks capacity to match usage.</span>
        <span class="tok-comment">/// TODO update this and related methods to match the conventions set by ArrayList</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (prealloc_item_count != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (new_capacity &lt;= <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; (<a href="std.segmented_list.html#std.segmented_list.SegmentedList.prealloc_exp">prealloc_exp</a> + <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len)))) {
                    <span class="tok-kw">return</span> self.shrinkCapacity(allocator, new_capacity);
                }
            }
            <span class="tok-kw">return</span> self.growCapacity(allocator, new_capacity);
        }

        <span class="tok-comment">/// Only grows capacity, or retains current capacity.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">growCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_cap_shelf_count = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfCount">shelfCount</a>(new_capacity);
            <span class="tok-kw">const</span> old_shelf_count = <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len));
            <span class="tok-kw">if</span> (new_cap_shelf_count &lt;= old_shelf_count) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> new_dynamic_segments = <span class="tok-kw">try</span> allocator.alloc([*]T, new_cap_shelf_count);
            <span class="tok-kw">errdefer</span> allocator.free(new_dynamic_segments);

            <span class="tok-kw">var</span> i: <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (i &lt; old_shelf_count) : (i += <span class="tok-number">1</span>) {
                new_dynamic_segments[i] = self.dynamic_segments[i];
            }
            <span class="tok-kw">errdefer</span> <span class="tok-kw">while</span> (i &gt; old_shelf_count) : (i -= <span class="tok-number">1</span>) {
                allocator.free(new_dynamic_segments[i][<span class="tok-number">0</span>..<a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfSize">shelfSize</a>(i)]);
            };
            <span class="tok-kw">while</span> (i &lt; new_cap_shelf_count) : (i += <span class="tok-number">1</span>) {
                new_dynamic_segments[i] = (<span class="tok-kw">try</span> allocator.alloc(T, <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfSize">shelfSize</a>(i))).ptr;
            }

            allocator.free(self.dynamic_segments);
            self.dynamic_segments = new_dynamic_segments;
        }

        <span class="tok-comment">/// Only shrinks capacity or retains current capacity.</span>
        <span class="tok-comment">/// It may fail to reduce the capacity in which case the capacity will remain unchanged.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkCapacity</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (new_capacity &lt;= prealloc_item_count) {
                <span class="tok-kw">const</span> len = <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len));
                self.freeShelves(allocator, len, <span class="tok-number">0</span>);
                allocator.free(self.dynamic_segments);
                self.dynamic_segments = &amp;[_][*]T{};
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">const</span> new_cap_shelf_count = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfCount">shelfCount</a>(new_capacity);
            <span class="tok-kw">const</span> old_shelf_count = <span class="tok-builtin">@as</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, <span class="tok-builtin">@intCast</span>(self.dynamic_segments.len));
            <a href="std.debug.html#std.debug.assert">assert</a>(new_cap_shelf_count &lt;= old_shelf_count);
            <span class="tok-kw">if</span> (new_cap_shelf_count == old_shelf_count) <span class="tok-kw">return</span>;<span class="tok-comment">

            // freeShelves() must be called before resizing the dynamic
            // segments, but we don't know if resizing the dynamic segments
            // will work until we try it. So we must allocate a fresh memory
            // buffer in order to reduce capacity.
            </span><span class="tok-kw">const</span> new_dynamic_segments = allocator.alloc([*]T, new_cap_shelf_count) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            self.freeShelves(allocator, old_shelf_count, new_cap_shelf_count);
            <span class="tok-kw">if</span> (allocator.resize(self.dynamic_segments, new_cap_shelf_count)) {<span class="tok-comment">
                // We didn't need the new memory allocation after all.
                </span>self.dynamic_segments = self.dynamic_segments[<span class="tok-number">0</span>..new_cap_shelf_count];
                allocator.free(new_dynamic_segments);
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Good thing we allocated that new memory slice.
                </span><span class="tok-builtin">@memcpy</span>(new_dynamic_segments, self.dynamic_segments[<span class="tok-number">0</span>..new_cap_shelf_count]);
                allocator.free(self.dynamic_segments);
                self.dynamic_segments = new_dynamic_segments;
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrink</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len &lt;= self.len);<span class="tok-comment">
            // TODO take advantage of the new realloc semantics
            </span>self.len = new_len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeToSlice</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, dest: []T, start: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> end = start + dest.len;
            <a href="std.debug.html#std.debug.assert">assert</a>(end &lt;= self.len);

            <span class="tok-kw">var</span> i = start;
            <span class="tok-kw">if</span> (end &lt;= prealloc_item_count) {
                <span class="tok-kw">const</span> src = self.prealloc_segment[i..end];
                <span class="tok-builtin">@memcpy</span>(dest[i - start ..][<span class="tok-number">0</span>..src.len], src);
                <span class="tok-kw">return</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (i &lt; prealloc_item_count) {
                <span class="tok-kw">const</span> src = self.prealloc_segment[i..];
                <span class="tok-builtin">@memcpy</span>(dest[i - start ..][<span class="tok-number">0</span>..src.len], src);
                i = prealloc_item_count;
            }

            <span class="tok-kw">while</span> (i &lt; end) {
                <span class="tok-kw">const</span> shelf_index = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfIndex">shelfIndex</a>(i);
                <span class="tok-kw">const</span> copy_start = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.boxIndex">boxIndex</a>(i, shelf_index);
                <span class="tok-kw">const</span> copy_end = <span class="tok-builtin">@min</span>(<a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfSize">shelfSize</a>(shelf_index), copy_start + end - i);
                <span class="tok-kw">const</span> src = self.dynamic_segments[shelf_index][copy_start..copy_end];
                <span class="tok-builtin">@memcpy</span>(dest[i - start ..][<span class="tok-number">0</span>..src.len], src);
                i += (copy_end - copy_start);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uncheckedAt</span>(self: <span class="tok-kw">anytype</span>, index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.AtType">AtType</a>(<span class="tok-builtin">@TypeOf</span>(self)) {
            <span class="tok-kw">if</span> (index &lt; prealloc_item_count) {
                <span class="tok-kw">return</span> &amp;self.prealloc_segment[index];
            }
            <span class="tok-kw">const</span> shelf_index = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfIndex">shelfIndex</a>(index);
            <span class="tok-kw">const</span> box_index = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.boxIndex">boxIndex</a>(index, shelf_index);
            <span class="tok-kw">return</span> &amp;self.dynamic_segments[shelf_index][box_index];
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">shelfCount</span>(box_count: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a> {
            <span class="tok-kw">if</span> (prealloc_item_count == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> <a href="std.segmented_list.html#std.segmented_list.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, box_count + <span class="tok-number">1</span>);
            }
            <span class="tok-kw">return</span> <a href="std.segmented_list.html#std.segmented_list.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, box_count + prealloc_item_count) - <a href="std.segmented_list.html#std.segmented_list.SegmentedList.prealloc_exp">prealloc_exp</a> - <span class="tok-number">1</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">shelfSize</span>(shelf_index: <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (prealloc_item_count == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; shelf_index;
            }
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; (shelf_index + (<a href="std.segmented_list.html#std.segmented_list.SegmentedList.prealloc_exp">prealloc_exp</a> + <span class="tok-number">1</span>));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">shelfIndex</span>(list_index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a> {
            <span class="tok-kw">if</span> (prealloc_item_count == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int">log2_int</a>(<span class="tok-type">usize</span>, list_index + <span class="tok-number">1</span>);
            }
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int">log2_int</a>(<span class="tok-type">usize</span>, list_index + prealloc_item_count) - <a href="std.segmented_list.html#std.segmented_list.SegmentedList.prealloc_exp">prealloc_exp</a> - <span class="tok-number">1</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">boxIndex</span>(list_index: <span class="tok-type">usize</span>, shelf_index: <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (prealloc_item_count == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> (list_index + <span class="tok-number">1</span>) - (<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; shelf_index);
            }
            <span class="tok-kw">return</span> list_index + prealloc_item_count - (<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; ((<a href="std.segmented_list.html#std.segmented_list.SegmentedList.prealloc_exp">prealloc_exp</a> + <span class="tok-number">1</span>) + shelf_index));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">freeShelves</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, from_count: <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>, to_count: <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> i = from_count;
            <span class="tok-kw">while</span> (i != to_count) {
                i -= <span class="tok-number">1</span>;
                allocator.free(self.dynamic_segments[i][<span class="tok-number">0</span>..<a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfSize">shelfSize</a>(i)]);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.BaseIterator">BaseIterator</a>(*<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, *T);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConstIterator = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.BaseIterator">BaseIterator</a>(*<span class="tok-kw">const</span> <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, *<span class="tok-kw">const</span> T);
        <span class="tok-kw">fn</span> <span class="tok-fn">BaseIterator</span>(<span class="tok-kw">comptime</span> SelfType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> ElementPtr: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
                list: SelfType,
                index: <span class="tok-type">usize</span>,
                box_index: <span class="tok-type">usize</span>,
                shelf_index: <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ShelfIndex">ShelfIndex</a>,
                shelf_size: <span class="tok-type">usize</span>,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<span class="tok-builtin">@This</span>()) ?ElementPtr {
                    <span class="tok-kw">if</span> (it.index &gt;= it.list.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    <span class="tok-kw">if</span> (it.index &lt; prealloc_item_count) {
                        <span class="tok-kw">const</span> ptr = &amp;it.list.prealloc_segment[it.index];
                        it.index += <span class="tok-number">1</span>;
                        <span class="tok-kw">if</span> (it.index == prealloc_item_count) {
                            it.box_index = <span class="tok-number">0</span>;
                            it.shelf_index = <span class="tok-number">0</span>;
                            it.shelf_size = prealloc_item_count * <span class="tok-number">2</span>;
                        }
                        <span class="tok-kw">return</span> ptr;
                    }

                    <span class="tok-kw">const</span> ptr = &amp;it.list.dynamic_segments[it.shelf_index][it.box_index];
                    it.index += <span class="tok-number">1</span>;
                    it.box_index += <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (it.box_index == it.shelf_size) {
                        it.shelf_index += <span class="tok-number">1</span>;
                        it.box_index = <span class="tok-number">0</span>;
                        it.shelf_size *= <span class="tok-number">2</span>;
                    }
                    <span class="tok-kw">return</span> ptr;
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prev</span>(it: *<span class="tok-builtin">@This</span>()) ?ElementPtr {
                    <span class="tok-kw">if</span> (it.index == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                    it.index -= <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (it.index &lt; prealloc_item_count) <span class="tok-kw">return</span> &amp;it.list.prealloc_segment[it.index];

                    <span class="tok-kw">if</span> (it.box_index == <span class="tok-number">0</span>) {
                        it.shelf_index -= <span class="tok-number">1</span>;
                        it.shelf_size /= <span class="tok-number">2</span>;
                        it.box_index = it.shelf_size - <span class="tok-number">1</span>;
                    } <span class="tok-kw">else</span> {
                        it.box_index -= <span class="tok-number">1</span>;
                    }

                    <span class="tok-kw">return</span> &amp;it.list.dynamic_segments[it.shelf_index][it.box_index];
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(it: *<span class="tok-builtin">@This</span>()) ?ElementPtr {
                    <span class="tok-kw">if</span> (it.index &gt;= it.list.len)
                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    <span class="tok-kw">if</span> (it.index &lt; prealloc_item_count)
                        <span class="tok-kw">return</span> &amp;it.list.prealloc_segment[it.index];

                    <span class="tok-kw">return</span> &amp;it.list.dynamic_segments[it.shelf_index][it.box_index];
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(it: *<span class="tok-builtin">@This</span>(), index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
                    it.index = index;
                    <span class="tok-kw">if</span> (index &lt; prealloc_item_count) <span class="tok-kw">return</span>;
                    it.shelf_index = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfIndex">shelfIndex</a>(index);
                    it.box_index = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.boxIndex">boxIndex</a>(index, it.shelf_index);
                    it.shelf_size = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.shelfSize">shelfSize</a>(it.shelf_index);
                }
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, start_index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.Iterator">Iterator</a> {
            <span class="tok-kw">var</span> it = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.Iterator">Iterator</a>{
                .list = self,
                .index = <span class="tok-null">undefined</span>,
                .shelf_index = <span class="tok-null">undefined</span>,
                .box_index = <span class="tok-null">undefined</span>,
                .shelf_size = <span class="tok-null">undefined</span>,
            };
            it.set(start_index);
            <span class="tok-kw">return</span> it;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">constIterator</span>(self: *<span class="tok-kw">const</span> <a href="std.segmented_list.html#std.segmented_list.SegmentedList">Self</a>, start_index: <span class="tok-type">usize</span>) <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ConstIterator">ConstIterator</a> {
            <span class="tok-kw">var</span> it = <a href="std.segmented_list.html#std.segmented_list.SegmentedList.ConstIterator">ConstIterator</a>{
                .list = self,
                .index = <span class="tok-null">undefined</span>,
                .shelf_index = <span class="tok-null">undefined</span>,
                .box_index = <span class="tok-null">undefined</span>,
                .shelf_size = <span class="tok-null">undefined</span>,
            };
            it.set(start_index);
            <span class="tok-kw">return</span> it;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.linked_list.SinglyLinkedList" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">SinglyLinkedList</span><a href="#src.zig-std.linked_list.SinglyLinkedList">[src]</a></h2><div class="tldDocs"><p>A singly-linked list is headed by a single forward pointer. The elements
are singly-linked for minimum space and pointer manipulation overhead at
the expense of O(n) removal for arbitrary elements. New elements can be
added to the list after an existing element or at the head of the list.
A singly-linked list may only be traversed in the forward direction.
Singly-linked lists are ideal for applications with large datasets and
few or no removals or for implementing a LIFO queue.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.linked_list.SinglyLinkedList.Node.html">std.linked_list.SinglyLinkedList.Node</a></li></ul></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>first: ?*<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.linked_list.SinglyLinkedList.prepend" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">prepend</span><a href="#src.zig-std.linked_list.SinglyLinkedList.prepend">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepend</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>, new_node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert a new node at the head.</p>
<p>Arguments:
new_node: Pointer to the new node to insert.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a></code></pre></div><div><pre><code>new_node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.SinglyLinkedList.prepend">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepend</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>, new_node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
    new_node.next = list.first;
    list.first = new_node;
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.SinglyLinkedList.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.linked_list.SinglyLinkedList.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>, node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Remove a node from the list.</p>
<p>Arguments:
node: Pointer to the node to be removed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a></code></pre></div><div><pre><code>node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.SinglyLinkedList.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>, node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (list.first == node) {
        list.first = node.next;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">var</span> current_elm = list.first.?;
        <span class="tok-kw">while</span> (current_elm.next != node) {
            current_elm = current_elm.next.?;
        }
        current_elm.next = node.next;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.SinglyLinkedList.popFirst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popFirst</span><a href="#src.zig-std.linked_list.SinglyLinkedList.popFirst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popFirst</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>) ?*<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a></code></pre></div><div class="tldDocs"><p>Remove and return the first node in the list.</p>
<p>Returns:
A pointer to the first node in the list.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.SinglyLinkedList.popFirst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popFirst</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>) ?*<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> {
    <span class="tok-kw">const</span> first = list.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    list.first = first.next;
    <span class="tok-kw">return</span> first;
}</code></pre></details></div></div><div class="decl"><h3 id="std.linked_list.SinglyLinkedList.len" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.linked_list.SinglyLinkedList.len">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(list: <a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Iterate over all nodes, returning the count.
This operation is O(N).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>list: <a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.linked_list.SinglyLinkedList.len">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(list: <a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (list.first) |n| {
        <span class="tok-kw">return</span> <span class="tok-number">1</span> + n.countChildren();
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.linked_list.SinglyLinkedList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SinglyLinkedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Node inside the linked list wrapping the actual data.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            next: ?*<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span>,
            data: T,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = T;

            <span class="tok-comment">/// Insert a new node after the current one.</span>
            <span class="tok-comment">///</span>
            <span class="tok-comment">/// Arguments:</span>
            <span class="tok-comment">///     new_node: Pointer to the new node to insert.</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertAfter</span>(node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>, new_node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
                new_node.next = node.next;
                node.next = new_node;
            }

            <span class="tok-comment">/// Remove a node from the list.</span>
            <span class="tok-comment">///</span>
            <span class="tok-comment">/// Arguments:</span>
            <span class="tok-comment">///     node: Pointer to the node to be removed.</span>
            <span class="tok-comment">/// Returns:</span>
            <span class="tok-comment">///     node removed</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeNext</span>(node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) ?*<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> {
                <span class="tok-kw">const</span> next_node = node.next <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                node.next = next_node.next;
                <span class="tok-kw">return</span> next_node;
            }

            <span class="tok-comment">/// Iterate over the singly-linked list from this node, until the final node is found.</span>
            <span class="tok-comment">/// This operation is O(N).</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findLast</span>(node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> {
                <span class="tok-kw">var</span> it = node;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    it = it.next <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> it;
                }
            }

            <span class="tok-comment">/// Iterate over each next node, returning the count of all nodes except the starting one.</span>
            <span class="tok-comment">/// This operation is O(N).</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countChildren</span>(node: *<span class="tok-kw">const</span> <a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">usize</span> {
                <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">var</span> it: ?*<span class="tok-kw">const</span> <a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> = node.next;
                <span class="tok-kw">while</span> (it) |n| : (it = n.next) {
                    count += <span class="tok-number">1</span>;
                }
                <span class="tok-kw">return</span> count;
            }

            <span class="tok-comment">/// Reverse the list starting from this node in-place.</span>
            <span class="tok-comment">/// This operation is O(N).</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverse</span>(indirect: *?*<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
                <span class="tok-kw">if</span> (indirect.* == <span class="tok-null">null</span>) {
                    <span class="tok-kw">return</span>;
                }
                <span class="tok-kw">var</span> current: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> = indirect.*.?;
                <span class="tok-kw">while</span> (current.next) |next| {
                    current.next = next.next;
                    next.next = indirect.*;
                    indirect.* = next;
                }
            }
        };

        first: ?*<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> = <span class="tok-null">null</span>,

        <span class="tok-comment">/// Insert a new node at the head.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Arguments:</span>
        <span class="tok-comment">///     new_node: Pointer to the new node to insert.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prepend</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>, new_node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
            new_node.next = list.first;
            list.first = new_node;
        }

        <span class="tok-comment">/// Remove a node from the list.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Arguments:</span>
        <span class="tok-comment">///     node: Pointer to the node to be removed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>, node: *<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (list.first == node) {
                list.first = node.next;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> current_elm = list.first.?;
                <span class="tok-kw">while</span> (current_elm.next != node) {
                    current_elm = current_elm.next.?;
                }
                current_elm.next = node.next;
            }
        }

        <span class="tok-comment">/// Remove and return the first node in the list.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Returns:</span>
        <span class="tok-comment">///     A pointer to the first node in the list.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popFirst</span>(list: *<a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>) ?*<a href="std.linked_list.SinglyLinkedList.Node.html">Node</a> {
            <span class="tok-kw">const</span> first = list.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            list.first = first.next;
            <span class="tok-kw">return</span> first;
        }

        <span class="tok-comment">/// Iterate over all nodes, returning the count.</span>
        <span class="tok-comment">/// This operation is O(N).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(list: <a href="std.linked_list.html#std.linked_list.SinglyLinkedList">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (list.first) |n| {
                <span class="tok-kw">return</span> <span class="tok-number">1</span> + n.countChildren();
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-number">0</span>;
            }
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.StaticBitSet" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StaticBitSet</span><a href="#src.zig-std.bit_set.StaticBitSet">[src]</a></h2><div class="tldDocs"><p>Returns the optimal static bit set type for the specified number
of elements: either <code><a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a></code> or <code><a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a></code>,
both of which fulfill the same interface.
The returned type will perform no allocations,
can be copied by value, and does not require deinitialization.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>size: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> StaticBitSet {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">0</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-number">5</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">5</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>) + <span class="tok-number">1</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>) + <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, <span class="tok-number">500</span>), <a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>(<span class="tok-number">500</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.StaticBitSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StaticBitSet</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (size &lt;= <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)) {
        <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.IntegerBitSet">IntegerBitSet</a>(size);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.ArrayBitSet">ArrayBitSet</a>(<span class="tok-type">usize</span>, size);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.StringHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StringHashMap</span><a href="#src.zig-std.hash_map.StringHashMap">[src]</a></h2><div class="tldDocs"><p>Builtin hashmap for strings as keys.
Key memory is managed by the caller.  Keys and values
will not automatically be freed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMap.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.hash_map.HashMap.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The type of the unmanaged hash map underlying this wrapper</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMap.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.hash_map.HashMap.Entry">[src]</a></h3><div class="tldDocs"><p>An entry, containing pointers to a key and value stored in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.hash_map.HashMap.KV">[src]</a></h3><div class="tldDocs"><p>A copy of a key and value which are no longer in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMap.Hash">[src]</a></h3><div class="tldDocs"><p>The integer type that is the result of hashing</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.hash_map.HashMap.Iterator">[src]</a></h3><div class="tldDocs"><p>The iterator type returned by iterator()</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KeyIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMap.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ValueIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMap.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Size" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMap.Size">[src]</a></h3><div class="tldDocs"><p>The integer type used to store the size of the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.hash_map.HashMap.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>The type returned from getOrPut and variants</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMap.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.hash_map.HashMap.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with an empty context.
If the context is not zero-sized, you must use
initContext(allocator, ctx) instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
    }
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
    </span>};
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.hash_map.HashMap.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with a context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMap.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMap.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMap.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release the backing array and invalidate this map.
This does <em>not</em> deinit keys, values, or the context!
If your keys or values need to be released, ensure
that that is done before calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMap.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map, but keep the backing allocation for future use.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMap.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map and release the backing allocation.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMap.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Return the number of items in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMap.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the entries in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMap.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the keys in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.keyIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMap.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the values in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.valueIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMap.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMap.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMap.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMap.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMap.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMap.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes a value from the map and returns the removed kv pair.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMap.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMap.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Finds the value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMap.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMap.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMap.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Finds the actual key associated with an adapted key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMap.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds the key and value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMap.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMap.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check if the map contains a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMap.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMap.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMap.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMap.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
    self.unmanaged.removeByPtr(key_ptr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMap.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using the same allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>( self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
    self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
    new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    new_ctx: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMap.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMap.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.rehash(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.StringHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringHashMap</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.hash_map.StringContext.html">StringContext</a>, <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.StringHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StringHashMapUnmanaged</span><a href="#src.zig-std.hash_map.StringHashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>Key memory is managed by the caller.  Keys and values
will not automatically be freed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.hash_map.HashMapUnmanaged.Entry.html">std.hash_map.HashMapUnmanaged.Entry</a></li><li><a href="std.hash_map.HashMapUnmanaged.KV.html">std.hash_map.HashMapUnmanaged.KV</a></li><li><a href="std.hash_map.HashMapUnmanaged.Iterator.html">std.hash_map.HashMapUnmanaged.Iterator</a></li><li><a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">std.hash_map.HashMapUnmanaged.GetOrPutResult</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Size" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Size">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Hash">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.KeyIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ValueIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Managed">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Pointer to the metadata.</p>
</div></div><div><pre><code>size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Current number of elements in the hashmap.</p>
</div></div><div><pre><code>available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Number of available slots before a grow is needed to satisfy the
<code>max_load_percentage</code>.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
    .metadata = <span class="tok-null">null</span>,
    .size = <span class="tok-number">0</span>,
    .available = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.deallocate(allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (new_size &gt; self.size)
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (self.metadata) |_| {
        self.initMetadatas();
        self.size = <span class="tok-number">0</span>;
        self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    self.deallocate(allocator);
    self.size = <span class="tok-number">0</span>;
    self.available = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">return</span> self.size;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">return</span> self.header().capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{ .hm = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.keys(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.values(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
    }
    self.putAssumeCapacityNoClobberContext(key, value, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    gop.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present,
and that no allocation is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

    <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

    <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
    self.available -= <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    self.keys()[idx] = key;
    self.values()[idx] = value;

    self.size += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
        <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
        <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = old_key.*,
            .value = old_val.*,
        };
        self.metadata.?[idx].remove();
        old_key.* = <span class="tok-null">undefined</span>;
        old_val.* = <span class="tok-null">undefined</span>;
        self.size -= <span class="tok-number">1</span>;
        self.available += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
            .key_ptr = &amp;self.keys()[idx],
            .value_ptr = &amp;self.values()[idx],
        };
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry if the associated key is not already present, otherwise update preexisting value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Get a copy of the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Get a copy of the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // If allocation fails, try to do the lookup anyway.
            // If we find an existing item, we can return it.
            // Otherwise return the error, we could not add another.
            </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = &amp;self.keys()[index],
                .value_ptr = &amp;self.values()[index],
                .found_existing = <span class="tok-null">true</span>,
            };
        };
    }
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!result.found_existing) {
        result.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

    // If you get a compile error on this line, it means that your generic hash
    // function is invalid for these parameters.
    </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    <span class="tok-kw">var</span> limit = self.capacity();
    <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

    <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
    </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
            <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
            // If you get a compile error on this line, it means that your generic eql
            // function is invalid for these parameters.

            </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = test_key,
                    .value_ptr = &amp;self.values()[idx],
                    .found_existing = <span class="tok-null">true</span>,
                };
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
            first_tombstone_idx = idx;
        }

        limit -= <span class="tok-number">1</span>;
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
        // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
        </span>idx = first_tombstone_idx;
        metadata = self.metadata.? + idx;
    }<span class="tok-comment">
    // We're using a slot previously free or a tombstone.
    </span>self.available -= <span class="tok-number">1</span>;

    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
    <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
    new_key.* = <span class="tok-null">undefined</span>;
    new_value.* = <span class="tok-null">undefined</span>;
    self.size += <span class="tok-number">1</span>;

    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
        .key_ptr = new_key,
        .value_ptr = new_value,
        .found_existing = <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Return true if there is a value associated with key in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        self.removeByIndex(idx);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
    // TODO: replace with pointer subtraction once supported by zig
    // if @sizeOf(K) == 0 then there is at most one item in the hash
    // map, which is assumed to exist as key_ptr must be valid.  This
    // item must be at index 0.
    </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
        (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;

    self.removeByIndex(idx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
    <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> other;

    <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
    <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
    other.initMetadatas();
    other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

    <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">const</span> keys_ptr = self.keys();
    <span class="tok-kw">const</span> values_ptr = self.values();
    <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (metadata[i].isUsed()) {
            other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
            <span class="tok-kw">if</span> (other.size == self.size)
                <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">var</span> keys_ptr = self.keys();
    <span class="tok-kw">var</span> values_ptr = self.values();
    <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

    // While we are re-hashing every slot, we will use the
    // fingerprint to mark used buckets as being used and either free
    // (needing to be rehashed) or tombstone (already rehashed).

    </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
    }<span class="tok-comment">

    // Now iterate over all the buckets, rehashing them

    </span>curr = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
        <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            curr += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
        <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
        <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

        // For each bucket, rehash to an index:
        // 1) before the cursor, probed into a free slot, or
        // 2) equal to the cursor, no need to move, or
        // 3) ahead of the cursor, probing over already rehashed

        </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
            (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
        {
            idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        }

        <span class="tok-kw">if</span> (idx &lt; curr) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
            metadata[idx].fill(fingerprint);
            keys_ptr[idx] = keys_ptr[curr];
            values_ptr[idx] = values_ptr[curr];

            metadata[curr].used = <span class="tok-number">0</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            keys_ptr[curr] = <span class="tok-null">undefined</span>;
            values_ptr[curr] = <span class="tok-null">undefined</span>;

            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
            metadata[idx].fingerprint = fingerprint;
            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
            metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
            } <span class="tok-kw">else</span> {
                metadata[idx].used = <span class="tok-number">1</span>;
                keys_ptr[idx] = keys_ptr[curr];
                values_ptr[idx] = values_ptr[curr];

                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                metadata[curr].used = <span class="tok-number">0</span>;
                keys_ptr[curr] = <span class="tok-null">undefined</span>;
                values_ptr[curr] = <span class="tok-null">undefined</span>;

                curr += <span class="tok-number">1</span>;
            }
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.StringHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.hash_map.StringContext.html">StringContext</a>, <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.StringArrayHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StringArrayHashMap</span><a href="#src.zig-std.array_hash_map.StringArrayHashMap">[src]</a></h2><div class="tldDocs"><p>An <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a></code> with strings as keys.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.StringArrayHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringArrayHashMap</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.array_hash_map.StringContext.html">StringContext</a>, <span class="tok-null">true</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.StringArrayHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StringArrayHashMapUnmanaged</span><a href="#src.zig-std.array_hash_map.StringArrayHashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>An <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> with strings as keys.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">std.array_hash_map.ArrayHashMapUnmanaged.Entry</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">std.array_hash_map.ArrayHashMapUnmanaged.KV</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">std.array_hash_map.ArrayHashMapUnmanaged.Data</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">std.array_hash_map.ArrayHashMapUnmanaged.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.DataList" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMap type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{}</code></pre><div class="fieldDocs"><p>It is permitted to access this field directly.
After any modification to the keys, consider calling <code>reIndex</code>.</p>
</div></div><div><pre><code>index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>When entries length is less than <code>linear_scan_max</code>, this remains <code>null</code>.
Once entries length grows big enough, this field is allocated. There is
an IndexHeader followed by an array of Index(I) structs, where I is defined
by how many total indexes there are.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
    .entries = .{},
    .index_header = <span class="tok-null">null</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="tldDocs"><p>Convert from an unmanaged map to a managed map.  After calling this,
the promoted map should no longer be used.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = gpa,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    <span class="tok-kw">errdefer</span> self.deinit(gpa);
    <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>An empty <code>value_list</code> may be passed, in which case the values array becomes <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
    <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
    <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
        <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
        <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
    }
    <span class="tok-kw">try</span> self.reIndex(gpa);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.entries.deinit(gpa);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
    }
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.len = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">switch</span> (header.capacityIndexType()) {
            .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
            .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
            .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
        self.index_header = <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.entries.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
    <span class="tok-kw">return</span> self.entries.items(.key);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
    <span class="tok-kw">return</span> self.entries.items(.value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> .{
        .keys = slice.items(.key).ptr,
        .values = slice.items(.value).ptr,
        .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // &quot;If key exists this function cannot fail.&quot;
        </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            .found_existing = <span class="tok-null">true</span>,
            .index = index,
        };
    };
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
both the key and the value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = item_key,<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = i,
                };
            }
        }

        <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
        // The slice length changed, so we directly index the pointer.
        </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
            .found_existing = <span class="tok-null">false</span>,
            .index = index,
        };
    };

    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> res;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
        <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">return</span>;
        }
    }

    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
    <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
    <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

    <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
    self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
    self.index_header = new_header;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ctx: Context, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
    ctx: Context,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
    <span class="tok-kw">const</span> indexes_cap = header.capacity();
    <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
        .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
        // workaround for #6974
        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> i;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    };
    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // workaround for #6974
    </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> &amp;self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but is allocated
with the provided allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
    <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

    <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
        // TODO: I'm pretty sure this could be memcpy'd instead of
        // doing all this work.
        </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
        other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
        other.index_header = new_header;
    }
    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Recompute all hashes.
    </span><span class="tok-kw">if</span> (store_hash) {
        <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            hash.* = h;
        }
    }
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify an entry's key without reordering any entries.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
    key_ptr.* = new_key;
    <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses a stable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstable</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses an unstable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstableContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkRetainingCapacity(new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFreeContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacityContext</code> can be used
instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkAndFree(gpa, new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.popContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (self.index_header) |header|
        self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    self.entries.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> .{
        .key = item.key,
        .value = item.value,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.StringArrayHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringArrayHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.array_hash_map.StringContext.html">StringContext</a>, <span class="tok-null">true</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.treap.Treap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Treap</span><a href="#src.zig-std.treap.Treap">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>Key: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.treap.Treap.Node.html">std.treap.Treap.Node</a></li><li><a href="std.treap.Treap.Entry.html">std.treap.Treap.Entry</a></li><li><a href="std.treap.Treap.InorderIterator.html">std.treap.Treap.InorderIterator</a></li></ul></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>root: ?*<a href="std.treap.Treap.Node.html">Node</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>prng: <a href="std.treap.Treap.Prng.html">Prng</a> = .{}</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.treap.Treap.getMin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getMin</span><a href="#src.zig-std.treap.Treap.getMin">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMin</span>(self: <a href="std.treap.html#std.treap.Treap">Self</a>) ?*<a href="std.treap.Treap.Node.html">Node</a></code></pre></div><div class="tldDocs"><p>Returns the smallest Node by key in the treap if there is one.
Use <code>getEntryForExisting()</code> to replace/remove this Node from the treap.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.treap.html#std.treap.Treap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.treap.Treap.getMin">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMin</span>(self: <a href="std.treap.html#std.treap.Treap">Self</a>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
    <span class="tok-kw">if</span> (self.root) |root| <span class="tok-kw">return</span> <a href="std.treap.html#std.treap.Treap.extremeInSubtreeOnDirection">extremeInSubtreeOnDirection</a>(root, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.treap.Treap.getMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getMax</span><a href="#src.zig-std.treap.Treap.getMax">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMax</span>(self: <a href="std.treap.html#std.treap.Treap">Self</a>) ?*<a href="std.treap.Treap.Node.html">Node</a></code></pre></div><div class="tldDocs"><p>Returns the largest Node by key in the treap if there is one.
Use <code>getEntryForExisting()</code> to replace/remove this Node from the treap.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.treap.html#std.treap.Treap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.treap.Treap.getMax">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMax</span>(self: <a href="std.treap.html#std.treap.Treap">Self</a>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
    <span class="tok-kw">if</span> (self.root) |root| <span class="tok-kw">return</span> <a href="std.treap.html#std.treap.Treap.extremeInSubtreeOnDirection">extremeInSubtreeOnDirection</a>(root, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.treap.Treap.getEntryFor" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryFor</span><a href="#src.zig-std.treap.Treap.getEntryFor">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryFor</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, key: Key) <a href="std.treap.Treap.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Lookup the Entry for the given key in the treap.
The Entry act's as a slot in the treap to insert/replace/remove the node associated with the key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.treap.html#std.treap.Treap">Self</a></code></pre></div><div><pre><code>key: Key</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.treap.Treap.getEntryFor">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryFor</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, key: Key) <a href="std.treap.Treap.Entry.html">Entry</a> {
    <span class="tok-kw">var</span> parent: ?*<a href="std.treap.Treap.Node.html">Node</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> node = self.find(key, &amp;parent);

    <span class="tok-kw">return</span> <a href="std.treap.Treap.Entry.html">Entry</a>{
        .key = key,
        .treap = self,
        .node = node,
        .context = .{ .inserted_under = parent },
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.treap.Treap.getEntryForExisting" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryForExisting</span><a href="#src.zig-std.treap.Treap.getEntryForExisting">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryForExisting</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, node: *<a href="std.treap.Treap.Node.html">Node</a>) <a href="std.treap.Treap.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Get an entry for a Node that currently exists in the treap.
It is undefined behavior if the Node is not currently inserted in the treap.
The Entry act's as a slot in the treap to insert/replace/remove the node associated with the key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.treap.html#std.treap.Treap">Self</a></code></pre></div><div><pre><code>node: *<a href="std.treap.Treap.Node.html">Node</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.treap.Treap.getEntryForExisting">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryForExisting</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, node: *<a href="std.treap.Treap.Node.html">Node</a>) <a href="std.treap.Treap.Entry.html">Entry</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(node.priority != <span class="tok-number">0</span>);

    <span class="tok-kw">return</span> <a href="std.treap.Treap.Entry.html">Entry</a>{
        .key = node.key,
        .treap = self,
        .node = node,
        .context = .{ .inserted_under = node.parent },
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.treap.Treap.inorderIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inorderIterator</span><a href="#src.zig-std.treap.Treap.inorderIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inorderIterator</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>) <a href="std.treap.Treap.InorderIterator.html">InorderIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.treap.html#std.treap.Treap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.treap.Treap.inorderIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inorderIterator</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>) <a href="std.treap.Treap.InorderIterator.html">InorderIterator</a> {
    <span class="tok-kw">return</span> .{ .current = self.getMin() };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.treap.Treap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Treap</span>(<span class="tok-kw">comptime</span> Key: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">anytype</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // Allow for compareFn to be fn (anytype, anytype) anytype
        // which allows the convenient use of std.math.order.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">compare</span>(a: Key, b: Key) <a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> compareFn(a, b);
        }

        root: ?*<a href="std.treap.Treap.Node.html">Node</a> = <span class="tok-null">null</span>,
        prng: <a href="std.treap.Treap.Prng.html">Prng</a> = .{},

        <span class="tok-comment">/// A customized pseudo random number generator for the treap.</span>
        <span class="tok-comment">/// This just helps reducing the memory size of the treap itself</span>
        <span class="tok-comment">/// as std.Random.DefaultPrng requires larger state (while producing better entropy for randomness to be fair).</span>
        <span class="tok-kw">const</span> Prng = <span class="tok-kw">struct</span> {
            xorshift: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">random</span>(self: *<a href="std.treap.Treap.Prng.html">Prng</a>, seed: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {<span class="tok-comment">
                // Lazily seed the prng state
                </span><span class="tok-kw">if</span> (self.xorshift == <span class="tok-number">0</span>) {
                    self.xorshift = seed;
                }<span class="tok-comment">

                // Since we're using usize, decide the shifts by the integer's bit width.
                </span><span class="tok-kw">const</span> shifts = <span class="tok-kw">switch</span> (<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)) {
                    <span class="tok-number">64</span> =&gt; .{ <span class="tok-number">13</span>, <span class="tok-number">7</span>, <span class="tok-number">17</span> },
                    <span class="tok-number">32</span> =&gt; .{ <span class="tok-number">13</span>, <span class="tok-number">17</span>, <span class="tok-number">5</span> },
                    <span class="tok-number">16</span> =&gt; .{ <span class="tok-number">7</span>, <span class="tok-number">9</span>, <span class="tok-number">8</span> },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;platform not supported&quot;</span>),
                };

                self.xorshift ^= self.xorshift &gt;&gt; shifts[<span class="tok-number">0</span>];
                self.xorshift ^= self.xorshift &lt;&lt; shifts[<span class="tok-number">1</span>];
                self.xorshift ^= self.xorshift &gt;&gt; shifts[<span class="tok-number">2</span>];

                <a href="std.debug.html#std.debug.assert">assert</a>(self.xorshift != <span class="tok-number">0</span>);
                <span class="tok-kw">return</span> self.xorshift;
            }
        };

        <span class="tok-comment">/// A Node represents an item or point in the treap with a uniquely associated key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            key: Key,
            priority: <span class="tok-type">usize</span>,
            parent: ?*<a href="std.treap.Treap.Node.html">Node</a>,
            children: [<span class="tok-number">2</span>]?*<a href="std.treap.Treap.Node.html">Node</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(node: *<a href="std.treap.Treap.Node.html">Node</a>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
                <span class="tok-kw">return</span> <a href="std.treap.html#std.treap.Treap.nextOnDirection">nextOnDirection</a>(node, <span class="tok-number">1</span>);
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prev</span>(node: *<a href="std.treap.Treap.Node.html">Node</a>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
                <span class="tok-kw">return</span> <a href="std.treap.html#std.treap.Treap.nextOnDirection">nextOnDirection</a>(node, <span class="tok-number">0</span>);
            }
        };

        <span class="tok-kw">fn</span> <span class="tok-fn">extremeInSubtreeOnDirection</span>(node: *<a href="std.treap.Treap.Node.html">Node</a>, direction: <span class="tok-type">u1</span>) *<a href="std.treap.Treap.Node.html">Node</a> {
            <span class="tok-kw">var</span> cur = node;
            <span class="tok-kw">while</span> (cur.children[direction]) |next| cur = next;
            <span class="tok-kw">return</span> cur;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">nextOnDirection</span>(node: *<a href="std.treap.Treap.Node.html">Node</a>, direction: <span class="tok-type">u1</span>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
            <span class="tok-kw">if</span> (node.children[direction]) |child| {
                <span class="tok-kw">return</span> <a href="std.treap.html#std.treap.Treap.extremeInSubtreeOnDirection">extremeInSubtreeOnDirection</a>(child, direction ^ <span class="tok-number">1</span>);
            }
            <span class="tok-kw">var</span> cur = node;<span class="tok-comment">
            // Traversing upward until we find `parent` to `cur` is NOT on
            // `direction`, or equivalently, `cur` to `parent` IS on
            // `direction` thus `parent` is the next.
            </span><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">if</span> (cur.parent) |parent| {<span class="tok-comment">
                    // If `parent -&gt; node` is NOT on `direction`, then
                    // `node -&gt; parent` IS on `direction`
                    </span><span class="tok-kw">if</span> (parent.children[direction] != cur) <span class="tok-kw">return</span> parent;
                    cur = parent;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            }
        }

        <span class="tok-comment">/// Returns the smallest Node by key in the treap if there is one.</span>
        <span class="tok-comment">/// Use `getEntryForExisting()` to replace/remove this Node from the treap.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMin</span>(self: <a href="std.treap.html#std.treap.Treap">Self</a>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
            <span class="tok-kw">if</span> (self.root) |root| <span class="tok-kw">return</span> <a href="std.treap.html#std.treap.Treap.extremeInSubtreeOnDirection">extremeInSubtreeOnDirection</a>(root, <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Returns the largest Node by key in the treap if there is one.</span>
        <span class="tok-comment">/// Use `getEntryForExisting()` to replace/remove this Node from the treap.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMax</span>(self: <a href="std.treap.html#std.treap.Treap">Self</a>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
            <span class="tok-kw">if</span> (self.root) |root| <span class="tok-kw">return</span> <a href="std.treap.html#std.treap.Treap.extremeInSubtreeOnDirection">extremeInSubtreeOnDirection</a>(root, <span class="tok-number">1</span>);
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Lookup the Entry for the given key in the treap.</span>
        <span class="tok-comment">/// The Entry act's as a slot in the treap to insert/replace/remove the node associated with the key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryFor</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, key: Key) <a href="std.treap.Treap.Entry.html">Entry</a> {
            <span class="tok-kw">var</span> parent: ?*<a href="std.treap.Treap.Node.html">Node</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> node = self.find(key, &amp;parent);

            <span class="tok-kw">return</span> <a href="std.treap.Treap.Entry.html">Entry</a>{
                .key = key,
                .treap = self,
                .node = node,
                .context = .{ .inserted_under = parent },
            };
        }

        <span class="tok-comment">/// Get an entry for a Node that currently exists in the treap.</span>
        <span class="tok-comment">/// It is undefined behavior if the Node is not currently inserted in the treap.</span>
        <span class="tok-comment">/// The Entry act's as a slot in the treap to insert/replace/remove the node associated with the key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryForExisting</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, node: *<a href="std.treap.Treap.Node.html">Node</a>) <a href="std.treap.Treap.Entry.html">Entry</a> {
            <a href="std.debug.html#std.debug.assert">assert</a>(node.priority != <span class="tok-number">0</span>);

            <span class="tok-kw">return</span> <a href="std.treap.Treap.Entry.html">Entry</a>{
                .key = node.key,
                .treap = self,
                .node = node,
                .context = .{ .inserted_under = node.parent },
            };
        }

        <span class="tok-comment">/// An Entry represents a slot in the treap associated with a given key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The associated key for this entry.</span>
            key: Key,
            <span class="tok-comment">/// A reference to the treap this entry is apart of.</span>
            treap: *<a href="std.treap.html#std.treap.Treap">Self</a>,
            <span class="tok-comment">/// The current node at this entry.</span>
            node: ?*<a href="std.treap.Treap.Node.html">Node</a>,
            <span class="tok-comment">/// The current state of the entry.</span>
            context: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
                <span class="tok-comment">/// A find() was called for this entry and the position in the treap is known.</span>
                inserted_under: ?*<a href="std.treap.Treap.Node.html">Node</a>,
                <span class="tok-comment">/// The entry's node was removed from the treap and a lookup must occur again for modification.</span>
                removed,
            },

            <span class="tok-comment">/// Update's the Node at this Entry in the treap with the new node (null for deleting). `new_node`</span>
            <span class="tok-comment">/// can have `undefind` content because the value will be initialized internally.</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.treap.Treap.Entry.html">Entry</a>, new_node: ?*<a href="std.treap.Treap.Node.html">Node</a>) <span class="tok-type">void</span> {<span class="tok-comment">
                // Update the entry's node reference after updating the treap below.
                </span><span class="tok-kw">defer</span> self.node = new_node;

                <span class="tok-kw">if</span> (self.node) |old| {
                    <span class="tok-kw">if</span> (new_node) |new| {
                        self.treap.replace(old, new);
                        <span class="tok-kw">return</span>;
                    }

                    self.treap.remove(old);
                    self.context = .removed;
                    <span class="tok-kw">return</span>;
                }

                <span class="tok-kw">if</span> (new_node) |new| {<span class="tok-comment">
                    // A previous treap.remove() could have rebalanced the nodes
                    // so when inserting after a removal, we have to re-lookup the parent again.
                    // This lookup shouldn't find a node because we're yet to insert it..
                    </span><span class="tok-kw">var</span> parent: ?*<a href="std.treap.Treap.Node.html">Node</a> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">switch</span> (self.context) {
                        .inserted_under =&gt; |p| parent = p,
                        .removed =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(self.treap.find(self.key, &amp;parent) == <span class="tok-null">null</span>),
                    }

                    self.treap.insert(self.key, parent, new);
                    self.context = .{ .inserted_under = parent };
                }
            }
        };

        <span class="tok-kw">fn</span> <span class="tok-fn">find</span>(self: <a href="std.treap.html#std.treap.Treap">Self</a>, key: Key, parent_ref: *?*<a href="std.treap.Treap.Node.html">Node</a>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
            <span class="tok-kw">var</span> node = self.root;
            parent_ref.* = <span class="tok-null">null</span>;<span class="tok-comment">

            // basic binary search while tracking the parent.
            </span><span class="tok-kw">while</span> (node) |current| {
                <span class="tok-kw">const</span> order = <a href="std.treap.html#std.treap.Treap.compare">compare</a>(key, current.key);
                <span class="tok-kw">if</span> (order == .eq) <span class="tok-kw">break</span>;

                parent_ref.* = current;
                node = current.children[<span class="tok-builtin">@intFromBool</span>(order == .gt)];
            }

            <span class="tok-kw">return</span> node;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">insert</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, key: Key, parent: ?*<a href="std.treap.Treap.Node.html">Node</a>, node: *<a href="std.treap.Treap.Node.html">Node</a>) <span class="tok-type">void</span> {<span class="tok-comment">
            // generate a random priority &amp; prepare the node to be inserted into the tree
            </span>node.key = key;
            node.priority = self.prng.random(<span class="tok-builtin">@intFromPtr</span>(node));
            node.parent = parent;
            node.children = [_]?*<a href="std.treap.Treap.Node.html">Node</a>{ <span class="tok-null">null</span>, <span class="tok-null">null</span> };<span class="tok-comment">

            // point the parent at the new node
            </span><span class="tok-kw">const</span> link = <span class="tok-kw">if</span> (parent) |p| &amp;p.children[<span class="tok-builtin">@intFromBool</span>(<a href="std.treap.html#std.treap.Treap.compare">compare</a>(key, p.key) == .gt)] <span class="tok-kw">else</span> &amp;self.root;
            <a href="std.debug.html#std.debug.assert">assert</a>(link.* == <span class="tok-null">null</span>);
            link.* = node;<span class="tok-comment">

            // rotate the node up into the tree to balance it according to its priority
            </span><span class="tok-kw">while</span> (node.parent) |p| {
                <span class="tok-kw">if</span> (p.priority &lt;= node.priority) <span class="tok-kw">break</span>;

                <span class="tok-kw">const</span> is_right = p.children[<span class="tok-number">1</span>] == node;
                <a href="std.debug.html#std.debug.assert">assert</a>(p.children[<span class="tok-builtin">@intFromBool</span>(is_right)] == node);

                <span class="tok-kw">const</span> rotate_right = !is_right;
                self.rotate(p, rotate_right);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">replace</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, old: *<a href="std.treap.Treap.Node.html">Node</a>, new: *<a href="std.treap.Treap.Node.html">Node</a>) <span class="tok-type">void</span> {<span class="tok-comment">
            // copy over the values from the old node
            </span>new.key = old.key;
            new.priority = old.priority;
            new.parent = old.parent;
            new.children = old.children;<span class="tok-comment">

            // point the parent at the new node
            </span><span class="tok-kw">const</span> link = <span class="tok-kw">if</span> (old.parent) |p| &amp;p.children[<span class="tok-builtin">@intFromBool</span>(p.children[<span class="tok-number">1</span>] == old)] <span class="tok-kw">else</span> &amp;self.root;
            <a href="std.debug.html#std.debug.assert">assert</a>(link.* == old);
            link.* = new;<span class="tok-comment">

            // point the children's parent at the new node
            </span><span class="tok-kw">for</span> (old.children) |child_node| {
                <span class="tok-kw">const</span> child = child_node <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
                <a href="std.debug.html#std.debug.assert">assert</a>(child.parent == old);
                child.parent = new;
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, node: *<a href="std.treap.Treap.Node.html">Node</a>) <span class="tok-type">void</span> {<span class="tok-comment">
            // rotate the node down to be a leaf of the tree for removal, respecting priorities.
            </span><span class="tok-kw">while</span> (node.children[<span class="tok-number">0</span>] <span class="tok-kw">orelse</span> node.children[<span class="tok-number">1</span>]) |_| {
                self.rotate(node, rotate_right: {
                    <span class="tok-kw">const</span> right = node.children[<span class="tok-number">1</span>] <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :rotate_right <span class="tok-null">true</span>;
                    <span class="tok-kw">const</span> left = node.children[<span class="tok-number">0</span>] <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :rotate_right <span class="tok-null">false</span>;
                    <span class="tok-kw">break</span> :rotate_right (left.priority &lt; right.priority);
                });
            }<span class="tok-comment">

            // node is a now a leaf; remove by nulling out the parent's reference to it.
            </span><span class="tok-kw">const</span> link = <span class="tok-kw">if</span> (node.parent) |p| &amp;p.children[<span class="tok-builtin">@intFromBool</span>(p.children[<span class="tok-number">1</span>] == node)] <span class="tok-kw">else</span> &amp;self.root;
            <a href="std.debug.html#std.debug.assert">assert</a>(link.* == node);
            link.* = <span class="tok-null">null</span>;<span class="tok-comment">

            // clean up after ourselves
            </span>node.priority = <span class="tok-number">0</span>;
            node.parent = <span class="tok-null">null</span>;
            node.children = [_]?*<a href="std.treap.Treap.Node.html">Node</a>{ <span class="tok-null">null</span>, <span class="tok-null">null</span> };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">rotate</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>, node: *<a href="std.treap.Treap.Node.html">Node</a>, right: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {<span class="tok-comment">
            // if right, converts the following:
            //      parent -&gt; (node (target YY adjacent) XX)
            //      parent -&gt; (target YY (node adjacent XX))
            //
            // if left (!right), converts the following:
            //      parent -&gt; (node (target YY adjacent) XX)
            //      parent -&gt; (target YY (node adjacent XX))
            </span><span class="tok-kw">const</span> parent = node.parent;
            <span class="tok-kw">const</span> target = node.children[<span class="tok-builtin">@intFromBool</span>(!right)] <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">const</span> adjacent = target.children[<span class="tok-builtin">@intFromBool</span>(right)];<span class="tok-comment">

            // rotate the children
            </span>target.children[<span class="tok-builtin">@intFromBool</span>(right)] = node;
            node.children[<span class="tok-builtin">@intFromBool</span>(!right)] = adjacent;<span class="tok-comment">

            // rotate the parents
            </span>node.parent = target;
            target.parent = parent;
            <span class="tok-kw">if</span> (adjacent) |adj| adj.parent = node;<span class="tok-comment">

            // fix the parent link
            </span><span class="tok-kw">const</span> link = <span class="tok-kw">if</span> (parent) |p| &amp;p.children[<span class="tok-builtin">@intFromBool</span>(p.children[<span class="tok-number">1</span>] == node)] <span class="tok-kw">else</span> &amp;self.root;
            <a href="std.debug.html#std.debug.assert">assert</a>(link.* == node);
            link.* = target;
        }

        <span class="tok-comment">/// Usage example:</span>
        <span class="tok-comment">///   var iter = treap.inorderIterator();</span>
        <span class="tok-comment">///   while (iter.next()) |node| {</span>
        <span class="tok-comment">///     ...</span>
        <span class="tok-comment">///   }</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InorderIterator = <span class="tok-kw">struct</span> {
            current: ?*<a href="std.treap.Treap.Node.html">Node</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.treap.Treap.InorderIterator.html">InorderIterator</a>) ?*<a href="std.treap.Treap.Node.html">Node</a> {
                <span class="tok-kw">const</span> current = it.current;
                it.current = <span class="tok-kw">if</span> (current) |cur|
                    cur.next()
                <span class="tok-kw">else</span>
                    <span class="tok-null">null</span>;
                <span class="tok-kw">return</span> current;
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inorderIterator</span>(self: *<a href="std.treap.html#std.treap.Treap">Self</a>) <a href="std.treap.Treap.InorderIterator.html">InorderIterator</a> {
            <span class="tok-kw">return</span> .{ .current = self.getMin() };
        }
    };
}</code></pre></details></div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.options" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">options</span><a href="#src.zig-std.options">[src]</a></h2><div class="tldDocs"><p>Stdlib-wide options that can be overridden by the root file.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.options">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> options: <a href="std.Options.html">Options</a> = <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<a href="std.html#std.root">root</a>, <span class="tok-str">&quot;std_options&quot;</span>)) <a href="std.html#std.root">root</a>.<a href="#">std_options</a> <span class="tok-kw">else</span> .{}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.once.once" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">once</span><a href="#src.zig-std.once.once">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">once</span>(<span class="tok-kw">comptime</span> f: <span class="tok-kw">fn</span> () <span class="tok-type">void</span>) <a href="std.once.html#std.once.Once">Once</a>(f)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>f: <span class="tok-kw">fn</span> () <span class="tok-type">void</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.once.once">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">once</span>(<span class="tok-kw">comptime</span> f: <span class="tok-kw">fn</span> () <span class="tok-type">void</span>) <a href="std.once.html#std.once.Once">Once</a>(f) {
    <span class="tok-kw">return</span> <a href="std.once.html#std.once.Once">Once</a>(f){};
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayHashMap = <a href="std.array_hash_map.html">array_hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayHashMapUnmanaged = <a href="std.array_hash_map.html">array_hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayList = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;array_list.zig&quot;</span>).ArrayList;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayListAligned = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;array_list.zig&quot;</span>).ArrayListAligned;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayListAlignedUnmanaged = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;array_list.zig&quot;</span>).ArrayListAlignedUnmanaged;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayListUnmanaged = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;array_list.zig&quot;</span>).ArrayListUnmanaged;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AutoArrayHashMap = <a href="std.array_hash_map.html">array_hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AutoArrayHashMapUnmanaged = <a href="std.array_hash_map.html">array_hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AutoHashMap = <a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AutoHashMapUnmanaged = <a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BitStack = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;BitStack.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BoundedArray = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;bounded_array.zig&quot;</span>).BoundedArray;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BoundedArrayAligned = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;bounded_array.zig&quot;</span>).BoundedArrayAligned;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Build = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BufMap = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;buf_map.zig&quot;</span>).BufMap;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BufSet = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;buf_set.zig&quot;</span>).BufSet;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StaticStringMap = <a href="std.static_string_map.html">static_string_map</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMap">StaticStringMap</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StaticStringMapWithEql = <a href="std.static_string_map.html">static_string_map</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMapWithEql">StaticStringMapWithEql</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DoublyLinkedList = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;linked_list.zig&quot;</span>).DoublyLinkedList;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DynLib = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dynamic_library.zig&quot;</span>).DynLib;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DynamicBitSet = <a href="std.bit_set.html">bit_set</a>.<a href="std.bit_set.DynamicBitSet.html">DynamicBitSet</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DynamicBitSetUnmanaged = <a href="std.bit_set.html">bit_set</a>.<a href="std.bit_set.DynamicBitSetUnmanaged.html">DynamicBitSetUnmanaged</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnumArray = <a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.EnumArray">EnumArray</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnumMap = <a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.EnumMap">EnumMap</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnumSet = <a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.EnumSet">EnumSet</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HashMap = <a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HashMapUnmanaged = <a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MultiArrayList = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;multi_array_list.zig&quot;</span>).MultiArrayList;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PriorityQueue = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;priority_queue.zig&quot;</span>).PriorityQueue;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PriorityDequeue = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;priority_dequeue.zig&quot;</span>).PriorityDequeue;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Progress = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Progress.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Random = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RingBuffer = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;RingBuffer.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SegmentedList = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;segmented_list.zig&quot;</span>).SegmentedList;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SemanticVersion = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;SemanticVersion.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SinglyLinkedList = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;linked_list.zig&quot;</span>).SinglyLinkedList;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StaticBitSet = <a href="std.bit_set.html">bit_set</a>.<a href="std.bit_set.html#std.bit_set.StaticBitSet">StaticBitSet</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringHashMap = <a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringHashMapUnmanaged = <a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.StringHashMapUnmanaged">StringHashMapUnmanaged</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringArrayHashMap = <a href="std.array_hash_map.html">array_hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMap">StringArrayHashMap</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringArrayHashMapUnmanaged = <a href="std.array_hash_map.html">array_hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Target = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Target.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Thread = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Thread.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Treap = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;treap.zig&quot;</span>).Treap;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tz = <a href="std.tz.html">tz</a>.<a href="std.tz.Tz.html">Tz</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Uri = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Uri.zig&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> array_hash_map = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;array_hash_map.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> atomic = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;atomic.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;base64.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> bit_set = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;bit_set.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> c = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;c.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> coff = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;coff.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> compress = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;compress.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> static_string_map = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;static_string_map.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> crypto = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;crypto.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> debug = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> dwarf = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> elf = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;elf.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> enums = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;enums.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> fifo = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fifo.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> fmt = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fmt.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> fs = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> gpu = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;gpu.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> hash = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;hash.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> hash_map = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;hash_map.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> heap = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;heap.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> http = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;http.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> io = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;io.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> json = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> leb = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;leb128.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> log = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;log.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> macho = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;macho.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> math = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;math.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;mem.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> meta = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;meta.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> net = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;net.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> os = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;os.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> once = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;once.zig&quot;</span>).once;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> pdb = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;pdb.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> posix = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;posix.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> process = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;process.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> sort = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;sort.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> simd = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;simd.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ascii = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;ascii.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> tar = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;tar.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> testing = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;testing.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> time = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;time.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> tz = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;tz.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> unicode = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;unicode.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> valgrind = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;valgrind.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> wasm = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;wasm.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;zig.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zip = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;zip.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zon = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;zon.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> start = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;start.zig&quot;</span>);

<span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);

<span class="tok-comment">/// Stdlib-wide options that can be overridden by the root file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> options: <a href="std.Options.html">Options</a> = <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<a href="std.html#std.root">root</a>, <span class="tok-str">&quot;std_options&quot;</span>)) <a href="std.html#std.root">root</a>.<a href="#">std_options</a> <span class="tok-kw">else</span> .{};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
    enable_segfault_handler: <span class="tok-type">bool</span> = <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.default_enable_segfault_handler">default_enable_segfault_handler</a>,

    <span class="tok-comment">/// Function used to implement `std.fs.cwd` for WASI.</span>
    wasiCwd: <span class="tok-kw">fn</span> () <a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_t">fd_t</a> = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.defaultWasiCwd">defaultWasiCwd</a>,

    <span class="tok-comment">/// The current log level.</span>
    log_level: <a href="std.log.html">log</a>.<a href="std.log.Level.html">Level</a> = <a href="std.log.html">log</a>.<a href="std.log.html#std.log.default_level">default_level</a>,

    log_scope_levels: []<span class="tok-kw">const</span> <a href="std.log.html">log</a>.<a href="std.log.ScopeLevel.html">ScopeLevel</a> = &amp;.{},

    logFn: <span class="tok-kw">fn</span> (
        <span class="tok-kw">comptime</span> message_level: <a href="std.log.html">log</a>.<a href="std.log.Level.html">Level</a>,
        <span class="tok-kw">comptime</span> scope: <span class="tok-builtin">@TypeOf</span>(.enum_literal),
        <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        args: <span class="tok-kw">anytype</span>,
    ) <span class="tok-type">void</span> = <a href="std.log.html">log</a>.<a href="std.log.html#std.log.defaultLog">defaultLog</a>,

    <span class="tok-comment">/// Overrides `std.heap.page_size_min`.</span>
    page_size_min: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Overrides `std.heap.page_size_max`.</span>
    page_size_max: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Overrides default implementation for determining OS page size at runtime.</span>
    queryPageSize: <span class="tok-kw">fn</span> () <span class="tok-type">usize</span> = <a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.defaultQueryPageSize">defaultQueryPageSize</a>,

    fmt_max_depth: <span class="tok-type">usize</span> = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.default_max_depth">default_max_depth</a>,

    cryptoRandomSeed: <span class="tok-kw">fn</span> (buffer: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;crypto/tlcsprng.zig&quot;</span>).defaultRandomSeed,

    crypto_always_getrandom: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    crypto_fork_safety: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

    <span class="tok-comment">/// By default Zig disables SIGPIPE by setting a &quot;no-op&quot; handler for it.  Set this option</span>
    <span class="tok-comment">/// to `true` to prevent that.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Note that we use a &quot;no-op&quot; handler instead of SIG_IGN because it will not be inherited by</span>
    <span class="tok-comment">/// any child process.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// SIGPIPE is triggered when a process attempts to write to a broken pipe. By default, SIGPIPE</span>
    <span class="tok-comment">/// will terminate the process instead of exiting.  It doesn't trigger the panic handler so in many</span>
    <span class="tok-comment">/// cases it's unclear why the process was terminated.  By capturing SIGPIPE instead, functions that</span>
    <span class="tok-comment">/// write to broken pipes will return the EPIPE error (error.BrokenPipe) and the program can handle</span>
    <span class="tok-comment">/// it like any other error.</span>
    keep_sigpipe: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// By default, std.http.Client will support HTTPS connections.  Set this option to `true` to</span>
    <span class="tok-comment">/// disable TLS support.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This will likely reduce the size of the binary, but it will also make it impossible to</span>
    <span class="tok-comment">/// make a HTTPS connection.</span>
    http_disable_tls: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// This enables `std.http.Client` to log ssl secrets to the file specified by the SSLKEYLOGFILE</span>
    <span class="tok-comment">/// env var.  Creating such a log file allows other programs with access to that file to decrypt</span>
    <span class="tok-comment">/// all `std.http.Client` traffic made by this program.</span>
    http_enable_ssl_key_log_file: <span class="tok-type">bool</span> = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).mode == .Debug,

    side_channels_mitigations: <a href="std.crypto.html">crypto</a>.<a href="std.crypto.SideChannelsMitigations.html">SideChannelsMitigations</a> = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.html#std.crypto.default_side_channels_mitigations">default_side_channels_mitigations</a>,
};<span class="tok-comment">

// This forces the start.zig file to be imported, and the comptime logic inside that
// file decides whether to export any appropriate start symbols, and call main.
</span><span class="tok-kw">comptime</span> {
    _ = <a href="std.start.html">start</a>;
}

<span class="tok-kw">test</span> {
    <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.refAllDecls">refAllDecls</a>(<span class="tok-builtin">@This</span>());
}

<span class="tok-kw">comptime</span> {
    <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>) == <span class="tok-builtin">@This</span>());<span class="tok-comment"> // std lib tests require --zig-lib-dir
</span>}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
