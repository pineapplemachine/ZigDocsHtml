<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.bit_set.html" class="">bit_set</a></li><li><a href="std.bit_set.DynamicBitSetUnmanaged.html" class="active">DynamicBitSetUnmanaged</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.bit_set.DynamicBitSetUnmanaged" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.bit_set.DynamicBitSetUnmanaged</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged">[src]</a></h1><div class="tldDocs"><p>A bit set with runtime-known size, backed by an allocated slice
of usize.  The allocator must be tracked externally by the user.</p>
</div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.MaskInt" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">MaskInt</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.MaskInt">[src]</a></h2><div class="tldDocs"><p>The integer type used to represent a mask in this bit set</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.MaskInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = <span class="tok-type">usize</span></code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.ShiftInt" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ShiftInt</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.ShiftInt">[src]</a></h2><div class="tldDocs"><p>The integer type used to shift a mask in this bit set</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.ShiftInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>)</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.Iterator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.Iterator">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.Iterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.BitSetIterator">BitSetIterator</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, options);
}</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>bit_length: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>The number of valid items in this bit set</p>
</div></div><div><pre><code>masks: [*]<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a> = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.empty_masks_ptr">empty_masks_ptr</a></code></pre><div class="fieldDocs"><p>The bit masks, ordered with lower indices first.
Padding bits at the end must be zeroed.</p>
</div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.initEmpty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initEmpty</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.initEmpty">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div class="tldDocs"><p>Creates a bit set with no elements present.
If bit_length is not zero, deinit must eventually be called.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>bit_length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.initEmpty">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
    <span class="tok-kw">try</span> self.resize(allocator, bit_length, <span class="tok-null">false</span>);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.initFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initFull</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.initFull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div class="tldDocs"><p>Creates a bit set with all elements present.
If bit_length is not zero, deinit must eventually be called.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>bit_length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.initFull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
    <span class="tok-kw">var</span> self = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
    <span class="tok-kw">try</span> self.resize(allocator, bit_length, <span class="tok-null">true</span>);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.resize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, fill: <span class="tok-type">bool</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Resizes to a new bit_length.  If the new length is larger
than the old length, fills any added bits with <code>fill</code>.
If new_len is not zero, deinit must eventually be called.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>fill: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.resize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, fill: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> old_len = self.bit_length;

    <span class="tok-kw">const</span> old_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(old_len);
    <span class="tok-kw">const</span> new_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(new_len);

    <span class="tok-kw">const</span> old_allocation = (self.masks - <span class="tok-number">1</span>)[<span class="tok-number">0</span>..(self.masks - <span class="tok-number">1</span>)[<span class="tok-number">0</span>]];

    <span class="tok-kw">if</span> (new_masks == <span class="tok-number">0</span>) {
        <a href="std.debug.html#std.debug.assert">assert</a>(new_len == <span class="tok-number">0</span>);
        allocator.free(old_allocation);
        self.masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.empty_masks_ptr">empty_masks_ptr</a>;
        self.bit_length = <span class="tok-number">0</span>;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (old_allocation.len != new_masks + <span class="tok-number">1</span>) realloc: {<span class="tok-comment">
        // If realloc fails, it may mean one of two things.
        // If we are growing, it means we are out of memory.
        // If we are shrinking, it means the allocator doesn't
        // want to move the allocation.  This means we need to
        // hold on to the extra 8 bytes required to be able to free
        // this allocation properly.
        </span><span class="tok-kw">const</span> new_allocation = allocator.realloc(old_allocation, new_masks + <span class="tok-number">1</span>) <span class="tok-kw">catch</span> |err| {
            <span class="tok-kw">if</span> (new_masks + <span class="tok-number">1</span> &gt; old_allocation.len) <span class="tok-kw">return</span> err;
            <span class="tok-kw">break</span> :realloc;
        };

        new_allocation[<span class="tok-number">0</span>] = new_allocation.len;
        self.masks = new_allocation.ptr + <span class="tok-number">1</span>;
    }<span class="tok-comment">

    // If we increased in size, we need to set any new bits
    // to the fill value.
    </span><span class="tok-kw">if</span> (new_len &gt; old_len) {<span class="tok-comment">
        // set the padding bits in the old last item to 1
        </span><span class="tok-kw">if</span> (fill <span class="tok-kw">and</span> old_masks &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> old_padding_bits = old_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - old_len;
            <span class="tok-kw">const</span> old_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(old_padding_bits));
            self.masks[old_masks - <span class="tok-number">1</span>] |= ~old_mask;
        }<span class="tok-comment">

        // fill in any new masks
        </span><span class="tok-kw">if</span> (new_masks &gt; old_masks) {
            <span class="tok-kw">const</span> fill_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, fill);
            <span class="tok-builtin">@memset</span>(self.masks[old_masks..new_masks], fill_value);
        }
    }<span class="tok-comment">

    // Zero out the padding bits
    </span><span class="tok-kw">if</span> (new_len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> padding_bits = new_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - new_len;
        <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
        self.masks[new_masks - <span class="tok-number">1</span>] &amp;= last_item_mask;
    }<span class="tok-comment">

    // And finally, save the new length.
    </span>self.bit_length = new_len;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deinitializes the array and releases its memory.
The passed allocator must be the same one used for
init* or resize in the past.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.resize(allocator, <span class="tok-number">0</span>, <span class="tok-null">false</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.clone">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div class="tldDocs"><p>Creates a duplicate of this bit set, using the new allocator.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.clone">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">var</span> copy = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
    <span class="tok-kw">try</span> copy.resize(new_allocator, self.bit_length, <span class="tok-null">false</span>);
    <span class="tok-builtin">@memcpy</span>(copy.masks[<span class="tok-number">0</span>..num_masks], self.masks[<span class="tok-number">0</span>..num_masks]);
    <span class="tok-kw">return</span> copy;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.capacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bits in this bit set</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.capacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.bit_length;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.isSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isSet</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.isSet">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if the bit at the specified index
is present in the set, false otherwise.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.isSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
    <span class="tok-kw">return</span> (self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] &amp; <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.count">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the total number of set bits in this bit set.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.count">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> num_masks = (self.bit_length + (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>)) / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
    <span class="tok-kw">var</span> total: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks]) |mask| {<span class="tok-comment">
        // Note: This is where we depend on padding bits being zero
        </span>total += <span class="tok-builtin">@popCount</span>(mask);
    }
    <span class="tok-kw">return</span> total;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.setValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setValue</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.setValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the value of the specified bit of the bit
set to match the passed boolean.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>value: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.setValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
    <span class="tok-kw">const</span> bit = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
    <span class="tok-kw">const</span> mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index);
    <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value);
    self.masks[mask_index] = (self.masks[mask_index] &amp; ~bit) | new_bit;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.set" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">set</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.set">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds a specific bit to the bit set</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.set">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
    self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] |= <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.setRangeValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setRangeValue</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.setRangeValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the value of all bits in the specified range to
match the passed boolean.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>range: <a href="std.bit_set.Range.html">Range</a></code></pre></div><div><pre><code>value: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.setRangeValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= self.bit_length);
    <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
    <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> start_mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(range.start);
    <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.start));

    <span class="tok-kw">const</span> end_mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(range.end);
    <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.end));

    <span class="tok-kw">if</span> (start_mask_index == end_mask_index) {
        <span class="tok-kw">var</span> mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
        <span class="tok-kw">var</span> mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
        self.masks[start_mask_index] &amp;= ~(mask1 &amp; mask2);

        mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
        mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &gt;&gt; (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
        self.masks[start_mask_index] |= mask1 &amp; mask2;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">var</span> bulk_mask_index: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (start_bit &gt; <span class="tok-number">0</span>) {
            self.masks[start_mask_index] =
                (self.masks[start_mask_index] &amp; ~(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit)) |
                (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit);
            bulk_mask_index = start_mask_index + <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            bulk_mask_index = start_mask_index;
        }

        <span class="tok-kw">while</span> (bulk_mask_index &lt; end_mask_index) : (bulk_mask_index += <span class="tok-number">1</span>) {
            self.masks[bulk_mask_index] = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value);
        }

        <span class="tok-kw">if</span> (end_bit &gt; <span class="tok-number">0</span>) {
            self.masks[end_mask_index] =
                (self.masks[end_mask_index] &amp; (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; end_bit)) |
                (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &gt;&gt; ((<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>)));
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.unset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unset</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.unset">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes a specific bit from the bit set</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.unset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
    self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] &amp;= ~<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.unsetAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unsetAll</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.unsetAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unsetAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set all bits to 0.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.unsetAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unsetAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> masks_len = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-builtin">@memset</span>(self.masks[<span class="tok-number">0</span>..masks_len], <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.setAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setAll</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.setAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Set all bits to 1.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.setAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> masks_len = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-builtin">@memset</span>(self.masks[<span class="tok-number">0</span>..masks_len], <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>));
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.toggle" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggle</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.toggle">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips a specific bit in the bit set</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.toggle">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
    self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] ^= <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.toggleSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleSet</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.toggleSet">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, toggles: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips all bits in this bit set which are present
in the toggles bit set.  Both sets must have the
same bit_length.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>toggles: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.toggleSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, toggles: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(toggles.bit_length == self.bit_length);
    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
        mask.* ^= toggles.masks[i];
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.toggleAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleAll</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.toggleAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Flips every bit in the bit set.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.toggleAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bit_length = self.bit_length;<span class="tok-comment">
    // avoid underflow if bit_length is zero
    </span><span class="tok-kw">if</span> (bit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks]) |*mask| {
        mask.* = ~mask.*;
    }

    <span class="tok-kw">const</span> padding_bits = num_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - bit_length;
    <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
    self.masks[num_masks - <span class="tok-number">1</span>] &amp;= last_item_mask;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.setUnion" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setUnion</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.setUnion">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Performs a union of two bit sets, and stores the
result in the first one.  Bits in the result are
set if the corresponding bits were set in either input.
The two sets must both be the same bit_length.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.setUnion">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(other.bit_length == self.bit_length);
    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
        mask.* |= other.masks[i];
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.setIntersection" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setIntersection</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.setIntersection">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Performs an intersection of two bit sets, and stores
the result in the first one.  Bits in the result are
set if the corresponding bits were set in both inputs.
The two sets must both be the same bit_length.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.setIntersection">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(other.bit_length == self.bit_length);
    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
        mask.* &amp;= other.masks[i];
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.findFirstSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">findFirstSet</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.findFirstSet">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index of the first set bit.
If no bits are set, returns null.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.findFirstSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> mask = self.masks;
    <span class="tok-kw">while</span> (offset &lt; self.bit_length) {
        <span class="tok-kw">if</span> (mask[<span class="tok-number">0</span>] != <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        mask += <span class="tok-number">1</span>;
        offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> offset + <span class="tok-builtin">@ctz</span>(mask[<span class="tok-number">0</span>]);
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.toggleFirstSet" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toggleFirstSet</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.toggleFirstSet">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index of the first set bit, and unsets it.
If no bits are set, returns null.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.toggleFirstSet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> mask = self.masks;
    <span class="tok-kw">while</span> (offset &lt; self.bit_length) {
        <span class="tok-kw">if</span> (mask[<span class="tok-number">0</span>] != <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        mask += <span class="tok-number">1</span>;
        offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask[<span class="tok-number">0</span>]);
    mask[<span class="tok-number">0</span>] &amp;= (mask[<span class="tok-number">0</span>] - <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> offset + index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.eql">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff every corresponding bit in both
bit sets are the same.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.eql">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (self.masks[i] != other.masks[i]) {
            <span class="tok-kw">break</span> <span class="tok-null">false</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.subsetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subsetOf</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.subsetOf">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff the first bit set is the subset
of the second one.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.subsetOf">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (self.masks[i] &amp; other.masks[i] != self.masks[i]) {
            <span class="tok-kw">break</span> <span class="tok-null">false</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.supersetOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supersetOf</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.supersetOf">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true iff the first bit set is the superset
of the second one.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.supersetOf">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (self.masks[i] &amp; other.masks[i] != other.masks[i]) {
            <span class="tok-kw">break</span> <span class="tok-null">false</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.bit_set.DynamicBitSetUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.bit_set.DynamicBitSetUnmanaged.iterator">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>(options)</code></pre></div><div class="tldDocs"><p>Iterates through the items in the set, according to the options.
The default options (.{}) will iterate indices of set bits in
ascending order.  Modifications to the underlying bit set may
or may not be observed by the iterator.  Resizing the underlying
bit set invalidates the iterator.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a></code></pre></div><div><pre><code>options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged.iterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>(options) {
    <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
    <span class="tok-kw">const</span> padding_bits = num_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - self.bit_length;
    <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
    <span class="tok-kw">return</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>(options).init(self.masks[<span class="tok-number">0</span>..num_masks], last_item_mask);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.bit_set.DynamicBitSetUnmanaged">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DynamicBitSetUnmanaged = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// The integer type used to represent a mask in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MaskInt = <span class="tok-type">usize</span>;

    <span class="tok-comment">/// The integer type used to shift a mask in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShiftInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);

    <span class="tok-comment">/// The number of valid items in this bit set</span>
    bit_length: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

    <span class="tok-comment">/// The bit masks, ordered with lower indices first.</span>
    <span class="tok-comment">/// Padding bits at the end must be zeroed.</span>
    masks: [*]<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a> = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.empty_masks_ptr">empty_masks_ptr</a>,<span class="tok-comment">
    // This pointer is one usize after the actual allocation.
    // That slot holds the size of the true allocation, which
    // is needed by Zig's allocator interface in case a shrink
    // fails.

    // Don't modify this value.  Ideally it would go in const data so
    // modifications would cause a bus error, but the only way
    // to discard a const qualifier is through intFromPtr, which
    // cannot currently round trip at comptime.
    </span><span class="tok-kw">var</span> empty_masks_data = [_]<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>{ <span class="tok-number">0</span>, <span class="tok-null">undefined</span> };
    <span class="tok-kw">const</span> empty_masks_ptr = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.empty_masks_data">empty_masks_data</a>[<span class="tok-number">1</span>..<span class="tok-number">2</span>];

    <span class="tok-comment">/// Creates a bit set with no elements present.</span>
    <span class="tok-comment">/// If bit_length is not zero, deinit must eventually be called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initEmpty</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
        <span class="tok-kw">var</span> self = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
        <span class="tok-kw">try</span> self.resize(allocator, bit_length, <span class="tok-null">false</span>);
        <span class="tok-kw">return</span> self;
    }

    <span class="tok-comment">/// Creates a bit set with all elements present.</span>
    <span class="tok-comment">/// If bit_length is not zero, deinit must eventually be called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initFull</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, bit_length: <span class="tok-type">usize</span>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
        <span class="tok-kw">var</span> self = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
        <span class="tok-kw">try</span> self.resize(allocator, bit_length, <span class="tok-null">true</span>);
        <span class="tok-kw">return</span> self;
    }

    <span class="tok-comment">/// Resizes to a new bit_length.  If the new length is larger</span>
    <span class="tok-comment">/// than the old length, fills any added bits with `fill`.</span>
    <span class="tok-comment">/// If new_len is not zero, deinit must eventually be called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, fill: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> old_len = self.bit_length;

        <span class="tok-kw">const</span> old_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(old_len);
        <span class="tok-kw">const</span> new_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(new_len);

        <span class="tok-kw">const</span> old_allocation = (self.masks - <span class="tok-number">1</span>)[<span class="tok-number">0</span>..(self.masks - <span class="tok-number">1</span>)[<span class="tok-number">0</span>]];

        <span class="tok-kw">if</span> (new_masks == <span class="tok-number">0</span>) {
            <a href="std.debug.html#std.debug.assert">assert</a>(new_len == <span class="tok-number">0</span>);
            allocator.free(old_allocation);
            self.masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.empty_masks_ptr">empty_masks_ptr</a>;
            self.bit_length = <span class="tok-number">0</span>;
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (old_allocation.len != new_masks + <span class="tok-number">1</span>) realloc: {<span class="tok-comment">
            // If realloc fails, it may mean one of two things.
            // If we are growing, it means we are out of memory.
            // If we are shrinking, it means the allocator doesn't
            // want to move the allocation.  This means we need to
            // hold on to the extra 8 bytes required to be able to free
            // this allocation properly.
            </span><span class="tok-kw">const</span> new_allocation = allocator.realloc(old_allocation, new_masks + <span class="tok-number">1</span>) <span class="tok-kw">catch</span> |err| {
                <span class="tok-kw">if</span> (new_masks + <span class="tok-number">1</span> &gt; old_allocation.len) <span class="tok-kw">return</span> err;
                <span class="tok-kw">break</span> :realloc;
            };

            new_allocation[<span class="tok-number">0</span>] = new_allocation.len;
            self.masks = new_allocation.ptr + <span class="tok-number">1</span>;
        }<span class="tok-comment">

        // If we increased in size, we need to set any new bits
        // to the fill value.
        </span><span class="tok-kw">if</span> (new_len &gt; old_len) {<span class="tok-comment">
            // set the padding bits in the old last item to 1
            </span><span class="tok-kw">if</span> (fill <span class="tok-kw">and</span> old_masks &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> old_padding_bits = old_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - old_len;
                <span class="tok-kw">const</span> old_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(old_padding_bits));
                self.masks[old_masks - <span class="tok-number">1</span>] |= ~old_mask;
            }<span class="tok-comment">

            // fill in any new masks
            </span><span class="tok-kw">if</span> (new_masks &gt; old_masks) {
                <span class="tok-kw">const</span> fill_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, fill);
                <span class="tok-builtin">@memset</span>(self.masks[old_masks..new_masks], fill_value);
            }
        }<span class="tok-comment">

        // Zero out the padding bits
        </span><span class="tok-kw">if</span> (new_len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> padding_bits = new_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - new_len;
            <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
            self.masks[new_masks - <span class="tok-number">1</span>] &amp;= last_item_mask;
        }<span class="tok-comment">

        // And finally, save the new length.
        </span>self.bit_length = new_len;
    }

    <span class="tok-comment">/// Deinitializes the array and releases its memory.</span>
    <span class="tok-comment">/// The passed allocator must be the same one used for</span>
    <span class="tok-comment">/// init* or resize in the past.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        self.resize(allocator, <span class="tok-number">0</span>, <span class="tok-null">false</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-comment">/// Creates a duplicate of this bit set, using the new allocator.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a> {
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">var</span> copy = <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>{};
        <span class="tok-kw">try</span> copy.resize(new_allocator, self.bit_length, <span class="tok-null">false</span>);
        <span class="tok-builtin">@memcpy</span>(copy.masks[<span class="tok-number">0</span>..num_masks], self.masks[<span class="tok-number">0</span>..num_masks]);
        <span class="tok-kw">return</span> copy;
    }

    <span class="tok-comment">/// Returns the number of bits in this bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.bit_length;
    }

    <span class="tok-comment">/// Returns true if the bit at the specified index</span>
    <span class="tok-comment">/// is present in the set, false otherwise.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        <span class="tok-kw">return</span> (self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] &amp; <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index)) != <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Returns the total number of set bits in this bit set.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> num_masks = (self.bit_length + (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>)) / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
        <span class="tok-kw">var</span> total: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks]) |mask| {<span class="tok-comment">
            // Note: This is where we depend on padding bits being zero
            </span>total += <span class="tok-builtin">@popCount</span>(mask);
        }
        <span class="tok-kw">return</span> total;
    }

    <span class="tok-comment">/// Changes the value of the specified bit of the bit</span>
    <span class="tok-comment">/// set to match the passed boolean.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setValue</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        <span class="tok-kw">const</span> bit = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
        <span class="tok-kw">const</span> mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index);
        <span class="tok-kw">const</span> new_bit = bit &amp; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value);
        self.masks[mask_index] = (self.masks[mask_index] &amp; ~bit) | new_bit;
    }

    <span class="tok-comment">/// Adds a specific bit to the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] |= <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
    }

    <span class="tok-comment">/// Changes the value of all bits in the specified range to</span>
    <span class="tok-comment">/// match the passed boolean.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setRangeValue</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, range: <a href="std.bit_set.Range.html">Range</a>, value: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(range.end &lt;= self.bit_length);
        <a href="std.debug.html#std.debug.assert">assert</a>(range.start &lt;= range.end);
        <span class="tok-kw">if</span> (range.start == range.end) <span class="tok-kw">return</span>;

        <span class="tok-kw">const</span> start_mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(range.start);
        <span class="tok-kw">const</span> start_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.start));

        <span class="tok-kw">const</span> end_mask_index = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(range.end);
        <span class="tok-kw">const</span> end_bit = <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(range.end));

        <span class="tok-kw">if</span> (start_mask_index == end_mask_index) {
            <span class="tok-kw">var</span> mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit;
            <span class="tok-kw">var</span> mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &gt;&gt; (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
            self.masks[start_mask_index] &amp;= ~(mask1 &amp; mask2);

            mask1 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit;
            mask2 = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &gt;&gt; (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>);
            self.masks[start_mask_index] |= mask1 &amp; mask2;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">var</span> bulk_mask_index: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">if</span> (start_bit &gt; <span class="tok-number">0</span>) {
                self.masks[start_mask_index] =
                    (self.masks[start_mask_index] &amp; ~(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; start_bit)) |
                    (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &lt;&lt; start_bit);
                bulk_mask_index = start_mask_index + <span class="tok-number">1</span>;
            } <span class="tok-kw">else</span> {
                bulk_mask_index = start_mask_index;
            }

            <span class="tok-kw">while</span> (bulk_mask_index &lt; end_mask_index) : (bulk_mask_index += <span class="tok-number">1</span>) {
                self.masks[bulk_mask_index] = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value);
            }

            <span class="tok-kw">if</span> (end_bit &gt; <span class="tok-number">0</span>) {
                self.masks[end_mask_index] =
                    (self.masks[end_mask_index] &amp; (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-null">true</span>) &lt;&lt; end_bit)) |
                    (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.boolMask">boolMask</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, value) &gt;&gt; ((<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>) - (end_bit - <span class="tok-number">1</span>)));
            }
        }
    }

    <span class="tok-comment">/// Removes a specific bit from the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unset</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] &amp;= ~<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
    }

    <span class="tok-comment">/// Set all bits to 0.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unsetAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> masks_len = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-builtin">@memset</span>(self.masks[<span class="tok-number">0</span>..masks_len], <span class="tok-number">0</span>);
    }

    <span class="tok-comment">/// Set all bits to 1.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> masks_len = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-builtin">@memset</span>(self.masks[<span class="tok-number">0</span>..masks_len], <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>));
    }

    <span class="tok-comment">/// Flips a specific bit in the bit set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggle</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.bit_length);
        self.masks[<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskIndex">maskIndex</a>(index)] ^= <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.maskBit">maskBit</a>(index);
    }

    <span class="tok-comment">/// Flips all bits in this bit set which are present</span>
    <span class="tok-comment">/// in the toggles bit set.  Both sets must have the</span>
    <span class="tok-comment">/// same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleSet</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, toggles: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(toggles.bit_length == self.bit_length);
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
            mask.* ^= toggles.masks[i];
        }
    }

    <span class="tok-comment">/// Flips every bit in the bit set.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleAll</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> bit_length = self.bit_length;<span class="tok-comment">
        // avoid underflow if bit_length is zero
        </span><span class="tok-kw">if</span> (bit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks]) |*mask| {
            mask.* = ~mask.*;
        }

        <span class="tok-kw">const</span> padding_bits = num_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - bit_length;
        <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
        self.masks[num_masks - <span class="tok-number">1</span>] &amp;= last_item_mask;
    }

    <span class="tok-comment">/// Performs a union of two bit sets, and stores the</span>
    <span class="tok-comment">/// result in the first one.  Bits in the result are</span>
    <span class="tok-comment">/// set if the corresponding bits were set in either input.</span>
    <span class="tok-comment">/// The two sets must both be the same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(other.bit_length == self.bit_length);
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
            mask.* |= other.masks[i];
        }
    }

    <span class="tok-comment">/// Performs an intersection of two bit sets, and stores</span>
    <span class="tok-comment">/// the result in the first one.  Bits in the result are</span>
    <span class="tok-comment">/// set if the corresponding bits were set in both inputs.</span>
    <span class="tok-comment">/// The two sets must both be the same bit_length.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIntersection</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(other.bit_length == self.bit_length);
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">for</span> (self.masks[<span class="tok-number">0</span>..num_masks], <span class="tok-number">0</span>..) |*mask, i| {
            mask.* &amp;= other.masks[i];
        }
    }

    <span class="tok-comment">/// Finds the index of the first set bit.</span>
    <span class="tok-comment">/// If no bits are set, returns null.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findFirstSet</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> mask = self.masks;
        <span class="tok-kw">while</span> (offset &lt; self.bit_length) {
            <span class="tok-kw">if</span> (mask[<span class="tok-number">0</span>] != <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            mask += <span class="tok-number">1</span>;
            offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> offset + <span class="tok-builtin">@ctz</span>(mask[<span class="tok-number">0</span>]);
    }

    <span class="tok-comment">/// Finds the index of the first set bit, and unsets it.</span>
    <span class="tok-comment">/// If no bits are set, returns null.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toggleFirstSet</span>(self: *<a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> mask = self.masks;
        <span class="tok-kw">while</span> (offset &lt; self.bit_length) {
            <span class="tok-kw">if</span> (mask[<span class="tok-number">0</span>] != <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            mask += <span class="tok-number">1</span>;
            offset += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> index = <span class="tok-builtin">@ctz</span>(mask[<span class="tok-number">0</span>]);
        mask[<span class="tok-number">0</span>] &amp;= (mask[<span class="tok-number">0</span>] - <span class="tok-number">1</span>);
        <span class="tok-kw">return</span> offset + index;
    }

    <span class="tok-comment">/// Returns true iff every corresponding bit in both</span>
    <span class="tok-comment">/// bit sets are the same.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (self.masks[i] != other.masks[i]) {
                <span class="tok-kw">break</span> <span class="tok-null">false</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Returns true iff the first bit set is the subset</span>
    <span class="tok-comment">/// of the second one.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subsetOf</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (self.masks[i] &amp; other.masks[i] != self.masks[i]) {
                <span class="tok-kw">break</span> <span class="tok-null">false</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Returns true iff the first bit set is the superset</span>
    <span class="tok-comment">/// of the second one.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supersetOf</span>(self: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, other: <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.bit_length != other.bit_length) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; num_masks) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (self.masks[i] &amp; other.masks[i] != other.masks[i]) {
                <span class="tok-kw">break</span> <span class="tok-null">false</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Iterates through the items in the set, according to the options.</span>
    <span class="tok-comment">/// The default options (.{}) will iterate indices of set bits in</span>
    <span class="tok-comment">/// ascending order.  Modifications to the underlying bit set may</span>
    <span class="tok-comment">/// or may not be observed by the iterator.  Resizing the underlying</span>
    <span class="tok-comment">/// bit set invalidates the iterator.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html">Self</a>, <span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>(options) {
        <span class="tok-kw">const</span> num_masks = <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.numMasks">numMasks</a>(self.bit_length);
        <span class="tok-kw">const</span> padding_bits = num_masks * <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - self.bit_length;
        <span class="tok-kw">const</span> last_item_mask = (~<span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">0</span>)) &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(padding_bits));
        <span class="tok-kw">return</span> <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.Iterator">Iterator</a>(options).init(self.masks[<span class="tok-number">0</span>..num_masks], last_item_mask);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> options: <a href="std.bit_set.IteratorOptions.html">IteratorOptions</a>) <span class="tok-type">type</span> {
        <span class="tok-kw">return</span> <a href="std.bit_set.html#std.bit_set.BitSetIterator">BitSetIterator</a>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, options);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">maskBit</span>(index: <span class="tok-type">usize</span>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@truncate</span>(index));
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">maskIndex</span>(index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> index &gt;&gt; <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>);
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">boolMaskBit</span>(index: <span class="tok-type">usize</span>, value: <span class="tok-type">bool</span>) <a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>, <span class="tok-builtin">@intFromBool</span>(value)) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.ShiftInt">ShiftInt</a>, <span class="tok-builtin">@intCast</span>(index));
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">numMasks</span>(bit_length: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> (bit_length + (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>) - <span class="tok-number">1</span>)) / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.bit_set.DynamicBitSetUnmanaged.html#std.bit_set.DynamicBitSetUnmanaged.MaskInt">MaskInt</a>);
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
