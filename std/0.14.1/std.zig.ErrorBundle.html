<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.ErrorBundle.html" class="active">ErrorBundle</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.ErrorBundle" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zig.ErrorBundle</span><a href="#src.zig-std.zig.ErrorBundle">[src]</a></h1><div class="tldDocs"><p>To support incremental compilation, errors are stored in various places
so that they can be created and destroyed appropriately. This structure
is used to collect all the errors from the various places into one
convenient place for API users to consume.</p>
<p>There is one special encoding for this data structure. If both arrays are
empty, it means there are no errors. This special encoding exists so that
heap allocation is not needed in the common case of no errors.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.zig.ErrorBundle.MessageIndex.html">std.zig.ErrorBundle.MessageIndex</a></li><li><a href="std.zig.ErrorBundle.SourceLocationIndex.html">std.zig.ErrorBundle.SourceLocationIndex</a></li><li><a href="std.zig.ErrorBundle.ErrorMessageList.html">std.zig.ErrorBundle.ErrorMessageList</a></li><li><a href="std.zig.ErrorBundle.SourceLocation.html">std.zig.ErrorBundle.SourceLocation</a></li><li><a href="std.zig.ErrorBundle.ErrorMessage.html">std.zig.ErrorBundle.ErrorMessage</a></li><li><a href="std.zig.ErrorBundle.ReferenceTrace.html">std.zig.ErrorBundle.ReferenceTrace</a></li><li><a href="std.zig.ErrorBundle.RenderOptions.html">std.zig.ErrorBundle.RenderOptions</a></li><li><a href="std.zig.ErrorBundle.Wip.html">std.zig.ErrorBundle.Wip</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.zig.ErrorBundle.String" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">String</span><a href="#src.zig-std.zig.ErrorBundle.String">[src]</a></h2><div class="tldDocs"><p>Index into <code>string_bytes</code>.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.String">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> String = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.OptionalString" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">OptionalString</span><a href="#src.zig-std.zig.ErrorBundle.OptionalString">[src]</a></h2><div class="tldDocs"><p>Index into <code>string_bytes</code>, or null.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.OptionalString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OptionalString = <span class="tok-type">u32</span></code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>string_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>extra: []<span class="tok-kw">const</span> <span class="tok-type">u32</span></code></pre><div class="fieldDocs"><p>The first thing in this array is an <code><a href="std.zig.ErrorBundle.ErrorMessageList.html">ErrorMessageList</a></code>.</p>
</div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.zig.ErrorBundle.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.zig.ErrorBundle.empty">[src]</a></h2><div class="tldDocs"><p>Special encoding when there are no errors.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.empty">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.zig.ErrorBundle.html">ErrorBundle</a> = .{
    .string_bytes = &amp;.{},
    .extra = &amp;.{},
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.zig.ErrorBundle.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.zig.ErrorBundle.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(eb: *<a href="std.zig.ErrorBundle.html">ErrorBundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: *<a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(eb: *<a href="std.zig.ErrorBundle.html">ErrorBundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    gpa.free(eb.string_bytes);
    gpa.free(eb.extra);
    eb.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.errorMessageCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">errorMessageCount</span><a href="#src.zig-std.zig.ErrorBundle.errorMessageCount">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorMessageCount</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.errorMessageCount">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorMessageCount</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (eb.extra.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> eb.getErrorMessageList().len;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.getErrorMessageList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getErrorMessageList</span><a href="#src.zig-std.zig.ErrorBundle.getErrorMessageList">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getErrorMessageList</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) <a href="std.zig.ErrorBundle.ErrorMessageList.html">ErrorMessageList</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.getErrorMessageList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getErrorMessageList</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) <a href="std.zig.ErrorBundle.ErrorMessageList.html">ErrorMessageList</a> {
    <span class="tok-kw">return</span> eb.extraData(<a href="std.zig.ErrorBundle.ErrorMessageList.html">ErrorMessageList</a>, <span class="tok-number">0</span>).data;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.getMessages" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getMessages</span><a href="#src.zig-std.zig.ErrorBundle.getMessages">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMessages</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) []<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.getMessages">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMessages</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) []<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> {
    <span class="tok-kw">const</span> list = eb.getErrorMessageList();
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>, <span class="tok-builtin">@ptrCast</span>(eb.extra[list.start..][<span class="tok-number">0</span>..list.len]));
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.getErrorMessage" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getErrorMessage</span><a href="#src.zig-std.zig.ErrorBundle.getErrorMessage">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getErrorMessage</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>) <a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div><div><pre><code>index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.getErrorMessage">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getErrorMessage</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>) <a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a> {
    <span class="tok-kw">return</span> eb.extraData(<a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>, <span class="tok-builtin">@intFromEnum</span>(index)).data;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.getSourceLocation" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getSourceLocation</span><a href="#src.zig-std.zig.ErrorBundle.getSourceLocation">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSourceLocation</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a>) <a href="std.zig.ErrorBundle.SourceLocation.html">SourceLocation</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div><div><pre><code>index: <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.getSourceLocation">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSourceLocation</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a>) <a href="std.zig.ErrorBundle.SourceLocation.html">SourceLocation</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index != .none);
    <span class="tok-kw">return</span> eb.extraData(<a href="std.zig.ErrorBundle.SourceLocation.html">SourceLocation</a>, <span class="tok-builtin">@intFromEnum</span>(index)).data;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.getNotes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getNotes</span><a href="#src.zig-std.zig.ErrorBundle.getNotes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getNotes</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>) []<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div><div><pre><code>index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.getNotes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getNotes</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>) []<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> {
    <span class="tok-kw">const</span> notes_len = eb.getErrorMessage(index).notes_len;
    <span class="tok-kw">const</span> start = <span class="tok-builtin">@intFromEnum</span>(index) + <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>).@&quot;struct&quot;.fields.len;
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>, <span class="tok-builtin">@ptrCast</span>(eb.extra[start..][<span class="tok-number">0</span>..notes_len]));
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.getCompileLogOutput" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getCompileLogOutput</span><a href="#src.zig-std.zig.ErrorBundle.getCompileLogOutput">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCompileLogOutput</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.getCompileLogOutput">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCompileLogOutput</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.nullTerminatedString">nullTerminatedString</a>(eb, <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.getErrorMessageList">getErrorMessageList</a>(eb).compile_log_text);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.nullTerminatedString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nullTerminatedString</span><a href="#src.zig-std.zig.ErrorBundle.nullTerminatedString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullTerminatedString</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Given an index into <code>string_bytes</code> returns the null-terminated string found there.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div><div><pre><code>index: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.nullTerminatedString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullTerminatedString</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> string_bytes = eb.string_bytes;
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = index;
    <span class="tok-kw">while</span> (string_bytes[end] != <span class="tok-number">0</span>) {
        end += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> string_bytes[index..end :<span class="tok-number">0</span>];
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.renderToStdErr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renderToStdErr</span><a href="#src.zig-std.zig.ErrorBundle.renderToStdErr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToStdErr</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div><div><pre><code>options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.renderToStdErr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToStdErr</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a>) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
    <span class="tok-kw">defer</span> <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();
    <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();
    <span class="tok-kw">return</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.renderToWriter">renderToWriter</a>(eb, options, stderr.writer()) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.ErrorBundle.renderToWriter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renderToWriter</span><a href="#src.zig-std.zig.ErrorBundle.renderToWriter">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToWriter</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a>, writer: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a></code></pre></div><div><pre><code>options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.ErrorBundle.renderToWriter">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToWriter</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a>, writer: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (eb.extra.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">for</span> (eb.getMessages()) |err_msg| {
        <span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.renderErrorMessageToWriter">renderErrorMessageToWriter</a>(eb, options, err_msg, writer, <span class="tok-str">&quot;error&quot;</span>, .red, <span class="tok-number">0</span>);
    }

    <span class="tok-kw">if</span> (options.include_log_text) {
        <span class="tok-kw">const</span> log_text = eb.getCompileLogOutput();
        <span class="tok-kw">if</span> (log_text.len != <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\nCompile Log Output:\n&quot;</span>);
            <span class="tok-kw">try</span> writer.writeAll(log_text);
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.ErrorBundle">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! To support incremental compilation, errors are stored in various places</span>
<span class="tok-comment">//! so that they can be created and destroyed appropriately. This structure</span>
<span class="tok-comment">//! is used to collect all the errors from the various places into one</span>
<span class="tok-comment">//! convenient place for API users to consume.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! There is one special encoding for this data structure. If both arrays are</span>
<span class="tok-comment">//! empty, it means there are no errors. This special encoding exists so that</span>
<span class="tok-comment">//! heap allocation is not needed in the common case of no errors.</span>

string_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
<span class="tok-comment">/// The first thing in this array is an `ErrorMessageList`.</span>
extra: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,

<span class="tok-comment">/// Index into `string_bytes`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> String = <span class="tok-type">u32</span>;
<span class="tok-comment">/// Index into `string_bytes`, or null.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OptionalString = <span class="tok-type">u32</span>;

<span class="tok-comment">/// Special encoding when there are no errors.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.zig.ErrorBundle.html">ErrorBundle</a> = .{
    .string_bytes = &amp;.{},
    .extra = &amp;.{},
};<span class="tok-comment">

// An index into `extra` pointing at an `ErrorMessage`.
</span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MessageIndex = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    _,
};<span class="tok-comment">

// An index into `extra` pointing at an `SourceLocation`.
</span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SourceLocationIndex = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    none = <span class="tok-number">0</span>,
    _,
};

<span class="tok-comment">/// There will be a MessageIndex for each len at start.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorMessageList = <span class="tok-kw">struct</span> {
    len: <span class="tok-type">u32</span>,
    start: <span class="tok-type">u32</span>,
    <span class="tok-comment">/// null-terminated string index. 0 means no compile log text.</span>
    compile_log_text: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.OptionalString">OptionalString</a>,
};

<span class="tok-comment">/// Trailing:</span>
<span class="tok-comment">/// * ReferenceTrace for each reference_trace_len</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SourceLocation = <span class="tok-kw">struct</span> {
    src_path: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a>,
    line: <span class="tok-type">u32</span>,
    column: <span class="tok-type">u32</span>,
    <span class="tok-comment">/// byte offset of starting token</span>
    span_start: <span class="tok-type">u32</span>,
    <span class="tok-comment">/// byte offset of main error location</span>
    span_main: <span class="tok-type">u32</span>,
    <span class="tok-comment">/// byte offset of end of last token</span>
    span_end: <span class="tok-type">u32</span>,
    <span class="tok-comment">/// Does not include the trailing newline.</span>
    source_line: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.OptionalString">OptionalString</a> = <span class="tok-number">0</span>,
    reference_trace_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
};

<span class="tok-comment">/// Trailing:</span>
<span class="tok-comment">/// * MessageIndex for each notes_len.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorMessage = <span class="tok-kw">struct</span> {
    msg: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a>,
    <span class="tok-comment">/// Usually one, but incremented for redundant messages.</span>
    count: <span class="tok-type">u32</span> = <span class="tok-number">1</span>,
    src_loc: <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a> = .none,
    notes_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReferenceTrace = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// null terminated string index</span>
    <span class="tok-comment">/// Except for the sentinel ReferenceTrace element, in which case:</span>
    <span class="tok-comment">/// * 0 means remaining references hidden</span>
    <span class="tok-comment">/// * &gt;0 means N references hidden</span>
    decl_name: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a>,
    <span class="tok-comment">/// Index into extra of a SourceLocation</span>
    <span class="tok-comment">/// If this is 0, this is the sentinel ReferenceTrace element.</span>
    src_loc: <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(eb: *<a href="std.zig.ErrorBundle.html">ErrorBundle</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    gpa.free(eb.string_bytes);
    gpa.free(eb.extra);
    eb.* = <span class="tok-null">undefined</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorMessageCount</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (eb.extra.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> eb.getErrorMessageList().len;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getErrorMessageList</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) <a href="std.zig.ErrorBundle.ErrorMessageList.html">ErrorMessageList</a> {
    <span class="tok-kw">return</span> eb.extraData(<a href="std.zig.ErrorBundle.ErrorMessageList.html">ErrorMessageList</a>, <span class="tok-number">0</span>).data;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMessages</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) []<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> {
    <span class="tok-kw">const</span> list = eb.getErrorMessageList();
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>, <span class="tok-builtin">@ptrCast</span>(eb.extra[list.start..][<span class="tok-number">0</span>..list.len]));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getErrorMessage</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>) <a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a> {
    <span class="tok-kw">return</span> eb.extraData(<a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>, <span class="tok-builtin">@intFromEnum</span>(index)).data;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSourceLocation</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a>) <a href="std.zig.ErrorBundle.SourceLocation.html">SourceLocation</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(index != .none);
    <span class="tok-kw">return</span> eb.extraData(<a href="std.zig.ErrorBundle.SourceLocation.html">SourceLocation</a>, <span class="tok-builtin">@intFromEnum</span>(index)).data;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getNotes</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>) []<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> {
    <span class="tok-kw">const</span> notes_len = eb.getErrorMessage(index).notes_len;
    <span class="tok-kw">const</span> start = <span class="tok-builtin">@intFromEnum</span>(index) + <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>).@&quot;struct&quot;.fields.len;
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>, <span class="tok-builtin">@ptrCast</span>(eb.extra[start..][<span class="tok-number">0</span>..notes_len]));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCompileLogOutput</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.nullTerminatedString">nullTerminatedString</a>(eb, <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.getErrorMessageList">getErrorMessageList</a>(eb).compile_log_text);
}

<span class="tok-comment">/// Returns the requested data, as well as the new index which is at the start of the</span>
<span class="tok-comment">/// trailers for the object.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">extraData</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, index: <span class="tok-type">usize</span>) <span class="tok-kw">struct</span> { data: T, end: <span class="tok-type">usize</span> } {
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = index;
    <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {
        <span class="tok-builtin">@field</span>(result, field.name) = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
            <span class="tok-type">u32</span> =&gt; eb.extra[i],
            <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> =&gt; <span class="tok-builtin">@as</span>(<a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>, <span class="tok-builtin">@enumFromInt</span>(eb.extra[i])),
            <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a> =&gt; <span class="tok-builtin">@as</span>(<a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a>, <span class="tok-builtin">@enumFromInt</span>(eb.extra[i])),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type&quot;</span>),
        };
        i += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> .{
        .data = result,
        .end = i,
    };
}

<span class="tok-comment">/// Given an index into `string_bytes` returns the null-terminated string found there.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullTerminatedString</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, index: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> string_bytes = eb.string_bytes;
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = index;
    <span class="tok-kw">while</span> (string_bytes[end] != <span class="tok-number">0</span>) {
        end += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> string_bytes[index..end :<span class="tok-number">0</span>];
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenderOptions = <span class="tok-kw">struct</span> {
    ttyconf: <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>,
    include_reference_trace: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    include_source_line: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    include_log_text: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToStdErr</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a>) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
    <span class="tok-kw">defer</span> <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();
    <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();
    <span class="tok-kw">return</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.renderToWriter">renderToWriter</a>(eb, options, stderr.writer()) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToWriter</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a>, writer: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (eb.extra.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">for</span> (eb.getMessages()) |err_msg| {
        <span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.renderErrorMessageToWriter">renderErrorMessageToWriter</a>(eb, options, err_msg, writer, <span class="tok-str">&quot;error&quot;</span>, .red, <span class="tok-number">0</span>);
    }

    <span class="tok-kw">if</span> (options.include_log_text) {
        <span class="tok-kw">const</span> log_text = eb.getCompileLogOutput();
        <span class="tok-kw">if</span> (log_text.len != <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\nCompile Log Output:\n&quot;</span>);
            <span class="tok-kw">try</span> writer.writeAll(log_text);
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">renderErrorMessageToWriter</span>(
    eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>,
    options: <a href="std.zig.ErrorBundle.RenderOptions.html">RenderOptions</a>,
    err_msg_index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>,
    stderr: <span class="tok-kw">anytype</span>,
    kind: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    color: <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Color.html">Color</a>,
    indent: <span class="tok-type">usize</span>,
) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> ttyconf = options.ttyconf;
    <span class="tok-kw">var</span> counting_writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.counting_writer.html#std.io.counting_writer.countingWriter">countingWriter</a>(stderr);
    <span class="tok-kw">const</span> counting_stderr = counting_writer.writer();
    <span class="tok-kw">const</span> err_msg = eb.getErrorMessage(err_msg_index);
    <span class="tok-kw">if</span> (err_msg.src_loc != .none) {
        <span class="tok-kw">const</span> src = eb.extraData(<a href="std.zig.ErrorBundle.SourceLocation.html">SourceLocation</a>, <span class="tok-builtin">@intFromEnum</span>(err_msg.src_loc));
        <span class="tok-kw">try</span> counting_stderr.writeByteNTimes(<span class="tok-str">' '</span>, indent);
        <span class="tok-kw">try</span> ttyconf.setColor(stderr, .bold);
        <span class="tok-kw">try</span> counting_stderr.print(<span class="tok-str">&quot;{s}:{d}:{d}: &quot;</span>, .{
            eb.nullTerminatedString(src.data.src_path),
            src.data.line + <span class="tok-number">1</span>,
            src.data.column + <span class="tok-number">1</span>,
        });
        <span class="tok-kw">try</span> ttyconf.setColor(stderr, color);
        <span class="tok-kw">try</span> counting_stderr.writeAll(kind);
        <span class="tok-kw">try</span> counting_stderr.writeAll(<span class="tok-str">&quot;: &quot;</span>);<span class="tok-comment">
        // This is the length of the part before the error message:
        // e.g. &quot;file.zig:4:5: error: &quot;
        </span><span class="tok-kw">const</span> prefix_len: <span class="tok-type">usize</span> = <span class="tok-builtin">@intCast</span>(counting_stderr.context.bytes_written);
        <span class="tok-kw">try</span> ttyconf.setColor(stderr, .reset);
        <span class="tok-kw">try</span> ttyconf.setColor(stderr, .bold);
        <span class="tok-kw">if</span> (err_msg.count == <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.writeMsg">writeMsg</a>(eb, err_msg, stderr, prefix_len);
            <span class="tok-kw">try</span> stderr.writeByte(<span class="tok-str">'\n'</span>);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.writeMsg">writeMsg</a>(eb, err_msg, stderr, prefix_len);
            <span class="tok-kw">try</span> ttyconf.setColor(stderr, .dim);
            <span class="tok-kw">try</span> stderr.print(<span class="tok-str">&quot; ({d} times)\n&quot;</span>, .{err_msg.count});
        }
        <span class="tok-kw">try</span> ttyconf.setColor(stderr, .reset);
        <span class="tok-kw">if</span> (src.data.source_line != <span class="tok-number">0</span> <span class="tok-kw">and</span> options.include_source_line) {
            <span class="tok-kw">const</span> line = eb.nullTerminatedString(src.data.source_line);
            <span class="tok-kw">for</span> (line) |b| <span class="tok-kw">switch</span> (b) {
                <span class="tok-str">'\t'</span> =&gt; <span class="tok-kw">try</span> stderr.writeByte(<span class="tok-str">' '</span>),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> stderr.writeByte(b),
            };
            <span class="tok-kw">try</span> stderr.writeByte(<span class="tok-str">'\n'</span>);<span class="tok-comment">
            // TODO basic unicode code point monospace width
            </span><span class="tok-kw">const</span> before_caret = src.data.span_main - src.data.span_start;<span class="tok-comment">
            // -1 since span.main includes the caret
            </span><span class="tok-kw">const</span> after_caret = src.data.span_end -| src.data.span_main -| <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> stderr.writeByteNTimes(<span class="tok-str">' '</span>, src.data.column - before_caret);
            <span class="tok-kw">try</span> ttyconf.setColor(stderr, .green);
            <span class="tok-kw">try</span> stderr.writeByteNTimes(<span class="tok-str">'~'</span>, before_caret);
            <span class="tok-kw">try</span> stderr.writeByte(<span class="tok-str">'^'</span>);
            <span class="tok-kw">try</span> stderr.writeByteNTimes(<span class="tok-str">'~'</span>, after_caret);
            <span class="tok-kw">try</span> stderr.writeByte(<span class="tok-str">'\n'</span>);
            <span class="tok-kw">try</span> ttyconf.setColor(stderr, .reset);
        }
        <span class="tok-kw">for</span> (eb.getNotes(err_msg_index)) |note| {
            <span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.renderErrorMessageToWriter">renderErrorMessageToWriter</a>(eb, options, note, stderr, <span class="tok-str">&quot;note&quot;</span>, .cyan, indent);
        }
        <span class="tok-kw">if</span> (src.data.reference_trace_len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> options.include_reference_trace) {
            <span class="tok-kw">try</span> ttyconf.setColor(stderr, .reset);
            <span class="tok-kw">try</span> ttyconf.setColor(stderr, .dim);
            <span class="tok-kw">try</span> stderr.print(<span class="tok-str">&quot;referenced by:\n&quot;</span>, .{});
            <span class="tok-kw">var</span> ref_index = src.end;
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..src.data.reference_trace_len) |_| {
                <span class="tok-kw">const</span> ref_trace = eb.extraData(<a href="std.zig.ErrorBundle.ReferenceTrace.html">ReferenceTrace</a>, ref_index);
                ref_index = ref_trace.end;
                <span class="tok-kw">if</span> (ref_trace.data.src_loc != .none) {
                    <span class="tok-kw">const</span> ref_src = eb.getSourceLocation(ref_trace.data.src_loc);
                    <span class="tok-kw">try</span> stderr.print(<span class="tok-str">&quot;    {s}: {s}:{d}:{d}\n&quot;</span>, .{
                        eb.nullTerminatedString(ref_trace.data.decl_name),
                        eb.nullTerminatedString(ref_src.src_path),
                        ref_src.line + <span class="tok-number">1</span>,
                        ref_src.column + <span class="tok-number">1</span>,
                    });
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (ref_trace.data.decl_name != <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> count = ref_trace.data.decl_name;
                    <span class="tok-kw">try</span> stderr.print(
                        <span class="tok-str">&quot;    {d} reference(s) hidden; use '-freference-trace={d}' to see all references\n&quot;</span>,
                        .{ count, count + src.data.reference_trace_len - <span class="tok-number">1</span> },
                    );
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">try</span> stderr.print(
                        <span class="tok-str">&quot;    remaining reference traces hidden; use '-freference-trace' to see all reference traces\n&quot;</span>,
                        .{},
                    );
                }
            }
            <span class="tok-kw">try</span> ttyconf.setColor(stderr, .reset);
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> ttyconf.setColor(stderr, color);
        <span class="tok-kw">try</span> stderr.writeByteNTimes(<span class="tok-str">' '</span>, indent);
        <span class="tok-kw">try</span> stderr.writeAll(kind);
        <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;: &quot;</span>);
        <span class="tok-kw">try</span> ttyconf.setColor(stderr, .reset);
        <span class="tok-kw">const</span> msg = eb.nullTerminatedString(err_msg.msg);
        <span class="tok-kw">if</span> (err_msg.count == <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{msg});
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> stderr.print(<span class="tok-str">&quot;{s}&quot;</span>, .{msg});
            <span class="tok-kw">try</span> ttyconf.setColor(stderr, .dim);
            <span class="tok-kw">try</span> stderr.print(<span class="tok-str">&quot; ({d} times)\n&quot;</span>, .{err_msg.count});
        }
        <span class="tok-kw">try</span> ttyconf.setColor(stderr, .reset);
        <span class="tok-kw">for</span> (eb.getNotes(err_msg_index)) |note| {
            <span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.renderErrorMessageToWriter">renderErrorMessageToWriter</a>(eb, options, note, stderr, <span class="tok-str">&quot;note&quot;</span>, .cyan, indent + <span class="tok-number">4</span>);
        }
    }
}

<span class="tok-comment">/// Splits the error message up into lines to properly indent them</span>
<span class="tok-comment">/// to allow for long, good-looking error messages.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This is used to split the message in `@compileError(&quot;hello\nworld&quot;)` for example.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">writeMsg</span>(eb: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, err_msg: <a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>, stderr: <span class="tok-kw">anytype</span>, indent: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> lines = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, eb.nullTerminatedString(err_msg.msg), <span class="tok-str">'\n'</span>);
    <span class="tok-kw">while</span> (lines.next()) |line| {
        <span class="tok-kw">try</span> stderr.writeAll(line);
        <span class="tok-kw">if</span> (lines.index == <span class="tok-null">null</span>) <span class="tok-kw">break</span>;
        <span class="tok-kw">try</span> stderr.writeByte(<span class="tok-str">'\n'</span>);
        <span class="tok-kw">try</span> stderr.writeByteNTimes(<span class="tok-str">' '</span>, indent);
    }
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> ErrorBundle = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Wip = <span class="tok-kw">struct</span> {
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    string_bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
    <span class="tok-comment">/// The first thing in this array is a ErrorMessageList.</span>
    extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
    root_list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>),

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-type">void</span> {
        wip.* = .{
            .gpa = gpa,
            .string_bytes = .{},
            .extra = .{},
            .root_list = .{},
        };<span class="tok-comment">

        // So that 0 can be used to indicate a null string.
        </span><span class="tok-kw">try</span> wip.string_bytes.append(gpa, <span class="tok-number">0</span>);

        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-number">0</span> == <span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.Wip.html#std.zig.ErrorBundle.Wip.addExtra">addExtra</a>(wip, <a href="std.zig.ErrorBundle.ErrorMessageList.html">ErrorMessageList</a>{
            .len = <span class="tok-number">0</span>,
            .start = <span class="tok-number">0</span>,
            .compile_log_text = <span class="tok-number">0</span>,
        }));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> gpa = wip.gpa;
        wip.root_list.deinit(gpa);
        wip.string_bytes.deinit(gpa);
        wip.extra.deinit(gpa);
        wip.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedBundle</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, compile_log_text: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.zig.ErrorBundle.html">ErrorBundle</a> {
        <span class="tok-kw">const</span> gpa = wip.gpa;
        <span class="tok-kw">if</span> (wip.root_list.items.len == <span class="tok-number">0</span>) {
            <a href="std.debug.html#std.debug.assert">assert</a>(compile_log_text.len == <span class="tok-number">0</span>);<span class="tok-comment">
            // Special encoding when there are no errors.
            </span>wip.deinit();
            wip.* = .{
                .gpa = gpa,
                .string_bytes = .{},
                .extra = .{},
                .root_list = .{},
            };
            <span class="tok-kw">return</span> <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.empty">empty</a>;
        }

        <span class="tok-kw">const</span> compile_log_str_index = <span class="tok-kw">if</span> (compile_log_text.len == <span class="tok-number">0</span>) <span class="tok-number">0</span> <span class="tok-kw">else</span> str: {
            <span class="tok-kw">const</span> str: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(wip.string_bytes.items.len);
            <span class="tok-kw">try</span> wip.string_bytes.ensureUnusedCapacity(gpa, compile_log_text.len + <span class="tok-number">1</span>);
            wip.string_bytes.appendSliceAssumeCapacity(compile_log_text);
            wip.string_bytes.appendAssumeCapacity(<span class="tok-number">0</span>);
            <span class="tok-kw">break</span> :str str;
        };

        wip.setExtra(<span class="tok-number">0</span>, <a href="std.zig.ErrorBundle.ErrorMessageList.html">ErrorMessageList</a>{
            .len = <span class="tok-builtin">@intCast</span>(wip.root_list.items.len),
            .start = <span class="tok-builtin">@intCast</span>(wip.extra.items.len),
            .compile_log_text = compile_log_str_index,
        });
        <span class="tok-kw">try</span> wip.extra.appendSlice(gpa, <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(wip.root_list.items)));
        wip.root_list.clearAndFree(gpa);
        <span class="tok-kw">return</span> .{
            .string_bytes = <span class="tok-kw">try</span> wip.string_bytes.toOwnedSlice(gpa),
            .extra = <span class="tok-kw">try</span> wip.extra.toOwnedSlice(gpa),
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tmpBundle</span>(wip: <a href="std.zig.ErrorBundle.Wip.html">Wip</a>) <a href="std.zig.ErrorBundle.html">ErrorBundle</a> {
        <span class="tok-kw">return</span> .{
            .string_bytes = wip.string_bytes.items,
            .extra = wip.extra.items,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addString</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a> {
        <span class="tok-kw">const</span> gpa = wip.gpa;
        <span class="tok-kw">const</span> index: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a> = <span class="tok-builtin">@intCast</span>(wip.string_bytes.items.len);
        <span class="tok-kw">try</span> wip.string_bytes.ensureUnusedCapacity(gpa, s.len + <span class="tok-number">1</span>);
        wip.string_bytes.appendSliceAssumeCapacity(s);
        wip.string_bytes.appendAssumeCapacity(<span class="tok-number">0</span>);
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printString</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a> {
        <span class="tok-kw">const</span> gpa = wip.gpa;
        <span class="tok-kw">const</span> index: <a href="std.zig.ErrorBundle.html#std.zig.ErrorBundle.String">String</a> = <span class="tok-builtin">@intCast</span>(wip.string_bytes.items.len);
        <span class="tok-kw">try</span> wip.string_bytes.writer(gpa).print(fmt, args);
        <span class="tok-kw">try</span> wip.string_bytes.append(gpa, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRootErrorMessage</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, em: <a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> wip.root_list.ensureUnusedCapacity(wip.gpa, <span class="tok-number">1</span>);
        wip.root_list.appendAssumeCapacity(<span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.Wip.html#std.zig.ErrorBundle.Wip.addErrorMessage">addErrorMessage</a>(wip, em));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addErrorMessage</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, em: <a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.Wip.html#std.zig.ErrorBundle.Wip.addExtra">addExtra</a>(wip, em));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addErrorMessageAssumeCapacity</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, em: <a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>) <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<a href="std.zig.ErrorBundle.Wip.html#std.zig.ErrorBundle.Wip.addExtraAssumeCapacity">addExtraAssumeCapacity</a>(wip, em));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSourceLocation</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, sl: <a href="std.zig.ErrorBundle.SourceLocation.html">SourceLocation</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.Wip.html#std.zig.ErrorBundle.Wip.addExtra">addExtra</a>(wip, sl));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addReferenceTrace</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, rt: <a href="std.zig.ErrorBundle.ReferenceTrace.html">ReferenceTrace</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        _ = <span class="tok-kw">try</span> <a href="std.zig.ErrorBundle.Wip.html#std.zig.ErrorBundle.Wip.addExtra">addExtra</a>(wip, rt);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addBundleAsNotes</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, other: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> gpa = wip.gpa;

        <span class="tok-kw">try</span> wip.string_bytes.ensureUnusedCapacity(gpa, other.string_bytes.len);
        <span class="tok-kw">try</span> wip.extra.ensureUnusedCapacity(gpa, other.extra.len);

        <span class="tok-kw">const</span> other_list = other.getMessages();<span class="tok-comment">

        // The ensureUnusedCapacity call above guarantees this.
        </span><span class="tok-kw">const</span> notes_start = wip.reserveNotes(<span class="tok-builtin">@intCast</span>(other_list.len)) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        <span class="tok-kw">for</span> (notes_start.., other_list) |note, message| {<span class="tok-comment">
            // This line can cause `wip.extra.items` to be resized.
            </span><span class="tok-kw">const</span> note_index = <span class="tok-builtin">@intFromEnum</span>(wip.addOtherMessage(other, message) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
            wip.extra.items[note] = note_index;
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addBundleAsRoots</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, other: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> gpa = wip.gpa;

        <span class="tok-kw">try</span> wip.string_bytes.ensureUnusedCapacity(gpa, other.string_bytes.len);
        <span class="tok-kw">try</span> wip.extra.ensureUnusedCapacity(gpa, other.extra.len);

        <span class="tok-kw">const</span> other_list = other.getMessages();

        <span class="tok-kw">try</span> wip.root_list.ensureUnusedCapacity(gpa, other_list.len);
        <span class="tok-kw">for</span> (other_list) |other_msg| {<span class="tok-comment">
            // The ensureUnusedCapacity calls above guarantees this.
            </span>wip.root_list.appendAssumeCapacity(wip.addOtherMessage(other, other_msg) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reserveNotes</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, notes_len: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span> {
        <span class="tok-kw">try</span> wip.extra.ensureUnusedCapacity(wip.gpa, notes_len +
            notes_len * <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.ErrorBundle.html">ErrorBundle</a>.<a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>).@&quot;struct&quot;.fields.len);
        wip.extra.items.len += notes_len;
        <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(wip.extra.items.len - notes_len);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addZirErrorMessages</span>(
        eb: *<a href="std.zig.ErrorBundle.html">ErrorBundle</a>.<a href="std.zig.ErrorBundle.Wip.html">Wip</a>,
        zir: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Zir.html">Zir</a>,
        tree: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>,
        source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> Zir = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Zir.html">Zir</a>;
        <span class="tok-kw">const</span> payload_index = zir.extra[<span class="tok-builtin">@intFromEnum</span>(Zir.ExtraIndex.compile_errors)];
        <a href="std.debug.html#std.debug.assert">assert</a>(payload_index != <span class="tok-number">0</span>);

        <span class="tok-kw">const</span> header = zir.extraData(Zir.Inst.CompileErrors, payload_index);
        <span class="tok-kw">const</span> items_len = header.data.items_len;
        <span class="tok-kw">var</span> extra_index = header.end;
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..items_len) |_| {
            <span class="tok-kw">const</span> item = zir.extraData(Zir.Inst.CompileErrors.Item, extra_index);
            extra_index = item.end;
            <span class="tok-kw">const</span> err_span = blk: {
                <span class="tok-kw">if</span> (item.data.node != <span class="tok-number">0</span>) {
                    <span class="tok-kw">break</span> :blk tree.nodeToSpan(item.data.node);
                }
                <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
                <span class="tok-kw">const</span> start = token_starts[item.data.token] + item.data.byte_offset;
                <span class="tok-kw">const</span> end = start + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(tree.tokenSlice(item.data.token).len)) - item.data.byte_offset;
                <span class="tok-kw">break</span> :blk <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Span.html">Span</a>{ .start = start, .end = end, .main = start };
            };
            <span class="tok-kw">const</span> err_loc = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.findLineColumn">findLineColumn</a>(source, err_span.main);

            {
                <span class="tok-kw">const</span> msg = zir.nullTerminatedString(item.data.msg);
                <span class="tok-kw">try</span> eb.addRootErrorMessage(.{
                    .msg = <span class="tok-kw">try</span> eb.addString(msg),
                    .src_loc = <span class="tok-kw">try</span> eb.addSourceLocation(.{
                        .src_path = <span class="tok-kw">try</span> eb.addString(src_path),
                        .span_start = err_span.start,
                        .span_main = err_span.main,
                        .span_end = err_span.end,
                        .line = <span class="tok-builtin">@intCast</span>(err_loc.line),
                        .column = <span class="tok-builtin">@intCast</span>(err_loc.column),
                        .source_line = <span class="tok-kw">try</span> eb.addString(err_loc.source_line),
                    }),
                    .notes_len = item.data.notesLen(zir),
                });
            }

            <span class="tok-kw">if</span> (item.data.notes != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> notes_start = <span class="tok-kw">try</span> eb.reserveNotes(item.data.notesLen(zir));
                <span class="tok-kw">const</span> block = zir.extraData(Zir.Inst.Block, item.data.notes);
                <span class="tok-kw">const</span> body = zir.extra[block.end..][<span class="tok-number">0</span>..block.data.body_len];
                <span class="tok-kw">for</span> (notes_start.., body) |note_i, body_elem| {
                    <span class="tok-kw">const</span> note_item = zir.extraData(Zir.Inst.CompileErrors.Item, body_elem);
                    <span class="tok-kw">const</span> msg = zir.nullTerminatedString(note_item.data.msg);
                    <span class="tok-kw">const</span> span = blk: {
                        <span class="tok-kw">if</span> (note_item.data.node != <span class="tok-number">0</span>) {
                            <span class="tok-kw">break</span> :blk tree.nodeToSpan(note_item.data.node);
                        }
                        <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
                        <span class="tok-kw">const</span> start = token_starts[note_item.data.token] + note_item.data.byte_offset;
                        <span class="tok-kw">const</span> end = start + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(tree.tokenSlice(note_item.data.token).len)) - item.data.byte_offset;
                        <span class="tok-kw">break</span> :blk <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Span.html">Span</a>{ .start = start, .end = end, .main = start };
                    };
                    <span class="tok-kw">const</span> loc = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.findLineColumn">findLineColumn</a>(source, span.main);<span class="tok-comment">

                    // This line can cause `wip.extra.items` to be resized.
                    </span><span class="tok-kw">const</span> note_index = <span class="tok-builtin">@intFromEnum</span>(<span class="tok-kw">try</span> eb.addErrorMessage(.{
                        .msg = <span class="tok-kw">try</span> eb.addString(msg),
                        .src_loc = <span class="tok-kw">try</span> eb.addSourceLocation(.{
                            .src_path = <span class="tok-kw">try</span> eb.addString(src_path),
                            .span_start = span.start,
                            .span_main = span.main,
                            .span_end = span.end,
                            .line = <span class="tok-builtin">@intCast</span>(loc.line),
                            .column = <span class="tok-builtin">@intCast</span>(loc.column),
                            .source_line = <span class="tok-kw">if</span> (loc.eql(err_loc))
                                <span class="tok-number">0</span>
                            <span class="tok-kw">else</span>
                                <span class="tok-kw">try</span> eb.addString(loc.source_line),
                        }),
                        .notes_len = <span class="tok-number">0</span>,<span class="tok-comment"> // TODO rework this function to be recursive
                    </span>}));
                    eb.extra.items[note_i] = note_index;
                }
            }
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addZoirErrorMessages</span>(
        eb: *<a href="std.zig.ErrorBundle.html">ErrorBundle</a>.<a href="std.zig.ErrorBundle.Wip.html">Wip</a>,
        zoir: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Zoir.html">Zoir</a>,
        tree: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>,
        source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(zoir.hasCompileErrors());

        <span class="tok-kw">for</span> (zoir.compile_errors) |err| {
            <span class="tok-kw">const</span> err_span: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Span.html">Span</a> = span: {
                <span class="tok-kw">if</span> (err.token == <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.CompileError.html">CompileError</a>.<a href="std.zig.Zoir.CompileError.html#std.zig.Zoir.CompileError.invalid_token">invalid_token</a>) {
                    <span class="tok-kw">break</span> :span tree.nodeToSpan(err.node_or_offset);
                }
                <span class="tok-kw">const</span> token_start = tree.tokens.items(.start)[err.token];
                <span class="tok-kw">const</span> start = token_start + err.node_or_offset;
                <span class="tok-kw">const</span> end = token_start + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(tree.tokenSlice(err.token).len));
                <span class="tok-kw">break</span> :span .{ .start = start, .end = end, .main = start };
            };
            <span class="tok-kw">const</span> err_loc = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.findLineColumn">findLineColumn</a>(source, err_span.main);

            <span class="tok-kw">try</span> eb.addRootErrorMessage(.{
                .msg = <span class="tok-kw">try</span> eb.addString(err.msg.get(zoir)),
                .src_loc = <span class="tok-kw">try</span> eb.addSourceLocation(.{
                    .src_path = <span class="tok-kw">try</span> eb.addString(src_path),
                    .span_start = err_span.start,
                    .span_main = err_span.main,
                    .span_end = err_span.end,
                    .line = <span class="tok-builtin">@intCast</span>(err_loc.line),
                    .column = <span class="tok-builtin">@intCast</span>(err_loc.column),
                    .source_line = <span class="tok-kw">try</span> eb.addString(err_loc.source_line),
                }),
                .notes_len = err.note_count,
            });

            <span class="tok-kw">const</span> notes_start = <span class="tok-kw">try</span> eb.reserveNotes(err.note_count);
            <span class="tok-kw">for</span> (notes_start.., err.first_note.., <span class="tok-number">0</span>..err.note_count) |eb_note_idx, zoir_note_idx, _| {
                <span class="tok-kw">const</span> note = zoir.error_notes[zoir_note_idx];
                <span class="tok-kw">const</span> note_span: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Span.html">Span</a> = span: {
                    <span class="tok-kw">if</span> (note.token == <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Zoir.html">Zoir</a>.<a href="std.zig.Zoir.CompileError.html">CompileError</a>.<a href="std.zig.Zoir.CompileError.html#std.zig.Zoir.CompileError.invalid_token">invalid_token</a>) {
                        <span class="tok-kw">break</span> :span tree.nodeToSpan(note.node_or_offset);
                    }
                    <span class="tok-kw">const</span> token_start = tree.tokens.items(.start)[note.token];
                    <span class="tok-kw">const</span> start = token_start + note.node_or_offset;
                    <span class="tok-kw">const</span> end = token_start + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(tree.tokenSlice(note.token).len));
                    <span class="tok-kw">break</span> :span .{ .start = start, .end = end, .main = start };
                };
                <span class="tok-kw">const</span> note_loc = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.findLineColumn">findLineColumn</a>(source, note_span.main);<span class="tok-comment">

                // This line can cause `wip.extra.items` to be resized.
                </span><span class="tok-kw">const</span> note_index = <span class="tok-builtin">@intFromEnum</span>(<span class="tok-kw">try</span> eb.addErrorMessage(.{
                    .msg = <span class="tok-kw">try</span> eb.addString(note.msg.get(zoir)),
                    .src_loc = <span class="tok-kw">try</span> eb.addSourceLocation(.{
                        .src_path = <span class="tok-kw">try</span> eb.addString(src_path),
                        .span_start = note_span.start,
                        .span_main = note_span.main,
                        .span_end = note_span.end,
                        .line = <span class="tok-builtin">@intCast</span>(note_loc.line),
                        .column = <span class="tok-builtin">@intCast</span>(note_loc.column),
                        .source_line = <span class="tok-kw">if</span> (note_loc.eql(err_loc))
                            <span class="tok-number">0</span>
                        <span class="tok-kw">else</span>
                            <span class="tok-kw">try</span> eb.addString(note_loc.source_line),
                    }),
                    .notes_len = <span class="tok-number">0</span>,
                }));
                eb.extra.items[eb_note_idx] = note_index;
            }
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addOtherMessage</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, other: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>, msg_index: <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a>) !<a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> {
        <span class="tok-kw">const</span> other_msg = other.getErrorMessage(msg_index);
        <span class="tok-kw">const</span> src_loc = <span class="tok-kw">try</span> wip.addOtherSourceLocation(other, other_msg.src_loc);
        <span class="tok-kw">const</span> msg = <span class="tok-kw">try</span> wip.addErrorMessage(.{
            .msg = <span class="tok-kw">try</span> wip.addString(other.nullTerminatedString(other_msg.msg)),
            .count = other_msg.count,
            .src_loc = src_loc,
            .notes_len = other_msg.notes_len,
        });
        <span class="tok-kw">const</span> notes_start = <span class="tok-kw">try</span> wip.reserveNotes(other_msg.notes_len);
        <span class="tok-kw">for</span> (notes_start.., other.getNotes(msg_index)) |note, other_note| {
            wip.extra.items[note] = <span class="tok-builtin">@intFromEnum</span>(<span class="tok-kw">try</span> wip.addOtherMessage(other, other_note));
        }
        <span class="tok-kw">return</span> msg;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addOtherSourceLocation</span>(
        wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>,
        other: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>,
        index: <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a>,
    ) !<a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a> {
        <span class="tok-kw">if</span> (index == .none) <span class="tok-kw">return</span> .none;
        <span class="tok-kw">const</span> other_sl = other.getSourceLocation(index);

        <span class="tok-kw">var</span> ref_traces: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.ErrorBundle.ReferenceTrace.html">ReferenceTrace</a>) = .empty;
        <span class="tok-kw">defer</span> ref_traces.deinit(wip.gpa);

        <span class="tok-kw">if</span> (other_sl.reference_trace_len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">var</span> ref_index = other.extraData(<a href="std.zig.ErrorBundle.SourceLocation.html">SourceLocation</a>, <span class="tok-builtin">@intFromEnum</span>(index)).end;
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..other_sl.reference_trace_len) |_| {
                <span class="tok-kw">const</span> other_ref_trace_ed = other.extraData(<a href="std.zig.ErrorBundle.ReferenceTrace.html">ReferenceTrace</a>, ref_index);
                <span class="tok-kw">const</span> other_ref_trace = other_ref_trace_ed.data;
                ref_index = other_ref_trace_ed.end;

                <span class="tok-kw">const</span> ref_trace: <a href="std.zig.ErrorBundle.ReferenceTrace.html">ReferenceTrace</a> = <span class="tok-kw">if</span> (other_ref_trace.src_loc == .none) .{<span class="tok-comment">
                    // sentinel ReferenceTrace does not store a string index in decl_name
                    </span>.decl_name = other_ref_trace.decl_name,
                    .src_loc = .none,
                } <span class="tok-kw">else</span> .{
                    .decl_name = <span class="tok-kw">try</span> wip.addString(other.nullTerminatedString(other_ref_trace.decl_name)),
                    .src_loc = <span class="tok-kw">try</span> wip.addOtherSourceLocation(other, other_ref_trace.src_loc),
                };
                <span class="tok-kw">try</span> ref_traces.append(wip.gpa, ref_trace);
            }
        }

        <span class="tok-kw">const</span> src_loc = <span class="tok-kw">try</span> wip.addSourceLocation(.{
            .src_path = <span class="tok-kw">try</span> wip.addString(other.nullTerminatedString(other_sl.src_path)),
            .line = other_sl.line,
            .column = other_sl.column,
            .span_start = other_sl.span_start,
            .span_main = other_sl.span_main,
            .span_end = other_sl.span_end,
            .source_line = <span class="tok-kw">if</span> (other_sl.source_line != <span class="tok-number">0</span>)
                <span class="tok-kw">try</span> wip.addString(other.nullTerminatedString(other_sl.source_line))
            <span class="tok-kw">else</span>
                <span class="tok-number">0</span>,
            .reference_trace_len = other_sl.reference_trace_len,
        });

        <span class="tok-kw">for</span> (ref_traces.items) |ref_trace| {
            <span class="tok-kw">try</span> wip.addReferenceTrace(ref_trace);
        }

        <span class="tok-kw">return</span> src_loc;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtra</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, extra: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">u32</span> {
        <span class="tok-kw">const</span> gpa = wip.gpa;
        <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields;
        <span class="tok-kw">try</span> wip.extra.ensureUnusedCapacity(gpa, fields.len);
        <span class="tok-kw">return</span> <a href="std.zig.ErrorBundle.Wip.html#std.zig.ErrorBundle.Wip.addExtraAssumeCapacity">addExtraAssumeCapacity</a>(wip, extra);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtraAssumeCapacity</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, extra: <span class="tok-kw">anytype</span>) <span class="tok-type">u32</span> {
        <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields;
        <span class="tok-kw">const</span> result: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(wip.extra.items.len);
        wip.extra.items.len += fields.len;
        <a href="std.zig.ErrorBundle.Wip.html#std.zig.ErrorBundle.Wip.setExtra">setExtra</a>(wip, result, extra);
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">setExtra</span>(wip: *<a href="std.zig.ErrorBundle.Wip.html">Wip</a>, index: <span class="tok-type">usize</span>, extra: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields;
        <span class="tok-kw">var</span> i = index;
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {
            wip.extra.items[i] = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                <span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@field</span>(extra, field.name),
                <a href="std.zig.ErrorBundle.MessageIndex.html">MessageIndex</a> =&gt; <span class="tok-builtin">@intFromEnum</span>(<span class="tok-builtin">@field</span>(extra, field.name)),
                <a href="std.zig.ErrorBundle.SourceLocationIndex.html">SourceLocationIndex</a> =&gt; <span class="tok-builtin">@intFromEnum</span>(<span class="tok-builtin">@field</span>(extra, field.name)),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type&quot;</span>),
            };
            i += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">test</span> addBundleAsRoots {
        <span class="tok-kw">var</span> bundle = bundle: {
            <span class="tok-kw">var</span> wip: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>.<a href="std.zig.ErrorBundle.Wip.html">Wip</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> wip.init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
            <span class="tok-kw">errdefer</span> wip.deinit();

            <span class="tok-kw">var</span> ref_traces: [<span class="tok-number">3</span>]<a href="std.zig.ErrorBundle.ReferenceTrace.html">ReferenceTrace</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (&amp;ref_traces, <span class="tok-number">0</span>..) |*ref_trace, i| {
                <span class="tok-kw">if</span> (i == ref_traces.len - <span class="tok-number">1</span>) {<span class="tok-comment">
                    // sentinel reference trace
                    </span>ref_trace.* = .{
                        .decl_name = <span class="tok-number">3</span>,<span class="tok-comment"> // signifies 3 hidden references
                        </span>.src_loc = .none,
                    };
                } <span class="tok-kw">else</span> {
                    ref_trace.* = .{
                        .decl_name = <span class="tok-kw">try</span> wip.addString(<span class="tok-str">&quot;foo&quot;</span>),
                        .src_loc = <span class="tok-kw">try</span> wip.addSourceLocation(.{
                            .src_path = <span class="tok-kw">try</span> wip.addString(<span class="tok-str">&quot;foo&quot;</span>),
                            .line = <span class="tok-number">1</span>,
                            .column = <span class="tok-number">2</span>,
                            .span_start = <span class="tok-number">3</span>,
                            .span_main = <span class="tok-number">4</span>,
                            .span_end = <span class="tok-number">5</span>,
                            .source_line = <span class="tok-number">0</span>,
                        }),
                    };
                }
            }

            <span class="tok-kw">const</span> src_loc = <span class="tok-kw">try</span> wip.addSourceLocation(.{
                .src_path = <span class="tok-kw">try</span> wip.addString(<span class="tok-str">&quot;foo&quot;</span>),
                .line = <span class="tok-number">1</span>,
                .column = <span class="tok-number">2</span>,
                .span_start = <span class="tok-number">3</span>,
                .span_main = <span class="tok-number">4</span>,
                .span_end = <span class="tok-number">5</span>,
                .source_line = <span class="tok-kw">try</span> wip.addString(<span class="tok-str">&quot;some source code&quot;</span>),
                .reference_trace_len = ref_traces.len,
            });
            <span class="tok-kw">for</span> (&amp;ref_traces) |ref_trace| {
                <span class="tok-kw">try</span> wip.addReferenceTrace(ref_trace);
            }

            <span class="tok-kw">try</span> wip.addRootErrorMessage(<a href="std.zig.ErrorBundle.ErrorMessage.html">ErrorMessage</a>{
                .msg = <span class="tok-kw">try</span> wip.addString(<span class="tok-str">&quot;hello world&quot;</span>),
                .src_loc = src_loc,
                .notes_len = <span class="tok-number">1</span>,
            });
            <span class="tok-kw">const</span> i = <span class="tok-kw">try</span> wip.reserveNotes(<span class="tok-number">1</span>);
            <span class="tok-kw">const</span> note_index = <span class="tok-builtin">@intFromEnum</span>(wip.addErrorMessageAssumeCapacity(.{
                .msg = <span class="tok-kw">try</span> wip.addString(<span class="tok-str">&quot;this is a note&quot;</span>),
                .src_loc = <span class="tok-kw">try</span> wip.addSourceLocation(.{
                    .src_path = <span class="tok-kw">try</span> wip.addString(<span class="tok-str">&quot;bar&quot;</span>),
                    .line = <span class="tok-number">1</span>,
                    .column = <span class="tok-number">2</span>,
                    .span_start = <span class="tok-number">3</span>,
                    .span_main = <span class="tok-number">4</span>,
                    .span_end = <span class="tok-number">5</span>,
                    .source_line = <span class="tok-kw">try</span> wip.addString(<span class="tok-str">&quot;another line of source&quot;</span>),
                }),
            }));
            wip.extra.items[i] = note_index;

            <span class="tok-kw">break</span> :bundle <span class="tok-kw">try</span> wip.toOwnedBundle(<span class="tok-str">&quot;&quot;</span>);
        };
        <span class="tok-kw">defer</span> bundle.deinit(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);

        <span class="tok-kw">const</span> ttyconf: <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a> = .no_color;

        <span class="tok-kw">var</span> bundle_buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
        <span class="tok-kw">defer</span> bundle_buf.deinit();
        <span class="tok-kw">try</span> bundle.renderToWriter(.{ .ttyconf = ttyconf }, bundle_buf.writer());

        <span class="tok-kw">var</span> copy = copy: {
            <span class="tok-kw">var</span> wip: <a href="std.zig.ErrorBundle.html">ErrorBundle</a>.<a href="std.zig.ErrorBundle.Wip.html">Wip</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> wip.init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
            <span class="tok-kw">errdefer</span> wip.deinit();

            <span class="tok-kw">try</span> wip.addBundleAsRoots(bundle);

            <span class="tok-kw">break</span> :copy <span class="tok-kw">try</span> wip.toOwnedBundle(<span class="tok-str">&quot;&quot;</span>);
        };
        <span class="tok-kw">defer</span> copy.deinit(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);

        <span class="tok-kw">var</span> copy_buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
        <span class="tok-kw">defer</span> copy_buf.deinit();
        <span class="tok-kw">try</span> copy.renderToWriter(.{ .ttyconf = ttyconf }, copy_buf.writer());

        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(bundle_buf.items, copy_buf.items);
    }
};</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
