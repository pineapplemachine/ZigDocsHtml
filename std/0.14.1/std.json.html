<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.json.html" class="active">json</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.json" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.json</span><a href="#src.zig-std.json">[src]</a></h1><div class="tldDocs"><p>JSON parsing and stringification conforming to RFC 8259. <a href="https://datatracker.ietf.org/doc/html/rfc8259">https://datatracker.ietf.org/doc/html/rfc8259</a></p>
<p>The low-level <code><a href="std.json.scanner.Scanner.html">Scanner</a></code> API produces <code><a href="std.json.scanner.Token.html">Token</a></code>s from an input slice or successive slices of inputs,
The <code><a href="std.json.scanner.html#std.json.scanner.Reader">Reader</a></code> API connects a <code>std.io.Reader</code> to a <code><a href="std.json.scanner.Scanner.html">Scanner</a></code>.</p>
<p>The high-level <code><a href="std.json.static.html#std.json.static.parseFromSlice">parseFromSlice</a></code> and <code><a href="std.json.static.html#std.json.static.parseFromTokenSource">parseFromTokenSource</a></code> deserialize a JSON document into a Zig type.
Parse into a dynamically-typed <code><a href="std.json.dynamic.Value.html">Value</a></code> to load any JSON value for runtime inspection.</p>
<p>The low-level <code><a href="std.json.stringify.html#std.json.stringify.writeStream">writeStream</a></code> emits syntax-conformant JSON tokens to a <code>std.io.Writer</code>.
The high-level <code><a href="std.json.stringify.html#std.json.stringify.stringify">stringify</a></code> serializes a Zig or <code><a href="std.json.dynamic.Value.html">Value</a></code> type into JSON.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.json.dynamic.Value.html">std.json.dynamic.Value</a></li><li><a href="std.json.scanner.Token.html">std.json.scanner.Token</a></li><li><a href="std.json.scanner.TokenType.html">std.json.scanner.TokenType</a></li><li><a href="std.json.scanner.Diagnostics.html">std.json.scanner.Diagnostics</a></li><li><a href="std.json.scanner.AllocWhen.html">std.json.scanner.AllocWhen</a></li><li><a href="std.json.scanner.Scanner.html">std.json.scanner.Scanner</a></li><li><a href="std.json.static.ParseOptions.html">std.json.static.ParseOptions</a></li><li><a href="std.json.stringify.StringifyOptions.html">std.json.stringify.StringifyOptions</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.json.dynamic.ObjectMap" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ObjectMap</span><a href="#src.zig-std.json.dynamic.ObjectMap">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.dynamic.ObjectMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ObjectMap = <a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMap">StringArrayHashMap</a>(<a href="std.json.dynamic.Value.html">Value</a>)</code></pre></details></div></div><div class="decl"><h2 id="std.json.dynamic.Array" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Array</span><a href="#src.zig-std.json.dynamic.Array">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.dynamic.Array">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Array = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.json.dynamic.Value.html">Value</a>)</code></pre></details></div></div><div class="decl"><h2 id="std.json.hashmap.ArrayHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayHashMap</span><a href="#src.zig-std.json.hashmap.ArrayHashMap">[src]</a></h2><div class="tldDocs"><p>A thin wrapper around <code><a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">std.StringArrayHashMapUnmanaged</a></code> that implements
<code>jsonParse</code>, <code>jsonParseFromValue</code>, and <code>jsonStringify</code>.
This is useful when your JSON schema has an object with arbitrary data keys
instead of comptime-known struct field names.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(T) = .empty</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.json.hashmap.ArrayHashMap.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.json.hashmap.ArrayHashMap.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.hashmap.ArrayHashMap.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.map.deinit(allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.hashmap.ArrayHashMap.jsonParse" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">jsonParse</span><a href="#src.zig-std.json.hashmap.ArrayHashMap.jsonParse">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonParse</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <span class="tok-kw">anytype</span>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>) !<span class="tok-builtin">@This</span>()</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.hashmap.ArrayHashMap.jsonParse">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonParse</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <span class="tok-kw">anytype</span>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>) !<span class="tok-builtin">@This</span>() {
    <span class="tok-kw">var</span> map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(T) = .empty;
    <span class="tok-kw">errdefer</span> map.deinit(allocator);

    <span class="tok-kw">if</span> (.object_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> source.nextAlloc(allocator, options.allocate.?);
        <span class="tok-kw">switch</span> (token) {
            <span class="tok-kw">inline</span> .string, .allocated_string =&gt; |k| {
                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> map.getOrPut(allocator, k);
                <span class="tok-kw">if</span> (gop.found_existing) {
                    <span class="tok-kw">switch</span> (options.duplicate_field_behavior) {
                        .use_first =&gt; {<span class="tok-comment">
                            // Parse and ignore the redundant value.
                            // We don't want to skip the value, because we want type checking.
                            </span>_ = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(T, allocator, source, options);
                            <span class="tok-kw">continue</span>;
                        },
                        .@&quot;error&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DuplicateField,
                        .use_last =&gt; {},
                    }
                }
                gop.value_ptr.* = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(T, allocator, source, options);
            },
            .object_end =&gt; <span class="tok-kw">break</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
    <span class="tok-kw">return</span> .{ .map = map };
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.hashmap.ArrayHashMap.jsonParseFromValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">jsonParseFromValue</span><a href="#src.zig-std.json.hashmap.ArrayHashMap.jsonParseFromValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonParseFromValue</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <a href="std.json.dynamic.Value.html">Value</a>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>) !<span class="tok-builtin">@This</span>()</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>source: <a href="std.json.dynamic.Value.html">Value</a></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.hashmap.ArrayHashMap.jsonParseFromValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonParseFromValue</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <a href="std.json.dynamic.Value.html">Value</a>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>) !<span class="tok-builtin">@This</span>() {
    <span class="tok-kw">if</span> (source != .object) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

    <span class="tok-kw">var</span> map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(T) = .empty;
    <span class="tok-kw">errdefer</span> map.deinit(allocator);

    <span class="tok-kw">var</span> it = source.object.iterator();
    <span class="tok-kw">while</span> (it.next()) |kv| {
        <span class="tok-kw">try</span> map.put(allocator, kv.key_ptr.*, <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(T, allocator, kv.value_ptr.*, options));
    }
    <span class="tok-kw">return</span> .{ .map = map };
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.hashmap.ArrayHashMap.jsonStringify" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">jsonStringify</span><a href="#src.zig-std.json.hashmap.ArrayHashMap.jsonStringify">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonStringify</span>(self: <span class="tok-builtin">@This</span>(), jws: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.hashmap.ArrayHashMap.jsonStringify">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonStringify</span>(self: <span class="tok-builtin">@This</span>(), jws: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> jws.beginObject();
    <span class="tok-kw">var</span> it = self.map.iterator();
    <span class="tok-kw">while</span> (it.next()) |kv| {
        <span class="tok-kw">try</span> jws.objectField(kv.key_ptr.*);
        <span class="tok-kw">try</span> jws.write(kv.value_ptr.*);
    }
    <span class="tok-kw">try</span> jws.endObject();
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.hashmap.ArrayHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayHashMap</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(T) = .empty,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.map.deinit(allocator);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonParse</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <span class="tok-kw">anytype</span>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>) !<span class="tok-builtin">@This</span>() {
            <span class="tok-kw">var</span> map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(T) = .empty;
            <span class="tok-kw">errdefer</span> map.deinit(allocator);

            <span class="tok-kw">if</span> (.object_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> source.nextAlloc(allocator, options.allocate.?);
                <span class="tok-kw">switch</span> (token) {
                    <span class="tok-kw">inline</span> .string, .allocated_string =&gt; |k| {
                        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> map.getOrPut(allocator, k);
                        <span class="tok-kw">if</span> (gop.found_existing) {
                            <span class="tok-kw">switch</span> (options.duplicate_field_behavior) {
                                .use_first =&gt; {<span class="tok-comment">
                                    // Parse and ignore the redundant value.
                                    // We don't want to skip the value, because we want type checking.
                                    </span>_ = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(T, allocator, source, options);
                                    <span class="tok-kw">continue</span>;
                                },
                                .@&quot;error&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DuplicateField,
                                .use_last =&gt; {},
                            }
                        }
                        gop.value_ptr.* = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(T, allocator, source, options);
                    },
                    .object_end =&gt; <span class="tok-kw">break</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            }
            <span class="tok-kw">return</span> .{ .map = map };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonParseFromValue</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <a href="std.json.dynamic.Value.html">Value</a>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>) !<span class="tok-builtin">@This</span>() {
            <span class="tok-kw">if</span> (source != .object) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

            <span class="tok-kw">var</span> map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(T) = .empty;
            <span class="tok-kw">errdefer</span> map.deinit(allocator);

            <span class="tok-kw">var</span> it = source.object.iterator();
            <span class="tok-kw">while</span> (it.next()) |kv| {
                <span class="tok-kw">try</span> map.put(allocator, kv.key_ptr.*, <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(T, allocator, kv.value_ptr.*, options));
            }
            <span class="tok-kw">return</span> .{ .map = map };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">jsonStringify</span>(self: <span class="tok-builtin">@This</span>(), jws: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> jws.beginObject();
            <span class="tok-kw">var</span> it = self.map.iterator();
            <span class="tok-kw">while</span> (it.next()) |kv| {
                <span class="tok-kw">try</span> jws.objectField(kv.key_ptr.*);
                <span class="tok-kw">try</span> jws.write(kv.value_ptr.*);
            }
            <span class="tok-kw">try</span> jws.endObject();
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.Reader" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Reader</span><a href="#src.zig-std.json.scanner.Reader">[src]</a></h2><div class="tldDocs"><p>Connects a <code><a href="std.io.html#std.io.GenericReader">std.io.Reader</a></code> to a <code><a href="std.json.scanner.Scanner.html">std.json.Scanner</a></code>.
All <code>next*()</code> methods here handle <code>error.BufferUnderrun</code> from <code><a href="std.json.scanner.Scanner.html">std.json.Scanner</a></code>, and then read from the reader.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>buffer_size: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ReaderType: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>scanner: <a href="std.json.scanner.Scanner.html">Scanner</a></code></pre></div><div><pre><code>reader: ReaderType</code></pre></div><div><pre><code>buffer: [buffer_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span></code></pre></div></div></div><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.json.scanner.Reader.NextError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">NextError</span><a href="#src.zig-std.json.scanner.Reader.NextError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.NextError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = ReaderType.Error || <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.NextError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">NextError</span><a href="#src.zig-std.json.scanner.Reader.NextError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.NextError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = ReaderType.Error || <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.AllocError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">AllocError</span><a href="#src.zig-std.json.scanner.Reader.AllocError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>ValueTooLong</dt></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.AllocError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocError = <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a> || <span class="tok-kw">error</span>{ValueTooLong}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.PeekError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PeekError</span><a href="#src.zig-std.json.scanner.Reader.PeekError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>SyntaxError <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div><div><dt>UnexpectedEndOfInput <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></dt></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.PeekError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PeekError = ReaderType.Error || <a href="std.json.scanner.html#std.json.scanner.Error">Error</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.json.scanner.Reader.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.json.scanner.Reader.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, io_reader: ReaderType) <span class="tok-builtin">@This</span>()</code></pre></div><div class="tldDocs"><p>The allocator is only used to track <code>[]</code> and <code>{}</code> nesting levels.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>io_reader: ReaderType</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, io_reader: ReaderType) <span class="tok-builtin">@This</span>() {
    <span class="tok-kw">return</span> .{
        .scanner = <a href="std.json.scanner.Scanner.html">Scanner</a>.<a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.initStreaming">initStreaming</a>(allocator),
        .reader = io_reader,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.json.scanner.Reader.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
    self.scanner.deinit();
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.enableDiagnostics" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">enableDiagnostics</span><a href="#src.zig-std.json.scanner.Reader.enableDiagnostics">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *<a href="std.json.scanner.Diagnostics.html">Diagnostics</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Calls <code>std.json.Scanner.enableDiagnostics</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>diagnostics: *<a href="std.json.scanner.Diagnostics.html">Diagnostics</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.enableDiagnostics">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *<a href="std.json.scanner.Diagnostics.html">Diagnostics</a>) <span class="tok-type">void</span> {
    self.scanner.enableDiagnostics(diagnostics);
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.nextAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nextAlloc</span><a href="#src.zig-std.json.scanner.Reader.nextAlloc">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a></code></pre></div><div class="tldDocs"><p>Equivalent to <code>nextAllocMax(allocator, when, default_max_value_len);</code>
See also <code>std.json.Token</code> for documentation of <code>nextAlloc*()</code> function behavior.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.nextAlloc">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a> {
    <span class="tok-kw">return</span> self.nextAllocMax(allocator, when, <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.nextAllocMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nextAllocMax</span><a href="#src.zig-std.json.scanner.Reader.nextAllocMax">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a></code></pre></div><div class="tldDocs"><p>See also <code>std.json.Token</code> for documentation of <code>nextAlloc*()</code> function behavior.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a></code></pre></div><div><pre><code>max_value_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.nextAllocMax">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a> {
    <span class="tok-kw">const</span> token_type = <span class="tok-kw">try</span> self.peekNextTokenType();
    <span class="tok-kw">switch</span> (token_type) {
        .number, .string =&gt; {
            <span class="tok-kw">var</span> value_list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
            <span class="tok-kw">errdefer</span> {
                value_list.deinit();
            }
            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.allocNextIntoArrayListMax(&amp;value_list, when, max_value_len)) |slice| {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)
                    <a href="std.json.scanner.Token.html">Token</a>{ .number = slice }
                <span class="tok-kw">else</span>
                    <a href="std.json.scanner.Token.html">Token</a>{ .string = slice };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)
                    <a href="std.json.scanner.Token.html">Token</a>{ .allocated_number = <span class="tok-kw">try</span> value_list.toOwnedSlice() }
                <span class="tok-kw">else</span>
                    <a href="std.json.scanner.Token.html">Token</a>{ .allocated_string = <span class="tok-kw">try</span> value_list.toOwnedSlice() };
            }
        },<span class="tok-comment">

        // Simple tokens never alloc.
        </span>.object_begin,
        .object_end,
        .array_begin,
        .array_end,
        .<span class="tok-null">true</span>,
        .<span class="tok-null">false</span>,
        .<span class="tok-null">null</span>,
        .end_of_document,
        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next(),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.allocNextIntoArrayList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocNextIntoArrayList</span><a href="#src.zig-std.json.scanner.Reader.allocNextIntoArrayList">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Equivalent to <code>allocNextIntoArrayListMax(value_list, when, default_max_value_len);</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.allocNextIntoArrayList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> self.allocNextIntoArrayListMax(value_list, when, <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.allocNextIntoArrayListMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocNextIntoArrayListMax</span><a href="#src.zig-std.json.scanner.Reader.allocNextIntoArrayListMax">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Calls <code>std.json.Scanner.allocNextIntoArrayListMax</code> and handles <code>error.BufferUnderrun</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a></code></pre></div><div><pre><code>max_value_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.allocNextIntoArrayListMax">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">return</span> self.scanner.allocNextIntoArrayListMax(value_list, when, max_value_len) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.BufferUnderrun =&gt; {
                <span class="tok-kw">try</span> self.refillBuffer();
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.skipValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">skipValue</span><a href="#src.zig-std.json.scanner.Reader.skipValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">SkipError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code>std.json.Scanner.skipValue</code>, but handles <code>error.BufferUnderrun</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.skipValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">SkipError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.peekNextTokenType()) {
        .object_begin, .array_begin =&gt; {
            <span class="tok-kw">try</span> self.skipUntilStackHeight(self.stackHeight());
        },
        .number, .string =&gt; {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.next()) {
                    .partial_number,
                    .partial_string,
                    .partial_string_escaped_1,
                    .partial_string_escaped_2,
                    .partial_string_escaped_3,
                    .partial_string_escaped_4,
                    =&gt; <span class="tok-kw">continue</span>,

                    .number, .string =&gt; <span class="tok-kw">break</span>,

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            }
        },
        .<span class="tok-null">true</span>, .<span class="tok-null">false</span>, .<span class="tok-null">null</span> =&gt; {
            _ = <span class="tok-kw">try</span> self.next();
        },

        .object_end, .array_end, .end_of_document =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Attempt to skip a non-value token.
    </span>}
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.skipUntilStackHeight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">skipUntilStackHeight</span><a href="#src.zig-std.json.scanner.Reader.skipUntilStackHeight">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code>std.json.Scanner.skipUntilStackHeight()</code> but handles <code>error.BufferUnderrun</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>terminal_stack_height: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.skipUntilStackHeight">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">return</span> self.scanner.skipUntilStackHeight(terminal_stack_height) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.BufferUnderrun =&gt; {
                <span class="tok-kw">try</span> self.refillBuffer();
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.stackHeight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stackHeight</span><a href="#src.zig-std.json.scanner.Reader.stackHeight">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Calls <code>std.json.Scanner.stackHeight</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.stackHeight">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.scanner.stackHeight();
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.ensureTotalStackCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalStackCapacity</span><a href="#src.zig-std.json.scanner.Reader.ensureTotalStackCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Calls <code>std.json.Scanner.ensureTotalStackCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>height: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.ensureTotalStackCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.scanner.ensureTotalStackCapacity(height);
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.json.scanner.Reader.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a>!<a href="std.json.scanner.Token.html">Token</a></code></pre></div><div class="tldDocs"><p>See <code>std.json.Token</code> for documentation of this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a>!<a href="std.json.scanner.Token.html">Token</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">return</span> self.scanner.next() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.BufferUnderrun =&gt; {
                <span class="tok-kw">try</span> self.refillBuffer();
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.scanner.Reader.peekNextTokenType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">peekNextTokenType</span><a href="#src.zig-std.json.scanner.Reader.peekNextTokenType">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.PeekError">PeekError</a>!<a href="std.json.scanner.TokenType.html">TokenType</a></code></pre></div><div class="tldDocs"><p>See <code>std.json.Scanner.peekNextTokenType()</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.scanner.Reader.peekNextTokenType">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.PeekError">PeekError</a>!<a href="std.json.scanner.TokenType.html">TokenType</a> {
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">return</span> self.scanner.peekNextTokenType() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.BufferUnderrun =&gt; {
                <span class="tok-kw">try</span> self.refillBuffer();
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,
        };
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Reader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Reader</span>(<span class="tok-kw">comptime</span> buffer_size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> ReaderType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        scanner: <a href="std.json.scanner.Scanner.html">Scanner</a>,
        reader: ReaderType,

        buffer: [buffer_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,

        <span class="tok-comment">/// The allocator is only used to track `[]` and `{}` nesting levels.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, io_reader: ReaderType) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{
                .scanner = <a href="std.json.scanner.Scanner.html">Scanner</a>.<a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.initStreaming">initStreaming</a>(allocator),
                .reader = io_reader,
            };
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            self.scanner.deinit();
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Calls `std.json.Scanner.enableDiagnostics`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enableDiagnostics</span>(self: *<span class="tok-builtin">@This</span>(), diagnostics: *<a href="std.json.scanner.Diagnostics.html">Diagnostics</a>) <span class="tok-type">void</span> {
            self.scanner.enableDiagnostics(diagnostics);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NextError = ReaderType.Error || <a href="std.json.scanner.html#std.json.scanner.Error">Error</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SkipError = <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocError = <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a> || <span class="tok-kw">error</span>{ValueTooLong};
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PeekError = ReaderType.Error || <a href="std.json.scanner.html#std.json.scanner.Error">Error</a>;

        <span class="tok-comment">/// Equivalent to `nextAllocMax(allocator, when, default_max_value_len);`</span>
        <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAlloc</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a> {
            <span class="tok-kw">return</span> self.nextAllocMax(allocator, when, <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>);
        }
        <span class="tok-comment">/// See also `std.json.Token` for documentation of `nextAlloc*()` function behavior.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextAllocMax</span>(self: *<span class="tok-builtin">@This</span>(), allocator: <a href="std.mem.Allocator.html">Allocator</a>, when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!<a href="std.json.scanner.Token.html">Token</a> {
            <span class="tok-kw">const</span> token_type = <span class="tok-kw">try</span> self.peekNextTokenType();
            <span class="tok-kw">switch</span> (token_type) {
                .number, .string =&gt; {
                    <span class="tok-kw">var</span> value_list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
                    <span class="tok-kw">errdefer</span> {
                        value_list.deinit();
                    }
                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> self.allocNextIntoArrayListMax(&amp;value_list, when, max_value_len)) |slice| {
                        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)
                            <a href="std.json.scanner.Token.html">Token</a>{ .number = slice }
                        <span class="tok-kw">else</span>
                            <a href="std.json.scanner.Token.html">Token</a>{ .string = slice };
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (token_type == .number)
                            <a href="std.json.scanner.Token.html">Token</a>{ .allocated_number = <span class="tok-kw">try</span> value_list.toOwnedSlice() }
                        <span class="tok-kw">else</span>
                            <a href="std.json.scanner.Token.html">Token</a>{ .allocated_string = <span class="tok-kw">try</span> value_list.toOwnedSlice() };
                    }
                },<span class="tok-comment">

                // Simple tokens never alloc.
                </span>.object_begin,
                .object_end,
                .array_begin,
                .array_end,
                .<span class="tok-null">true</span>,
                .<span class="tok-null">false</span>,
                .<span class="tok-null">null</span>,
                .end_of_document,
                =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next(),
            }
        }

        <span class="tok-comment">/// Equivalent to `allocNextIntoArrayListMax(value_list, when, default_max_value_len);`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayList</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">return</span> self.allocNextIntoArrayListMax(value_list, when, <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>);
        }
        <span class="tok-comment">/// Calls `std.json.Scanner.allocNextIntoArrayListMax` and handles `error.BufferUnderrun`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocNextIntoArrayListMax</span>(self: *<span class="tok-builtin">@This</span>(), value_list: *<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), when: <a href="std.json.scanner.AllocWhen.html">AllocWhen</a>, max_value_len: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.AllocError">AllocError</a>!?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">return</span> self.scanner.allocNextIntoArrayListMax(value_list, when, max_value_len) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {
                        <span class="tok-kw">try</span> self.refillBuffer();
                        <span class="tok-kw">continue</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,
                };
            }
        }

        <span class="tok-comment">/// Like `std.json.Scanner.skipValue`, but handles `error.BufferUnderrun`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipValue</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">SkipError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.peekNextTokenType()) {
                .object_begin, .array_begin =&gt; {
                    <span class="tok-kw">try</span> self.skipUntilStackHeight(self.stackHeight());
                },
                .number, .string =&gt; {
                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                        <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.next()) {
                            .partial_number,
                            .partial_string,
                            .partial_string_escaped_1,
                            .partial_string_escaped_2,
                            .partial_string_escaped_3,
                            .partial_string_escaped_4,
                            =&gt; <span class="tok-kw">continue</span>,

                            .number, .string =&gt; <span class="tok-kw">break</span>,

                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }
                    }
                },
                .<span class="tok-null">true</span>, .<span class="tok-null">false</span>, .<span class="tok-null">null</span> =&gt; {
                    _ = <span class="tok-kw">try</span> self.next();
                },

                .object_end, .array_end, .end_of_document =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Attempt to skip a non-value token.
            </span>}
        }
        <span class="tok-comment">/// Like `std.json.Scanner.skipUntilStackHeight()` but handles `error.BufferUnderrun`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipUntilStackHeight</span>(self: *<span class="tok-builtin">@This</span>(), terminal_stack_height: <span class="tok-type">usize</span>) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">return</span> self.scanner.skipUntilStackHeight(terminal_stack_height) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {
                        <span class="tok-kw">try</span> self.refillBuffer();
                        <span class="tok-kw">continue</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,
                };
            }
        }

        <span class="tok-comment">/// Calls `std.json.Scanner.stackHeight`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stackHeight</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.scanner.stackHeight();
        }
        <span class="tok-comment">/// Calls `std.json.Scanner.ensureTotalStackCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalStackCapacity</span>(self: *<span class="tok-builtin">@This</span>(), height: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.scanner.ensureTotalStackCapacity(height);
        }

        <span class="tok-comment">/// See `std.json.Token` for documentation of this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.NextError">NextError</a>!<a href="std.json.scanner.Token.html">Token</a> {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">return</span> self.scanner.next() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {
                        <span class="tok-kw">try</span> self.refillBuffer();
                        <span class="tok-kw">continue</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,
                };
            }
        }

        <span class="tok-comment">/// See `std.json.Scanner.peekNextTokenType()`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekNextTokenType</span>(self: *<span class="tok-builtin">@This</span>()) <a href="std.json.scanner.html#std.json.scanner.Reader.PeekError">PeekError</a>!<a href="std.json.scanner.TokenType.html">TokenType</a> {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">return</span> self.scanner.peekNextTokenType() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.BufferUnderrun =&gt; {
                        <span class="tok-kw">try</span> self.refillBuffer();
                        <span class="tok-kw">continue</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; |other_err| <span class="tok-kw">return</span> other_err,
                };
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">refillBuffer</span>(self: *<span class="tok-builtin">@This</span>()) ReaderType.Error!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> input = self.buffer[<span class="tok-number">0</span>..<span class="tok-kw">try</span> self.reader.read(self.buffer[<span class="tok-number">0</span>..])];
            <span class="tok-kw">if</span> (input.len &gt; <span class="tok-number">0</span>) {
                self.scanner.feedInput(input);
            } <span class="tok-kw">else</span> {
                self.scanner.endInput();
            }
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.Parsed" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Parsed</span><a href="#src.zig-std.json.static.Parsed">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>arena: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a></code></pre></div><div><pre><code>value: T</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.json.static.Parsed.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.json.static.Parsed.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.static.Parsed.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> allocator = self.arena.child_allocator;
    self.arena.deinit();
    allocator.destroy(self.arena);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.Parsed">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Parsed</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        arena: *<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>,
        value: T,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> allocator = self.arena.child_allocator;
            self.arena.deinit();
            allocator.destroy(self.arena);
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.ParseError" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ParseError</span><a href="#src.zig-std.json.static.ParseError">[src]</a></h2><div class="tldDocs"><p>The error set that will be returned when parsing from <code>*Source</code>.
Note that this may contain <code>error.BufferUnderrun</code>, but that error will never actually be returned.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>Source: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.ParseError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ParseError</span>(<span class="tok-kw">comptime</span> Source: <span class="tok-type">type</span>) <span class="tok-type">type</span> {<span class="tok-comment">
    // A few of these will either always be present or present enough of the time that
    // omitting them is more confusing than always including them.
    </span><span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.ParseFromValueError">ParseFromValueError</a> || Source.NextError || Source.PeekError || Source.AllocError;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.WriteStream" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">WriteStream</span><a href="#src.zig-std.json.stringify.WriteStream">[src]</a></h2><div class="tldDocs"><p>Writes JSON (<a href="https://tools.ietf.org/html/rfc8259">RFC8259</a>) formatted data
to a stream.</p>
<p>The sequence of method calls to write JSON content must follow this grammar:</p>
<pre><code> &lt;once&gt; = &lt;value&gt;
 &lt;value&gt; =
   | &lt;object&gt;
   | &lt;array&gt;
   | write
   | print
   | &lt;writeRawStream&gt;
 &lt;object&gt; = beginObject ( &lt;field&gt; &lt;value&gt; )* endObject
 &lt;field&gt; = objectField | objectFieldRaw | &lt;objectFieldRawStream&gt;
 &lt;array&gt; = beginArray ( &lt;value&gt; )* endArray
 &lt;writeRawStream&gt; = beginWriteRaw ( stream.writeAll )* endWriteRaw
 &lt;objectFieldRawStream&gt; = beginObjectFieldRaw ( stream.writeAll )* endObjectFieldRaw
</code></pre>
<p>The <code>safety_checks_hint</code> parameter determines how much memory is used to enable assertions that the above grammar is being followed,
e.g. tripping an assertion rather than allowing <code>endObject</code> to emit the final <code>}</code> in <code>[[[]]}</code>.
&quot;Depth&quot; in this context means the depth of nested <code>[]</code> or <code>{}</code> expressions
(or equivalently the amount of recursion on the <code>&lt;value&gt;</code> grammar expression above).
For example, emitting the JSON <code>[[[]]]</code> requires a depth of 3.
If <code>.checked_to_fixed_depth</code> is used, there is additionally an assertion that the nesting depth never exceeds the given limit.
<code>.checked_to_arbitrary_depth</code> requires a runtime allocator for the memory.
<code>.checked_to_fixed_depth</code> embeds the storage required in the <code><a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a></code> struct.
<code>.assumed_correct</code> requires no space and performs none of these assertions.
In <code>ReleaseFast</code> and <code>ReleaseSmall</code> mode, the given <code>safety_checks_hint</code> is ignored and is always treated as <code>.assumed_correct</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>OutStream: <span class="tok-type">type</span></code></pre></div><div><pre><code>safety_checks_hint: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    checked_to_arbitrary_depth,
    checked_to_fixed_depth: <span class="tok-type">usize</span>,<span class="tok-comment"> // Rounded up to the nearest multiple of 8.
    </span>assumed_correct,
}</code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.json.stringify.WriteStream.Error" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.json.stringify.WriteStream.Error">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.Error">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
    .checked_to_arbitrary_depth =&gt; <a href="std.json.stringify.html#std.json.stringify.WriteStream.Stream">Stream</a>.<a href="#">Error</a> || <span class="tok-kw">error</span>{OutOfMemory},
    .checked_to_fixed_depth, .assumed_correct =&gt; <a href="std.json.stringify.html#std.json.stringify.WriteStream.Stream">Stream</a>.<a href="#">Error</a>,
}</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div><div><pre><code>stream: OutStream</code></pre></div><div><pre><code>indent_level: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>next_punctuation: <span class="tok-kw">enum</span> {
    the_beginning,
    none,
    comma,
    colon,
} = .the_beginning</code></pre></div><div><pre><code>nesting_stack: <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
    .checked_to_arbitrary_depth =&gt; <a href="std.BitStack.html">BitStack</a>,
    .checked_to_fixed_depth =&gt; |fixed_buffer_size| [(fixed_buffer_size + <span class="tok-number">7</span>) &gt;&gt; <span class="tok-number">3</span>]<span class="tok-type">u8</span>,
    .assumed_correct =&gt; <span class="tok-type">void</span>,
}</code></pre></div><div><pre><code>raw_streaming_mode: <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>)
    <span class="tok-kw">enum</span> { none, value, <a href="std.json.stringify.html#std.json.stringify.WriteStream.objectField">objectField</a> }
<span class="tok-kw">else</span>
    <span class="tok-type">void</span> = <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) .none <span class="tok-kw">else</span> {}</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.json.stringify.WriteStream.Stream" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Stream</span><a href="#src.zig-std.json.stringify.WriteStream.Stream">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.Stream">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stream = OutStream</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.json.stringify.WriteStream.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.json.stringify.WriteStream.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(safety_allocator: <a href="std.mem.Allocator.html">Allocator</a>, stream: OutStream, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>safety_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>stream: OutStream</code></pre></div><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(safety_allocator: <a href="std.mem.Allocator.html">Allocator</a>, stream: OutStream, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a> {
    <span class="tok-kw">return</span> .{
        .options = options,
        .stream = stream,
        .nesting_stack = <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
            .checked_to_arbitrary_depth =&gt; <a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.init">init</a>(safety_allocator),
            .checked_to_fixed_depth =&gt; |fixed_buffer_size| [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** ((fixed_buffer_size + <span class="tok-number">7</span>) &gt;&gt; <span class="tok-number">3</span>),
            .assumed_correct =&gt; {},
        },
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.json.stringify.WriteStream.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Only necessary with .checked_to_arbitrary_depth.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
        .checked_to_arbitrary_depth =&gt; self.nesting_stack.deinit(),
        .checked_to_fixed_depth, .assumed_correct =&gt; {},
    }
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.beginArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">beginArray</span><a href="#src.zig-std.json.stringify.WriteStream.beginArray">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginArray</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.beginArray">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginArray</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
    <span class="tok-kw">try</span> self.valueStart();
    <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">'['</span>);
    <span class="tok-kw">try</span> self.pushIndentation(<a href="std.json.stringify.html#std.json.stringify.ARRAY_MODE">ARRAY_MODE</a>);
    self.next_punctuation = .none;
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.beginObject" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">beginObject</span><a href="#src.zig-std.json.stringify.WriteStream.beginObject">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginObject</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.beginObject">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginObject</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
    <span class="tok-kw">try</span> self.valueStart();
    <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">'{'</span>);
    <span class="tok-kw">try</span> self.pushIndentation(<a href="std.json.stringify.html#std.json.stringify.OBJECT_MODE">OBJECT_MODE</a>);
    self.next_punctuation = .none;
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.endArray" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">endArray</span><a href="#src.zig-std.json.stringify.WriteStream.endArray">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endArray</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.endArray">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endArray</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
    self.popIndentation(<a href="std.json.stringify.html#std.json.stringify.ARRAY_MODE">ARRAY_MODE</a>);
    <span class="tok-kw">switch</span> (self.next_punctuation) {
        .none =&gt; {},
        .comma =&gt; {
            <span class="tok-kw">try</span> self.indent();
        },
        .the_beginning, .colon =&gt; <span class="tok-kw">unreachable</span>,
    }
    <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">']'</span>);
    self.valueDone();
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.endObject" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">endObject</span><a href="#src.zig-std.json.stringify.WriteStream.endObject">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endObject</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.endObject">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endObject</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
    self.popIndentation(<a href="std.json.stringify.html#std.json.stringify.OBJECT_MODE">OBJECT_MODE</a>);
    <span class="tok-kw">switch</span> (self.next_punctuation) {
        .none =&gt; {},
        .comma =&gt; {
            <span class="tok-kw">try</span> self.indent();
        },
        .the_beginning, .colon =&gt; <span class="tok-kw">unreachable</span>,
    }
    <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">'}'</span>);
    self.valueDone();
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.print" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">print</span><a href="#src.zig-std.json.stringify.WriteStream.print">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>An alternative to calling <code>write</code> that formats a value with <code>std.fmt</code>.
This function does the usual punctuation and indentation formatting
assuming the resulting formatted string represents a single complete value;
e.g. <code>&quot;1&quot;</code>, <code>&quot;[]&quot;</code>, <code>&quot;[1,2]&quot;</code>, not <code>&quot;1,2&quot;</code>.
This function may be useful for doing your own number formatting.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div><div><pre><code>fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.print">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
    <span class="tok-kw">try</span> self.valueStart();
    <span class="tok-kw">try</span> self.stream.print(fmt, args);
    self.valueDone();
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.beginWriteRaw" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">beginWriteRaw</span><a href="#src.zig-std.json.stringify.WriteStream.beginWriteRaw">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginWriteRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>An alternative to calling <code>write</code> that allows you to write directly to the <code>.stream</code> field, e.g. with <code>.stream.writeAll()</code>.
Call <code>beginWriteRaw()</code>, then write a complete value (including any quotes if necessary) directly to the <code>.stream</code> field,
then call <code>endWriteRaw()</code>.
This can be useful for streaming very long strings into the output without needing it all buffered in memory.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.beginWriteRaw">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginWriteRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
        self.raw_streaming_mode = .value;
    }
    <span class="tok-kw">try</span> self.valueStart();
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.endWriteRaw" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">endWriteRaw</span><a href="#src.zig-std.json.stringify.WriteStream.endWriteRaw">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endWriteRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>See <code>beginWriteRaw</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.endWriteRaw">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endWriteRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .value);
        self.raw_streaming_mode = .none;
    }
    self.valueDone();
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.objectField" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">objectField</span><a href="#src.zig-std.json.stringify.WriteStream.objectField">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">objectField</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>See <code>WriteStream</code> for when to call this method.
<code>key</code> is the string content of the property name.
Surrounding quotes will be added and any special characters will be escaped.
See also <code>objectFieldRaw</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.objectField">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">objectField</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
    <span class="tok-kw">try</span> self.objectFieldStart();
    <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.encodeJsonString">encodeJsonString</a>(key, self.options, self.stream);
    self.next_punctuation = .colon;
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.objectFieldRaw" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">objectFieldRaw</span><a href="#src.zig-std.json.stringify.WriteStream.objectFieldRaw">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">objectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, quoted_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>See <code>WriteStream</code> for when to call this method.
<code>quoted_key</code> is the complete bytes of the key including quotes and any necessary escape sequences.
A few assertions are performed on the given value to ensure that the caller of this function understands the API contract.
See also <code>objectField</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div><div><pre><code>quoted_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.objectFieldRaw">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">objectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, quoted_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
    <a href="std.debug.html#std.debug.assert">assert</a>(quoted_key.len &gt;= <span class="tok-number">2</span> <span class="tok-kw">and</span> quoted_key[<span class="tok-number">0</span>] == <span class="tok-str">'&quot;'</span> <span class="tok-kw">and</span> quoted_key[quoted_key.len - <span class="tok-number">1</span>] == <span class="tok-str">'&quot;'</span>);<span class="tok-comment"> // quoted_key should be &quot;quoted&quot;.
    </span><span class="tok-kw">try</span> self.objectFieldStart();
    <span class="tok-kw">try</span> self.stream.writeAll(quoted_key);
    self.next_punctuation = .colon;
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.beginObjectFieldRaw" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">beginObjectFieldRaw</span><a href="#src.zig-std.json.stringify.WriteStream.beginObjectFieldRaw">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginObjectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>In the rare case that you need to write very long object field names,
this is an alternative to <code>objectField</code> and <code>objectFieldRaw</code> that allows you to write directly to the <code>.stream</code> field
similar to <code>beginWriteRaw</code>.
Call <code>endObjectFieldRaw()</code> when you're done.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.beginObjectFieldRaw">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginObjectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
        self.raw_streaming_mode = .objectField;
    }
    <span class="tok-kw">try</span> self.objectFieldStart();
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.endObjectFieldRaw" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">endObjectFieldRaw</span><a href="#src.zig-std.json.stringify.WriteStream.endObjectFieldRaw">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endObjectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>See <code>beginObjectFieldRaw</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.endObjectFieldRaw">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endObjectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .objectField);
        self.raw_streaming_mode = .none;
    }
    self.next_punctuation = .colon;
}</code></pre></details></div></div><div class="decl"><h3 id="std.json.stringify.WriteStream.write" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">write</span><a href="#src.zig-std.json.stringify.WriteStream.write">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, value: <span class="tok-kw">anytype</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Renders the given Zig value as JSON.</p>
<p>Supported types:</p>
<ul>
<li>Zig <code>bool</code> -&gt; JSON <code>true</code> or <code>false</code>.</li>
<li>Zig <code>?T</code> -&gt; <code>null</code> or the rendering of <code>T</code>.</li>
<li>Zig <code>i32</code>, <code>u64</code>, etc. -&gt; JSON number or string.<ul>
<li>When option <code>emit_nonportable_numbers_as_strings</code> is true, if the value is outside the range <code>+-1&lt;&lt;53</code> (the precise integer range of f64), it is rendered as a JSON string in base 10. Otherwise, it is rendered as JSON number.</li>
</ul>
</li>
<li>Zig floats -&gt; JSON number or string.<ul>
<li>If the value cannot be precisely represented by an f64, it is rendered as a JSON string. Otherwise, it is rendered as JSON number.</li>
<li>TODO: Float rendering will likely change in the future, e.g. to remove the unnecessary &quot;e+00&quot;.</li>
</ul>
</li>
<li>Zig <code>[]const u8</code>, <code>[]u8</code>, <code>*[N]u8</code>, <code>@Vector(N, u8)</code>, and similar -&gt; JSON string.<ul>
<li>See <code>StringifyOptions.emit_strings_as_arrays</code>.</li>
<li>If the content is not valid UTF-8, rendered as an array of numbers instead.</li>
</ul>
</li>
<li>Zig <code>[]T</code>, <code>[N]T</code>, <code>*[N]T</code>, <code>@Vector(N, T)</code>, and similar -&gt; JSON array of the rendering of each item.</li>
<li>Zig tuple -&gt; JSON array of the rendering of each item.</li>
<li>Zig <code>struct</code> -&gt; JSON object with each field in declaration order.<ul>
<li>If the struct declares a method <code>pub fn jsonStringify(self: *@This(), jw: anytype) !void</code>, it is called to do the serialization instead of the default behavior. The given <code>jw</code> is a pointer to this <code>WriteStream</code>. See <code>std.json.Value</code> for an example.</li>
<li>See <code>StringifyOptions.emit_null_optional_fields</code>.</li>
</ul>
</li>
<li>Zig <code>union(enum)</code> -&gt; JSON object with one field named for the active tag and a value representing the payload.<ul>
<li>If the payload is <code>void</code>, then the emitted value is <code>{}</code>.</li>
<li>If the union declares a method <code>pub fn jsonStringify(self: *@This(), jw: anytype) !void</code>, it is called to do the serialization instead of the default behavior. The given <code>jw</code> is a pointer to this <code>WriteStream</code>.</li>
</ul>
</li>
<li>Zig <code>enum</code> -&gt; JSON string naming the active tag.<ul>
<li>If the enum declares a method <code>pub fn jsonStringify(self: *@This(), jw: anytype) !void</code>, it is called to do the serialization instead of the default behavior. The given <code>jw</code> is a pointer to this <code>WriteStream</code>.</li>
<li>If the enum is non-exhaustive, unnamed values are rendered as integers.</li>
</ul>
</li>
<li>Zig untyped enum literal -&gt; JSON string naming the active tag.</li>
<li>Zig error -&gt; JSON string naming the error.</li>
<li>Zig <code>*T</code> -&gt; the rendering of <code>T</code>. Note there is no guard against circular-reference infinite recursion.</li>
</ul>
<p>See also alternative functions <code>print</code> and <code>beginWriteRaw</code>.
For writing object field names, use <code>objectField</code> instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream.write">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, value: <span class="tok-kw">anytype</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(value);
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .int =&gt; {
            <span class="tok-kw">try</span> self.valueStart();
            <span class="tok-kw">if</span> (self.options.emit_nonportable_numbers_as_strings <span class="tok-kw">and</span>
                (value &lt;= -(<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">53</span>) <span class="tok-kw">or</span> value &gt;= (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">53</span>)))
            {
                <span class="tok-kw">try</span> self.stream.print(<span class="tok-str">&quot;\&quot;{}\&quot;&quot;</span>, .{value});
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">try</span> self.stream.print(<span class="tok-str">&quot;{}&quot;</span>, .{value});
            }
            self.valueDone();
            <span class="tok-kw">return</span>;
        },
        .<span class="tok-type">comptime_int</span> =&gt; {
            <span class="tok-kw">return</span> self.write(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(value, value), value));
        },
        .float, .<span class="tok-type">comptime_float</span> =&gt; {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-builtin">@floatCast</span>(value)) == value) {
                <span class="tok-kw">try</span> self.valueStart();
                <span class="tok-kw">try</span> self.stream.print(<span class="tok-str">&quot;{}&quot;</span>, .{<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-builtin">@floatCast</span>(value))});
                self.valueDone();
                <span class="tok-kw">return</span>;
            }
            <span class="tok-kw">try</span> self.valueStart();
            <span class="tok-kw">try</span> self.stream.print(<span class="tok-str">&quot;\&quot;{}\&quot;&quot;</span>, .{value});
            self.valueDone();
            <span class="tok-kw">return</span>;
        },

        .<span class="tok-type">bool</span> =&gt; {
            <span class="tok-kw">try</span> self.valueStart();
            <span class="tok-kw">try</span> self.stream.writeAll(<span class="tok-kw">if</span> (value) <span class="tok-str">&quot;true&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;false&quot;</span>);
            self.valueDone();
            <span class="tok-kw">return</span>;
        },
        .<span class="tok-null">null</span> =&gt; {
            <span class="tok-kw">try</span> self.valueStart();
            <span class="tok-kw">try</span> self.stream.writeAll(<span class="tok-str">&quot;null&quot;</span>);
            self.valueDone();
            <span class="tok-kw">return</span>;
        },
        .optional =&gt; {
            <span class="tok-kw">if</span> (value) |payload| {
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.write(payload);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.write(<span class="tok-null">null</span>);
            }
        },
        .@&quot;enum&quot; =&gt; |enum_info| {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonStringify&quot;</span>)) {
                <span class="tok-kw">return</span> value.jsonStringify(self);
            }

            <span class="tok-kw">if</span> (!enum_info.is_exhaustive) {
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (enum_info.fields) |field| {
                    <span class="tok-kw">if</span> (value == <span class="tok-builtin">@field</span>(T, field.name)) {
                        <span class="tok-kw">break</span>;
                    }
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> self.write(<span class="tok-builtin">@intFromEnum</span>(value));
                }
            }

            <span class="tok-kw">return</span> self.stringValue(<span class="tok-builtin">@tagName</span>(value));
        },
        .enum_literal =&gt; {
            <span class="tok-kw">return</span> self.stringValue(<span class="tok-builtin">@tagName</span>(value));
        },
        .@&quot;union&quot; =&gt; {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonStringify&quot;</span>)) {
                <span class="tok-kw">return</span> value.jsonStringify(self);
            }

            <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).@&quot;union&quot;;
            <span class="tok-kw">if</span> (info.tag_type) |UnionTagType| {
                <span class="tok-kw">try</span> self.beginObject();
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields) |u_field| {
                    <span class="tok-kw">if</span> (value == <span class="tok-builtin">@field</span>(UnionTagType, u_field.name)) {
                        <span class="tok-kw">try</span> self.objectField(u_field.name);
                        <span class="tok-kw">if</span> (u_field.<span class="tok-type">type</span> == <span class="tok-type">void</span>) {<span class="tok-comment">
                            // void value is {}
                            </span><span class="tok-kw">try</span> self.beginObject();
                            <span class="tok-kw">try</span> self.endObject();
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">try</span> self.write(<span class="tok-builtin">@field</span>(value, u_field.name));
                        }
                        <span class="tok-kw">break</span>;
                    }
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // No active tag?
                </span>}
                <span class="tok-kw">try</span> self.endObject();
                <span class="tok-kw">return</span>;
            } <span class="tok-kw">else</span> {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to stringify untagged union '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);
            }
        },
        .@&quot;struct&quot; =&gt; |S| {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonStringify&quot;</span>)) {
                <span class="tok-kw">return</span> value.jsonStringify(self);
            }

            <span class="tok-kw">if</span> (S.is_tuple) {
                <span class="tok-kw">try</span> self.beginArray();
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">try</span> self.beginObject();
            }
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (S.fields) |Field| {<span class="tok-comment">
                // don't include void fields
                </span><span class="tok-kw">if</span> (Field.<span class="tok-type">type</span> == <span class="tok-type">void</span>) <span class="tok-kw">continue</span>;

                <span class="tok-kw">var</span> emit_field = <span class="tok-null">true</span>;<span class="tok-comment">

                // don't include optional fields that are null when emit_null_optional_fields is set to false
                </span><span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(Field.<span class="tok-type">type</span>) == .optional) {
                    <span class="tok-kw">if</span> (self.options.emit_null_optional_fields == <span class="tok-null">false</span>) {
                        <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(value, Field.name) == <span class="tok-null">null</span>) {
                            emit_field = <span class="tok-null">false</span>;
                        }
                    }
                }

                <span class="tok-kw">if</span> (emit_field) {
                    <span class="tok-kw">if</span> (!S.is_tuple) {
                        <span class="tok-kw">try</span> self.objectField(Field.name);
                    }
                    <span class="tok-kw">try</span> self.write(<span class="tok-builtin">@field</span>(value, Field.name));
                }
            }
            <span class="tok-kw">if</span> (S.is_tuple) {
                <span class="tok-kw">try</span> self.endArray();
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">try</span> self.endObject();
            }
            <span class="tok-kw">return</span>;
        },
        .error_set =&gt; <span class="tok-kw">return</span> self.stringValue(<span class="tok-builtin">@errorName</span>(value)),
        .pointer =&gt; |ptr_info| <span class="tok-kw">switch</span> (ptr_info.size) {
            .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(ptr_info.child)) {
                .array =&gt; {<span class="tok-comment">
                    // Coerce `*[N]T` to `[]const T`.
                    </span><span class="tok-kw">const</span> Slice = []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(ptr_info.child);
                    <span class="tok-kw">return</span> self.write(<span class="tok-builtin">@as</span>(Slice, value));
                },
                <span class="tok-kw">else</span> =&gt; {
                    <span class="tok-kw">return</span> self.write(value.*);
                },
            },
            .many, .slice =&gt; {
                <span class="tok-kw">if</span> (ptr_info.size == .many <span class="tok-kw">and</span> ptr_info.sentinel() == <span class="tok-null">null</span>)
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unable to stringify type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;' without sentinel&quot;</span>);
                <span class="tok-kw">const</span> slice = <span class="tok-kw">if</span> (ptr_info.size == .many) <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(value) <span class="tok-kw">else</span> value;

                <span class="tok-kw">if</span> (ptr_info.child == <span class="tok-type">u8</span>) {<span class="tok-comment">
                    // This is a []const u8, or some similar Zig string.
                    </span><span class="tok-kw">if</span> (!self.options.emit_strings_as_arrays <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ValidateSlice">utf8ValidateSlice</a>(slice)) {
                        <span class="tok-kw">return</span> self.stringValue(slice);
                    }
                }

                <span class="tok-kw">try</span> self.beginArray();
                <span class="tok-kw">for</span> (slice) |x| {
                    <span class="tok-kw">try</span> self.write(x);
                }
                <span class="tok-kw">try</span> self.endArray();
                <span class="tok-kw">return</span>;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to stringify type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
        },
        .array =&gt; {<span class="tok-comment">
            // Coerce `[N]T` to `*const [N]T` (and then to `[]const T`).
            </span><span class="tok-kw">return</span> self.write(&amp;value);
        },
        .vector =&gt; |info| {
            <span class="tok-kw">const</span> array: [info.len]info.child = value;
            <span class="tok-kw">return</span> self.write(&amp;array);
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to stringify type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    }
    <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.WriteStream">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">WriteStream</span>(
    <span class="tok-kw">comptime</span> OutStream: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> safety_checks_hint: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        checked_to_arbitrary_depth,
        checked_to_fixed_depth: <span class="tok-type">usize</span>,<span class="tok-comment"> // Rounded up to the nearest multiple of 8.
        </span>assumed_correct,
    },
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-kw">const</span> build_mode_has_safety = <span class="tok-kw">switch</span> (<span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).mode) {
            .Debug, .ReleaseSafe =&gt; <span class="tok-null">true</span>,
            .ReleaseFast, .ReleaseSmall =&gt; <span class="tok-null">false</span>,
        };
        <span class="tok-kw">const</span> safety_checks: <span class="tok-builtin">@TypeOf</span>(safety_checks_hint) = <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>)
            safety_checks_hint
        <span class="tok-kw">else</span>
            .assumed_correct;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stream = OutStream;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
            .checked_to_arbitrary_depth =&gt; <a href="std.json.stringify.html#std.json.stringify.WriteStream.Stream">Stream</a>.<a href="#">Error</a> || <span class="tok-kw">error</span>{OutOfMemory},
            .checked_to_fixed_depth, .assumed_correct =&gt; <a href="std.json.stringify.html#std.json.stringify.WriteStream.Stream">Stream</a>.<a href="#">Error</a>,
        };

        options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,

        stream: OutStream,
        indent_level: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        next_punctuation: <span class="tok-kw">enum</span> {
            the_beginning,
            none,
            comma,
            colon,
        } = .the_beginning,

        nesting_stack: <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
            .checked_to_arbitrary_depth =&gt; <a href="std.BitStack.html">BitStack</a>,
            .checked_to_fixed_depth =&gt; |fixed_buffer_size| [(fixed_buffer_size + <span class="tok-number">7</span>) &gt;&gt; <span class="tok-number">3</span>]<span class="tok-type">u8</span>,
            .assumed_correct =&gt; <span class="tok-type">void</span>,
        },

        raw_streaming_mode: <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>)
            <span class="tok-kw">enum</span> { none, value, <a href="std.json.stringify.html#std.json.stringify.WriteStream.objectField">objectField</a> }
        <span class="tok-kw">else</span>
            <span class="tok-type">void</span> = <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) .none <span class="tok-kw">else</span> {},

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(safety_allocator: <a href="std.mem.Allocator.html">Allocator</a>, stream: OutStream, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a> {
            <span class="tok-kw">return</span> .{
                .options = options,
                .stream = stream,
                .nesting_stack = <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
                    .checked_to_arbitrary_depth =&gt; <a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.init">init</a>(safety_allocator),
                    .checked_to_fixed_depth =&gt; |fixed_buffer_size| [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** ((fixed_buffer_size + <span class="tok-number">7</span>) &gt;&gt; <span class="tok-number">3</span>),
                    .assumed_correct =&gt; {},
                },
            };
        }

        <span class="tok-comment">/// Only necessary with .checked_to_arbitrary_depth.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
                .checked_to_arbitrary_depth =&gt; self.nesting_stack.deinit(),
                .checked_to_fixed_depth, .assumed_correct =&gt; {},
            }
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginArray</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
            <span class="tok-kw">try</span> self.valueStart();
            <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">'['</span>);
            <span class="tok-kw">try</span> self.pushIndentation(<a href="std.json.stringify.html#std.json.stringify.ARRAY_MODE">ARRAY_MODE</a>);
            self.next_punctuation = .none;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginObject</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
            <span class="tok-kw">try</span> self.valueStart();
            <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">'{'</span>);
            <span class="tok-kw">try</span> self.pushIndentation(<a href="std.json.stringify.html#std.json.stringify.OBJECT_MODE">OBJECT_MODE</a>);
            self.next_punctuation = .none;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endArray</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
            self.popIndentation(<a href="std.json.stringify.html#std.json.stringify.ARRAY_MODE">ARRAY_MODE</a>);
            <span class="tok-kw">switch</span> (self.next_punctuation) {
                .none =&gt; {},
                .comma =&gt; {
                    <span class="tok-kw">try</span> self.indent();
                },
                .the_beginning, .colon =&gt; <span class="tok-kw">unreachable</span>,
            }
            <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">']'</span>);
            self.valueDone();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endObject</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
            self.popIndentation(<a href="std.json.stringify.html#std.json.stringify.OBJECT_MODE">OBJECT_MODE</a>);
            <span class="tok-kw">switch</span> (self.next_punctuation) {
                .none =&gt; {},
                .comma =&gt; {
                    <span class="tok-kw">try</span> self.indent();
                },
                .the_beginning, .colon =&gt; <span class="tok-kw">unreachable</span>,
            }
            <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">'}'</span>);
            self.valueDone();
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">pushIndentation</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, mode: <span class="tok-type">u1</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
                .checked_to_arbitrary_depth =&gt; {
                    <span class="tok-kw">try</span> self.nesting_stack.push(mode);
                    self.indent_level += <span class="tok-number">1</span>;
                },
                .checked_to_fixed_depth =&gt; {
                    <a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.pushWithStateAssumeCapacity">pushWithStateAssumeCapacity</a>(&amp;self.nesting_stack, &amp;self.indent_level, mode);
                },
                .assumed_correct =&gt; {
                    self.indent_level += <span class="tok-number">1</span>;
                },
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">popIndentation</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, assert_its_this_one: <span class="tok-type">u1</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
                .checked_to_arbitrary_depth =&gt; {
                    <a href="std.debug.html#std.debug.assert">assert</a>(self.nesting_stack.pop() == assert_its_this_one);
                    self.indent_level -= <span class="tok-number">1</span>;
                },
                .checked_to_fixed_depth =&gt; {
                    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.popWithState">popWithState</a>(&amp;self.nesting_stack, &amp;self.indent_level) == assert_its_this_one);
                },
                .assumed_correct =&gt; {
                    self.indent_level -= <span class="tok-number">1</span>;
                },
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">indent</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> char: <span class="tok-type">u8</span> = <span class="tok-str">' '</span>;
            <span class="tok-kw">const</span> n_chars = <span class="tok-kw">switch</span> (self.options.whitespace) {
                .minified =&gt; <span class="tok-kw">return</span>,
                .indent_1 =&gt; <span class="tok-number">1</span> * self.indent_level,
                .indent_2 =&gt; <span class="tok-number">2</span> * self.indent_level,
                .indent_3 =&gt; <span class="tok-number">3</span> * self.indent_level,
                .indent_4 =&gt; <span class="tok-number">4</span> * self.indent_level,
                .indent_8 =&gt; <span class="tok-number">8</span> * self.indent_level,
                .indent_tab =&gt; blk: {
                    char = <span class="tok-str">'\t'</span>;
                    <span class="tok-kw">break</span> :blk self.indent_level;
                },
            };
            <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">'\n'</span>);
            <span class="tok-kw">try</span> self.stream.writeByteNTimes(char, n_chars);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">valueStart</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.isObjectKeyExpected()) |is_it| <a href="std.debug.html#std.debug.assert">assert</a>(!is_it);<span class="tok-comment"> // Call objectField*(), not write(), for object keys.
            </span><span class="tok-kw">return</span> self.valueStartAssumeTypeOk();
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">objectFieldStart</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.isObjectKeyExpected()) |is_it| <a href="std.debug.html#std.debug.assert">assert</a>(is_it);<span class="tok-comment"> // Expected write(), not objectField*().
            </span><span class="tok-kw">return</span> self.valueStartAssumeTypeOk();
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">valueStartAssumeTypeOk</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(!self.isComplete());<span class="tok-comment"> // JSON document already complete.
            </span><span class="tok-kw">switch</span> (self.next_punctuation) {
                .the_beginning =&gt; {<span class="tok-comment">
                    // No indentation for the very beginning.
                </span>},
                .none =&gt; {<span class="tok-comment">
                    // First item in a container.
                    </span><span class="tok-kw">try</span> self.indent();
                },
                .comma =&gt; {<span class="tok-comment">
                    // Subsequent item in a container.
                    </span><span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">','</span>);
                    <span class="tok-kw">try</span> self.indent();
                },
                .colon =&gt; {
                    <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">':'</span>);
                    <span class="tok-kw">if</span> (self.options.whitespace != .minified) {
                        <span class="tok-kw">try</span> self.stream.writeByte(<span class="tok-str">' '</span>);
                    }
                },
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">valueDone</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span> {
            self.next_punctuation = .comma;
        }<span class="tok-comment">

        // Only when safety is enabled:
        </span><span class="tok-kw">fn</span> <span class="tok-fn">isObjectKeyExpected</span>(self: *<span class="tok-kw">const</span> <a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) ?<span class="tok-type">bool</span> {
            <span class="tok-kw">switch</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.safety_checks">safety_checks</a>) {
                .checked_to_arbitrary_depth =&gt; <span class="tok-kw">return</span> self.indent_level &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span>
                    self.nesting_stack.peek() == <a href="std.json.stringify.html#std.json.stringify.OBJECT_MODE">OBJECT_MODE</a> <span class="tok-kw">and</span>
                    self.next_punctuation != .colon,
                .checked_to_fixed_depth =&gt; <span class="tok-kw">return</span> self.indent_level &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span>
                    <a href="std.BitStack.html">BitStack</a>.<a href="std.BitStack.html#std.BitStack.peekWithState">peekWithState</a>(&amp;self.nesting_stack, self.indent_level) == <a href="std.json.stringify.html#std.json.stringify.OBJECT_MODE">OBJECT_MODE</a> <span class="tok-kw">and</span>
                    self.next_punctuation != .colon,
                .assumed_correct =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">isComplete</span>(self: *<span class="tok-kw">const</span> <a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.indent_level == <span class="tok-number">0</span> <span class="tok-kw">and</span> self.next_punctuation == .comma;
        }

        <span class="tok-comment">/// An alternative to calling `write` that formats a value with `std.fmt`.</span>
        <span class="tok-comment">/// This function does the usual punctuation and indentation formatting</span>
        <span class="tok-comment">/// assuming the resulting formatted string represents a single complete value;</span>
        <span class="tok-comment">/// e.g. `&quot;1&quot;`, `&quot;[]&quot;`, `&quot;[1,2]&quot;`, not `&quot;1,2&quot;`.</span>
        <span class="tok-comment">/// This function may be useful for doing your own number formatting.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
            <span class="tok-kw">try</span> self.valueStart();
            <span class="tok-kw">try</span> self.stream.print(fmt, args);
            self.valueDone();
        }

        <span class="tok-comment">/// An alternative to calling `write` that allows you to write directly to the `.stream` field, e.g. with `.stream.writeAll()`.</span>
        <span class="tok-comment">/// Call `beginWriteRaw()`, then write a complete value (including any quotes if necessary) directly to the `.stream` field,</span>
        <span class="tok-comment">/// then call `endWriteRaw()`.</span>
        <span class="tok-comment">/// This can be useful for streaming very long strings into the output without needing it all buffered in memory.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginWriteRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) {
                <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
                self.raw_streaming_mode = .value;
            }
            <span class="tok-kw">try</span> self.valueStart();
        }

        <span class="tok-comment">/// See `beginWriteRaw`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endWriteRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) {
                <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .value);
                self.raw_streaming_mode = .none;
            }
            self.valueDone();
        }

        <span class="tok-comment">/// See `WriteStream` for when to call this method.</span>
        <span class="tok-comment">/// `key` is the string content of the property name.</span>
        <span class="tok-comment">/// Surrounding quotes will be added and any special characters will be escaped.</span>
        <span class="tok-comment">/// See also `objectFieldRaw`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">objectField</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
            <span class="tok-kw">try</span> self.objectFieldStart();
            <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.encodeJsonString">encodeJsonString</a>(key, self.options, self.stream);
            self.next_punctuation = .colon;
        }
        <span class="tok-comment">/// See `WriteStream` for when to call this method.</span>
        <span class="tok-comment">/// `quoted_key` is the complete bytes of the key including quotes and any necessary escape sequences.</span>
        <span class="tok-comment">/// A few assertions are performed on the given value to ensure that the caller of this function understands the API contract.</span>
        <span class="tok-comment">/// See also `objectField`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">objectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, quoted_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
            <a href="std.debug.html#std.debug.assert">assert</a>(quoted_key.len &gt;= <span class="tok-number">2</span> <span class="tok-kw">and</span> quoted_key[<span class="tok-number">0</span>] == <span class="tok-str">'&quot;'</span> <span class="tok-kw">and</span> quoted_key[quoted_key.len - <span class="tok-number">1</span>] == <span class="tok-str">'&quot;'</span>);<span class="tok-comment"> // quoted_key should be &quot;quoted&quot;.
            </span><span class="tok-kw">try</span> self.objectFieldStart();
            <span class="tok-kw">try</span> self.stream.writeAll(quoted_key);
            self.next_punctuation = .colon;
        }

        <span class="tok-comment">/// In the rare case that you need to write very long object field names,</span>
        <span class="tok-comment">/// this is an alternative to `objectField` and `objectFieldRaw` that allows you to write directly to the `.stream` field</span>
        <span class="tok-comment">/// similar to `beginWriteRaw`.</span>
        <span class="tok-comment">/// Call `endObjectFieldRaw()` when you're done.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beginObjectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) {
                <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
                self.raw_streaming_mode = .objectField;
            }
            <span class="tok-kw">try</span> self.objectFieldStart();
        }

        <span class="tok-comment">/// See `beginObjectFieldRaw`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endObjectFieldRaw</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) {
                <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .objectField);
                self.raw_streaming_mode = .none;
            }
            self.next_punctuation = .colon;
        }

        <span class="tok-comment">/// Renders the given Zig value as JSON.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Supported types:</span>
        <span class="tok-comment">///  * Zig `bool` -&gt; JSON `true` or `false`.</span>
        <span class="tok-comment">///  * Zig `?T` -&gt; `null` or the rendering of `T`.</span>
        <span class="tok-comment">///  * Zig `i32`, `u64`, etc. -&gt; JSON number or string.</span>
        <span class="tok-comment">///      * When option `emit_nonportable_numbers_as_strings` is true, if the value is outside the range `+-1&lt;&lt;53` (the precise integer range of f64), it is rendered as a JSON string in base 10. Otherwise, it is rendered as JSON number.</span>
        <span class="tok-comment">///  * Zig floats -&gt; JSON number or string.</span>
        <span class="tok-comment">///      * If the value cannot be precisely represented by an f64, it is rendered as a JSON string. Otherwise, it is rendered as JSON number.</span>
        <span class="tok-comment">///      * TODO: Float rendering will likely change in the future, e.g. to remove the unnecessary &quot;e+00&quot;.</span>
        <span class="tok-comment">///  * Zig `[]const u8`, `[]u8`, `*[N]u8`, `@Vector(N, u8)`, and similar -&gt; JSON string.</span>
        <span class="tok-comment">///      * See `StringifyOptions.emit_strings_as_arrays`.</span>
        <span class="tok-comment">///      * If the content is not valid UTF-8, rendered as an array of numbers instead.</span>
        <span class="tok-comment">///  * Zig `[]T`, `[N]T`, `*[N]T`, `@Vector(N, T)`, and similar -&gt; JSON array of the rendering of each item.</span>
        <span class="tok-comment">///  * Zig tuple -&gt; JSON array of the rendering of each item.</span>
        <span class="tok-comment">///  * Zig `struct` -&gt; JSON object with each field in declaration order.</span>
        <span class="tok-comment">///      * If the struct declares a method `pub fn jsonStringify(self: *@This(), jw: anytype) !void`, it is called to do the serialization instead of the default behavior. The given `jw` is a pointer to this `WriteStream`. See `std.json.Value` for an example.</span>
        <span class="tok-comment">///      * See `StringifyOptions.emit_null_optional_fields`.</span>
        <span class="tok-comment">///  * Zig `union(enum)` -&gt; JSON object with one field named for the active tag and a value representing the payload.</span>
        <span class="tok-comment">///      * If the payload is `void`, then the emitted value is `{}`.</span>
        <span class="tok-comment">///      * If the union declares a method `pub fn jsonStringify(self: *@This(), jw: anytype) !void`, it is called to do the serialization instead of the default behavior. The given `jw` is a pointer to this `WriteStream`.</span>
        <span class="tok-comment">///  * Zig `enum` -&gt; JSON string naming the active tag.</span>
        <span class="tok-comment">///      * If the enum declares a method `pub fn jsonStringify(self: *@This(), jw: anytype) !void`, it is called to do the serialization instead of the default behavior. The given `jw` is a pointer to this `WriteStream`.</span>
        <span class="tok-comment">///      * If the enum is non-exhaustive, unnamed values are rendered as integers.</span>
        <span class="tok-comment">///  * Zig untyped enum literal -&gt; JSON string naming the active tag.</span>
        <span class="tok-comment">///  * Zig error -&gt; JSON string naming the error.</span>
        <span class="tok-comment">///  * Zig `*T` -&gt; the rendering of `T`. Note there is no guard against circular-reference infinite recursion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// See also alternative functions `print` and `beginWriteRaw`.</span>
        <span class="tok-comment">/// For writing object field names, use `objectField` instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, value: <span class="tok-kw">anytype</span>) <a href="std.json.stringify.html#std.json.stringify.WriteStream.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<a href="std.json.stringify.html#std.json.stringify.WriteStream.build_mode_has_safety">build_mode_has_safety</a>) <a href="std.debug.html#std.debug.assert">assert</a>(self.raw_streaming_mode == .none);
            <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(value);
            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
                .int =&gt; {
                    <span class="tok-kw">try</span> self.valueStart();
                    <span class="tok-kw">if</span> (self.options.emit_nonportable_numbers_as_strings <span class="tok-kw">and</span>
                        (value &lt;= -(<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">53</span>) <span class="tok-kw">or</span> value &gt;= (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">53</span>)))
                    {
                        <span class="tok-kw">try</span> self.stream.print(<span class="tok-str">&quot;\&quot;{}\&quot;&quot;</span>, .{value});
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">try</span> self.stream.print(<span class="tok-str">&quot;{}&quot;</span>, .{value});
                    }
                    self.valueDone();
                    <span class="tok-kw">return</span>;
                },
                .<span class="tok-type">comptime_int</span> =&gt; {
                    <span class="tok-kw">return</span> self.write(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(value, value), value));
                },
                .float, .<span class="tok-type">comptime_float</span> =&gt; {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-builtin">@floatCast</span>(value)) == value) {
                        <span class="tok-kw">try</span> self.valueStart();
                        <span class="tok-kw">try</span> self.stream.print(<span class="tok-str">&quot;{}&quot;</span>, .{<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-builtin">@floatCast</span>(value))});
                        self.valueDone();
                        <span class="tok-kw">return</span>;
                    }
                    <span class="tok-kw">try</span> self.valueStart();
                    <span class="tok-kw">try</span> self.stream.print(<span class="tok-str">&quot;\&quot;{}\&quot;&quot;</span>, .{value});
                    self.valueDone();
                    <span class="tok-kw">return</span>;
                },

                .<span class="tok-type">bool</span> =&gt; {
                    <span class="tok-kw">try</span> self.valueStart();
                    <span class="tok-kw">try</span> self.stream.writeAll(<span class="tok-kw">if</span> (value) <span class="tok-str">&quot;true&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;false&quot;</span>);
                    self.valueDone();
                    <span class="tok-kw">return</span>;
                },
                .<span class="tok-null">null</span> =&gt; {
                    <span class="tok-kw">try</span> self.valueStart();
                    <span class="tok-kw">try</span> self.stream.writeAll(<span class="tok-str">&quot;null&quot;</span>);
                    self.valueDone();
                    <span class="tok-kw">return</span>;
                },
                .optional =&gt; {
                    <span class="tok-kw">if</span> (value) |payload| {
                        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.write(payload);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.write(<span class="tok-null">null</span>);
                    }
                },
                .@&quot;enum&quot; =&gt; |enum_info| {
                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonStringify&quot;</span>)) {
                        <span class="tok-kw">return</span> value.jsonStringify(self);
                    }

                    <span class="tok-kw">if</span> (!enum_info.is_exhaustive) {
                        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (enum_info.fields) |field| {
                            <span class="tok-kw">if</span> (value == <span class="tok-builtin">@field</span>(T, field.name)) {
                                <span class="tok-kw">break</span>;
                            }
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">return</span> self.write(<span class="tok-builtin">@intFromEnum</span>(value));
                        }
                    }

                    <span class="tok-kw">return</span> self.stringValue(<span class="tok-builtin">@tagName</span>(value));
                },
                .enum_literal =&gt; {
                    <span class="tok-kw">return</span> self.stringValue(<span class="tok-builtin">@tagName</span>(value));
                },
                .@&quot;union&quot; =&gt; {
                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonStringify&quot;</span>)) {
                        <span class="tok-kw">return</span> value.jsonStringify(self);
                    }

                    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).@&quot;union&quot;;
                    <span class="tok-kw">if</span> (info.tag_type) |UnionTagType| {
                        <span class="tok-kw">try</span> self.beginObject();
                        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (info.fields) |u_field| {
                            <span class="tok-kw">if</span> (value == <span class="tok-builtin">@field</span>(UnionTagType, u_field.name)) {
                                <span class="tok-kw">try</span> self.objectField(u_field.name);
                                <span class="tok-kw">if</span> (u_field.<span class="tok-type">type</span> == <span class="tok-type">void</span>) {<span class="tok-comment">
                                    // void value is {}
                                    </span><span class="tok-kw">try</span> self.beginObject();
                                    <span class="tok-kw">try</span> self.endObject();
                                } <span class="tok-kw">else</span> {
                                    <span class="tok-kw">try</span> self.write(<span class="tok-builtin">@field</span>(value, u_field.name));
                                }
                                <span class="tok-kw">break</span>;
                            }
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // No active tag?
                        </span>}
                        <span class="tok-kw">try</span> self.endObject();
                        <span class="tok-kw">return</span>;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to stringify untagged union '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);
                    }
                },
                .@&quot;struct&quot; =&gt; |S| {
                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonStringify&quot;</span>)) {
                        <span class="tok-kw">return</span> value.jsonStringify(self);
                    }

                    <span class="tok-kw">if</span> (S.is_tuple) {
                        <span class="tok-kw">try</span> self.beginArray();
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">try</span> self.beginObject();
                    }
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (S.fields) |Field| {<span class="tok-comment">
                        // don't include void fields
                        </span><span class="tok-kw">if</span> (Field.<span class="tok-type">type</span> == <span class="tok-type">void</span>) <span class="tok-kw">continue</span>;

                        <span class="tok-kw">var</span> emit_field = <span class="tok-null">true</span>;<span class="tok-comment">

                        // don't include optional fields that are null when emit_null_optional_fields is set to false
                        </span><span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(Field.<span class="tok-type">type</span>) == .optional) {
                            <span class="tok-kw">if</span> (self.options.emit_null_optional_fields == <span class="tok-null">false</span>) {
                                <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(value, Field.name) == <span class="tok-null">null</span>) {
                                    emit_field = <span class="tok-null">false</span>;
                                }
                            }
                        }

                        <span class="tok-kw">if</span> (emit_field) {
                            <span class="tok-kw">if</span> (!S.is_tuple) {
                                <span class="tok-kw">try</span> self.objectField(Field.name);
                            }
                            <span class="tok-kw">try</span> self.write(<span class="tok-builtin">@field</span>(value, Field.name));
                        }
                    }
                    <span class="tok-kw">if</span> (S.is_tuple) {
                        <span class="tok-kw">try</span> self.endArray();
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">try</span> self.endObject();
                    }
                    <span class="tok-kw">return</span>;
                },
                .error_set =&gt; <span class="tok-kw">return</span> self.stringValue(<span class="tok-builtin">@errorName</span>(value)),
                .pointer =&gt; |ptr_info| <span class="tok-kw">switch</span> (ptr_info.size) {
                    .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(ptr_info.child)) {
                        .array =&gt; {<span class="tok-comment">
                            // Coerce `*[N]T` to `[]const T`.
                            </span><span class="tok-kw">const</span> Slice = []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(ptr_info.child);
                            <span class="tok-kw">return</span> self.write(<span class="tok-builtin">@as</span>(Slice, value));
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            <span class="tok-kw">return</span> self.write(value.*);
                        },
                    },
                    .many, .slice =&gt; {
                        <span class="tok-kw">if</span> (ptr_info.size == .many <span class="tok-kw">and</span> ptr_info.sentinel() == <span class="tok-null">null</span>)
                            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unable to stringify type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;' without sentinel&quot;</span>);
                        <span class="tok-kw">const</span> slice = <span class="tok-kw">if</span> (ptr_info.size == .many) <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(value) <span class="tok-kw">else</span> value;

                        <span class="tok-kw">if</span> (ptr_info.child == <span class="tok-type">u8</span>) {<span class="tok-comment">
                            // This is a []const u8, or some similar Zig string.
                            </span><span class="tok-kw">if</span> (!self.options.emit_strings_as_arrays <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ValidateSlice">utf8ValidateSlice</a>(slice)) {
                                <span class="tok-kw">return</span> self.stringValue(slice);
                            }
                        }

                        <span class="tok-kw">try</span> self.beginArray();
                        <span class="tok-kw">for</span> (slice) |x| {
                            <span class="tok-kw">try</span> self.write(x);
                        }
                        <span class="tok-kw">try</span> self.endArray();
                        <span class="tok-kw">return</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to stringify type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
                },
                .array =&gt; {<span class="tok-comment">
                    // Coerce `[N]T` to `*const [N]T` (and then to `[]const T`).
                    </span><span class="tok-kw">return</span> self.write(&amp;value);
                },
                .vector =&gt; |info| {
                    <span class="tok-kw">const</span> array: [info.len]info.child = value;
                    <span class="tok-kw">return</span> self.write(&amp;array);
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to stringify type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">stringValue</span>(self: *<a href="std.json.stringify.html#std.json.stringify.WriteStream">Self</a>, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.valueStart();
            <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.encodeJsonString">encodeJsonString</a>(s, self.options, self.stream);
            self.valueDone();
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.fmt.Formatter" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Formatter</span><a href="#src.zig-std.json.fmt.Formatter">[src]</a></h2><div class="tldDocs"><p>Formats the given value using stringify.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>value: T</code></pre></div><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.json.fmt.Formatter.format" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">format</span><a href="#src.zig-std.json.fmt.Formatter.format">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>( self: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> fmt_spec: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>, writer: <span class="tok-kw">anytype</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>fmt_spec: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.json.fmt.Formatter.format">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
    self: <span class="tok-builtin">@This</span>(),
    <span class="tok-kw">comptime</span> fmt_spec: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
    writer: <span class="tok-kw">anytype</span>,
) !<span class="tok-type">void</span> {
    _ = fmt_spec;
    _ = options;
    <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.stringify">stringify</a>(self.value, self.options, writer);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.fmt.Formatter">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Formatter</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        value: T,
        options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
            self: <span class="tok-builtin">@This</span>(),
            <span class="tok-kw">comptime</span> fmt_spec: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
            writer: <span class="tok-kw">anytype</span>,
        ) !<span class="tok-type">void</span> {
            _ = fmt_spec;
            _ = options;
            <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.stringify">stringify</a>(self.value, self.options, writer);
        }
    };
}</code></pre></details></div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.json.scanner.default_buffer_size" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">default_buffer_size</span><a href="#src.zig-std.json.scanner.default_buffer_size">[src]</a></h2><div class="tldDocs"><p>Used by <code>json.reader</code>.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.default_buffer_size">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_buffer_size = <span class="tok-number">0x1000</span></code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.default_max_value_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">default_max_value_len</span><a href="#src.zig-std.json.scanner.default_max_value_len">[src]</a></h2><div class="tldDocs"><p>For security, the maximum size allocated to store a single string or number value is limited to 4MiB by default.
This limit can be specified by calling <code>nextAllocMax()</code> instead of <code>nextAlloc()</code>.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.default_max_value_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_max_value_len = <span class="tok-number">4</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span></code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.json.scanner.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.json.scanner.Error">[src]</a></h2><div class="tldDocs"><p>The parsing errors are divided into two categories:</p>
<ul>
<li><code>SyntaxError</code> is for clearly malformed JSON documents,
such as giving an input document that isn't JSON at all.</li>
<li><code>UnexpectedEndOfInput</code> is for signaling that everything's been
valid so far, but the input appears to be truncated for some reason.
Note that a completely empty (or whitespace-only) input will give <code>UnexpectedEndOfInput</code>.</li>
</ul>
</div><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>SyntaxError</dt></div><div><dt>UnexpectedEndOfInput</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.Error">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{ SyntaxError, UnexpectedEndOfInput }</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.ParseFromValueError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ParseFromValueError</span><a href="#src.zig-std.json.static.ParseFromValueError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>DuplicateField</dt></div><div><dt>InvalidCharacter <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The input was empty or contained an invalid character</p>
</dd></div><div><dt>InvalidEnumTag</dt></div><div><dt>InvalidNumber</dt></div><div><dt>LengthMismatch</dt></div><div><dt>MissingField</dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>Overflow <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The result cannot fit in the type specified</p>
</dd></div><div><dt>UnexpectedToken</dt></div><div><dt>UnknownField</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.ParseFromValueError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseFromValueError = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a> || <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.parse_float.html#std.fmt.parse_float.ParseFloatError">ParseFloatError</a> || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <span class="tok-kw">error</span>{
    UnexpectedToken,
    InvalidNumber,
    Overflow,
    InvalidEnumTag,
    DuplicateField,
    UnknownField,
    MissingField,
    LengthMismatch,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.json.scanner.validate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">validate</span><a href="#src.zig-std.json.scanner.validate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validate</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Scan the input and check for malformed JSON.
On <code>SyntaxError</code> or <code>UnexpectedEndOfInput</code>, returns <code>false</code>.
Returns any errors from the allocator as-is, which is unlikely,
but can be caused by extreme nesting depth in the input.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.validate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validate</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> scanner = <a href="std.json.scanner.Scanner.html">Scanner</a>.<a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.initCompleteInput">initCompleteInput</a>(allocator, s);
    <span class="tok-kw">defer</span> scanner.deinit();

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> token = scanner.next() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.SyntaxError, <span class="tok-kw">error</span>.UnexpectedEndOfInput =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">error</span>.BufferUnderrun =&gt; <span class="tok-kw">unreachable</span>,
        };
        <span class="tok-kw">if</span> (token == .end_of_document) <span class="tok-kw">break</span>;
    }

    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.reader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reader</span><a href="#src.zig-std.json.scanner.reader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, io_reader: <span class="tok-kw">anytype</span>) <a href="std.json.scanner.html#std.json.scanner.Reader">Reader</a>(<a href="std.json.scanner.html#std.json.scanner.default_buffer_size">default_buffer_size</a>, <span class="tok-builtin">@TypeOf</span>(io_reader))</code></pre></div><div class="tldDocs"><p>Calls <code><a href="std.json.scanner.html#std.json.scanner.Reader">std.json.Reader</a></code> with <code><a href="std.json.scanner.html#std.json.scanner.default_buffer_size">std.json.default_buffer_size</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.reader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, io_reader: <span class="tok-kw">anytype</span>) <a href="std.json.scanner.html#std.json.scanner.Reader">Reader</a>(<a href="std.json.scanner.html#std.json.scanner.default_buffer_size">default_buffer_size</a>, <span class="tok-builtin">@TypeOf</span>(io_reader)) {
    <span class="tok-kw">return</span> <a href="std.json.scanner.html#std.json.scanner.Reader">Reader</a>(<a href="std.json.scanner.html#std.json.scanner.default_buffer_size">default_buffer_size</a>, <span class="tok-builtin">@TypeOf</span>(io_reader)).init(allocator, io_reader);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.scanner.isNumberFormattedLikeAnInteger" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isNumberFormattedLikeAnInteger</span><a href="#src.zig-std.json.scanner.isNumberFormattedLikeAnInteger">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNumberFormattedLikeAnInteger</span>(value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>For the slice you get from a <code>Token.number</code> or <code>Token.allocated_number</code>,
this function returns true if the number doesn't contain any fraction or exponent components, and is not <code>-0</code>.
Note, the numeric value encoded by the value may still be an integer, such as <code>1.0</code>.
This function is meant to give a hint about whether integer parsing or float parsing should be used on the value.
This function will not give meaningful results on non-numeric input.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.scanner.isNumberFormattedLikeAnInteger">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNumberFormattedLikeAnInteger</span>(value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, value, <span class="tok-str">&quot;-0&quot;</span>)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfAny">indexOfAny</a>(<span class="tok-type">u8</span>, value, <span class="tok-str">&quot;.eE&quot;</span>) == <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.parseFromSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseFromSlice</span><a href="#src.zig-std.json.static.parseFromSlice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromSlice</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>, ) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<a href="std.json.scanner.Scanner.html">Scanner</a>)!<a href="std.json.static.html#std.json.static.Parsed">Parsed</a>(T)</code></pre></div><div class="tldDocs"><p>Parses the json document from <code>s</code> and returns the result packaged in a <code><a href="std.json.static.html#std.json.static.Parsed">std.json.Parsed</a></code>.
You must call <code>deinit()</code> of the returned object to clean up allocated resources.
If you are using a <code><a href="std.heap.arena_allocator.ArenaAllocator.html">std.heap.ArenaAllocator</a></code> or similar, consider calling <code><a href="std.json.static.html#std.json.static.parseFromSliceLeaky">parseFromSliceLeaky</a></code> instead.
Note that <code>error.BufferUnderrun</code> is not actually possible to return from this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.parseFromSlice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromSlice</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>,
) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<a href="std.json.scanner.Scanner.html">Scanner</a>)!<a href="std.json.static.html#std.json.static.Parsed">Parsed</a>(T) {
    <span class="tok-kw">var</span> scanner = <a href="std.json.scanner.Scanner.html">Scanner</a>.<a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.initCompleteInput">initCompleteInput</a>(allocator, s);
    <span class="tok-kw">defer</span> scanner.deinit();

    <span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.parseFromTokenSource">parseFromTokenSource</a>(T, allocator, &amp;scanner, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.parseFromSliceLeaky" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseFromSliceLeaky</span><a href="#src.zig-std.json.static.parseFromSliceLeaky">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromSliceLeaky</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>, ) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<a href="std.json.scanner.Scanner.html">Scanner</a>)!T</code></pre></div><div class="tldDocs"><p>Parses the json document from <code>s</code> and returns the result.
Allocations made during this operation are not carefully tracked and may not be possible to individually clean up.
It is recommended to use a <code><a href="std.heap.arena_allocator.ArenaAllocator.html">std.heap.ArenaAllocator</a></code> or similar.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.parseFromSliceLeaky">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromSliceLeaky</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>,
) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<a href="std.json.scanner.Scanner.html">Scanner</a>)!T {
    <span class="tok-kw">var</span> scanner = <a href="std.json.scanner.Scanner.html">Scanner</a>.<a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.initCompleteInput">initCompleteInput</a>(allocator, s);
    <span class="tok-kw">defer</span> scanner.deinit();

    <span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.parseFromTokenSourceLeaky">parseFromTokenSourceLeaky</a>(T, allocator, &amp;scanner, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.parseFromTokenSource" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseFromTokenSource</span><a href="#src.zig-std.json.static.parseFromTokenSource">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromTokenSource</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, scanner_or_reader: <span class="tok-kw">anytype</span>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>, ) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*))!<a href="std.json.static.html#std.json.static.Parsed">Parsed</a>(T)</code></pre></div><div class="tldDocs"><p><code>scanner_or_reader</code> must be either a <code>*std.json.Scanner</code> with complete input or a <code>*std.json.Reader</code>.
Note that <code>error.BufferUnderrun</code> is not actually possible to return from this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.parseFromTokenSource">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromTokenSource</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    scanner_or_reader: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>,
) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*))!<a href="std.json.static.html#std.json.static.Parsed">Parsed</a>(T) {
    <span class="tok-kw">var</span> parsed = <a href="std.json.static.html#std.json.static.Parsed">Parsed</a>(T){
        .arena = <span class="tok-kw">try</span> allocator.create(<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>),
        .value = <span class="tok-null">undefined</span>,
    };
    <span class="tok-kw">errdefer</span> allocator.destroy(parsed.arena);
    parsed.arena.* = <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(allocator);
    <span class="tok-kw">errdefer</span> parsed.arena.deinit();

    parsed.value = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.parseFromTokenSourceLeaky">parseFromTokenSourceLeaky</a>(T, parsed.arena.allocator(), scanner_or_reader, options);

    <span class="tok-kw">return</span> parsed;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.parseFromTokenSourceLeaky" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseFromTokenSourceLeaky</span><a href="#src.zig-std.json.static.parseFromTokenSourceLeaky">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromTokenSourceLeaky</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, scanner_or_reader: <span class="tok-kw">anytype</span>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>, ) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*))!T</code></pre></div><div class="tldDocs"><p><code>scanner_or_reader</code> must be either a <code>*std.json.Scanner</code> with complete input or a <code>*std.json.Reader</code>.
Allocations made during this operation are not carefully tracked and may not be possible to individually clean up.
It is recommended to use a <code><a href="std.heap.arena_allocator.ArenaAllocator.html">std.heap.ArenaAllocator</a></code> or similar.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.parseFromTokenSourceLeaky">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromTokenSourceLeaky</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    scanner_or_reader: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>,
) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*))!T {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*) == <a href="std.json.scanner.Scanner.html">Scanner</a>) {
        <a href="std.debug.html#std.debug.assert">assert</a>(scanner_or_reader.is_end_of_input);
    }
    <span class="tok-kw">var</span> resolved_options = options;
    <span class="tok-kw">if</span> (resolved_options.max_value_len == <span class="tok-null">null</span>) {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*) == <a href="std.json.scanner.Scanner.html">Scanner</a>) {
            resolved_options.max_value_len = scanner_or_reader.input.len;
        } <span class="tok-kw">else</span> {
            resolved_options.max_value_len = <a href="std.json.scanner.html#std.json.scanner.default_max_value_len">default_max_value_len</a>;
        }
    }
    <span class="tok-kw">if</span> (resolved_options.allocate == <span class="tok-null">null</span>) {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(scanner_or_reader.*) == <a href="std.json.scanner.Scanner.html">Scanner</a>) {
            resolved_options.allocate = .alloc_if_needed;
        } <span class="tok-kw">else</span> {
            resolved_options.allocate = .alloc_always;
        }
    }

    <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(T, allocator, scanner_or_reader, resolved_options);

    <a href="std.debug.html#std.debug.assert">assert</a>(.end_of_document == <span class="tok-kw">try</span> scanner_or_reader.next());

    <span class="tok-kw">return</span> value;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.innerParse" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">innerParse</span><a href="#src.zig-std.json.static.innerParse">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">innerParse</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <span class="tok-kw">anytype</span>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>, ) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<span class="tok-builtin">@TypeOf</span>(source.*))!T</code></pre></div><div class="tldDocs"><p>This is an internal function called recursively
during the implementation of <code><a href="std.json.static.html#std.json.static.parseFromTokenSourceLeaky">parseFromTokenSourceLeaky</a></code> and similar.
It is exposed primarily to enable custom <code>jsonParse()</code> methods to call back into the <code>parseFrom*</code> system,
such as if you're implementing a custom container of type <code>T</code>;
you can call <code>innerParse(T, ...)</code> for each of the container's items.
Note that <code>null</code> fields are not allowed on the <code>options</code> when calling this function.
(The <code>options</code> you get in your <code>jsonParse</code> method has no <code>null</code> fields.)</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.innerParse">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">innerParse</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    source: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>,
) <a href="std.json.static.html#std.json.static.ParseError">ParseError</a>(<span class="tok-builtin">@TypeOf</span>(source.*))!T {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .<span class="tok-type">bool</span> =&gt; {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.next()) {
                .<span class="tok-null">true</span> =&gt; <span class="tok-null">true</span>,
                .<span class="tok-null">false</span> =&gt; <span class="tok-null">false</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.UnexpectedToken,
            };
        },
        .float, .<span class="tok-type">comptime_float</span> =&gt; {
            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);
            <span class="tok-kw">defer</span> <a href="std.json.static.html#std.json.static.freeAllocated">freeAllocated</a>(allocator, token);
            <span class="tok-kw">const</span> slice = <span class="tok-kw">switch</span> (token) {
                <span class="tok-kw">inline</span> .number, .allocated_number, .string, .allocated_string =&gt; |slice| slice,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            };
            <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.parse_float.html#std.fmt.parse_float.parseFloat">parseFloat</a>(T, slice);
        },
        .int, .<span class="tok-type">comptime_int</span> =&gt; {
            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);
            <span class="tok-kw">defer</span> <a href="std.json.static.html#std.json.static.freeAllocated">freeAllocated</a>(allocator, token);
            <span class="tok-kw">const</span> slice = <span class="tok-kw">switch</span> (token) {
                <span class="tok-kw">inline</span> .number, .allocated_number, .string, .allocated_string =&gt; |slice| slice,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            };
            <span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.sliceToInt">sliceToInt</a>(T, slice);
        },
        .optional =&gt; |optionalInfo| {
            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {
                .<span class="tok-null">null</span> =&gt; {
                    _ = <span class="tok-kw">try</span> source.next();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                },
                <span class="tok-kw">else</span> =&gt; {
                    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(optionalInfo.child, allocator, source, options);
                },
            }
        },
        .@&quot;enum&quot; =&gt; {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonParse&quot;</span>)) {
                <span class="tok-kw">return</span> T.jsonParse(allocator, source, options);
            }

            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);
            <span class="tok-kw">defer</span> <a href="std.json.static.html#std.json.static.freeAllocated">freeAllocated</a>(allocator, token);
            <span class="tok-kw">const</span> slice = <span class="tok-kw">switch</span> (token) {
                <span class="tok-kw">inline</span> .number, .allocated_number, .string, .allocated_string =&gt; |slice| slice,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            };
            <span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.sliceToEnum">sliceToEnum</a>(T, slice);
        },
        .@&quot;union&quot; =&gt; |unionInfo| {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonParse&quot;</span>)) {
                <span class="tok-kw">return</span> T.jsonParse(allocator, source, options);
            }

            <span class="tok-kw">if</span> (unionInfo.tag_type == <span class="tok-null">null</span>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into untagged union '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);

            <span class="tok-kw">if</span> (.object_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

            <span class="tok-kw">var</span> result: ?T = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> name_token: ?<a href="std.json.scanner.Token.html">Token</a> = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);
            <span class="tok-kw">const</span> field_name = <span class="tok-kw">switch</span> (name_token.?) {
                <span class="tok-kw">inline</span> .string, .allocated_string =&gt; |slice| slice,
                <span class="tok-kw">else</span> =&gt; {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
                },
            };

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (unionInfo.fields) |u_field| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, u_field.name, field_name)) {<span class="tok-comment">
                    // Free the name token now in case we're using an allocator that optimizes freeing the last allocated object.
                    // (Recursing into innerParse() might trigger more allocations.)
                    </span><a href="std.json.static.html#std.json.static.freeAllocated">freeAllocated</a>(allocator, name_token.?);
                    name_token = <span class="tok-null">null</span>;
                    <span class="tok-kw">if</span> (u_field.<span class="tok-type">type</span> == <span class="tok-type">void</span>) {<span class="tok-comment">
                        // void isn't really a json type, but we can support void payload union tags with {} as a value.
                        </span><span class="tok-kw">if</span> (.object_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
                        <span class="tok-kw">if</span> (.object_end != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
                        result = <span class="tok-builtin">@unionInit</span>(T, u_field.name, {});
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // Recurse.
                        </span>result = <span class="tok-builtin">@unionInit</span>(T, u_field.name, <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(u_field.<span class="tok-type">type</span>, allocator, source, options));
                    }
                    <span class="tok-kw">break</span>;
                }
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Didn't match anything.
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownField;
            }

            <span class="tok-kw">if</span> (.object_end != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

            <span class="tok-kw">return</span> result.?;
        },

        .@&quot;struct&quot; =&gt; |structInfo| {
            <span class="tok-kw">if</span> (structInfo.is_tuple) {
                <span class="tok-kw">if</span> (.array_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

                <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..structInfo.fields.len) |i| {
                    r[i] = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(structInfo.fields[i].<span class="tok-type">type</span>, allocator, source, options);
                }

                <span class="tok-kw">if</span> (.array_end != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

                <span class="tok-kw">return</span> r;
            }

            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonParse&quot;</span>)) {
                <span class="tok-kw">return</span> T.jsonParse(allocator, source, options);
            }

            <span class="tok-kw">if</span> (.object_begin != <span class="tok-kw">try</span> source.next()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

            <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> fields_seen = [_]<span class="tok-type">bool</span>{<span class="tok-null">false</span>} ** structInfo.fields.len;

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">var</span> name_token: ?<a href="std.json.scanner.Token.html">Token</a> = <span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);
                <span class="tok-kw">const</span> field_name = <span class="tok-kw">switch</span> (name_token.?) {
                    <span class="tok-kw">inline</span> .string, .allocated_string =&gt; |slice| slice,
                    .object_end =&gt; {<span class="tok-comment"> // No more fields.
                        </span><span class="tok-kw">break</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
                    },
                };

                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (structInfo.fields, <span class="tok-number">0</span>..) |field, i| {
                    <span class="tok-kw">if</span> (field.is_comptime) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;comptime fields are not supported: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;.&quot;</span> ++ field.name);
                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field.name, field_name)) {<span class="tok-comment">
                        // Free the name token now in case we're using an allocator that optimizes freeing the last allocated object.
                        // (Recursing into innerParse() might trigger more allocations.)
                        </span><a href="std.json.static.html#std.json.static.freeAllocated">freeAllocated</a>(allocator, name_token.?);
                        name_token = <span class="tok-null">null</span>;
                        <span class="tok-kw">if</span> (fields_seen[i]) {
                            <span class="tok-kw">switch</span> (options.duplicate_field_behavior) {
                                .use_first =&gt; {<span class="tok-comment">
                                    // Parse and ignore the redundant value.
                                    // We don't want to skip the value, because we want type checking.
                                    </span>_ = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(field.<span class="tok-type">type</span>, allocator, source, options);
                                    <span class="tok-kw">break</span>;
                                },
                                .@&quot;error&quot; =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DuplicateField,
                                .use_last =&gt; {},
                            }
                        }
                        <span class="tok-builtin">@field</span>(r, field.name) = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(field.<span class="tok-type">type</span>, allocator, source, options);
                        fields_seen[i] = <span class="tok-null">true</span>;
                        <span class="tok-kw">break</span>;
                    }
                } <span class="tok-kw">else</span> {<span class="tok-comment">
                    // Didn't match anything.
                    </span><a href="std.json.static.html#std.json.static.freeAllocated">freeAllocated</a>(allocator, name_token.?);
                    <span class="tok-kw">if</span> (options.ignore_unknown_fields) {
                        <span class="tok-kw">try</span> source.skipValue();
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownField;
                    }
                }
            }
            <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.fillDefaultStructValues">fillDefaultStructValues</a>(T, &amp;r, &amp;fields_seen);
            <span class="tok-kw">return</span> r;
        },

        .array =&gt; |arrayInfo| {
            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {
                .array_begin =&gt; {<span class="tok-comment">
                    // Typical array.
                    </span><span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.internalParseArray">internalParseArray</a>(T, arrayInfo.child, arrayInfo.len, allocator, source, options);
                },
                .string =&gt; {
                    <span class="tok-kw">if</span> (arrayInfo.child != <span class="tok-type">u8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;<span class="tok-comment">
                    // Fixed-length string.

                    </span><span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                        <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.next()) {
                            .string =&gt; |slice| {
                                <span class="tok-kw">if</span> (i + slice.len != r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;
                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..slice.len], slice);
                                <span class="tok-kw">break</span>;
                            },
                            .partial_string =&gt; |slice| {
                                <span class="tok-kw">if</span> (i + slice.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;
                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..slice.len], slice);
                                i += slice.len;
                            },
                            .partial_string_escaped_1 =&gt; |arr| {
                                <span class="tok-kw">if</span> (i + arr.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;
                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..arr.len], arr[<span class="tok-number">0</span>..]);
                                i += arr.len;
                            },
                            .partial_string_escaped_2 =&gt; |arr| {
                                <span class="tok-kw">if</span> (i + arr.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;
                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..arr.len], arr[<span class="tok-number">0</span>..]);
                                i += arr.len;
                            },
                            .partial_string_escaped_3 =&gt; |arr| {
                                <span class="tok-kw">if</span> (i + arr.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;
                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..arr.len], arr[<span class="tok-number">0</span>..]);
                                i += arr.len;
                            },
                            .partial_string_escaped_4 =&gt; |arr| {
                                <span class="tok-kw">if</span> (i + arr.len &gt; r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;
                                <span class="tok-builtin">@memcpy</span>(r[i..][<span class="tok-number">0</span>..arr.len], arr[<span class="tok-number">0</span>..]);
                                i += arr.len;
                            },
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }
                    }

                    <span class="tok-kw">return</span> r;
                },

                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            }
        },

        .vector =&gt; |vecInfo| {
            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {
                .array_begin =&gt; {
                    <span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.internalParseArray">internalParseArray</a>(T, vecInfo.child, vecInfo.len, allocator, source, options);
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            }
        },

        .pointer =&gt; |ptrInfo| {
            <span class="tok-kw">switch</span> (ptrInfo.size) {
                .one =&gt; {
                    <span class="tok-kw">const</span> r: *ptrInfo.child = <span class="tok-kw">try</span> allocator.create(ptrInfo.child);
                    r.* = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(ptrInfo.child, allocator, source, options);
                    <span class="tok-kw">return</span> r;
                },
                .slice =&gt; {
                    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {
                        .array_begin =&gt; {
                            _ = <span class="tok-kw">try</span> source.next();<span class="tok-comment">

                            // Typical array.
                            </span><span class="tok-kw">var</span> arraylist = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(ptrInfo.child).init(allocator);
                            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.peekNextTokenType()) {
                                    .array_end =&gt; {
                                        _ = <span class="tok-kw">try</span> source.next();
                                        <span class="tok-kw">break</span>;
                                    },
                                    <span class="tok-kw">else</span> =&gt; {},
                                }

                                <span class="tok-kw">try</span> arraylist.ensureUnusedCapacity(<span class="tok-number">1</span>);
                                arraylist.appendAssumeCapacity(<span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParse">innerParse</a>(ptrInfo.child, allocator, source, options));
                            }

                            <span class="tok-kw">if</span> (ptrInfo.sentinel()) |s| {
                                <span class="tok-kw">return</span> <span class="tok-kw">try</span> arraylist.toOwnedSliceSentinel(s);
                            }

                            <span class="tok-kw">return</span> <span class="tok-kw">try</span> arraylist.toOwnedSlice();
                        },
                        .string =&gt; {
                            <span class="tok-kw">if</span> (ptrInfo.child != <span class="tok-type">u8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;<span class="tok-comment">

                            // Dynamic length string.
                            </span><span class="tok-kw">if</span> (ptrInfo.sentinel()) |s| {<span class="tok-comment">
                                // Use our own array list so we can append the sentinel.
                                </span><span class="tok-kw">var</span> value_list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
                                _ = <span class="tok-kw">try</span> source.allocNextIntoArrayList(&amp;value_list, .alloc_always);
                                <span class="tok-kw">return</span> <span class="tok-kw">try</span> value_list.toOwnedSliceSentinel(s);
                            }
                            <span class="tok-kw">if</span> (ptrInfo.is_const) {
                                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.nextAllocMax(allocator, options.allocate.?, options.max_value_len.?)) {
                                    <span class="tok-kw">inline</span> .string, .allocated_string =&gt; |slice| <span class="tok-kw">return</span> slice,
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                }
                            } <span class="tok-kw">else</span> {<span class="tok-comment">
                                // Have to allocate to get a mutable copy.
                                </span><span class="tok-kw">switch</span> (<span class="tok-kw">try</span> source.nextAllocMax(allocator, .alloc_always, options.max_value_len.?)) {
                                    .allocated_string =&gt; |slice| <span class="tok-kw">return</span> slice,
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                }
                            }
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
                    }
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    }
    <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.parseFromValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseFromValue</span><a href="#src.zig-std.json.static.parseFromValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromValue</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <a href="std.json.dynamic.Value.html">Value</a>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>, ) <a href="std.json.static.html#std.json.static.ParseFromValueError">ParseFromValueError</a>!<a href="std.json.static.html#std.json.static.Parsed">Parsed</a>(T)</code></pre></div><div class="tldDocs"><p>Like <code><a href="std.json.static.html#std.json.static.parseFromSlice">parseFromSlice</a></code>, but the input is an already-parsed <code><a href="std.json.dynamic.Value.html">std.json.Value</a></code> object.
Only <code>options.ignore_unknown_fields</code> is used from <code>options</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>source: <a href="std.json.dynamic.Value.html">Value</a></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.parseFromValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromValue</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    source: <a href="std.json.dynamic.Value.html">Value</a>,
    options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>,
) <a href="std.json.static.html#std.json.static.ParseFromValueError">ParseFromValueError</a>!<a href="std.json.static.html#std.json.static.Parsed">Parsed</a>(T) {
    <span class="tok-kw">var</span> parsed = <a href="std.json.static.html#std.json.static.Parsed">Parsed</a>(T){
        .arena = <span class="tok-kw">try</span> allocator.create(<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>),
        .value = <span class="tok-null">undefined</span>,
    };
    <span class="tok-kw">errdefer</span> allocator.destroy(parsed.arena);
    parsed.arena.* = <a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(allocator);
    <span class="tok-kw">errdefer</span> parsed.arena.deinit();

    parsed.value = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.parseFromValueLeaky">parseFromValueLeaky</a>(T, parsed.arena.allocator(), source, options);

    <span class="tok-kw">return</span> parsed;
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.parseFromValueLeaky" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseFromValueLeaky</span><a href="#src.zig-std.json.static.parseFromValueLeaky">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromValueLeaky</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <a href="std.json.dynamic.Value.html">Value</a>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>, ) <a href="std.json.static.html#std.json.static.ParseFromValueError">ParseFromValueError</a>!T</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>source: <a href="std.json.dynamic.Value.html">Value</a></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.parseFromValueLeaky">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseFromValueLeaky</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    source: <a href="std.json.dynamic.Value.html">Value</a>,
    options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>,
) <a href="std.json.static.html#std.json.static.ParseFromValueError">ParseFromValueError</a>!T {<span class="tok-comment">
    // I guess this function doesn't need to exist,
    // but the flow of the sourcecode is easy to follow and grouped nicely with
    // this pub redirect function near the top and the implementation near the bottom.
    </span><span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(T, allocator, source, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.static.innerParseFromValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">innerParseFromValue</span><a href="#src.zig-std.json.static.innerParseFromValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">innerParseFromValue</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, source: <a href="std.json.dynamic.Value.html">Value</a>, options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>, ) <a href="std.json.static.html#std.json.static.ParseFromValueError">ParseFromValueError</a>!T</code></pre></div><div class="tldDocs"><p>This is an internal function called recursively
during the implementation of <code><a href="std.json.static.html#std.json.static.parseFromValueLeaky">parseFromValueLeaky</a></code>.
It is exposed primarily to enable custom <code>jsonParseFromValue()</code> methods to call back into the <code>parseFromValue*</code> system,
such as if you're implementing a custom container of type <code>T</code>;
you can call <code>innerParseFromValue(T, ...)</code> for each of the container's items.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>source: <a href="std.json.dynamic.Value.html">Value</a></code></pre></div><div><pre><code>options: <a href="std.json.static.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.static.innerParseFromValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">innerParseFromValue</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    source: <a href="std.json.dynamic.Value.html">Value</a>,
    options: <a href="std.json.static.ParseOptions.html">ParseOptions</a>,
) <a href="std.json.static.html#std.json.static.ParseFromValueError">ParseFromValueError</a>!T {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .<span class="tok-type">bool</span> =&gt; {
            <span class="tok-kw">switch</span> (source) {
                .<span class="tok-type">bool</span> =&gt; |b| <span class="tok-kw">return</span> b,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            }
        },
        .float, .<span class="tok-type">comptime_float</span> =&gt; {
            <span class="tok-kw">switch</span> (source) {
                .float =&gt; |f| <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@floatCast</span>(f)),
                .integer =&gt; |i| <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@floatFromInt</span>(i)),
                .number_string, .string =&gt; |s| <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.parse_float.html#std.fmt.parse_float.parseFloat">parseFloat</a>(T, s),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            }
        },
        .int, .<span class="tok-type">comptime_int</span> =&gt; {
            <span class="tok-kw">switch</span> (source) {
                .float =&gt; |f| {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@round</span>(f) != f) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidNumber;
                    <span class="tok-kw">if</span> (f &gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(T)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    <span class="tok-kw">if</span> (f &lt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(T)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intFromFloat</span>(f));
                },
                .integer =&gt; |i| {
                    <span class="tok-kw">if</span> (i &gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(T)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    <span class="tok-kw">if</span> (i &lt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(T)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>(i));
                },
                .number_string, .string =&gt; |s| {
                    <span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.sliceToInt">sliceToInt</a>(T, s);
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            }
        },
        .optional =&gt; |optionalInfo| {
            <span class="tok-kw">switch</span> (source) {
                .<span class="tok-null">null</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(optionalInfo.child, allocator, source, options),
            }
        },
        .@&quot;enum&quot; =&gt; {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonParseFromValue&quot;</span>)) {
                <span class="tok-kw">return</span> T.jsonParseFromValue(allocator, source, options);
            }

            <span class="tok-kw">switch</span> (source) {
                .float =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnumTag,
                .integer =&gt; |i| <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(T, i),
                .number_string, .string =&gt; |s| <span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.sliceToEnum">sliceToEnum</a>(T, s),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            }
        },
        .@&quot;union&quot; =&gt; |unionInfo| {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonParseFromValue&quot;</span>)) {
                <span class="tok-kw">return</span> T.jsonParseFromValue(allocator, source, options);
            }

            <span class="tok-kw">if</span> (unionInfo.tag_type == <span class="tok-null">null</span>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into untagged union '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);

            <span class="tok-kw">if</span> (source != .object) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
            <span class="tok-kw">if</span> (source.object.count() != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

            <span class="tok-kw">var</span> it = source.object.iterator();
            <span class="tok-kw">const</span> kv = it.next().?;
            <span class="tok-kw">const</span> field_name = kv.key_ptr.*;

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (unionInfo.fields) |u_field| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, u_field.name, field_name)) {
                    <span class="tok-kw">if</span> (u_field.<span class="tok-type">type</span> == <span class="tok-type">void</span>) {<span class="tok-comment">
                        // void isn't really a json type, but we can support void payload union tags with {} as a value.
                        </span><span class="tok-kw">if</span> (kv.value_ptr.* != .object) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
                        <span class="tok-kw">if</span> (kv.value_ptr.*.object.count() != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
                        <span class="tok-kw">return</span> <span class="tok-builtin">@unionInit</span>(T, u_field.name, {});
                    }<span class="tok-comment">
                    // Recurse.
                    </span><span class="tok-kw">return</span> <span class="tok-builtin">@unionInit</span>(T, u_field.name, <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(u_field.<span class="tok-type">type</span>, allocator, kv.value_ptr.*, options));
                }
            }<span class="tok-comment">
            // Didn't match anything.
            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownField;
        },

        .@&quot;struct&quot; =&gt; |structInfo| {
            <span class="tok-kw">if</span> (structInfo.is_tuple) {
                <span class="tok-kw">if</span> (source != .array) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;
                <span class="tok-kw">if</span> (source.array.items.len != structInfo.fields.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

                <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..structInfo.fields.len, source.array.items) |i, item| {
                    r[i] = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(structInfo.fields[i].<span class="tok-type">type</span>, allocator, item, options);
                }

                <span class="tok-kw">return</span> r;
            }

            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasFn">hasFn</a>(T, <span class="tok-str">&quot;jsonParseFromValue&quot;</span>)) {
                <span class="tok-kw">return</span> T.jsonParseFromValue(allocator, source, options);
            }

            <span class="tok-kw">if</span> (source != .object) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;

            <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> fields_seen = [_]<span class="tok-type">bool</span>{<span class="tok-null">false</span>} ** structInfo.fields.len;

            <span class="tok-kw">var</span> it = source.object.iterator();
            <span class="tok-kw">while</span> (it.next()) |kv| {
                <span class="tok-kw">const</span> field_name = kv.key_ptr.*;

                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (structInfo.fields, <span class="tok-number">0</span>..) |field, i| {
                    <span class="tok-kw">if</span> (field.is_comptime) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;comptime fields are not supported: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;.&quot;</span> ++ field.name);
                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field.name, field_name)) {
                        <a href="std.debug.html#std.debug.assert">assert</a>(!fields_seen[i]);<span class="tok-comment"> // Can't have duplicate keys in a Value.object.
                        </span><span class="tok-builtin">@field</span>(r, field.name) = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(field.<span class="tok-type">type</span>, allocator, kv.value_ptr.*, options);
                        fields_seen[i] = <span class="tok-null">true</span>;
                        <span class="tok-kw">break</span>;
                    }
                } <span class="tok-kw">else</span> {<span class="tok-comment">
                    // Didn't match anything.
                    </span><span class="tok-kw">if</span> (!options.ignore_unknown_fields) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownField;
                }
            }
            <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.fillDefaultStructValues">fillDefaultStructValues</a>(T, &amp;r, &amp;fields_seen);
            <span class="tok-kw">return</span> r;
        },

        .array =&gt; |arrayInfo| {
            <span class="tok-kw">switch</span> (source) {
                .array =&gt; |array| {<span class="tok-comment">
                    // Typical array.
                    </span><span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.innerParseArrayFromArrayValue">innerParseArrayFromArrayValue</a>(T, arrayInfo.child, arrayInfo.len, allocator, array, options);
                },
                .string =&gt; |s| {
                    <span class="tok-kw">if</span> (arrayInfo.child != <span class="tok-type">u8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;<span class="tok-comment">
                    // Fixed-length string.

                    </span><span class="tok-kw">if</span> (s.len != arrayInfo.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.LengthMismatch;

                    <span class="tok-kw">var</span> r: T = <span class="tok-null">undefined</span>;
                    <span class="tok-builtin">@memcpy</span>(r[<span class="tok-number">0</span>..], s);
                    <span class="tok-kw">return</span> r;
                },

                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            }
        },

        .vector =&gt; |vecInfo| {
            <span class="tok-kw">switch</span> (source) {
                .array =&gt; |array| {
                    <span class="tok-kw">return</span> <a href="std.json.static.html#std.json.static.innerParseArrayFromArrayValue">innerParseArrayFromArrayValue</a>(T, vecInfo.child, vecInfo.len, allocator, array, options);
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
            }
        },

        .pointer =&gt; |ptrInfo| {
            <span class="tok-kw">switch</span> (ptrInfo.size) {
                .one =&gt; {
                    <span class="tok-kw">const</span> r: *ptrInfo.child = <span class="tok-kw">try</span> allocator.create(ptrInfo.child);
                    r.* = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(ptrInfo.child, allocator, source, options);
                    <span class="tok-kw">return</span> r;
                },
                .slice =&gt; {
                    <span class="tok-kw">switch</span> (source) {
                        .array =&gt; |array| {
                            <span class="tok-kw">const</span> r = <span class="tok-kw">if</span> (ptrInfo.sentinel()) |sentinel|
                                <span class="tok-kw">try</span> allocator.allocSentinel(ptrInfo.child, array.items.len, sentinel)
                            <span class="tok-kw">else</span>
                                <span class="tok-kw">try</span> allocator.alloc(ptrInfo.child, array.items.len);

                            <span class="tok-kw">for</span> (array.items, r) |item, *dest| {
                                dest.* = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.innerParseFromValue">innerParseFromValue</a>(ptrInfo.child, allocator, item, options);
                            }

                            <span class="tok-kw">return</span> r;
                        },
                        .string =&gt; |s| {
                            <span class="tok-kw">if</span> (ptrInfo.child != <span class="tok-type">u8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken;<span class="tok-comment">
                            // Dynamic length string.

                            </span><span class="tok-kw">const</span> r = <span class="tok-kw">if</span> (ptrInfo.sentinel()) |sentinel|
                                <span class="tok-kw">try</span> allocator.allocSentinel(ptrInfo.child, s.len, sentinel)
                            <span class="tok-kw">else</span>
                                <span class="tok-kw">try</span> allocator.alloc(ptrInfo.child, s.len);
                            <span class="tok-builtin">@memcpy</span>(r[<span class="tok-number">0</span>..], s);

                            <span class="tok-kw">return</span> r;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedToken,
                    }
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to parse into type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.stringify" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringify</span><a href="#src.zig-std.json.stringify.stringify">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringify</span>( value: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, out_stream: <span class="tok-kw">anytype</span>, ) <span class="tok-builtin">@TypeOf</span>(out_stream).Error!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Writes the given value to the <code><a href="std.io.html#std.io.GenericWriter">std.io.Writer</a></code> stream.
See <code><a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a></code> for how the given value is serialized into JSON.
The maximum nesting depth of the output JSON document is 256.
See also <code><a href="std.json.stringify.html#std.json.stringify.stringifyMaxDepth">stringifyMaxDepth</a></code> and <code><a href="std.json.stringify.html#std.json.stringify.stringifyArbitraryDepth">stringifyArbitraryDepth</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.stringify">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringify</span>(
    value: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,
    out_stream: <span class="tok-kw">anytype</span>,
) <span class="tok-builtin">@TypeOf</span>(out_stream).Error!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> jw = <a href="std.json.stringify.html#std.json.stringify.writeStream">writeStream</a>(out_stream, options);
    <span class="tok-kw">defer</span> jw.deinit();
    <span class="tok-kw">try</span> jw.write(value);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.stringifyMaxDepth" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringifyMaxDepth</span><a href="#src.zig-std.json.stringify.stringifyMaxDepth">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringifyMaxDepth</span>( value: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, out_stream: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> max_depth: ?<span class="tok-type">usize</span>, ) <span class="tok-builtin">@TypeOf</span>(out_stream).Error!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code><a href="std.json.stringify.html#std.json.stringify.stringify">stringify</a></code> with configurable nesting depth.
<code>max_depth</code> is rounded up to the nearest multiple of 8.
Give <code>null</code> for <code>max_depth</code> to disable some safety checks and allow arbitrary nesting depth.
See <code><a href="std.json.stringify.html#std.json.stringify.writeStreamMaxDepth">writeStreamMaxDepth</a></code> for more info.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div><div><pre><code>max_depth: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.stringifyMaxDepth">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringifyMaxDepth</span>(
    value: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,
    out_stream: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> max_depth: ?<span class="tok-type">usize</span>,
) <span class="tok-builtin">@TypeOf</span>(out_stream).Error!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> jw = <a href="std.json.stringify.html#std.json.stringify.writeStreamMaxDepth">writeStreamMaxDepth</a>(out_stream, options, max_depth);
    <span class="tok-kw">try</span> jw.write(value);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.stringifyArbitraryDepth" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringifyArbitraryDepth</span><a href="#src.zig-std.json.stringify.stringifyArbitraryDepth">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringifyArbitraryDepth</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, out_stream: <span class="tok-kw">anytype</span>, ) <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(<span class="tok-builtin">@TypeOf</span>(out_stream), .checked_to_arbitrary_depth).Error!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code><a href="std.json.stringify.html#std.json.stringify.stringify">stringify</a></code> but takes an allocator to facilitate safety checks while allowing arbitrary nesting depth.
These safety checks can be helpful when debugging custom <code>jsonStringify</code> implementations;
See <code><a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.stringifyArbitraryDepth">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringifyArbitraryDepth</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    value: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,
    out_stream: <span class="tok-kw">anytype</span>,
) <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(<span class="tok-builtin">@TypeOf</span>(out_stream), .checked_to_arbitrary_depth).Error!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> jw = <a href="std.json.stringify.html#std.json.stringify.writeStreamArbitraryDepth">writeStreamArbitraryDepth</a>(allocator, out_stream, options);
    <span class="tok-kw">defer</span> jw.deinit();
    <span class="tok-kw">try</span> jw.write(value);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.stringifyAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringifyAlloc</span><a href="#src.zig-std.json.stringify.stringifyAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringifyAlloc</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, ) <span class="tok-kw">error</span>{OutOfMemory}![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Calls <code><a href="std.json.stringify.html#std.json.stringify.stringifyArbitraryDepth">stringifyArbitraryDepth</a></code> and stores the result in dynamically allocated memory
instead of taking a <code><a href="std.io.html#std.io.GenericWriter">std.io.Writer</a></code>.</p>
<p>Caller owns returned memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.stringifyAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringifyAlloc</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    value: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,
) <span class="tok-kw">error</span>{OutOfMemory}![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> list = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
    <span class="tok-kw">errdefer</span> list.deinit();
    <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.stringifyArbitraryDepth">stringifyArbitraryDepth</a>(allocator, value, options, list.writer());
    <span class="tok-kw">return</span> list.toOwnedSlice();
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.writeStream" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeStream</span><a href="#src.zig-std.json.stringify.writeStream">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStream</span>( out_stream: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, ) <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(<span class="tok-builtin">@TypeOf</span>(out_stream), .{ .checked_to_fixed_depth = <span class="tok-number">256</span> })</code></pre></div><div class="tldDocs"><p>See <code><a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a></code> for documentation.
Equivalent to calling <code><a href="std.json.stringify.html#std.json.stringify.writeStreamMaxDepth">writeStreamMaxDepth</a></code> with a depth of <code>256</code>.</p>
<p>The caller does <em>not</em> need to call <code>deinit()</code> on the returned object.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.writeStream">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStream</span>(
    out_stream: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,
) <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(<span class="tok-builtin">@TypeOf</span>(out_stream), .{ .checked_to_fixed_depth = <span class="tok-number">256</span> }) {
    <span class="tok-kw">return</span> <a href="std.json.stringify.html#std.json.stringify.writeStreamMaxDepth">writeStreamMaxDepth</a>(out_stream, options, <span class="tok-number">256</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.writeStreamMaxDepth" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeStreamMaxDepth</span><a href="#src.zig-std.json.stringify.writeStreamMaxDepth">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStreamMaxDepth</span>( out_stream: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, <span class="tok-kw">comptime</span> max_depth: ?<span class="tok-type">usize</span>, ) <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>( <span class="tok-builtin">@TypeOf</span>(out_stream), <span class="tok-kw">if</span> (max_depth) |d| .{ .checked_to_fixed_depth = d } <span class="tok-kw">else</span> .assumed_correct, )</code></pre></div><div class="tldDocs"><p>See <code><a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a></code> for documentation.
The returned object includes 1 bit of size per <code>max_depth</code> to enable safety checks on the order of method calls;
see the grammar in the <code><a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a></code> documentation.
<code>max_depth</code> is rounded up to the nearest multiple of 8.
If the nesting depth exceeds <code>max_depth</code>, it is detectable illegal behavior.
Give <code>null</code> for <code>max_depth</code> to disable safety checks for the grammar and allow arbitrary nesting depth.
In <code>ReleaseFast</code> and <code>ReleaseSmall</code>, <code>max_depth</code> is ignored, effectively equivalent to passing <code>null</code>.
Alternatively, see <code><a href="std.json.stringify.html#std.json.stringify.writeStreamArbitraryDepth">writeStreamArbitraryDepth</a></code> to do safety checks to arbitrary depth.</p>
<p>The caller does <em>not</em> need to call <code>deinit()</code> on the returned object.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div><div><pre><code>max_depth: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.writeStreamMaxDepth">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStreamMaxDepth</span>(
    out_stream: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,
    <span class="tok-kw">comptime</span> max_depth: ?<span class="tok-type">usize</span>,
) <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(
    <span class="tok-builtin">@TypeOf</span>(out_stream),
    <span class="tok-kw">if</span> (max_depth) |d| .{ .checked_to_fixed_depth = d } <span class="tok-kw">else</span> .assumed_correct,
) {
    <span class="tok-kw">return</span> <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(
        <span class="tok-builtin">@TypeOf</span>(out_stream),
        <span class="tok-kw">if</span> (max_depth) |d| .{ .checked_to_fixed_depth = d } <span class="tok-kw">else</span> .assumed_correct,
    ).init(<span class="tok-null">undefined</span>, out_stream, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.writeStreamArbitraryDepth" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeStreamArbitraryDepth</span><a href="#src.zig-std.json.stringify.writeStreamArbitraryDepth">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStreamArbitraryDepth</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, out_stream: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, ) <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(<span class="tok-builtin">@TypeOf</span>(out_stream), .checked_to_arbitrary_depth)</code></pre></div><div class="tldDocs"><p>See <code><a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a></code> for documentation.
This version of the write stream enables safety checks to arbitrarily deep nesting levels
by using the given allocator.
The caller should call <code>deinit()</code> on the returned object to free allocated memory.</p>
<p>In <code>ReleaseFast</code> and <code>ReleaseSmall</code> mode, this function is effectively equivalent to calling <code>writeStreamMaxDepth(..., null)</code>;
in those build modes, the allocator is <em>not used</em>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.writeStreamArbitraryDepth">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStreamArbitraryDepth</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    out_stream: <span class="tok-kw">anytype</span>,
    options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>,
) <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(<span class="tok-builtin">@TypeOf</span>(out_stream), .checked_to_arbitrary_depth) {
    <span class="tok-kw">return</span> <a href="std.json.stringify.html#std.json.stringify.WriteStream">WriteStream</a>(<span class="tok-builtin">@TypeOf</span>(out_stream), .checked_to_arbitrary_depth).init(allocator, out_stream, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.encodeJsonString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">encodeJsonString</span><a href="#src.zig-std.json.stringify.encodeJsonString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">encodeJsonString</span>(string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>string</code> to <code>writer</code> as a JSON encoded string.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.encodeJsonString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">encodeJsonString</span>(string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\&quot;'</span>);
    <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.encodeJsonStringChars">encodeJsonStringChars</a>(string, options, writer);
    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\&quot;'</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.stringify.encodeJsonStringChars" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">encodeJsonStringChars</span><a href="#src.zig-std.json.stringify.encodeJsonStringChars">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">encodeJsonStringChars</span>(chars: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>chars</code> to <code>writer</code> as JSON encoded string characters.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>chars: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.stringify.encodeJsonStringChars">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">encodeJsonStringChars</span>(chars: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> write_cursor: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (options.escape_unicode) {
        <span class="tok-kw">while</span> (i &lt; chars.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">switch</span> (chars[i]) {<span class="tok-comment">
                // normal ascii character
                </span><span class="tok-number">0x20</span>...<span class="tok-number">0x21</span>, <span class="tok-number">0x23</span>...<span class="tok-number">0x5B</span>, <span class="tok-number">0x5D</span>...<span class="tok-number">0x7E</span> =&gt; {},
                <span class="tok-number">0x00</span>...<span class="tok-number">0x1F</span>, <span class="tok-str">'\\'</span>, <span class="tok-str">'\&quot;'</span> =&gt; {<span class="tok-comment">
                    // Always must escape these.
                    </span><span class="tok-kw">try</span> writer.writeAll(chars[write_cursor..i]);
                    <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.outputSpecialEscape">outputSpecialEscape</a>(chars[i], writer);
                    write_cursor = i + <span class="tok-number">1</span>;
                },
                <span class="tok-number">0x7F</span>...<span class="tok-number">0xFF</span> =&gt; {
                    <span class="tok-kw">try</span> writer.writeAll(chars[write_cursor..i]);
                    <span class="tok-kw">const</span> ulen = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ByteSequenceLength">utf8ByteSequenceLength</a>(chars[i]) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                    <span class="tok-kw">const</span> codepoint = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8Decode">utf8Decode</a>(chars[i..][<span class="tok-number">0</span>..ulen]) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                    <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.outputUnicodeEscape">outputUnicodeEscape</a>(codepoint, writer);
                    i += ulen - <span class="tok-number">1</span>;
                    write_cursor = i + <span class="tok-number">1</span>;
                },
            }
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">while</span> (i &lt; chars.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">switch</span> (chars[i]) {<span class="tok-comment">
                // normal bytes
                </span><span class="tok-number">0x20</span>...<span class="tok-number">0x21</span>, <span class="tok-number">0x23</span>...<span class="tok-number">0x5B</span>, <span class="tok-number">0x5D</span>...<span class="tok-number">0xFF</span> =&gt; {},
                <span class="tok-number">0x00</span>...<span class="tok-number">0x1F</span>, <span class="tok-str">'\\'</span>, <span class="tok-str">'\&quot;'</span> =&gt; {<span class="tok-comment">
                    // Always must escape these.
                    </span><span class="tok-kw">try</span> writer.writeAll(chars[write_cursor..i]);
                    <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.outputSpecialEscape">outputSpecialEscape</a>(chars[i], writer);
                    write_cursor = i + <span class="tok-number">1</span>;
                },
            }
        }
    }
    <span class="tok-kw">try</span> writer.writeAll(chars[write_cursor..chars.len]);
}</code></pre></details></div></div><div class="decl"><h2 id="std.json.fmt.fmt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fmt</span><a href="#src.zig-std.json.fmt.fmt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(value: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>) <a href="std.json.fmt.html#std.json.fmt.Formatter">Formatter</a>(<span class="tok-builtin">@TypeOf</span>(value))</code></pre></div><div class="tldDocs"><p>Returns a formatter that formats the given value using stringify.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> fmt {
    <span class="tok-kw">const</span> expectFmt = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectFmt">expectFmt</a>;
    <span class="tok-kw">try</span> expectFmt(<span class="tok-str">&quot;123&quot;</span>, <span class="tok-str">&quot;{}&quot;</span>, .{<a href="std.json.fmt.html#std.json.fmt.fmt">fmt</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">123</span>), .{})});
    <span class="tok-kw">try</span> expectFmt(
        <span class="tok-str">\\{&quot;num&quot;:927,&quot;msg&quot;:&quot;hello&quot;,&quot;sub&quot;:{&quot;mybool&quot;:true}}</span>
    , <span class="tok-str">&quot;{}&quot;</span>, .{<a href="std.json.fmt.html#std.json.fmt.fmt">fmt</a>(<span class="tok-kw">struct</span> {
        num: <span class="tok-type">u32</span>,
        msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        sub: <span class="tok-kw">struct</span> {
            mybool: <span class="tok-type">bool</span>,
        },
    }{
        .num = <span class="tok-number">927</span>,
        .msg = <span class="tok-str">&quot;hello&quot;</span>,
        .sub = .{ .mybool = <span class="tok-null">true</span> },
    }, .{})});
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.json.fmt.fmt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(value: <span class="tok-kw">anytype</span>, options: <a href="std.json.stringify.StringifyOptions.html">StringifyOptions</a>) <a href="std.json.fmt.html#std.json.fmt.Formatter">Formatter</a>(<span class="tok-builtin">@TypeOf</span>(value)) {
    <span class="tok-kw">return</span> <a href="std.json.fmt.html#std.json.fmt.Formatter">Formatter</a>(<span class="tok-builtin">@TypeOf</span>(value)){ .value = value, .options = options };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.json">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! JSON parsing and stringification conforming to RFC 8259. https://datatracker.ietf.org/doc/html/rfc8259</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! The low-level `Scanner` API produces `Token`s from an input slice or successive slices of inputs,</span>
<span class="tok-comment">//! The `Reader` API connects a `std.io.Reader` to a `Scanner`.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! The high-level `parseFromSlice` and `parseFromTokenSource` deserialize a JSON document into a Zig type.</span>
<span class="tok-comment">//! Parse into a dynamically-typed `Value` to load any JSON value for runtime inspection.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! The low-level `writeStream` emits syntax-conformant JSON tokens to a `std.io.Writer`.</span>
<span class="tok-comment">//! The high-level `stringify` serializes a Zig or `Value` type into JSON.</span>

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> testing = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing;
<span class="tok-kw">const</span> ArrayList = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).ArrayList;

<span class="tok-kw">test</span> Scanner {
    <span class="tok-kw">var</span> scanner = <a href="std.json.scanner.Scanner.html">Scanner</a>.<a href="std.json.scanner.Scanner.html#std.json.scanner.Scanner.initCompleteInput">initCompleteInput</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;{\&quot;foo\&quot;: 123}\n&quot;</span>);
    <span class="tok-kw">defer</span> scanner.deinit();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.json.scanner.Token.html">Token</a>.<a href="#">object_begin</a>, <span class="tok-kw">try</span> scanner.next());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, (<span class="tok-kw">try</span> scanner.next()).string);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123&quot;</span>, (<span class="tok-kw">try</span> scanner.next()).number);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.json.scanner.Token.html">Token</a>.<a href="#">object_end</a>, <span class="tok-kw">try</span> scanner.next());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.json.scanner.Token.html">Token</a>.<a href="#">end_of_document</a>, <span class="tok-kw">try</span> scanner.next());
}

<span class="tok-kw">test</span> parseFromSlice {
    <span class="tok-kw">var</span> parsed_str = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.parseFromSlice">parseFromSlice</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;\&quot;a\\u0020b\&quot;&quot;</span>, .{});
    <span class="tok-kw">defer</span> parsed_str.deinit();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a b&quot;</span>, parsed_str.value);

    <span class="tok-kw">const</span> T = <span class="tok-kw">struct</span> { a: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>, b: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> };
    <span class="tok-kw">var</span> parsed_struct = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.parseFromSlice">parseFromSlice</a>(T, <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;{\&quot;b\&quot;:\&quot;xy\&quot;}&quot;</span>, .{});
    <span class="tok-kw">defer</span> parsed_struct.deinit();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">1</span>), parsed_struct.value.a);<span class="tok-comment"> // default value
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;xy&quot;</span>, parsed_struct.value.b[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> Value {
    <span class="tok-kw">var</span> parsed = <span class="tok-kw">try</span> <a href="std.json.static.html#std.json.static.parseFromSlice">parseFromSlice</a>(<a href="std.json.dynamic.Value.html">Value</a>, <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;{\&quot;anything\&quot;: \&quot;goes\&quot;}&quot;</span>, .{});
    <span class="tok-kw">defer</span> parsed.deinit();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;goes&quot;</span>, parsed.value.object.get(<span class="tok-str">&quot;anything&quot;</span>).?.string);
}

<span class="tok-kw">test</span> writeStream {
    <span class="tok-kw">var</span> out = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> out.deinit();
    <span class="tok-kw">var</span> write_stream = <a href="std.json.stringify.html#std.json.stringify.writeStream">writeStream</a>(out.writer(), .{ .whitespace = .indent_2 });
    <span class="tok-kw">defer</span> write_stream.deinit();
    <span class="tok-kw">try</span> write_stream.beginObject();
    <span class="tok-kw">try</span> write_stream.objectField(<span class="tok-str">&quot;foo&quot;</span>);
    <span class="tok-kw">try</span> write_stream.write(<span class="tok-number">123</span>);
    <span class="tok-kw">try</span> write_stream.endObject();
    <span class="tok-kw">const</span> expected =
        <span class="tok-str">\\{</span>
        <span class="tok-str">\\  &quot;foo&quot;: 123</span>
        <span class="tok-str">\\}</span>
    ;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, expected, out.items);
}

<span class="tok-kw">test</span> stringify {
    <span class="tok-kw">var</span> out = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> out.deinit();

    <span class="tok-kw">const</span> T = <span class="tok-kw">struct</span> { a: <span class="tok-type">i32</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };
    <span class="tok-kw">try</span> <a href="std.json.stringify.html#std.json.stringify.stringify">stringify</a>(T{ .a = <span class="tok-number">123</span>, .b = <span class="tok-str">&quot;xy&quot;</span> }, .{}, out.writer());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;{\&quot;a\&quot;:123,\&quot;b\&quot;:\&quot;xy\&quot;}&quot;</span>, out.items);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ObjectMap = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/dynamic.zig&quot;</span>).ObjectMap;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Array = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/dynamic.zig&quot;</span>).Array;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/dynamic.zig&quot;</span>).Value;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayHashMap = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/hashmap.zig&quot;</span>).ArrayHashMap;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> validate = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).validate;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).Error;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> reader = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).reader;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_buffer_size = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).default_buffer_size;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Token = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).Token;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TokenType = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).TokenType;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostics = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).Diagnostics;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocWhen = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).AllocWhen;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_max_value_len = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).default_max_value_len;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).Reader;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Scanner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).Scanner;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> isNumberFormattedLikeAnInteger = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>).isNumberFormattedLikeAnInteger;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseOptions = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).ParseOptions;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Parsed = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).Parsed;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> parseFromSlice = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).parseFromSlice;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> parseFromSliceLeaky = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).parseFromSliceLeaky;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> parseFromTokenSource = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).parseFromTokenSource;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> parseFromTokenSourceLeaky = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).parseFromTokenSourceLeaky;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> innerParse = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).innerParse;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> parseFromValue = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).parseFromValue;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> parseFromValueLeaky = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).parseFromValueLeaky;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> innerParseFromValue = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).innerParseFromValue;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseError = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).ParseError;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseFromValueError = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>).ParseFromValueError;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringifyOptions = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).StringifyOptions;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> stringify = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).stringify;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> stringifyMaxDepth = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).stringifyMaxDepth;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> stringifyArbitraryDepth = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).stringifyArbitraryDepth;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> stringifyAlloc = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).stringifyAlloc;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> writeStream = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).writeStream;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> writeStreamMaxDepth = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).writeStreamMaxDepth;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> writeStreamArbitraryDepth = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).writeStreamArbitraryDepth;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteStream = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).WriteStream;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> encodeJsonString = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).encodeJsonString;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> encodeJsonStringChars = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>).encodeJsonStringChars;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Formatter = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/fmt.zig&quot;</span>).Formatter;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> fmt = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/fmt.zig&quot;</span>).fmt;

<span class="tok-kw">test</span> {
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/test.zig&quot;</span>);
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/scanner.zig&quot;</span>);
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/dynamic.zig&quot;</span>);
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/hashmap.zig&quot;</span>);
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/static.zig&quot;</span>);
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/stringify.zig&quot;</span>);
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;json/JSONTestSuite_test.zig&quot;</span>);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
