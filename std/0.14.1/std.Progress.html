<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.Progress.html" class="active">Progress</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Progress" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Progress</span><a href="#src.zig-std.Progress">[src]</a></h1><div class="tldDocs"><p>This API is non-allocating, non-fallible, thread-safe, and lock-free.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.Progress.TerminalMode.html">std.Progress.TerminalMode</a></li><li><a href="std.Progress.Options.html">std.Progress.Options</a></li><li><a href="std.Progress.Node.html">std.Progress.Node</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>terminal: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a></code></pre><div class="fieldDocs"><p><code>null</code> if the current node (and its children) should
not print on update()</p>
</div></div><div><pre><code>terminal_mode: <a href="std.Progress.TerminalMode.html">TerminalMode</a></code></pre></div><div><pre><code>update_thread: ?<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a></code></pre></div><div><pre><code>redraw_event: <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.ResetEvent.html">ResetEvent</a></code></pre><div class="fieldDocs"><p>Atomically set by SIGWINCH as well as the root done() function.</p>
</div></div><div><pre><code>done: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>Indicates a request to shut down and reset global state.
Accessed atomically.</p>
</div></div><div><pre><code>need_clear: <span class="tok-type">bool</span></code></pre></div><div><pre><code>refresh_rate_ns: <span class="tok-type">u64</span></code></pre></div><div><pre><code>initial_delay_ns: <span class="tok-type">u64</span></code></pre></div><div><pre><code>rows: <span class="tok-type">u16</span></code></pre></div><div><pre><code>cols: <span class="tok-type">u16</span></code></pre></div><div><pre><code>draw_buffer: []<span class="tok-type">u8</span></code></pre><div class="fieldDocs"><p>Accessed only by the update thread.</p>
</div></div><div><pre><code>node_parents: []<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a></code></pre><div class="fieldDocs"><p>This is in a separate array from <code>node_storage</code> but with the same length so
that it can be iterated over efficiently without trashing too much of the
CPU cache.</p>
</div></div><div><pre><code>node_storage: []<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a></code></pre></div><div><pre><code>node_freelist_next: []<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a></code></pre></div><div><pre><code>node_freelist: <a href="std.Progress.Freelist.html">Freelist</a></code></pre></div><div><pre><code>node_end_index: <span class="tok-type">u32</span></code></pre><div class="fieldDocs"><p>This is the number of elements in node arrays which have been used so far. Nodes before this
index are either active, or on the freelist. The remaining nodes are implicitly free. This
value may at times temporarily exceed the node count.</p>
</div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.Progress.have_ipc" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">have_ipc</span><a href="#src.zig-std.Progress.have_ipc">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Progress.have_ipc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_ipc = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
    .wasi, .freestanding, .windows =&gt; <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Progress.start" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">start</span><a href="#src.zig-std.Progress.start">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">start</span>(options: <a href="std.Progress.Options.html">Options</a>) <a href="std.Progress.Node.html">Node</a></code></pre></div><div class="tldDocs"><p>Initializes a global Progress instance.</p>
<p>Asserts there is only one global Progress instance.</p>
<p>Call <code><a href="std.Progress.Node.html#std.Progress.Node.end">Node.end</a></code> when done.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.Progress.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Progress.start">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">start</span>(options: <a href="std.Progress.Options.html">Options</a>) <a href="std.Progress.Node.html">Node</a> {<span class="tok-comment">
    // Ensure there is only 1 global Progress object.
    </span><span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_end_index</a> != <span class="tok-number">0</span>) {
        <a href="std.Progress.html#std.Progress.debug_start_trace">debug_start_trace</a>.<a href="#">dump</a>();
        <span class="tok-kw">unreachable</span>;
    }
    <a href="std.Progress.html#std.Progress.debug_start_trace">debug_start_trace</a>.<a href="#">add</a>(<span class="tok-str">&quot;first initialized here&quot;</span>);

    <span class="tok-builtin">@memset</span>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_parents</a>, .unused);
    <span class="tok-kw">const</span> root_node = <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.init">init</a>(<span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), .none, options.root_name, options.estimated_total_items);
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a> = <span class="tok-null">false</span>;
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_end_index</a> = <span class="tok-number">1</span>;

    <a href="std.debug.html#std.debug.assert">assert</a>(options.draw_buffer.len &gt;= <span class="tok-number">200</span>);
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">draw_buffer</a> = options.draw_buffer;
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">refresh_rate_ns</a> = options.refresh_rate_ns;
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">initial_delay_ns</a> = options.initial_delay_ns;

    <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.noop_impl">noop_impl</a>)
        <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;

    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.parseEnvVarInt">parseEnvVarInt</a>(<span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>, <span class="tok-type">u31</span>, <span class="tok-number">10</span>)) |ipc_fd| {
        <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">update_thread</a> = <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, <a href="std.Progress.html#std.Progress.ipcThreadRun">ipcThreadRun</a>, .{
            <span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)) {
                .int =&gt; ipc_fd,
                .pointer =&gt; <span class="tok-builtin">@ptrFromInt</span>(ipc_fd),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unsupported fd_t of &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)),
            }),
        }) <span class="tok-kw">catch</span> |err| {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;failed to spawn IPC thread for communicating progress to parent: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
            <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
        };
    } <span class="tok-kw">else</span> |env_err| <span class="tok-kw">switch</span> (env_err) {
        <span class="tok-kw">error</span>.EnvironmentVariableNotFound =&gt; {
            <span class="tok-kw">if</span> (options.disable_printing) {
                <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
            }
            <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal</a> = stderr;
            <span class="tok-kw">if</span> (stderr.getOrEnableAnsiEscapeSupport()) {
                <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a> = .ansi_escape_codes;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a> <span class="tok-kw">and</span> stderr.isTty()) {
                <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a> = <a href="std.Progress.TerminalMode.html">TerminalMode</a>{ .windows_api = .{
                    .code_page = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleOutputCP">GetConsoleOutputCP</a>(),
                } };
            }

            <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a> == .off) {
                <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
            }

            <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.have_sigwinch">have_sigwinch</a>) {
                <span class="tok-kw">var</span> act: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a> = .{
                    .handler = .{ .sigaction = <a href="std.Progress.html#std.Progress.handleSigWinch">handleSigWinch</a> },
                    .mask = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.empty_sigset">empty_sigset</a>,
                    .flags = (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">SIGINFO</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">RESTART</a>),
                };
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">WINCH</a>, &amp;act, <span class="tok-null">null</span>);
            }

            <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a>) {
                .off =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // handled a few lines above
                </span>.ansi_escape_codes =&gt; <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, <a href="std.Progress.html#std.Progress.updateThreadRun">updateThreadRun</a>, .{}),
                .windows_api =&gt; <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, <a href="std.Progress.html#std.Progress.windowsApiUpdateThreadRun">windowsApiUpdateThreadRun</a>, .{}) <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>,
            }) |thread| {
                <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">update_thread</a> = thread;
            } <span class="tok-kw">else</span> |err| {
                <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;unable to spawn thread for printing progress to terminal: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
                <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
            }
        },
        <span class="tok-kw">else</span> =&gt; |e| {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;invalid ZIG_PROGRESS file descriptor integer: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});
            <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
        },
    }

    <span class="tok-kw">return</span> root_node;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Progress.lockStdErr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockStdErr</span><a href="#src.zig-std.Progress.lockStdErr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockStdErr</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Allows the caller to freely write to stderr until <code><a href="std.Progress.html#std.Progress.unlockStdErr">unlockStdErr</a></code> is called.</p>
<p>During the lock, any <code><a href="std.Progress.html">std.Progress</a></code> information is cleared from the terminal.</p>
<p>The lock is recursive; the same thread may hold the lock multiple times.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Progress.lockStdErr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockStdErr</span>() <span class="tok-type">void</span> {
    <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">lock</a>();
    <a href="std.Progress.html#std.Progress.clearWrittenWithEscapeCodes">clearWrittenWithEscapeCodes</a>() <span class="tok-kw">catch</span> {};
}</code></pre></details></div></div><div class="decl"><h2 id="std.Progress.unlockStdErr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockStdErr</span><a href="#src.zig-std.Progress.unlockStdErr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockStdErr</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Progress.unlockStdErr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockStdErr</span>() <span class="tok-type">void</span> {
    <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">unlock</a>();
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Progress">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! This API is non-allocating, non-fallible, thread-safe, and lock-free.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> Progress = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> is_big_endian = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>() == .big;
<span class="tok-kw">const</span> is_windows = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows;

<span class="tok-comment">/// `null` if the current node (and its children) should</span>
<span class="tok-comment">/// not print on update()</span>
terminal: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,

terminal_mode: <a href="std.Progress.TerminalMode.html">TerminalMode</a>,

update_thread: ?<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>,

<span class="tok-comment">/// Atomically set by SIGWINCH as well as the root done() function.</span>
redraw_event: <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.ResetEvent.html">ResetEvent</a>,
<span class="tok-comment">/// Indicates a request to shut down and reset global state.</span>
<span class="tok-comment">/// Accessed atomically.</span>
done: <span class="tok-type">bool</span>,
need_clear: <span class="tok-type">bool</span>,

refresh_rate_ns: <span class="tok-type">u64</span>,
initial_delay_ns: <span class="tok-type">u64</span>,

rows: <span class="tok-type">u16</span>,
cols: <span class="tok-type">u16</span>,

<span class="tok-comment">/// Accessed only by the update thread.</span>
draw_buffer: []<span class="tok-type">u8</span>,

<span class="tok-comment">/// This is in a separate array from `node_storage` but with the same length so</span>
<span class="tok-comment">/// that it can be iterated over efficiently without trashing too much of the</span>
<span class="tok-comment">/// CPU cache.</span>
node_parents: []<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>,
node_storage: []<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a>,
node_freelist_next: []<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>,
node_freelist: <a href="std.Progress.Freelist.html">Freelist</a>,
<span class="tok-comment">/// This is the number of elements in node arrays which have been used so far. Nodes before this</span>
<span class="tok-comment">/// index are either active, or on the freelist. The remaining nodes are implicitly free. This</span>
<span class="tok-comment">/// value may at times temporarily exceed the node count.</span>
node_end_index: <span class="tok-type">u32</span>,

<span class="tok-kw">const</span> Freelist = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
    head: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>,
    <span class="tok-comment">/// Whenever `node_freelist` is added to, this generation is incremented</span>
    <span class="tok-comment">/// to avoid ABA bugs when acquiring nodes. Wrapping arithmetic is used.</span>
    generation: <span class="tok-type">u24</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TerminalMode = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    off,
    ansi_escape_codes,
    <span class="tok-comment">/// This is not the same as being run on windows because other terminals</span>
    <span class="tok-comment">/// exist like MSYS/git-bash.</span>
    windows_api: <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) <a href="std.Progress.TerminalMode.WindowsApi.html">WindowsApi</a> <span class="tok-kw">else</span> <span class="tok-type">void</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WindowsApi = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The output code page of the console.</span>
        code_page: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UINT">UINT</a>,
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// User-provided buffer with static lifetime.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Used to store the entire write buffer sent to the terminal. Progress output will be truncated if it</span>
    <span class="tok-comment">/// cannot fit into this buffer which will look bad but not cause any malfunctions.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Must be at least 200 bytes.</span>
    draw_buffer: []<span class="tok-type">u8</span> = &amp;<a href="std.Progress.html#std.Progress.default_draw_buffer">default_draw_buffer</a>,
    <span class="tok-comment">/// How many nanoseconds between writing updates to the terminal.</span>
    refresh_rate_ns: <span class="tok-type">u64</span> = <span class="tok-number">80</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a>,
    <span class="tok-comment">/// How many nanoseconds to keep the output hidden</span>
    initial_delay_ns: <span class="tok-type">u64</span> = <span class="tok-number">200</span> * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_ms">ns_per_ms</a>,
    <span class="tok-comment">/// If provided, causes the progress item to have a denominator.</span>
    <span class="tok-comment">/// 0 means unknown.</span>
    estimated_total_items: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    root_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,
    disable_printing: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
};

<span class="tok-comment">/// Represents one unit of progress. Each node can have children nodes, or</span>
<span class="tok-comment">/// one can use integers with `update`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
    index: <a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> none: <a href="std.Progress.Node.html">Node</a> = .{ .index = .none };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_name_len = <span class="tok-number">40</span>;

    <span class="tok-kw">const</span> Storage = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Little endian.</span>
        completed_count: <span class="tok-type">u32</span>,
        <span class="tok-comment">/// 0 means unknown.</span>
        <span class="tok-comment">/// Little endian.</span>
        estimated_total_count: <span class="tok-type">u32</span>,
        name: [<a href="std.Progress.Node.html#std.Progress.Node.max_name_len">max_name_len</a>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>)),

        <span class="tok-comment">/// Not thread-safe.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">getIpcFd</span>(s: <a href="std.Progress.Node.Storage.html">Storage</a>) ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (s.estimated_total_count == <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>)) <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)) {
                .int =&gt; <span class="tok-builtin">@bitCast</span>(s.completed_count),
                .pointer =&gt; <span class="tok-builtin">@ptrFromInt</span>(s.completed_count),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unsupported fd_t of &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)),
            } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Thread-safe.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">setIpcFd</span>(s: *<a href="std.Progress.Node.Storage.html">Storage</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> integer: <span class="tok-type">u32</span> = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)) {
                .int =&gt; <span class="tok-builtin">@bitCast</span>(fd),
                .pointer =&gt; <span class="tok-builtin">@intFromPtr</span>(fd),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unsupported fd_t of &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)),
            };<span class="tok-comment">
            // `estimated_total_count` max int indicates the special state that
            // causes `completed_count` to be treated as a file descriptor, so
            // the order here matters.
            </span><span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, &amp;s.completed_count, integer, .monotonic);
            <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, &amp;s.estimated_total_count, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>), .release);<span class="tok-comment"> // synchronizes with acquire in `serialize`
        </span>}

        <span class="tok-comment">/// Not thread-safe.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">byteSwap</span>(s: *<a href="std.Progress.Node.Storage.html">Storage</a>) <span class="tok-type">void</span> {
            s.completed_count = <span class="tok-builtin">@byteSwap</span>(s.completed_count);
            s.estimated_total_count = <span class="tok-builtin">@byteSwap</span>(s.estimated_total_count);
        }

        <span class="tok-kw">comptime</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>((<span class="tok-builtin">@sizeOf</span>(<a href="std.Progress.Node.Storage.html">Storage</a>) % <span class="tok-number">4</span>) == <span class="tok-number">0</span>);
        }
    };

    <span class="tok-kw">const</span> Parent = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        <span class="tok-comment">/// Unallocated storage.</span>
        unused = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u8</span>) - <span class="tok-number">1</span>,
        <span class="tok-comment">/// Indicates root node.</span>
        <a href="std.Progress.Node.html#std.Progress.Node.none">none</a> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u8</span>),
        <span class="tok-comment">/// Index into `node_storage`.</span>
        _,

        <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(i: <span class="tok-builtin">@This</span>()) ?<a href="std.Progress.Node.Index.html">Index</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (i) {
                .unused, .none =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(i)),
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> OptionalIndex = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        <a href="std.Progress.Node.html#std.Progress.Node.none">none</a> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u8</span>),
        <span class="tok-comment">/// Index into `node_storage`.</span>
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(i: <span class="tok-builtin">@This</span>()) ?<a href="std.Progress.Node.Index.html">Index</a> {
            <span class="tok-kw">if</span> (i == .none) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(i));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">toParent</span>(i: <span class="tok-builtin">@This</span>()) <a href="std.Progress.Node.Parent.html">Parent</a> {
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@intFromEnum</span>(i) != <span class="tok-builtin">@intFromEnum</span>(<a href="std.Progress.Node.Parent.html">Parent</a>.<a href="#">unused</a>));
            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(i));
        }
    };

    <span class="tok-comment">/// Index into `node_storage`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        _,

        <span class="tok-kw">fn</span> <span class="tok-fn">toParent</span>(i: <span class="tok-builtin">@This</span>()) <a href="std.Progress.Node.Parent.html">Parent</a> {
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@intFromEnum</span>(i) != <span class="tok-builtin">@intFromEnum</span>(<a href="std.Progress.Node.Parent.html">Parent</a>.<a href="#">unused</a>));
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@intFromEnum</span>(i) != <span class="tok-builtin">@intFromEnum</span>(<a href="std.Progress.Node.Parent.html">Parent</a>.<a href="#">none</a>));
            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(i));
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOptional</span>(i: <span class="tok-builtin">@This</span>()) <a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(i));
        }
    };

    <span class="tok-comment">/// Create a new child progress node. Thread-safe.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Passing 0 for `estimated_total_items` means unknown.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">start</span>(node: <a href="std.Progress.Node.html">Node</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, estimated_total_items: <span class="tok-type">usize</span>) <a href="std.Progress.Node.html">Node</a> {
        <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.noop_impl">noop_impl</a>) {
            <a href="std.debug.html#std.debug.assert">assert</a>(node.index == .none);
            <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
        }
        <span class="tok-kw">const</span> node_index = node.index.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
        <span class="tok-kw">const</span> parent = node_index.toParent();

        <span class="tok-kw">const</span> freelist = &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_freelist</a>;
        <span class="tok-kw">var</span> old_freelist = <span class="tok-builtin">@atomicLoad</span>(<a href="std.Progress.Freelist.html">Freelist</a>, freelist, .acquire);<span class="tok-comment"> // acquire to ensure we have the correct &quot;next&quot; entry
        </span><span class="tok-kw">while</span> (old_freelist.head.unwrap()) |free_index| {
            <span class="tok-kw">const</span> next_ptr = <a href="std.Progress.Node.html#std.Progress.Node.freelistNextByIndex">freelistNextByIndex</a>(free_index);
            <span class="tok-kw">const</span> new_freelist: <a href="std.Progress.Freelist.html">Freelist</a> = .{
                .head = <span class="tok-builtin">@atomicLoad</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>, next_ptr, .monotonic),<span class="tok-comment">
                // We don't need to increment the generation when removing nodes from the free list,
                // only when adding them. (This choice is arbitrary; the opposite would also work.)
                </span>.generation = old_freelist.generation,
            };
            old_freelist = <span class="tok-builtin">@cmpxchgWeak</span>(
                <a href="std.Progress.Freelist.html">Freelist</a>,
                freelist,
                old_freelist,
                new_freelist,
                .acquire,<span class="tok-comment"> // not theoretically necessary, but not allowed to be weaker than the failure order
                </span>.acquire,<span class="tok-comment"> // ensure we have the correct `node_freelist_next` entry on the next iteration
            </span>) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // We won the allocation race.
                </span><span class="tok-kw">return</span> <a href="std.Progress.Node.html#std.Progress.Node.init">init</a>(free_index, parent, name, estimated_total_items);
            };
        }

        <span class="tok-kw">const</span> free_index = <span class="tok-builtin">@atomicRmw</span>(<span class="tok-type">u32</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_end_index</a>, .Add, <span class="tok-number">1</span>, .monotonic);
        <span class="tok-kw">if</span> (free_index &gt;= <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_storage</a>.<a href="#">len</a>) {<span class="tok-comment">
            // Ran out of node storage memory. Progress for this node will not be tracked.
            </span>_ = <span class="tok-builtin">@atomicRmw</span>(<span class="tok-type">u32</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_end_index</a>, .Sub, <span class="tok-number">1</span>, .monotonic);
            <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
        }

        <span class="tok-kw">return</span> <a href="std.Progress.Node.html#std.Progress.Node.init">init</a>(<span class="tok-builtin">@enumFromInt</span>(free_index), parent, name, estimated_total_items);
    }

    <span class="tok-comment">/// This is the same as calling `start` and then `end` on the returned `Node`. Thread-safe.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">completeOne</span>(n: <a href="std.Progress.Node.html">Node</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> index = n.index.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">const</span> storage = <a href="std.Progress.Node.html#std.Progress.Node.storageByIndex">storageByIndex</a>(index);
        _ = <span class="tok-builtin">@atomicRmw</span>(<span class="tok-type">u32</span>, &amp;storage.completed_count, .Add, <span class="tok-number">1</span>, .monotonic);
    }

    <span class="tok-comment">/// Thread-safe.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCompletedItems</span>(n: <a href="std.Progress.Node.html">Node</a>, completed_items: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> index = n.index.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">const</span> storage = <a href="std.Progress.Node.html#std.Progress.Node.storageByIndex">storageByIndex</a>(index);
        <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, &amp;storage.completed_count, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.lossyCast">lossyCast</a>(<span class="tok-type">u32</span>, completed_items), .monotonic);
    }

    <span class="tok-comment">/// Thread-safe. 0 means unknown.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setEstimatedTotalItems</span>(n: <a href="std.Progress.Node.html">Node</a>, count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> index = n.index.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">const</span> storage = <a href="std.Progress.Node.html#std.Progress.Node.storageByIndex">storageByIndex</a>(index);<span class="tok-comment">
        // Avoid u32 max int which is used to indicate a special state.
        </span><span class="tok-kw">const</span> saturated = <span class="tok-builtin">@min</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>) - <span class="tok-number">1</span>, count);
        <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, &amp;storage.estimated_total_count, saturated, .monotonic);
    }

    <span class="tok-comment">/// Thread-safe.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">increaseEstimatedTotalItems</span>(n: <a href="std.Progress.Node.html">Node</a>, count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> index = n.index.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">const</span> storage = <a href="std.Progress.Node.html#std.Progress.Node.storageByIndex">storageByIndex</a>(index);
        _ = <span class="tok-builtin">@atomicRmw</span>(<span class="tok-type">u32</span>, &amp;storage.estimated_total_count, .Add, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.lossyCast">lossyCast</a>(<span class="tok-type">u32</span>, count), .monotonic);
    }

    <span class="tok-comment">/// Finish a started `Node`. Thread-safe.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">end</span>(n: <a href="std.Progress.Node.html">Node</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.noop_impl">noop_impl</a>) {
            <a href="std.debug.html#std.debug.assert">assert</a>(n.index == .none);
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> index = n.index.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">const</span> parent_ptr = <a href="std.Progress.Node.html#std.Progress.Node.parentByIndex">parentByIndex</a>(index);
        <span class="tok-kw">if</span> (<span class="tok-builtin">@atomicLoad</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>, parent_ptr, .monotonic).unwrap()) |parent_index| {
            _ = <span class="tok-builtin">@atomicRmw</span>(<span class="tok-type">u32</span>, &amp;<a href="std.Progress.Node.html#std.Progress.Node.storageByIndex">storageByIndex</a>(parent_index).completed_count, .Add, <span class="tok-number">1</span>, .monotonic);
            <span class="tok-builtin">@atomicStore</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>, parent_ptr, .unused, .monotonic);

            <span class="tok-kw">const</span> freelist = &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_freelist</a>;
            <span class="tok-kw">var</span> old_freelist = <span class="tok-builtin">@atomicLoad</span>(<a href="std.Progress.Freelist.html">Freelist</a>, freelist, .monotonic);
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-builtin">@atomicStore</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>, <a href="std.Progress.Node.html#std.Progress.Node.freelistNextByIndex">freelistNextByIndex</a>(index), old_freelist.head, .monotonic);
                old_freelist = <span class="tok-builtin">@cmpxchgWeak</span>(
                    <a href="std.Progress.Freelist.html">Freelist</a>,
                    freelist,
                    old_freelist,
                    .{ .head = index.toOptional(), .generation = old_freelist.generation +% <span class="tok-number">1</span> },
                    .release,<span class="tok-comment"> // ensure a matching `start` sees the freelist link written above
                    </span>.monotonic,<span class="tok-comment"> // our write above is irrelevant if we need to retry
                </span>) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                    // We won the race.
                    </span><span class="tok-kw">return</span>;
                };
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">bool</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a>, <span class="tok-null">true</span>, .monotonic);
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">redraw_event</a>.<a href="#">set</a>();
            <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">update_thread</a>) |thread| thread.join();
        }
    }

    <span class="tok-comment">/// Posix-only. Used by `std.process.Child`. Thread-safe.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setIpcFd</span>(node: <a href="std.Progress.Node.html">Node</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> index = node.index.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(fd &gt;= <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(fd != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDOUT_FILENO">STDOUT_FILENO</a>);
        <a href="std.debug.html#std.debug.assert">assert</a>(fd != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDIN_FILENO">STDIN_FILENO</a>);
        <a href="std.debug.html#std.debug.assert">assert</a>(fd != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDERR_FILENO">STDERR_FILENO</a>);
        <a href="std.Progress.Node.html#std.Progress.Node.storageByIndex">storageByIndex</a>(index).setIpcFd(fd);
    }

    <span class="tok-comment">/// Posix-only. Thread-safe. Assumes the node is storing an IPC file</span>
    <span class="tok-comment">/// descriptor.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIpcFd</span>(node: <a href="std.Progress.Node.html">Node</a>) ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
        <span class="tok-kw">const</span> index = node.index.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> storage = <a href="std.Progress.Node.html#std.Progress.Node.storageByIndex">storageByIndex</a>(index);
        <span class="tok-kw">const</span> int = <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, &amp;storage.completed_count, .monotonic);
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)) {
            .int =&gt; <span class="tok-builtin">@bitCast</span>(int),
            .pointer =&gt; <span class="tok-builtin">@ptrFromInt</span>(int),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unsupported fd_t of &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)),
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">storageByIndex</span>(index: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Index.html">Index</a>) *<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a> {
        <span class="tok-kw">return</span> &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_storage</a>[<span class="tok-builtin">@intFromEnum</span>(index)];
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parentByIndex</span>(index: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Index.html">Index</a>) *<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a> {
        <span class="tok-kw">return</span> &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_parents</a>[<span class="tok-builtin">@intFromEnum</span>(index)];
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">freelistNextByIndex</span>(index: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Index.html">Index</a>) *<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a> {
        <span class="tok-kw">return</span> &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_freelist_next</a>[<span class="tok-builtin">@intFromEnum</span>(index)];
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(free_index: <a href="std.Progress.Node.Index.html">Index</a>, parent: <a href="std.Progress.Node.Parent.html">Parent</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, estimated_total_items: <span class="tok-type">usize</span>) <a href="std.Progress.Node.html">Node</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(parent == .none <span class="tok-kw">or</span> <span class="tok-builtin">@intFromEnum</span>(parent) &lt; <a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>);

        <span class="tok-kw">const</span> storage = <a href="std.Progress.Node.html#std.Progress.Node.storageByIndex">storageByIndex</a>(free_index);
        <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, &amp;storage.completed_count, <span class="tok-number">0</span>, .monotonic);
        <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, &amp;storage.estimated_total_count, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.lossyCast">lossyCast</a>(<span class="tok-type">u32</span>, estimated_total_items), .monotonic);
        <span class="tok-kw">const</span> name_len = <span class="tok-builtin">@min</span>(<a href="std.Progress.Node.html#std.Progress.Node.max_name_len">max_name_len</a>, name.len);
        <a href="std.Progress.html#std.Progress.copyAtomicStore">copyAtomicStore</a>(storage.name[<span class="tok-number">0</span>..name_len], name[<span class="tok-number">0</span>..name_len]);
        <span class="tok-kw">if</span> (name_len &lt; storage.name.len)
            <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u8</span>, &amp;storage.name[name_len], <span class="tok-number">0</span>, .monotonic);

        <span class="tok-kw">const</span> parent_ptr = <a href="std.Progress.Node.html#std.Progress.Node.parentByIndex">parentByIndex</a>(free_index);
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) {
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@atomicLoad</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>, parent_ptr, .monotonic) == .unused);
        }
        <span class="tok-builtin">@atomicStore</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>, parent_ptr, parent, .monotonic);

        <span class="tok-kw">return</span> .{ .index = free_index.toOptional() };
    }
};

<span class="tok-kw">var</span> global_progress: <a href="std.Progress.html">Progress</a> = .{
    .terminal = <span class="tok-null">undefined</span>,
    .terminal_mode = .off,
    .update_thread = <span class="tok-null">null</span>,
    .redraw_event = .{},
    .refresh_rate_ns = <span class="tok-null">undefined</span>,
    .initial_delay_ns = <span class="tok-null">undefined</span>,
    .rows = <span class="tok-number">0</span>,
    .cols = <span class="tok-number">0</span>,
    .draw_buffer = <span class="tok-null">undefined</span>,
    .done = <span class="tok-null">false</span>,
    .need_clear = <span class="tok-null">false</span>,

    .node_parents = &amp;<a href="std.Progress.html#std.Progress.node_parents_buffer">node_parents_buffer</a>,
    .node_storage = &amp;<a href="std.Progress.html#std.Progress.node_storage_buffer">node_storage_buffer</a>,
    .node_freelist_next = &amp;<a href="std.Progress.html#std.Progress.node_freelist_next_buffer">node_freelist_next_buffer</a>,
    .node_freelist = .{ .head = .none, .generation = <span class="tok-number">0</span> },
    .node_end_index = <span class="tok-number">0</span>,
};

<span class="tok-kw">const</span> node_storage_buffer_len = <span class="tok-number">83</span>;
<span class="tok-kw">var</span> node_parents_buffer: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> node_storage_buffer: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> node_freelist_next_buffer: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a> = <span class="tok-null">undefined</span>;

<span class="tok-kw">var</span> default_draw_buffer: [<span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">var</span> debug_start_trace = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.Trace">Trace</a>.<a href="#">init</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_ipc = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
    .wasi, .freestanding, .windows =&gt; <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
};

<span class="tok-kw">const</span> noop_impl = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a> <span class="tok-kw">or</span> <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
    .wasi, .freestanding =&gt; <span class="tok-null">true</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
};

<span class="tok-comment">/// Initializes a global Progress instance.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Asserts there is only one global Progress instance.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Call `Node.end` when done.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">start</span>(options: <a href="std.Progress.Options.html">Options</a>) <a href="std.Progress.Node.html">Node</a> {<span class="tok-comment">
    // Ensure there is only 1 global Progress object.
    </span><span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_end_index</a> != <span class="tok-number">0</span>) {
        <a href="std.Progress.html#std.Progress.debug_start_trace">debug_start_trace</a>.<a href="#">dump</a>();
        <span class="tok-kw">unreachable</span>;
    }
    <a href="std.Progress.html#std.Progress.debug_start_trace">debug_start_trace</a>.<a href="#">add</a>(<span class="tok-str">&quot;first initialized here&quot;</span>);

    <span class="tok-builtin">@memset</span>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_parents</a>, .unused);
    <span class="tok-kw">const</span> root_node = <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.init">init</a>(<span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), .none, options.root_name, options.estimated_total_items);
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a> = <span class="tok-null">false</span>;
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_end_index</a> = <span class="tok-number">1</span>;

    <a href="std.debug.html#std.debug.assert">assert</a>(options.draw_buffer.len &gt;= <span class="tok-number">200</span>);
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">draw_buffer</a> = options.draw_buffer;
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">refresh_rate_ns</a> = options.refresh_rate_ns;
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">initial_delay_ns</a> = options.initial_delay_ns;

    <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.noop_impl">noop_impl</a>)
        <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;

    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.parseEnvVarInt">parseEnvVarInt</a>(<span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>, <span class="tok-type">u31</span>, <span class="tok-number">10</span>)) |ipc_fd| {
        <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">update_thread</a> = <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, <a href="std.Progress.html#std.Progress.ipcThreadRun">ipcThreadRun</a>, .{
            <span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)) {
                .int =&gt; ipc_fd,
                .pointer =&gt; <span class="tok-builtin">@ptrFromInt</span>(ipc_fd),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unsupported fd_t of &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>)),
            }),
        }) <span class="tok-kw">catch</span> |err| {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;failed to spawn IPC thread for communicating progress to parent: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
            <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
        };
    } <span class="tok-kw">else</span> |env_err| <span class="tok-kw">switch</span> (env_err) {
        <span class="tok-kw">error</span>.EnvironmentVariableNotFound =&gt; {
            <span class="tok-kw">if</span> (options.disable_printing) {
                <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
            }
            <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal</a> = stderr;
            <span class="tok-kw">if</span> (stderr.getOrEnableAnsiEscapeSupport()) {
                <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a> = .ansi_escape_codes;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a> <span class="tok-kw">and</span> stderr.isTty()) {
                <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a> = <a href="std.Progress.TerminalMode.html">TerminalMode</a>{ .windows_api = .{
                    .code_page = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleOutputCP">GetConsoleOutputCP</a>(),
                } };
            }

            <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a> == .off) {
                <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
            }

            <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.have_sigwinch">have_sigwinch</a>) {
                <span class="tok-kw">var</span> act: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a> = .{
                    .handler = .{ .sigaction = <a href="std.Progress.html#std.Progress.handleSigWinch">handleSigWinch</a> },
                    .mask = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.empty_sigset">empty_sigset</a>,
                    .flags = (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">SIGINFO</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">RESTART</a>),
                };
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">WINCH</a>, &amp;act, <span class="tok-null">null</span>);
            }

            <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a>) {
                .off =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // handled a few lines above
                </span>.ansi_escape_codes =&gt; <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, <a href="std.Progress.html#std.Progress.updateThreadRun">updateThreadRun</a>, .{}),
                .windows_api =&gt; <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.spawn">spawn</a>(.{}, <a href="std.Progress.html#std.Progress.windowsApiUpdateThreadRun">windowsApiUpdateThreadRun</a>, .{}) <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>,
            }) |thread| {
                <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">update_thread</a> = thread;
            } <span class="tok-kw">else</span> |err| {
                <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;unable to spawn thread for printing progress to terminal: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
                <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
            }
        },
        <span class="tok-kw">else</span> =&gt; |e| {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;invalid ZIG_PROGRESS file descriptor integer: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});
            <span class="tok-kw">return</span> <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>;
        },
    }

    <span class="tok-kw">return</span> root_node;
}

<span class="tok-comment">/// Returns whether a resize is needed to learn the terminal size.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(timeout_ns: <span class="tok-type">u64</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> resize_flag = <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">redraw_event</a>.<a href="#">timedWait</a>(timeout_ns)) |_|
        <span class="tok-null">true</span>
    <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Timeout =&gt; <span class="tok-null">false</span>,
    };
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">redraw_event</a>.<a href="#">reset</a>();
    <span class="tok-kw">return</span> resize_flag <span class="tok-kw">or</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">cols</a> == <span class="tok-number">0</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">updateThreadRun</span>() <span class="tok-type">void</span> {<span class="tok-comment">
    // Store this data in the thread so that it does not need to be part of the
    // linker data of the main executable.
    </span><span class="tok-kw">var</span> serialized_buffer: <a href="std.Progress.Serialized.html">Serialized</a>.<a href="std.Progress.Serialized.Buffer.html">Buffer</a> = <span class="tok-null">undefined</span>;

    {
        <span class="tok-kw">const</span> resize_flag = <a href="std.Progress.html#std.Progress.wait">wait</a>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">initial_delay_ns</a>);
        <span class="tok-kw">if</span> (<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a>, .monotonic)) <span class="tok-kw">return</span>;
        <a href="std.Progress.html#std.Progress.maybeUpdateSize">maybeUpdateSize</a>(resize_flag);

        <span class="tok-kw">const</span> buffer, _ = computeRedraw(&amp;serialized_buffer);
        <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">tryLock</a>()) {
            <span class="tok-kw">defer</span> <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">unlock</a>();
            <a href="std.Progress.html#std.Progress.write">write</a>(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">need_clear</a> = <span class="tok-null">true</span>;
        }
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> resize_flag = <a href="std.Progress.html#std.Progress.wait">wait</a>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">refresh_rate_ns</a>);

        <span class="tok-kw">if</span> (<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a>, .monotonic)) {
            <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">lock</a>();
            <span class="tok-kw">defer</span> <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">unlock</a>();
            <span class="tok-kw">return</span> <a href="std.Progress.html#std.Progress.clearWrittenWithEscapeCodes">clearWrittenWithEscapeCodes</a>() <span class="tok-kw">catch</span> {};
        }

        <a href="std.Progress.html#std.Progress.maybeUpdateSize">maybeUpdateSize</a>(resize_flag);

        <span class="tok-kw">const</span> buffer, _ = computeRedraw(&amp;serialized_buffer);
        <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">tryLock</a>()) {
            <span class="tok-kw">defer</span> <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">unlock</a>();
            <a href="std.Progress.html#std.Progress.write">write</a>(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">need_clear</a> = <span class="tok-null">true</span>;
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">windowsApiWriteMarker</span>() <span class="tok-type">void</span> {<span class="tok-comment">
    // Write the marker that we will use to find the beginning of the progress when clearing.
    // Note: This doesn't have to use WriteConsoleW, but doing so avoids dealing with the code page.
    </span><span class="tok-kw">var</span> num_chars_written: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> handle = <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal</a>.<a href="#">handle</a>;
    _ = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.WriteConsoleW">WriteConsoleW</a>(handle, &amp;[_]<span class="tok-type">u16</span>{<a href="std.Progress.html#std.Progress.windows_api_start_marker">windows_api_start_marker</a>}, <span class="tok-number">1</span>, &amp;num_chars_written, <span class="tok-null">null</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">windowsApiUpdateThreadRun</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> serialized_buffer: <a href="std.Progress.Serialized.html">Serialized</a>.<a href="std.Progress.Serialized.Buffer.html">Buffer</a> = <span class="tok-null">undefined</span>;

    {
        <span class="tok-kw">const</span> resize_flag = <a href="std.Progress.html#std.Progress.wait">wait</a>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">initial_delay_ns</a>);
        <span class="tok-kw">if</span> (<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a>, .monotonic)) <span class="tok-kw">return</span>;
        <a href="std.Progress.html#std.Progress.maybeUpdateSize">maybeUpdateSize</a>(resize_flag);

        <span class="tok-kw">const</span> buffer, <span class="tok-kw">const</span> nl_n = computeRedraw(&amp;serialized_buffer);
        <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">tryLock</a>()) {
            <span class="tok-kw">defer</span> <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">unlock</a>();
            <a href="std.Progress.html#std.Progress.windowsApiWriteMarker">windowsApiWriteMarker</a>();
            <a href="std.Progress.html#std.Progress.write">write</a>(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">need_clear</a> = <span class="tok-null">true</span>;
            <a href="std.Progress.html#std.Progress.windowsApiMoveToMarker">windowsApiMoveToMarker</a>(nl_n) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
        }
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> resize_flag = <a href="std.Progress.html#std.Progress.wait">wait</a>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">refresh_rate_ns</a>);

        <span class="tok-kw">if</span> (<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a>, .monotonic)) {
            <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">lock</a>();
            <span class="tok-kw">defer</span> <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">unlock</a>();
            <span class="tok-kw">return</span> <a href="std.Progress.html#std.Progress.clearWrittenWindowsApi">clearWrittenWindowsApi</a>() <span class="tok-kw">catch</span> {};
        }

        <a href="std.Progress.html#std.Progress.maybeUpdateSize">maybeUpdateSize</a>(resize_flag);

        <span class="tok-kw">const</span> buffer, <span class="tok-kw">const</span> nl_n = computeRedraw(&amp;serialized_buffer);
        <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">tryLock</a>()) {
            <span class="tok-kw">defer</span> <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">unlock</a>();
            <a href="std.Progress.html#std.Progress.clearWrittenWindowsApi">clearWrittenWindowsApi</a>() <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <a href="std.Progress.html#std.Progress.windowsApiWriteMarker">windowsApiWriteMarker</a>();
            <a href="std.Progress.html#std.Progress.write">write</a>(buffer) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">need_clear</a> = <span class="tok-null">true</span>;
            <a href="std.Progress.html#std.Progress.windowsApiMoveToMarker">windowsApiMoveToMarker</a>(nl_n) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
        }
    }
}

<span class="tok-comment">/// Allows the caller to freely write to stderr until `unlockStdErr` is called.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// During the lock, any `std.Progress` information is cleared from the terminal.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The lock is recursive; the same thread may hold the lock multiple times.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockStdErr</span>() <span class="tok-type">void</span> {
    <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">lock</a>();
    <a href="std.Progress.html#std.Progress.clearWrittenWithEscapeCodes">clearWrittenWithEscapeCodes</a>() <span class="tok-kw">catch</span> {};
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockStdErr</span>() <span class="tok-type">void</span> {
    <a href="std.Progress.html#std.Progress.stderr_mutex">stderr_mutex</a>.<a href="#">unlock</a>();
}

<span class="tok-kw">fn</span> <span class="tok-fn">ipcThreadRun</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Store this data in the thread so that it does not need to be part of the
    // linker data of the main executable.
    </span><span class="tok-kw">var</span> serialized_buffer: <a href="std.Progress.Serialized.html">Serialized</a>.<a href="std.Progress.Serialized.Buffer.html">Buffer</a> = <span class="tok-null">undefined</span>;

    {
        _ = <a href="std.Progress.html#std.Progress.wait">wait</a>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">initial_delay_ns</a>);

        <span class="tok-kw">if</span> (<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a>, .monotonic))
            <span class="tok-kw">return</span>;

        <span class="tok-kw">const</span> serialized = <a href="std.Progress.html#std.Progress.serialize">serialize</a>(&amp;serialized_buffer);
        <a href="std.Progress.html#std.Progress.writeIpc">writeIpc</a>(fd, serialized) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span>,
        };
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        _ = <a href="std.Progress.html#std.Progress.wait">wait</a>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">refresh_rate_ns</a>);

        <span class="tok-kw">if</span> (<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">bool</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">done</a>, .monotonic))
            <span class="tok-kw">return</span>;

        <span class="tok-kw">const</span> serialized = <a href="std.Progress.html#std.Progress.serialize">serialize</a>(&amp;serialized_buffer);
        <a href="std.Progress.html#std.Progress.writeIpc">writeIpc</a>(fd, serialized) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span>,
        };
    }
}

<span class="tok-kw">const</span> start_sync = <span class="tok-str">&quot;\x1b[?2026h&quot;</span>;
<span class="tok-kw">const</span> up_one_line = <span class="tok-str">&quot;\x1bM&quot;</span>;
<span class="tok-kw">const</span> clear = <span class="tok-str">&quot;\x1b[J&quot;</span>;
<span class="tok-kw">const</span> save = <span class="tok-str">&quot;\x1b7&quot;</span>;
<span class="tok-kw">const</span> restore = <span class="tok-str">&quot;\x1b8&quot;</span>;
<span class="tok-kw">const</span> finish_sync = <span class="tok-str">&quot;\x1b[?2026l&quot;</span>;

<span class="tok-kw">const</span> TreeSymbol = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// ├─</span>
    tee,
    <span class="tok-comment">/// │</span>
    line,
    <span class="tok-comment">/// └─</span>
    langle,

    <span class="tok-kw">const</span> Encoding = <span class="tok-kw">enum</span> {
        ansi_escapes,
        code_page_437,
        utf8,
        ascii,
    };

    <span class="tok-comment">/// The escape sequence representation as a string literal</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">escapeSeq</span>(symbol: <a href="std.Progress.TreeSymbol.html">TreeSymbol</a>) *<span class="tok-kw">const</span> [<span class="tok-number">9</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (symbol) {
            .tee =&gt; <span class="tok-str">&quot;\x1B\x28\x30\x74\x71\x1B\x28\x42 &quot;</span>,
            .line =&gt; <span class="tok-str">&quot;\x1B\x28\x30\x78\x1B\x28\x42  &quot;</span>,
            .langle =&gt; <span class="tok-str">&quot;\x1B\x28\x30\x6d\x71\x1B\x28\x42 &quot;</span>,
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">bytes</span>(symbol: <a href="std.Progress.TreeSymbol.html">TreeSymbol</a>, encoding: <a href="std.Progress.TreeSymbol.Encoding.html">Encoding</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (encoding) {
            .ansi_escapes =&gt; <a href="std.Progress.TreeSymbol.html#std.Progress.TreeSymbol.escapeSeq">escapeSeq</a>(symbol),
            .code_page_437 =&gt; <span class="tok-kw">switch</span> (symbol) {
                .tee =&gt; <span class="tok-str">&quot;\xC3\xC4 &quot;</span>,
                .line =&gt; <span class="tok-str">&quot;\xB3  &quot;</span>,
                .langle =&gt; <span class="tok-str">&quot;\xC0\xC4 &quot;</span>,
            },
            .utf8 =&gt; <span class="tok-kw">switch</span> (symbol) {
                .tee =&gt; <span class="tok-str">&quot;├─ &quot;</span>,
                .line =&gt; <span class="tok-str">&quot;│  &quot;</span>,
                .langle =&gt; <span class="tok-str">&quot;└─ &quot;</span>,
            },
            .ascii =&gt; <span class="tok-kw">switch</span> (symbol) {
                .tee =&gt; <span class="tok-str">&quot;|- &quot;</span>,
                .line =&gt; <span class="tok-str">&quot;|  &quot;</span>,
                .langle =&gt; <span class="tok-str">&quot;+- &quot;</span>,
            },
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">maxByteLen</span>(symbol: <a href="std.Progress.TreeSymbol.html">TreeSymbol</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> max: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.Progress.TreeSymbol.Encoding.html">Encoding</a>).@&quot;enum&quot;.fields) |field| {
            <span class="tok-kw">const</span> len = symbol.bytes(<span class="tok-builtin">@field</span>(<a href="std.Progress.TreeSymbol.Encoding.html">Encoding</a>, field.name)).len;
            max = <span class="tok-builtin">@max</span>(max, len);
        }
        <span class="tok-kw">return</span> max;
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">appendTreeSymbol</span>(symbol: <a href="std.Progress.TreeSymbol.html">TreeSymbol</a>, buf: []<span class="tok-type">u8</span>, start_i: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">switch</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a>) {
        .off =&gt; <span class="tok-kw">unreachable</span>,
        .ansi_escape_codes =&gt; {
            <span class="tok-kw">const</span> bytes = symbol.escapeSeq();
            buf[start_i..][<span class="tok-number">0</span>..bytes.len].* = bytes.*;
            <span class="tok-kw">return</span> start_i + bytes.len;
        },
        .windows_api =&gt; |windows_api| {
            <span class="tok-kw">const</span> bytes = <span class="tok-kw">if</span> (!<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) <span class="tok-kw">unreachable</span> <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (windows_api.code_page) {<span class="tok-comment">
                // Code page 437 is the default code page and contains the box drawing symbols
                </span><span class="tok-number">437</span> =&gt; symbol.bytes(.code_page_437),<span class="tok-comment">
                // UTF-8
                </span><span class="tok-number">65001</span> =&gt; symbol.bytes(.utf8),<span class="tok-comment">
                // Fall back to ASCII approximation
                </span><span class="tok-kw">else</span> =&gt; symbol.bytes(.ascii),
            };
            <span class="tok-builtin">@memcpy</span>(buf[start_i..][<span class="tok-number">0</span>..bytes.len], bytes);
            <span class="tok-kw">return</span> start_i + bytes.len;
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">clearWrittenWithEscapeCodes</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">need_clear</a>) <span class="tok-kw">return</span>;

    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">need_clear</a> = <span class="tok-null">false</span>;
    <span class="tok-kw">try</span> <a href="std.Progress.html#std.Progress.write">write</a>(<a href="std.Progress.html#std.Progress.clear">clear</a>);
}

<span class="tok-comment">/// U+25BA or ►</span>
<span class="tok-kw">const</span> windows_api_start_marker = <span class="tok-number">0x25BA</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">clearWrittenWindowsApi</span>() <span class="tok-kw">error</span>{Unexpected}!<span class="tok-type">void</span> {<span class="tok-comment">
    // This uses a 'marker' strategy. The idea is:
    // - Always write a marker (in this case U+25BA or ►) at the beginning of the progress
    // - Get the current cursor position (at the end of the progress)
    // - Subtract the number of lines written to get the expected start of the progress
    // - Check to see if the first character at the start of the progress is the marker
    // - If it's not the marker, keep checking the line before until we find it
    // - Clear the screen from that position down, and set the cursor position to the start
    //
    // This strategy works even if there is line wrapping, and can handle the window
    // being resized/scrolled arbitrarily.
    //
    // Notes:
    // - Ideally, the marker would be a zero-width character, but the Windows console
    //   doesn't seem to support rendering zero-width characters (they show up as a space)
    // - This same marker idea could technically be done with an attribute instead
    //   (https://learn.microsoft.com/en-us/windows/console/console-screen-buffers#character-attributes)
    //   but it must be a valid attribute and it actually needs to apply to the first
    //   character in order to be readable via ReadConsoleOutputAttribute. It doesn't seem
    //   like any of the available attributes are invisible/benign.
    </span><span class="tok-kw">if</span> (!<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">need_clear</a>) <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> handle = <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal</a>.<a href="#">handle</a>;
    <span class="tok-kw">const</span> screen_area = <span class="tok-builtin">@as</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a>, <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">cols</a>) * <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">rows</a>;

    <span class="tok-kw">var</span> console_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.CONSOLE_SCREEN_BUFFER_INFO.html">CONSOLE_SCREEN_BUFFER_INFO</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleScreenBufferInfo">GetConsoleScreenBufferInfo</a>(handle, &amp;console_info) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    }
    <span class="tok-kw">var</span> num_chars_written: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.FillConsoleOutputCharacterW">FillConsoleOutputCharacterW</a>(handle, <span class="tok-str">' '</span>, screen_area, console_info.dwCursorPosition, &amp;num_chars_written) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">windowsApiMoveToMarker</span>(nl_n: <span class="tok-type">usize</span>) <span class="tok-kw">error</span>{Unexpected}!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> handle = <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal</a>.<a href="#">handle</a>;
    <span class="tok-kw">var</span> console_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.CONSOLE_SCREEN_BUFFER_INFO.html">CONSOLE_SCREEN_BUFFER_INFO</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleScreenBufferInfo">GetConsoleScreenBufferInfo</a>(handle, &amp;console_info) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    }
    <span class="tok-kw">const</span> cursor_pos = console_info.dwCursorPosition;
    <span class="tok-kw">const</span> expected_y = cursor_pos.Y - <span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-builtin">@intCast</span>(nl_n));
    <span class="tok-kw">var</span> start_pos: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.COORD.html">COORD</a> = .{ .X = <span class="tok-number">0</span>, .Y = expected_y };
    <span class="tok-kw">while</span> (start_pos.Y &gt;= <span class="tok-number">0</span>) {
        <span class="tok-kw">var</span> wchar: [<span class="tok-number">1</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> num_console_chars_read: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.ReadConsoleOutputCharacterW">ReadConsoleOutputCharacterW</a>(handle, &amp;wchar, wchar.len, start_pos, &amp;num_console_chars_read) == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
        }

        <span class="tok-kw">if</span> (wchar[<span class="tok-number">0</span>] == <a href="std.Progress.html#std.Progress.windows_api_start_marker">windows_api_start_marker</a>) <span class="tok-kw">break</span>;
        start_pos.Y -= <span class="tok-number">1</span>;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // If we couldn't find the marker, then just assume that no lines wrapped
        </span>start_pos = .{ .X = <span class="tok-number">0</span>, .Y = expected_y };
    }
    <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.SetConsoleCursorPosition">SetConsoleCursorPosition</a>(handle, start_pos) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    }
}

<span class="tok-kw">const</span> Children = <span class="tok-kw">struct</span> {
    child: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>,
    sibling: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>,
};

<span class="tok-kw">const</span> Serialized = <span class="tok-kw">struct</span> {
    parents: []<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>,
    storage: []<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a>,

    <span class="tok-kw">const</span> Buffer = <span class="tok-kw">struct</span> {
        parents: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>,
        storage: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a>,
        map: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>,

        parents_copy: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>,
        storage_copy: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a>,
        ipc_metadata_fds_copy: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Fd.html">Fd</a>,
        ipc_metadata_copy: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.SavedMetadata.html">SavedMetadata</a>,

        ipc_metadata_fds: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Fd.html">Fd</a>,
        ipc_metadata: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.SavedMetadata.html">SavedMetadata</a>,
    };
};

<span class="tok-kw">fn</span> <span class="tok-fn">serialize</span>(serialized_buffer: *<a href="std.Progress.Serialized.html">Serialized</a>.<a href="std.Progress.Serialized.Buffer.html">Buffer</a>) <a href="std.Progress.Serialized.html">Serialized</a> {
    <span class="tok-kw">var</span> serialized_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> any_ipc = <span class="tok-null">false</span>;<span class="tok-comment">

    // Iterate all of the nodes and construct a serializable copy of the state that can be examined
    // without atomics. The `@min` call is here because `node_end_index` might briefly exceed the
    // node count sometimes.
    </span><span class="tok-kw">const</span> end_index = <span class="tok-builtin">@min</span>(<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, &amp;<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_end_index</a>, .monotonic), <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_storage</a>.<a href="#">len</a>);
    <span class="tok-kw">for</span> (
        <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_parents</a>[<span class="tok-number">0</span>..end_index],
        <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">node_storage</a>[<span class="tok-number">0</span>..end_index],
        serialized_buffer.map[<span class="tok-number">0</span>..end_index],
    ) |*parent_ptr, *storage_ptr, *map| {
        <span class="tok-kw">const</span> parent = <span class="tok-builtin">@atomicLoad</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>, parent_ptr, .monotonic);
        <span class="tok-kw">if</span> (parent == .unused) {<span class="tok-comment">
            // We might read &quot;mixed&quot; node data in this loop, due to weird atomic things
            // or just a node actually being freed while this loop runs. That could cause
            // there to be a parent reference to a nonexistent node. Without this assignment,
            // this would lead to the map entry containing stale data. By assigning none, the
            // child node with the bad parent pointer will be harmlessly omitted from the tree.
            //
            // Note that there's no concern of potentially creating &quot;looping&quot; data if we read
            // &quot;mixed&quot; node data like this, because if a node is (directly or indirectly) its own
            // parent, it will just not be printed at all. The general idea here is that performance
            // is more important than 100% correct output every frame, given that this API is likely
            // to be used in hot paths!
            </span>map.* = .none;
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">const</span> dest_storage = &amp;serialized_buffer.storage[serialized_len];
        <a href="std.Progress.html#std.Progress.copyAtomicLoad">copyAtomicLoad</a>(&amp;dest_storage.name, &amp;storage_ptr.name);
        dest_storage.estimated_total_count = <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, &amp;storage_ptr.estimated_total_count, .acquire);<span class="tok-comment"> // sychronizes with release in `setIpcFd`
        </span>dest_storage.completed_count = <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, &amp;storage_ptr.completed_count, .monotonic);

        any_ipc = any_ipc <span class="tok-kw">or</span> (dest_storage.getIpcFd() != <span class="tok-null">null</span>);
        serialized_buffer.parents[serialized_len] = parent;
        map.* = <span class="tok-builtin">@enumFromInt</span>(serialized_len);
        serialized_len += <span class="tok-number">1</span>;
    }<span class="tok-comment">

    // Remap parents to point inside serialized arrays.
    </span><span class="tok-kw">for</span> (serialized_buffer.parents[<span class="tok-number">0</span>..serialized_len]) |*parent| {
        parent.* = <span class="tok-kw">switch</span> (parent.*) {
            .unused =&gt; <span class="tok-kw">unreachable</span>,
            .none =&gt; .none,
            _ =&gt; |p| serialized_buffer.map[<span class="tok-builtin">@intFromEnum</span>(p)].toParent(),
        };
    }<span class="tok-comment">

    // Find nodes which correspond to child processes.
    </span><span class="tok-kw">if</span> (any_ipc)
        serialized_len = <a href="std.Progress.html#std.Progress.serializeIpc">serializeIpc</a>(serialized_len, serialized_buffer);

    <span class="tok-kw">return</span> .{
        .parents = serialized_buffer.parents[<span class="tok-number">0</span>..serialized_len],
        .storage = serialized_buffer.storage[<span class="tok-number">0</span>..serialized_len],
    };
}

<span class="tok-kw">const</span> SavedMetadata = <span class="tok-kw">struct</span> {
    remaining_read_trash_bytes: <span class="tok-type">u16</span>,
    main_index: <span class="tok-type">u8</span>,
    start_index: <span class="tok-type">u8</span>,
    nodes_len: <span class="tok-type">u8</span>,
};

<span class="tok-kw">const</span> Fd = <span class="tok-kw">enum</span>(<span class="tok-type">i32</span>) {
    _,

    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) <a href="std.Progress.Fd.html">Fd</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@intFromPtr</span>(fd))) <span class="tok-kw">else</span> fd);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(fd: <a href="std.Progress.Fd.html">Fd</a>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>)
            <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intFromEnum</span>(fd)))))
        <span class="tok-kw">else</span>
            <span class="tok-builtin">@intFromEnum</span>(fd);
    }
};

<span class="tok-kw">var</span> ipc_metadata_len: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">serializeIpc</span>(start_serialized_len: <span class="tok-type">usize</span>, serialized_buffer: *<a href="std.Progress.Serialized.html">Serialized</a>.<a href="std.Progress.Serialized.Buffer.html">Buffer</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> ipc_metadata_fds_copy = &amp;serialized_buffer.ipc_metadata_fds_copy;
    <span class="tok-kw">const</span> ipc_metadata_copy = &amp;serialized_buffer.ipc_metadata_copy;
    <span class="tok-kw">const</span> ipc_metadata_fds = &amp;serialized_buffer.ipc_metadata_fds;
    <span class="tok-kw">const</span> ipc_metadata = &amp;serialized_buffer.ipc_metadata;

    <span class="tok-kw">var</span> serialized_len = start_serialized_len;
    <span class="tok-kw">var</span> pipe_buf: [<span class="tok-number">2</span> * <span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> old_ipc_metadata_fds = ipc_metadata_fds_copy[<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>];
    <span class="tok-kw">const</span> old_ipc_metadata = ipc_metadata_copy[<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>];
    <a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a> = <span class="tok-number">0</span>;

    main_loop: <span class="tok-kw">for</span> (
        serialized_buffer.parents[<span class="tok-number">0</span>..serialized_len],
        serialized_buffer.storage[<span class="tok-number">0</span>..serialized_len],
        <span class="tok-number">0</span>..,
    ) |main_parent, *main_storage, main_index| {
        <span class="tok-kw">if</span> (main_parent == .unused) <span class="tok-kw">continue</span>;
        <span class="tok-kw">const</span> fd = main_storage.getIpcFd() <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">const</span> opt_saved_metadata = <a href="std.Progress.html#std.Progress.findOld">findOld</a>(fd, old_ipc_metadata_fds, old_ipc_metadata);
        <span class="tok-kw">var</span> bytes_read: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> n = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.read">read</a>(fd, pipe_buf[bytes_read..]) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">break</span>,
                <span class="tok-kw">else</span> =&gt; |e| {
                    <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.debug">debug</a>(<span class="tok-str">&quot;failed to read child progress data: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});
                    main_storage.completed_count = <span class="tok-number">0</span>;
                    main_storage.estimated_total_count = <span class="tok-number">0</span>;
                    <span class="tok-kw">continue</span> :main_loop;
                },
            };
            <span class="tok-kw">if</span> (n == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            <span class="tok-kw">if</span> (opt_saved_metadata) |m| {
                <span class="tok-kw">if</span> (m.remaining_read_trash_bytes &gt; <span class="tok-number">0</span>) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(bytes_read == <span class="tok-number">0</span>);
                    <span class="tok-kw">if</span> (m.remaining_read_trash_bytes &gt;= n) {
                        m.remaining_read_trash_bytes = <span class="tok-builtin">@intCast</span>(m.remaining_read_trash_bytes - n);
                        <span class="tok-kw">continue</span>;
                    }
                    <span class="tok-kw">const</span> src = pipe_buf[m.remaining_read_trash_bytes..n];
                    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, &amp;pipe_buf, src);
                    m.remaining_read_trash_bytes = <span class="tok-number">0</span>;
                    bytes_read = src.len;
                    <span class="tok-kw">continue</span>;
                }
            }
            bytes_read += n;
        }<span class="tok-comment">
        // Ignore all but the last message on the pipe.
        </span><span class="tok-kw">var</span> input: []<span class="tok-type">u8</span> = pipe_buf[<span class="tok-number">0</span>..bytes_read];
        <span class="tok-kw">if</span> (input.len == <span class="tok-number">0</span>) {
            serialized_len = <a href="std.Progress.html#std.Progress.useSavedIpcData">useSavedIpcData</a>(serialized_len, serialized_buffer, main_storage, main_index, opt_saved_metadata, <span class="tok-number">0</span>, fd);
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">const</span> storage, <span class="tok-kw">const</span> parents = <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> subtree_len: <span class="tok-type">usize</span> = input[<span class="tok-number">0</span>];
            <span class="tok-kw">const</span> expected_bytes = <span class="tok-number">1</span> + subtree_len * (<span class="tok-builtin">@sizeOf</span>(Node.Storage) + <span class="tok-builtin">@sizeOf</span>(Node.Parent));
            <span class="tok-kw">if</span> (input.len &lt; expected_bytes) {<span class="tok-comment">
                // Ignore short reads. We'll handle the next full message when it comes instead.
                </span><span class="tok-kw">const</span> remaining_read_trash_bytes: <span class="tok-type">u16</span> = <span class="tok-builtin">@intCast</span>(expected_bytes - input.len);
                serialized_len = useSavedIpcData(serialized_len, serialized_buffer, main_storage, main_index, opt_saved_metadata, remaining_read_trash_bytes, fd);
                <span class="tok-kw">continue</span> :main_loop;
            }
            <span class="tok-kw">if</span> (input.len &gt; expected_bytes) {
                input = input[expected_bytes..];
                <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">const</span> storage_bytes = input[<span class="tok-number">1</span>..][<span class="tok-number">0</span> .. subtree_len * <span class="tok-builtin">@sizeOf</span>(Node.Storage)];
            <span class="tok-kw">const</span> parents_bytes = input[<span class="tok-number">1</span> + storage_bytes.len ..][<span class="tok-number">0</span> .. subtree_len * <span class="tok-builtin">@sizeOf</span>(Node.Parent)];
            <span class="tok-kw">break</span> .{
                std.mem.bytesAsSlice(Node.Storage, storage_bytes),
                std.mem.bytesAsSlice(Node.Parent, parents_bytes),
            };
        };

        <span class="tok-kw">const</span> nodes_len: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@min</span>(parents.len - <span class="tok-number">1</span>, serialized_buffer.storage.len - serialized_len));<span class="tok-comment">

        // Remember in case the pipe is empty on next update.
        </span>ipc_metadata_fds[<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>] = <a href="std.Progress.Fd.html">Fd</a>.<a href="std.Progress.Fd.html#std.Progress.Fd.init">init</a>(fd);
        ipc_metadata[<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>] = .{
            .remaining_read_trash_bytes = <span class="tok-number">0</span>,
            .start_index = <span class="tok-builtin">@intCast</span>(serialized_len),
            .nodes_len = nodes_len,
            .main_index = <span class="tok-builtin">@intCast</span>(main_index),
        };
        <a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a> += <span class="tok-number">1</span>;<span class="tok-comment">

        // Mount the root here.
        </span><a href="std.Progress.html#std.Progress.copyRoot">copyRoot</a>(main_storage, &amp;storage[<span class="tok-number">0</span>]);
        <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_big_endian">is_big_endian</a>) main_storage.byteSwap();<span class="tok-comment">

        // Copy the rest of the tree to the end.
        </span><span class="tok-kw">const</span> storage_dest = serialized_buffer.storage[serialized_len..][<span class="tok-number">0</span>..nodes_len];
        <span class="tok-builtin">@memcpy</span>(storage_dest, storage[<span class="tok-number">1</span>..][<span class="tok-number">0</span>..nodes_len]);<span class="tok-comment">

        // Always little-endian over the pipe.
        </span><span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_big_endian">is_big_endian</a>) <span class="tok-kw">for</span> (storage_dest) |*s| s.byteSwap();<span class="tok-comment">

        // Patch up parent pointers taking into account how the subtree is mounted.
        </span><span class="tok-kw">for</span> (serialized_buffer.parents[serialized_len..][<span class="tok-number">0</span>..nodes_len], parents[<span class="tok-number">1</span>..][<span class="tok-number">0</span>..nodes_len]) |*dest, p| {
            dest.* = <span class="tok-kw">switch</span> (p) {<span class="tok-comment">
                // Fix bad data so the rest of the code does not see `unused`.
                </span>.none, .unused =&gt; .none,<span class="tok-comment">
                // Root node is being mounted here.
                </span><span class="tok-builtin">@as</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Parent.html">Parent</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>)) =&gt; <span class="tok-builtin">@enumFromInt</span>(main_index),<span class="tok-comment">
                // Other nodes mounted at the end.
                // Don't trust child data; if the data is outside the expected range, ignore the data.
                // This also handles the case when data was truncated.
                </span>_ =&gt; |off| <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(off) &gt; nodes_len)
                    .none
                <span class="tok-kw">else</span>
                    <span class="tok-builtin">@enumFromInt</span>(serialized_len + <span class="tok-builtin">@intFromEnum</span>(off) - <span class="tok-number">1</span>),
            };
        }

        serialized_len += nodes_len;
    }<span class="tok-comment">

    // Save a copy in case any pipes are empty on the next update.
    </span><span class="tok-builtin">@memcpy</span>(serialized_buffer.parents_copy[<span class="tok-number">0</span>..serialized_len], serialized_buffer.parents[<span class="tok-number">0</span>..serialized_len]);
    <span class="tok-builtin">@memcpy</span>(serialized_buffer.storage_copy[<span class="tok-number">0</span>..serialized_len], serialized_buffer.storage[<span class="tok-number">0</span>..serialized_len]);
    <span class="tok-builtin">@memcpy</span>(ipc_metadata_fds_copy[<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>], ipc_metadata_fds[<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>]);
    <span class="tok-builtin">@memcpy</span>(ipc_metadata_copy[<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>], ipc_metadata[<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>]);

    <span class="tok-kw">return</span> serialized_len;
}

<span class="tok-kw">fn</span> <span class="tok-fn">copyRoot</span>(dest: *<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a>, src: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a>) <span class="tok-type">void</span> {
    dest.* = .{
        .completed_count = src.completed_count,
        .estimated_total_count = src.estimated_total_count,
        .name = <span class="tok-kw">if</span> (src.name[<span class="tok-number">0</span>] == <span class="tok-number">0</span>) dest.name <span class="tok-kw">else</span> src.name,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">findOld</span>(
    ipc_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_metadata_fds: []<a href="std.Progress.Fd.html">Fd</a>,
    old_metadata: []<a href="std.Progress.SavedMetadata.html">SavedMetadata</a>,
) ?*<a href="std.Progress.SavedMetadata.html">SavedMetadata</a> {
    <span class="tok-kw">for</span> (old_metadata_fds, old_metadata) |fd, *m| {
        <span class="tok-kw">if</span> (fd.get() == ipc_fd)
            <span class="tok-kw">return</span> m;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">useSavedIpcData</span>(
    start_serialized_len: <span class="tok-type">usize</span>,
    serialized_buffer: *<a href="std.Progress.Serialized.html">Serialized</a>.<a href="std.Progress.Serialized.Buffer.html">Buffer</a>,
    main_storage: *<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a>,
    main_index: <span class="tok-type">usize</span>,
    opt_saved_metadata: ?*<a href="std.Progress.SavedMetadata.html">SavedMetadata</a>,
    remaining_read_trash_bytes: <span class="tok-type">u16</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> parents_copy = &amp;serialized_buffer.parents_copy;
    <span class="tok-kw">const</span> storage_copy = &amp;serialized_buffer.storage_copy;
    <span class="tok-kw">const</span> ipc_metadata_fds = &amp;serialized_buffer.ipc_metadata_fds;
    <span class="tok-kw">const</span> ipc_metadata = &amp;serialized_buffer.ipc_metadata;

    <span class="tok-kw">const</span> saved_metadata = opt_saved_metadata <span class="tok-kw">orelse</span> {
        main_storage.completed_count = <span class="tok-number">0</span>;
        main_storage.estimated_total_count = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (remaining_read_trash_bytes &gt; <span class="tok-number">0</span>) {
            ipc_metadata_fds[<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>] = <a href="std.Progress.Fd.html">Fd</a>.<a href="std.Progress.Fd.html#std.Progress.Fd.init">init</a>(fd);
            ipc_metadata[<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>] = .{
                .remaining_read_trash_bytes = remaining_read_trash_bytes,
                .start_index = <span class="tok-builtin">@intCast</span>(start_serialized_len),
                .nodes_len = <span class="tok-number">0</span>,
                .main_index = <span class="tok-builtin">@intCast</span>(main_index),
            };
            <a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a> += <span class="tok-number">1</span>;
        }
        <span class="tok-kw">return</span> start_serialized_len;
    };

    <span class="tok-kw">const</span> start_index = saved_metadata.start_index;
    <span class="tok-kw">const</span> nodes_len = <span class="tok-builtin">@min</span>(saved_metadata.nodes_len, serialized_buffer.storage.len - start_serialized_len);
    <span class="tok-kw">const</span> old_main_index = saved_metadata.main_index;

    ipc_metadata_fds[<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>] = <a href="std.Progress.Fd.html">Fd</a>.<a href="std.Progress.Fd.html#std.Progress.Fd.init">init</a>(fd);
    ipc_metadata[<a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a>] = .{
        .remaining_read_trash_bytes = remaining_read_trash_bytes,
        .start_index = <span class="tok-builtin">@intCast</span>(start_serialized_len),
        .nodes_len = nodes_len,
        .main_index = <span class="tok-builtin">@intCast</span>(main_index),
    };
    <a href="std.Progress.html#std.Progress.ipc_metadata_len">ipc_metadata_len</a> += <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> parents = parents_copy[start_index..][<span class="tok-number">0</span>..nodes_len];
    <span class="tok-kw">const</span> storage = storage_copy[start_index..][<span class="tok-number">0</span>..nodes_len];

    <a href="std.Progress.html#std.Progress.copyRoot">copyRoot</a>(main_storage, &amp;storage_copy[old_main_index]);

    <span class="tok-builtin">@memcpy</span>(serialized_buffer.storage[start_serialized_len..][<span class="tok-number">0</span>..storage.len], storage);

    <span class="tok-kw">for</span> (serialized_buffer.parents[start_serialized_len..][<span class="tok-number">0</span>..parents.len], parents) |*dest, p| {
        dest.* = <span class="tok-kw">switch</span> (p) {
            .none, .unused =&gt; .none,
            _ =&gt; |prev| d: {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(prev) == old_main_index) {
                    <span class="tok-kw">break</span> :d <span class="tok-builtin">@enumFromInt</span>(main_index);
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(prev) &gt; nodes_len) {
                    <span class="tok-kw">break</span> :d .none;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">break</span> :d <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(prev) - start_index + start_serialized_len);
                }
            },
        };
    }

    <span class="tok-kw">return</span> start_serialized_len + storage.len;
}

<span class="tok-kw">fn</span> <span class="tok-fn">computeRedraw</span>(serialized_buffer: *<a href="std.Progress.Serialized.html">Serialized</a>.<a href="std.Progress.Serialized.Buffer.html">Buffer</a>) <span class="tok-kw">struct</span> { []<span class="tok-type">u8</span>, <span class="tok-type">usize</span> } {
    <span class="tok-kw">const</span> serialized = <a href="std.Progress.html#std.Progress.serialize">serialize</a>(serialized_buffer);<span class="tok-comment">

    // Now we can analyze our copy of the graph without atomics, reconstructing
    // children lists which do not exist in the canonical data. These are
    // needed for tree traversal below.

    </span><span class="tok-kw">var</span> children_buffer: [<a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a>]<a href="std.Progress.Children.html">Children</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> children = children_buffer[<span class="tok-number">0</span>..serialized.parents.len];

    <span class="tok-builtin">@memset</span>(children, .{ .child = .none, .sibling = .none });

    <span class="tok-kw">for</span> (serialized.parents, <span class="tok-number">0</span>..) |parent, child_index_usize| {
        <span class="tok-kw">const</span> child_index: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(child_index_usize);
        <a href="std.debug.html#std.debug.assert">assert</a>(parent != .unused);
        <span class="tok-kw">const</span> parent_index = parent.unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">const</span> children_node = &amp;children[<span class="tok-builtin">@intFromEnum</span>(parent_index)];
        <span class="tok-kw">if</span> (children_node.child.unwrap()) |existing_child_index| {
            <span class="tok-kw">const</span> existing_child = &amp;children[<span class="tok-builtin">@intFromEnum</span>(existing_child_index)];
            children[<span class="tok-builtin">@intFromEnum</span>(child_index)].sibling = existing_child.sibling;
            existing_child.sibling = child_index.toOptional();
        } <span class="tok-kw">else</span> {
            children_node.child = child_index.toOptional();
        }
    }<span class="tok-comment">

    // The strategy is, with every redraw:
    // erase to end of screen, write, move cursor to beginning of line, move cursor up N lines
    // This keeps the cursor at the beginning so that unlocked stderr writes
    // don't get eaten by the clear.

    </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> buf = <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">draw_buffer</a>;

    <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a> == .ansi_escape_codes) {
        buf[i..][<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.start_sync">start_sync</a>.<a href="#">len</a>].* = <a href="std.Progress.html#std.Progress.start_sync">start_sync</a>.*;
        i += <a href="std.Progress.html#std.Progress.start_sync">start_sync</a>.<a href="#">len</a>;
    }

    <span class="tok-kw">switch</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a>) {
        .off =&gt; <span class="tok-kw">unreachable</span>,
        .ansi_escape_codes =&gt; {
            buf[i..][<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.clear">clear</a>.<a href="#">len</a>].* = <a href="std.Progress.html#std.Progress.clear">clear</a>.*;
            i += <a href="std.Progress.html#std.Progress.clear">clear</a>.<a href="#">len</a>;
        },
        .windows_api =&gt; <span class="tok-kw">if</span> (!<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) <span class="tok-kw">unreachable</span>,
    }

    <span class="tok-kw">const</span> root_node_index: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
    i, <span class="tok-kw">const</span> nl_n = computeNode(buf, i, <span class="tok-number">0</span>, serialized, children, root_node_index);

    <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal_mode</a> == .ansi_escape_codes) {
        <span class="tok-kw">if</span> (nl_n &gt; <span class="tok-number">0</span>) {
            buf[i] = <span class="tok-str">'\r'</span>;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..nl_n) |_| {
                buf[i..][<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.up_one_line">up_one_line</a>.<a href="#">len</a>].* = <a href="std.Progress.html#std.Progress.up_one_line">up_one_line</a>.*;
                i += <a href="std.Progress.html#std.Progress.up_one_line">up_one_line</a>.<a href="#">len</a>;
            }
        }

        buf[i..][<span class="tok-number">0</span>..<a href="std.Progress.html#std.Progress.finish_sync">finish_sync</a>.<a href="#">len</a>].* = <a href="std.Progress.html#std.Progress.finish_sync">finish_sync</a>.*;
        i += <a href="std.Progress.html#std.Progress.finish_sync">finish_sync</a>.<a href="#">len</a>;
    }

    <span class="tok-kw">return</span> .{ buf[<span class="tok-number">0</span>..i], nl_n };
}

<span class="tok-kw">fn</span> <span class="tok-fn">computePrefix</span>(
    buf: []<span class="tok-type">u8</span>,
    start_i: <span class="tok-type">usize</span>,
    nl_n: <span class="tok-type">usize</span>,
    serialized: <a href="std.Progress.Serialized.html">Serialized</a>,
    children: []<span class="tok-kw">const</span> <a href="std.Progress.Children.html">Children</a>,
    node_index: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Index.html">Index</a>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i = start_i;
    <span class="tok-kw">const</span> parent_index = serialized.parents[<span class="tok-builtin">@intFromEnum</span>(node_index)].unwrap() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> i;
    <span class="tok-kw">if</span> (serialized.parents[<span class="tok-builtin">@intFromEnum</span>(parent_index)] == .none) <span class="tok-kw">return</span> i;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(serialized.parents[<span class="tok-builtin">@intFromEnum</span>(parent_index)]) == <span class="tok-number">0</span> <span class="tok-kw">and</span>
        serialized.storage[<span class="tok-number">0</span>].name[<span class="tok-number">0</span>] == <span class="tok-number">0</span>)
    {
        <span class="tok-kw">return</span> i;
    }
    i = <a href="std.Progress.html#std.Progress.computePrefix">computePrefix</a>(buf, i, nl_n, serialized, children, parent_index);
    <span class="tok-kw">if</span> (children[<span class="tok-builtin">@intFromEnum</span>(parent_index)].sibling == .none) {
        <span class="tok-kw">const</span> prefix = <span class="tok-str">&quot;   &quot;</span>;
        <span class="tok-kw">const</span> upper_bound_len = prefix.len + <a href="std.Progress.html#std.Progress.lineUpperBoundLen">lineUpperBoundLen</a>(nl_n);
        <span class="tok-kw">if</span> (i + upper_bound_len &gt; buf.len) <span class="tok-kw">return</span> buf.len;
        buf[i..][<span class="tok-number">0</span>..prefix.len].* = prefix.*;
        i += prefix.len;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> upper_bound_len = <a href="std.Progress.TreeSymbol.html">TreeSymbol</a>.<a href="#">line</a>.<a href="#">maxByteLen</a>() + <a href="std.Progress.html#std.Progress.lineUpperBoundLen">lineUpperBoundLen</a>(nl_n);
        <span class="tok-kw">if</span> (i + upper_bound_len &gt; buf.len) <span class="tok-kw">return</span> buf.len;
        i = <a href="std.Progress.html#std.Progress.appendTreeSymbol">appendTreeSymbol</a>(.line, buf, i);
    }
    <span class="tok-kw">return</span> i;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lineUpperBoundLen</span>(nl_n: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {<span class="tok-comment">
    // \r\n on Windows, \n otherwise.
    </span><span class="tok-kw">const</span> nl_len = <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) <span class="tok-number">2</span> <span class="tok-kw">else</span> <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> <span class="tok-builtin">@max</span>(<a href="std.Progress.TreeSymbol.html">TreeSymbol</a>.<a href="#">tee</a>.<a href="#">maxByteLen</a>(), <a href="std.Progress.TreeSymbol.html">TreeSymbol</a>.<a href="#">langle</a>.<a href="#">maxByteLen</a>()) +
        <span class="tok-str">&quot;[4294967296/4294967296] &quot;</span>.len + <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.max_name_len">max_name_len</a> + nl_len +
        (<span class="tok-number">1</span> + (nl_n + <span class="tok-number">1</span>) * <a href="std.Progress.html#std.Progress.up_one_line">up_one_line</a>.<a href="#">len</a>) +
        <a href="std.Progress.html#std.Progress.finish_sync">finish_sync</a>.<a href="#">len</a>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">computeNode</span>(
    buf: []<span class="tok-type">u8</span>,
    start_i: <span class="tok-type">usize</span>,
    start_nl_n: <span class="tok-type">usize</span>,
    serialized: <a href="std.Progress.Serialized.html">Serialized</a>,
    children: []<span class="tok-kw">const</span> <a href="std.Progress.Children.html">Children</a>,
    node_index: <a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Index.html">Index</a>,
) <span class="tok-kw">struct</span> { <span class="tok-type">usize</span>, <span class="tok-type">usize</span> } {
    <span class="tok-kw">var</span> i = start_i;
    <span class="tok-kw">var</span> nl_n = start_nl_n;

    i = <a href="std.Progress.html#std.Progress.computePrefix">computePrefix</a>(buf, i, nl_n, serialized, children, node_index);

    <span class="tok-kw">if</span> (i + <a href="std.Progress.html#std.Progress.lineUpperBoundLen">lineUpperBoundLen</a>(nl_n) &gt; buf.len)
        <span class="tok-kw">return</span> .{ start_i, start_nl_n };

    <span class="tok-kw">const</span> storage = &amp;serialized.storage[<span class="tok-builtin">@intFromEnum</span>(node_index)];
    <span class="tok-kw">const</span> estimated_total = storage.estimated_total_count;
    <span class="tok-kw">const</span> completed_items = storage.completed_count;
    <span class="tok-kw">const</span> name = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, &amp;storage.name, <span class="tok-number">0</span>)) |end| storage.name[<span class="tok-number">0</span>..end] <span class="tok-kw">else</span> &amp;storage.name;
    <span class="tok-kw">const</span> parent = serialized.parents[<span class="tok-builtin">@intFromEnum</span>(node_index)];

    <span class="tok-kw">if</span> (parent != .none) p: {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(parent) == <span class="tok-number">0</span> <span class="tok-kw">and</span> serialized.storage[<span class="tok-number">0</span>].name[<span class="tok-number">0</span>] == <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span> :p;
        }
        <span class="tok-kw">if</span> (children[<span class="tok-builtin">@intFromEnum</span>(node_index)].sibling == .none) {
            i = <a href="std.Progress.html#std.Progress.appendTreeSymbol">appendTreeSymbol</a>(.langle, buf, i);
        } <span class="tok-kw">else</span> {
            i = <a href="std.Progress.html#std.Progress.appendTreeSymbol">appendTreeSymbol</a>(.tee, buf, i);
        }
    }

    <span class="tok-kw">const</span> is_empty_root = <span class="tok-builtin">@intFromEnum</span>(node_index) == <span class="tok-number">0</span> <span class="tok-kw">and</span> serialized.storage[<span class="tok-number">0</span>].name[<span class="tok-number">0</span>] == <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (!is_empty_root) {
        <span class="tok-kw">if</span> (name.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> estimated_total &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (estimated_total &gt; <span class="tok-number">0</span>) {
                i += (<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(buf[i..], <span class="tok-str">&quot;[{d}/{d}] &quot;</span>, .{ completed_items, estimated_total }) <span class="tok-kw">catch</span> &amp;.{}).len;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (completed_items != <span class="tok-number">0</span>) {
                i += (<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(buf[i..], <span class="tok-str">&quot;[{d}] &quot;</span>, .{completed_items}) <span class="tok-kw">catch</span> &amp;.{}).len;
            }
            <span class="tok-kw">if</span> (name.len != <span class="tok-number">0</span>) {
                i += (<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(buf[i..], <span class="tok-str">&quot;{s}&quot;</span>, .{name}) <span class="tok-kw">catch</span> &amp;.{}).len;
            }
        }

        i = <span class="tok-builtin">@min</span>(<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">cols</a> + start_i, i);
        <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) {<span class="tok-comment">
            // \r\n on Windows is necessary for the old console with the
            // ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN
            // console modes set to behave properly.
            </span>buf[i] = <span class="tok-str">'\r'</span>;
            i += <span class="tok-number">1</span>;
        }
        buf[i] = <span class="tok-str">'\n'</span>;
        i += <span class="tok-number">1</span>;
        nl_n += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">withinRowLimit</a>(nl_n)) {
        <span class="tok-kw">if</span> (children[<span class="tok-builtin">@intFromEnum</span>(node_index)].child.unwrap()) |child| {
            i, nl_n = computeNode(buf, i, nl_n, serialized, children, child);
        }
    }

    <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">withinRowLimit</a>(nl_n)) {
        <span class="tok-kw">if</span> (children[<span class="tok-builtin">@intFromEnum</span>(node_index)].sibling.unwrap()) |sibling| {
            i, nl_n = computeNode(buf, i, nl_n, serialized, children, sibling);
        }
    }

    <span class="tok-kw">return</span> .{ i, nl_n };
}

<span class="tok-kw">fn</span> <span class="tok-fn">withinRowLimit</span>(p: *<a href="std.Progress.html">Progress</a>, nl_n: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {<span class="tok-comment">
    // The +2 here is so that the PS1 is not scrolled off the top of the terminal.
    // one because we keep the cursor on the next line
    // one more to account for the PS1
    </span><span class="tok-kw">return</span> nl_n + <span class="tok-number">2</span> &lt; p.rows;
}

<span class="tok-kw">fn</span> <span class="tok-fn">write</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal</a>.<a href="#">writeAll</a>(buf);
}

<span class="tok-kw">var</span> remaining_write_trash_bytes: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">writeIpc</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, serialized: <a href="std.Progress.Serialized.html">Serialized</a>) <span class="tok-kw">error</span>{BrokenPipe}!<span class="tok-type">void</span> {<span class="tok-comment">
    // Byteswap if necessary to ensure little endian over the pipe. This is
    // needed because the parent or child process might be running in qemu.
    </span><span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_big_endian">is_big_endian</a>) <span class="tok-kw">for</span> (serialized.storage) |*s| s.byteSwap();

    <a href="std.debug.html#std.debug.assert">assert</a>(serialized.parents.len == serialized.storage.len);
    <span class="tok-kw">const</span> serialized_len: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(serialized.parents.len);
    <span class="tok-kw">const</span> header = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;serialized_len);
    <span class="tok-kw">const</span> storage = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(serialized.storage);
    <span class="tok-kw">const</span> parents = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(serialized.parents);

    <span class="tok-kw">var</span> vecs: [<span class="tok-number">3</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a> = .{
        .{ .base = header.ptr, .len = header.len },
        .{ .base = storage.ptr, .len = storage.len },
        .{ .base = parents.ptr, .len = parents.len },
    };<span class="tok-comment">

    // Ensures the packet can fit in the pipe buffer.
    </span><span class="tok-kw">const</span> upper_bound_msg_len = <span class="tok-number">1</span> + <a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a> * <span class="tok-builtin">@sizeOf</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.Storage.html">Storage</a>) +
        <a href="std.Progress.html#std.Progress.node_storage_buffer_len">node_storage_buffer_len</a> * <span class="tok-builtin">@sizeOf</span>(<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.OptionalIndex.html">OptionalIndex</a>);
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(upper_bound_msg_len &lt;= <span class="tok-number">4096</span>);

    <span class="tok-kw">while</span> (<a href="std.Progress.html#std.Progress.remaining_write_trash_bytes">remaining_write_trash_bytes</a> &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
        // We do this in a separate write call to give a better chance for the
        // writev below to be in a single packet.
        </span><span class="tok-kw">const</span> n = <span class="tok-builtin">@min</span>(parents.len, <a href="std.Progress.html#std.Progress.remaining_write_trash_bytes">remaining_write_trash_bytes</a>);
        <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.write">write</a>(fd, parents[<span class="tok-number">0</span>..n])) |written| {
            <a href="std.Progress.html#std.Progress.remaining_write_trash_bytes">remaining_write_trash_bytes</a> -= written;
            <span class="tok-kw">continue</span>;
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
            <span class="tok-kw">else</span> =&gt; |e| {
                <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.debug">debug</a>(<span class="tok-str">&quot;failed to send progress to parent process: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe;
            },
        }
    }<span class="tok-comment">

    // If this write would block we do not want to keep trying, but we need to
    // know if a partial message was written.
    </span><span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.writevNonblock">writevNonblock</a>(fd, &amp;vecs)) |written| {
        <span class="tok-kw">const</span> total = header.len + storage.len + parents.len;
        <span class="tok-kw">if</span> (written &lt; total) {
            <a href="std.Progress.html#std.Progress.remaining_write_trash_bytes">remaining_write_trash_bytes</a> = total - written;
        }
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.WouldBlock =&gt; {},
        <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe,
        <span class="tok-kw">else</span> =&gt; |e| {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.debug">debug</a>(<span class="tok-str">&quot;failed to send progress to parent process: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BrokenPipe;
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">writevNonblock</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, iov: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> iov_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> total_written: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">while</span> (<span class="tok-kw">if</span> (iov_index &lt; iov.len)
            written &gt;= iov[iov_index].len
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> total_written) : (iov_index += <span class="tok-number">1</span>) written -= iov[iov_index].len;
        iov[iov_index].base += written;
        iov[iov_index].len -= written;
        written = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.writev">writev</a>(fd, iov[iov_index..]);
        <span class="tok-kw">if</span> (written == <span class="tok-number">0</span>) <span class="tok-kw">return</span> total_written;
        total_written += written;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">maybeUpdateSize</span>(resize_flag: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!resize_flag) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> fd = <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">terminal</a>.<a href="#">handle</a>;

    <span class="tok-kw">if</span> (<a href="std.Progress.html#std.Progress.is_windows">is_windows</a>) {
        <span class="tok-kw">var</span> info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.CONSOLE_SCREEN_BUFFER_INFO.html">CONSOLE_SCREEN_BUFFER_INFO</a> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleScreenBufferInfo">GetConsoleScreenBufferInfo</a>(fd, &amp;info) != <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FALSE">FALSE</a>) {<span class="tok-comment">
            // In the old Windows console, dwSize.Y is the line count of the
            // entire scrollback buffer, so we use this instead so that we
            // always get the size of the screen.
            </span><span class="tok-kw">const</span> screen_height = info.srWindow.Bottom - info.srWindow.Top;
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">rows</a> = <span class="tok-builtin">@intCast</span>(screen_height);
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">cols</a> = <span class="tok-builtin">@intCast</span>(info.dwSize.X);
        } <span class="tok-kw">else</span> {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.debug">debug</a>(<span class="tok-str">&quot;failed to determine terminal size; using conservative guess 80x25&quot;</span>, .{});
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">rows</a> = <span class="tok-number">25</span>;
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">cols</a> = <span class="tok-number">80</span>;
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">var</span> winsize: <a href="std.posix.html">posix</a>.<a href="std.posix.winsize.html">winsize</a> = .{
            .row = <span class="tok-number">0</span>,
            .col = <span class="tok-number">0</span>,
            .xpixel = <span class="tok-number">0</span>,
            .ypixel = <span class="tok-number">0</span>,
        };

        <span class="tok-kw">const</span> err = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">ioctl</a>(fd, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.T">T</a>.<a href="#">IOCGWINSZ</a>, <span class="tok-builtin">@intFromPtr</span>(&amp;winsize));
        <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(err) == .SUCCESS) {
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">rows</a> = winsize.row;
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">cols</a> = winsize.col;
        } <span class="tok-kw">else</span> {
            <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.debug">debug</a>(<span class="tok-str">&quot;failed to determine terminal size; using conservative guess 80x25&quot;</span>, .{});
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">rows</a> = <span class="tok-number">25</span>;
            <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">cols</a> = <span class="tok-number">80</span>;
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">handleSigWinch</span>(sig: <span class="tok-type">i32</span>, info: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.siginfo_t">siginfo_t</a>, ctx_ptr: ?*<span class="tok-type">anyopaque</span>) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">void</span> {
    _ = info;
    _ = ctx_ptr;
    <a href="std.debug.html#std.debug.assert">assert</a>(sig == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">WINCH</a>);
    <a href="std.Progress.html#std.Progress.global_progress">global_progress</a>.<a href="#">redraw_event</a>.<a href="#">set</a>();
}

<span class="tok-kw">const</span> have_sigwinch = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
    .linux,
    .plan9,
    .solaris,
    .netbsd,
    .openbsd,
    .haiku,
    .macos,
    .ios,
    .watchos,
    .tvos,
    .visionos,
    .dragonfly,
    .freebsd,
    =&gt; <span class="tok-null">true</span>,

    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
};

<span class="tok-comment">/// The primary motivation for recursive mutex here is so that a panic while</span>
<span class="tok-comment">/// stderr mutex is held still dumps the stack trace and other debug</span>
<span class="tok-comment">/// information.</span>
<span class="tok-kw">var</span> stderr_mutex = <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a>.<a href="std.Thread.Mutex.Recursive.html">Recursive</a>.<a href="std.Thread.Mutex.Recursive.html#std.Thread.Mutex.Recursive.init">init</a>;

<span class="tok-kw">fn</span> <span class="tok-fn">copyAtomicStore</span>(dest: []<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>)) <span class="tok-type">u8</span>, src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(dest.len == src.len);
    <span class="tok-kw">const</span> chunked_len = dest.len / <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
    <span class="tok-kw">const</span> dest_chunked: []<span class="tok-type">usize</span> = <span class="tok-builtin">@as</span>([*]<span class="tok-type">usize</span>, <span class="tok-builtin">@ptrCast</span>(dest))[<span class="tok-number">0</span>..chunked_len];
    <span class="tok-kw">const</span> src_chunked: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">usize</span> = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrCast</span>(src))[<span class="tok-number">0</span>..chunked_len];
    <span class="tok-kw">for</span> (dest_chunked, src_chunked) |*d, s| {
        <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">usize</span>, d, s, .monotonic);
    }
    <span class="tok-kw">const</span> remainder_start = chunked_len * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
    <span class="tok-kw">for</span> (dest[remainder_start..], src[remainder_start..]) |*d, s| {
        <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u8</span>, d, s, .monotonic);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">copyAtomicLoad</span>(
    dest: *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>)) [<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.max_name_len">max_name_len</a>]<span class="tok-type">u8</span>,
    src: *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">const</span> [<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.max_name_len">max_name_len</a>]<span class="tok-type">u8</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> chunked_len = <span class="tok-builtin">@divExact</span>(dest.len, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>));
    <span class="tok-kw">const</span> dest_chunked: *[chunked_len]<span class="tok-type">usize</span> = <span class="tok-builtin">@ptrCast</span>(dest);
    <span class="tok-kw">const</span> src_chunked: *<span class="tok-kw">const</span> [chunked_len]<span class="tok-type">usize</span> = <span class="tok-builtin">@ptrCast</span>(src);
    <span class="tok-kw">for</span> (dest_chunked, src_chunked) |*d, *s| {
        d.* = <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">usize</span>, s, .monotonic);
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
