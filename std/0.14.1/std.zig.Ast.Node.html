<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.Ast.html" class="">Ast</a></li><li><a href="std.zig.Ast.Node.html" class="active">Node</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.Ast.Node" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zig.Ast.Node</span><a href="#src.zig-std.zig.Ast.Node">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.zig.Ast.Node.Tag.html">std.zig.Ast.Node.Tag</a></li><li><a href="std.zig.Ast.Node.Data.html">std.zig.Ast.Node.Data</a></li><li><a href="std.zig.Ast.Node.LocalVarDecl.html">std.zig.Ast.Node.LocalVarDecl</a></li><li><a href="std.zig.Ast.Node.ArrayTypeSentinel.html">std.zig.Ast.Node.ArrayTypeSentinel</a></li><li><a href="std.zig.Ast.Node.PtrType.html">std.zig.Ast.Node.PtrType</a></li><li><a href="std.zig.Ast.Node.PtrTypeBitRange.html">std.zig.Ast.Node.PtrTypeBitRange</a></li><li><a href="std.zig.Ast.Node.SubRange.html">std.zig.Ast.Node.SubRange</a></li><li><a href="std.zig.Ast.Node.If.html">std.zig.Ast.Node.If</a></li><li><a href="std.zig.Ast.Node.ContainerField.html">std.zig.Ast.Node.ContainerField</a></li><li><a href="std.zig.Ast.Node.GlobalVarDecl.html">std.zig.Ast.Node.GlobalVarDecl</a></li><li><a href="std.zig.Ast.Node.Slice.html">std.zig.Ast.Node.Slice</a></li><li><a href="std.zig.Ast.Node.SliceSentinel.html">std.zig.Ast.Node.SliceSentinel</a></li><li><a href="std.zig.Ast.Node.While.html">std.zig.Ast.Node.While</a></li><li><a href="std.zig.Ast.Node.WhileCont.html">std.zig.Ast.Node.WhileCont</a></li><li><a href="std.zig.Ast.Node.For.html">std.zig.Ast.Node.For</a></li><li><a href="std.zig.Ast.Node.FnProtoOne.html">std.zig.Ast.Node.FnProtoOne</a></li><li><a href="std.zig.Ast.Node.FnProto.html">std.zig.Ast.Node.FnProto</a></li><li><a href="std.zig.Ast.Node.Asm.html">std.zig.Ast.Node.Asm</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.zig.Ast.Node.Index" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Index</span><a href="#src.zig-std.zig.Ast.Node.Index">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.Node.Index">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-type">u32</span></code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a></code></pre></div><div><pre><code>main_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div><div><pre><code>data: <a href="std.zig.Ast.Node.Data.html">Data</a></code></pre></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.Ast.Node">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
    tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a>,
    main_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    data: <a href="std.zig.Ast.Node.Data.html">Data</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-type">u32</span>;

    <span class="tok-kw">comptime</span> {<span class="tok-comment">
        // Goal is to keep this under one byte for efficiency.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.zig.Ast.Node.Tag.html">Tag</a>) == <span class="tok-number">1</span>);
    }

    <span class="tok-comment">/// Note: The FooComma/FooSemicolon variants exist to ease the implementation of</span>
    <span class="tok-comment">/// Ast.lastToken()</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// sub_list[lhs...rhs]</span>
        root,
        <span class="tok-comment">/// `usingnamespace lhs;`. rhs unused. main_token is `usingnamespace`.</span>
        @&quot;usingnamespace&quot;,
        <span class="tok-comment">/// lhs is test name token (must be string literal or identifier), if any.</span>
        <span class="tok-comment">/// rhs is the body node.</span>
        test_decl,
        <span class="tok-comment">/// lhs is the index into extra_data.</span>
        <span class="tok-comment">/// rhs is the initialization expression, if any.</span>
        <span class="tok-comment">/// main_token is `var` or `const`.</span>
        global_var_decl,
        <span class="tok-comment">/// `var a: x align(y) = rhs`</span>
        <span class="tok-comment">/// lhs is the index into extra_data.</span>
        <span class="tok-comment">/// main_token is `var` or `const`.</span>
        local_var_decl,
        <span class="tok-comment">/// `var a: lhs = rhs`. lhs and rhs may be unused.</span>
        <span class="tok-comment">/// Can be local or global.</span>
        <span class="tok-comment">/// main_token is `var` or `const`.</span>
        simple_var_decl,
        <span class="tok-comment">/// `var a align(lhs) = rhs`. lhs and rhs may be unused.</span>
        <span class="tok-comment">/// Can be local or global.</span>
        <span class="tok-comment">/// main_token is `var` or `const`.</span>
        aligned_var_decl,
        <span class="tok-comment">/// lhs is the identifier token payload if any,</span>
        <span class="tok-comment">/// rhs is the deferred expression.</span>
        @&quot;errdefer&quot;,
        <span class="tok-comment">/// lhs is unused.</span>
        <span class="tok-comment">/// rhs is the deferred expression.</span>
        @&quot;defer&quot;,
        <span class="tok-comment">/// lhs catch rhs</span>
        <span class="tok-comment">/// lhs catch |err| rhs</span>
        <span class="tok-comment">/// main_token is the `catch` keyword.</span>
        <span class="tok-comment">/// payload is determined by looking at the next token after the `catch` keyword.</span>
        @&quot;catch&quot;,
        <span class="tok-comment">/// `lhs.a`. main_token is the dot. rhs is the identifier token index.</span>
        field_access,
        <span class="tok-comment">/// `lhs.?`. main_token is the dot. rhs is the `?` token index.</span>
        unwrap_optional,
        <span class="tok-comment">/// `lhs == rhs`. main_token is op.</span>
        equal_equal,
        <span class="tok-comment">/// `lhs != rhs`. main_token is op.</span>
        bang_equal,
        <span class="tok-comment">/// `lhs &lt; rhs`. main_token is op.</span>
        less_than,
        <span class="tok-comment">/// `lhs &gt; rhs`. main_token is op.</span>
        greater_than,
        <span class="tok-comment">/// `lhs &lt;= rhs`. main_token is op.</span>
        less_or_equal,
        <span class="tok-comment">/// `lhs &gt;= rhs`. main_token is op.</span>
        greater_or_equal,
        <span class="tok-comment">/// `lhs *= rhs`. main_token is op.</span>
        assign_mul,
        <span class="tok-comment">/// `lhs /= rhs`. main_token is op.</span>
        assign_div,
        <span class="tok-comment">/// `lhs %= rhs`. main_token is op.</span>
        assign_mod,
        <span class="tok-comment">/// `lhs += rhs`. main_token is op.</span>
        assign_add,
        <span class="tok-comment">/// `lhs -= rhs`. main_token is op.</span>
        assign_sub,
        <span class="tok-comment">/// `lhs &lt;&lt;= rhs`. main_token is op.</span>
        assign_shl,
        <span class="tok-comment">/// `lhs &lt;&lt;|= rhs`. main_token is op.</span>
        assign_shl_sat,
        <span class="tok-comment">/// `lhs &gt;&gt;= rhs`. main_token is op.</span>
        assign_shr,
        <span class="tok-comment">/// `lhs &amp;= rhs`. main_token is op.</span>
        assign_bit_and,
        <span class="tok-comment">/// `lhs ^= rhs`. main_token is op.</span>
        assign_bit_xor,
        <span class="tok-comment">/// `lhs |= rhs`. main_token is op.</span>
        assign_bit_or,
        <span class="tok-comment">/// `lhs *%= rhs`. main_token is op.</span>
        assign_mul_wrap,
        <span class="tok-comment">/// `lhs +%= rhs`. main_token is op.</span>
        assign_add_wrap,
        <span class="tok-comment">/// `lhs -%= rhs`. main_token is op.</span>
        assign_sub_wrap,
        <span class="tok-comment">/// `lhs *|= rhs`. main_token is op.</span>
        assign_mul_sat,
        <span class="tok-comment">/// `lhs +|= rhs`. main_token is op.</span>
        assign_add_sat,
        <span class="tok-comment">/// `lhs -|= rhs`. main_token is op.</span>
        assign_sub_sat,
        <span class="tok-comment">/// `lhs = rhs`. main_token is op.</span>
        assign,
        <span class="tok-comment">/// `a, b, ... = rhs`. main_token is op. lhs is index into `extra_data`</span>
        <span class="tok-comment">/// of an lhs elem count followed by an array of that many `Node.Index`,</span>
        <span class="tok-comment">/// with each node having one of the following types:</span>
        <span class="tok-comment">/// * `global_var_decl`</span>
        <span class="tok-comment">/// * `local_var_decl`</span>
        <span class="tok-comment">/// * `simple_var_decl`</span>
        <span class="tok-comment">/// * `aligned_var_decl`</span>
        <span class="tok-comment">/// * Any expression node</span>
        <span class="tok-comment">/// The first 3 types correspond to a `var` or `const` lhs node (note</span>
        <span class="tok-comment">/// that their `rhs` is always 0). An expression node corresponds to a</span>
        <span class="tok-comment">/// standard assignment LHS (which must be evaluated as an lvalue).</span>
        <span class="tok-comment">/// There may be a preceding `comptime` token, which does not create a</span>
        <span class="tok-comment">/// corresponding `comptime` node so must be manually detected.</span>
        assign_destructure,
        <span class="tok-comment">/// `lhs || rhs`. main_token is the `||`.</span>
        merge_error_sets,
        <span class="tok-comment">/// `lhs * rhs`. main_token is the `*`.</span>
        mul,
        <span class="tok-comment">/// `lhs / rhs`. main_token is the `/`.</span>
        div,
        <span class="tok-comment">/// `lhs % rhs`. main_token is the `%`.</span>
        mod,
        <span class="tok-comment">/// `lhs ** rhs`. main_token is the `**`.</span>
        array_mult,
        <span class="tok-comment">/// `lhs *% rhs`. main_token is the `*%`.</span>
        mul_wrap,
        <span class="tok-comment">/// `lhs *| rhs`. main_token is the `*|`.</span>
        mul_sat,
        <span class="tok-comment">/// `lhs + rhs`. main_token is the `+`.</span>
        add,
        <span class="tok-comment">/// `lhs - rhs`. main_token is the `-`.</span>
        sub,
        <span class="tok-comment">/// `lhs ++ rhs`. main_token is the `++`.</span>
        array_cat,
        <span class="tok-comment">/// `lhs +% rhs`. main_token is the `+%`.</span>
        add_wrap,
        <span class="tok-comment">/// `lhs -% rhs`. main_token is the `-%`.</span>
        sub_wrap,
        <span class="tok-comment">/// `lhs +| rhs`. main_token is the `+|`.</span>
        add_sat,
        <span class="tok-comment">/// `lhs -| rhs`. main_token is the `-|`.</span>
        sub_sat,
        <span class="tok-comment">/// `lhs &lt;&lt; rhs`. main_token is the `&lt;&lt;`.</span>
        shl,
        <span class="tok-comment">/// `lhs &lt;&lt;| rhs`. main_token is the `&lt;&lt;|`.</span>
        shl_sat,
        <span class="tok-comment">/// `lhs &gt;&gt; rhs`. main_token is the `&gt;&gt;`.</span>
        shr,
        <span class="tok-comment">/// `lhs &amp; rhs`. main_token is the `&amp;`.</span>
        bit_and,
        <span class="tok-comment">/// `lhs ^ rhs`. main_token is the `^`.</span>
        bit_xor,
        <span class="tok-comment">/// `lhs | rhs`. main_token is the `|`.</span>
        bit_or,
        <span class="tok-comment">/// `lhs orelse rhs`. main_token is the `orelse`.</span>
        @&quot;orelse&quot;,
        <span class="tok-comment">/// `lhs and rhs`. main_token is the `and`.</span>
        bool_and,
        <span class="tok-comment">/// `lhs or rhs`. main_token is the `or`.</span>
        bool_or,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        bool_not,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        negation,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        bit_not,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        negation_wrap,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        address_of,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        @&quot;try&quot;,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        @&quot;await&quot;,
        <span class="tok-comment">/// `?lhs`. rhs unused. main_token is the `?`.</span>
        optional_type,
        <span class="tok-comment">/// `[lhs]rhs`.</span>
        array_type,
        <span class="tok-comment">/// `[lhs:a]b`. `ArrayTypeSentinel[rhs]`.</span>
        array_type_sentinel,
        <span class="tok-comment">/// `[*]align(lhs) rhs`. lhs can be omitted.</span>
        <span class="tok-comment">/// `*align(lhs) rhs`. lhs can be omitted.</span>
        <span class="tok-comment">/// `[]rhs`.</span>
        <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
        <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
        <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
        <span class="tok-comment">/// pointer type and may require special handling.</span>
        ptr_type_aligned,
        <span class="tok-comment">/// `[*:lhs]rhs`. lhs can be omitted.</span>
        <span class="tok-comment">/// `*rhs`.</span>
        <span class="tok-comment">/// `[:lhs]rhs`.</span>
        <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
        <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
        <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
        <span class="tok-comment">/// pointer type and may require special handling.</span>
        ptr_type_sentinel,
        <span class="tok-comment">/// lhs is index into ptr_type. rhs is the element type expression.</span>
        <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
        <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
        <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
        <span class="tok-comment">/// pointer type and may require special handling.</span>
        ptr_type,
        <span class="tok-comment">/// lhs is index into ptr_type_bit_range. rhs is the element type expression.</span>
        <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
        <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
        <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
        <span class="tok-comment">/// pointer type and may require special handling.</span>
        ptr_type_bit_range,
        <span class="tok-comment">/// `lhs[rhs..]`</span>
        <span class="tok-comment">/// main_token is the lbracket.</span>
        slice_open,
        <span class="tok-comment">/// `lhs[b..c]`. rhs is index into Slice</span>
        <span class="tok-comment">/// main_token is the lbracket.</span>
        <a href="std.zig.Ast.html#std.zig.Ast.slice">slice</a>,
        <span class="tok-comment">/// `lhs[b..c :d]`. rhs is index into SliceSentinel. Slice end &quot;c&quot; can be omitted.</span>
        <span class="tok-comment">/// main_token is the lbracket.</span>
        slice_sentinel,
        <span class="tok-comment">/// `lhs.*`. rhs is unused.</span>
        deref,
        <span class="tok-comment">/// `lhs[rhs]`.</span>
        array_access,
        <span class="tok-comment">/// `lhs{rhs}`. rhs can be omitted.</span>
        array_init_one,
        <span class="tok-comment">/// `lhs{rhs,}`. rhs can *not* be omitted</span>
        array_init_one_comma,
        <span class="tok-comment">/// `.{lhs, rhs}`. lhs and rhs can be omitted.</span>
        array_init_dot_two,
        <span class="tok-comment">/// Same as `array_init_dot_two` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        array_init_dot_two_comma,
        <span class="tok-comment">/// `.{a, b}`. `sub_list[lhs..rhs]`.</span>
        array_init_dot,
        <span class="tok-comment">/// Same as `array_init_dot` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        array_init_dot_comma,
        <span class="tok-comment">/// `lhs{a, b}`. `sub_range_list[rhs]`. lhs can be omitted which means `.{a, b}`.</span>
        array_init,
        <span class="tok-comment">/// Same as `array_init` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        array_init_comma,
        <span class="tok-comment">/// `lhs{.a = rhs}`. rhs can be omitted making it empty.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        struct_init_one,
        <span class="tok-comment">/// `lhs{.a = rhs,}`. rhs can *not* be omitted.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        struct_init_one_comma,
        <span class="tok-comment">/// `.{.a = lhs, .b = rhs}`. lhs and rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        <span class="tok-comment">/// No trailing comma before the rbrace.</span>
        struct_init_dot_two,
        <span class="tok-comment">/// Same as `struct_init_dot_two` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        struct_init_dot_two_comma,
        <span class="tok-comment">/// `.{.a = b, .c = d}`. `sub_list[lhs..rhs]`.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        struct_init_dot,
        <span class="tok-comment">/// Same as `struct_init_dot` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        struct_init_dot_comma,
        <span class="tok-comment">/// `lhs{.a = b, .c = d}`. `sub_range_list[rhs]`.</span>
        <span class="tok-comment">/// lhs can be omitted which means `.{.a = b, .c = d}`.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        struct_init,
        <span class="tok-comment">/// Same as `struct_init` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        struct_init_comma,
        <span class="tok-comment">/// `lhs(rhs)`. rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the lparen.</span>
        call_one,
        <span class="tok-comment">/// `lhs(rhs,)`. rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the lparen.</span>
        call_one_comma,
        <span class="tok-comment">/// `async lhs(rhs)`. rhs can be omitted.</span>
        async_call_one,
        <span class="tok-comment">/// `async lhs(rhs,)`.</span>
        async_call_one_comma,
        <span class="tok-comment">/// `lhs(a, b, c)`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// main_token is the `(`.</span>
        call,
        <span class="tok-comment">/// `lhs(a, b, c,)`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// main_token is the `(`.</span>
        call_comma,
        <span class="tok-comment">/// `async lhs(a, b, c)`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// main_token is the `(`.</span>
        async_call,
        <span class="tok-comment">/// `async lhs(a, b, c,)`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// main_token is the `(`.</span>
        async_call_comma,
        <span class="tok-comment">/// `switch(lhs) {}`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// `main_token` is the identifier of a preceding label, if any; otherwise `switch`.</span>
        @&quot;switch&quot;,
        <span class="tok-comment">/// Same as switch except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace</span>
        switch_comma,
        <span class="tok-comment">/// `lhs =&gt; rhs`. If lhs is omitted it means `else`.</span>
        <span class="tok-comment">/// main_token is the `=&gt;`</span>
        switch_case_one,
        <span class="tok-comment">/// Same ast `switch_case_one` but the case is inline</span>
        switch_case_inline_one,
        <span class="tok-comment">/// `a, b, c =&gt; rhs`. `SubRange[lhs]`.</span>
        <span class="tok-comment">/// main_token is the `=&gt;`</span>
        switch_case,
        <span class="tok-comment">/// Same ast `switch_case` but the case is inline</span>
        switch_case_inline,
        <span class="tok-comment">/// `lhs...rhs`.</span>
        switch_range,
        <span class="tok-comment">/// `while (lhs) rhs`.</span>
        <span class="tok-comment">/// `while (lhs) |x| rhs`.</span>
        while_simple,
        <span class="tok-comment">/// `while (lhs) : (a) b`. `WhileCont[rhs]`.</span>
        <span class="tok-comment">/// `while (lhs) : (a) b`. `WhileCont[rhs]`.</span>
        while_cont,
        <span class="tok-comment">/// `while (lhs) : (a) b else c`. `While[rhs]`.</span>
        <span class="tok-comment">/// `while (lhs) |x| : (a) b else c`. `While[rhs]`.</span>
        <span class="tok-comment">/// `while (lhs) |x| : (a) b else |y| c`. `While[rhs]`.</span>
        <span class="tok-comment">/// The cont expression part `: (a)` may be omitted.</span>
        @&quot;while&quot;,
        <span class="tok-comment">/// `for (lhs) rhs`.</span>
        for_simple,
        <span class="tok-comment">/// `for (lhs[0..inputs]) lhs[inputs + 1] else lhs[inputs + 2]`. `For[rhs]`.</span>
        @&quot;for&quot;,
        <span class="tok-comment">/// `lhs..rhs`. rhs can be omitted.</span>
        for_range,
        <span class="tok-comment">/// `if (lhs) rhs`.</span>
        <span class="tok-comment">/// `if (lhs) |a| rhs`.</span>
        if_simple,
        <span class="tok-comment">/// `if (lhs) a else b`. `If[rhs]`.</span>
        <span class="tok-comment">/// `if (lhs) |x| a else b`. `If[rhs]`.</span>
        <span class="tok-comment">/// `if (lhs) |x| a else |y| b`. `If[rhs]`.</span>
        @&quot;if&quot;,
        <span class="tok-comment">/// `suspend lhs`. lhs can be omitted. rhs is unused.</span>
        @&quot;suspend&quot;,
        <span class="tok-comment">/// `resume lhs`. rhs is unused.</span>
        @&quot;resume&quot;,
        <span class="tok-comment">/// `continue :lhs rhs`</span>
        <span class="tok-comment">/// both lhs and rhs may be omitted.</span>
        @&quot;continue&quot;,
        <span class="tok-comment">/// `break :lhs rhs`</span>
        <span class="tok-comment">/// both lhs and rhs may be omitted.</span>
        @&quot;break&quot;,
        <span class="tok-comment">/// `return lhs`. lhs can be omitted. rhs is unused.</span>
        @&quot;return&quot;,
        <span class="tok-comment">/// `fn (a: lhs) rhs`. lhs can be omitted.</span>
        <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
        <span class="tok-comment">/// main_token is the `fn` keyword.</span>
        <span class="tok-comment">/// extern function declarations use this tag.</span>
        fn_proto_simple,
        <span class="tok-comment">/// `fn (a: b, c: d) rhs`. `sub_range_list[lhs]`.</span>
        <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
        <span class="tok-comment">/// main_token is the `fn` keyword.</span>
        <span class="tok-comment">/// extern function declarations use this tag.</span>
        fn_proto_multi,
        <span class="tok-comment">/// `fn (a: b) addrspace(e) linksection(f) callconv(g) rhs`. `FnProtoOne[lhs]`.</span>
        <span class="tok-comment">/// zero or one parameters.</span>
        <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
        <span class="tok-comment">/// main_token is the `fn` keyword.</span>
        <span class="tok-comment">/// extern function declarations use this tag.</span>
        fn_proto_one,
        <span class="tok-comment">/// `fn (a: b, c: d) addrspace(e) linksection(f) callconv(g) rhs`. `FnProto[lhs]`.</span>
        <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
        <span class="tok-comment">/// main_token is the `fn` keyword.</span>
        <span class="tok-comment">/// extern function declarations use this tag.</span>
        fn_proto,
        <span class="tok-comment">/// lhs is the fn_proto.</span>
        <span class="tok-comment">/// rhs is the function body block.</span>
        <span class="tok-comment">/// Note that extern function declarations use the fn_proto tags rather</span>
        <span class="tok-comment">/// than this one.</span>
        fn_decl,
        <span class="tok-comment">/// `anyframe-&gt;rhs`. main_token is `anyframe`. `lhs` is arrow token index.</span>
        anyframe_type,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        anyframe_literal,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        char_literal,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        number_literal,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        unreachable_literal,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        <span class="tok-comment">/// Most identifiers will not have explicit AST nodes, however for expressions</span>
        <span class="tok-comment">/// which could be one of many different kinds of AST nodes, there will be an</span>
        <span class="tok-comment">/// identifier AST node for it.</span>
        identifier,
        <span class="tok-comment">/// lhs is the dot token index, rhs unused, main_token is the identifier.</span>
        enum_literal,
        <span class="tok-comment">/// main_token is the string literal token</span>
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        string_literal,
        <span class="tok-comment">/// main_token is the first token index (redundant with lhs)</span>
        <span class="tok-comment">/// lhs is the first token index; rhs is the last token index.</span>
        <span class="tok-comment">/// Could be a series of multiline_string_literal_line tokens, or a single</span>
        <span class="tok-comment">/// string_literal token.</span>
        multiline_string_literal,
        <span class="tok-comment">/// `(lhs)`. main_token is the `(`; rhs is the token index of the `)`.</span>
        grouped_expression,
        <span class="tok-comment">/// `@a(lhs, rhs)`. lhs and rhs may be omitted.</span>
        <span class="tok-comment">/// main_token is the builtin token.</span>
        builtin_call_two,
        <span class="tok-comment">/// Same as builtin_call_two but there is known to be a trailing comma before the rparen.</span>
        builtin_call_two_comma,
        <span class="tok-comment">/// `@a(b, c)`. `sub_list[lhs..rhs]`.</span>
        <span class="tok-comment">/// main_token is the builtin token.</span>
        builtin_call,
        <span class="tok-comment">/// Same as builtin_call but there is known to be a trailing comma before the rparen.</span>
        builtin_call_comma,
        <span class="tok-comment">/// `error{a, b}`.</span>
        <span class="tok-comment">/// rhs is the rbrace, lhs is unused.</span>
        error_set_decl,
        <span class="tok-comment">/// `struct {}`, `union {}`, `opaque {}`, `enum {}`. `extra_data[lhs..rhs]`.</span>
        <span class="tok-comment">/// main_token is `struct`, `union`, `opaque`, `enum` keyword.</span>
        container_decl,
        <span class="tok-comment">/// Same as ContainerDecl but there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        container_decl_trailing,
        <span class="tok-comment">/// `struct {lhs, rhs}`, `union {lhs, rhs}`, `opaque {lhs, rhs}`, `enum {lhs, rhs}`.</span>
        <span class="tok-comment">/// lhs or rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is `struct`, `union`, `opaque`, `enum` keyword.</span>
        container_decl_two,
        <span class="tok-comment">/// Same as ContainerDeclTwo except there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        container_decl_two_trailing,
        <span class="tok-comment">/// `struct(lhs)` / `union(lhs)` / `enum(lhs)`. `SubRange[rhs]`.</span>
        container_decl_arg,
        <span class="tok-comment">/// Same as container_decl_arg but there is known to be a trailing</span>
        <span class="tok-comment">/// comma or semicolon before the rbrace.</span>
        container_decl_arg_trailing,
        <span class="tok-comment">/// `union(enum) {}`. `sub_list[lhs..rhs]`.</span>
        <span class="tok-comment">/// Note that tagged unions with explicitly provided enums are represented</span>
        <span class="tok-comment">/// by `container_decl_arg`.</span>
        tagged_union,
        <span class="tok-comment">/// Same as tagged_union but there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        tagged_union_trailing,
        <span class="tok-comment">/// `union(enum) {lhs, rhs}`. lhs or rhs may be omitted.</span>
        <span class="tok-comment">/// Note that tagged unions with explicitly provided enums are represented</span>
        <span class="tok-comment">/// by `container_decl_arg`.</span>
        tagged_union_two,
        <span class="tok-comment">/// Same as tagged_union_two but there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        tagged_union_two_trailing,
        <span class="tok-comment">/// `union(enum(lhs)) {}`. `SubRange[rhs]`.</span>
        tagged_union_enum_tag,
        <span class="tok-comment">/// Same as tagged_union_enum_tag but there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        tagged_union_enum_tag_trailing,
        <span class="tok-comment">/// `a: lhs = rhs,`. lhs and rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the field name identifier.</span>
        <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
        container_field_init,
        <span class="tok-comment">/// `a: lhs align(rhs),`. rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the field name identifier.</span>
        <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
        container_field_align,
        <span class="tok-comment">/// `a: lhs align(c) = d,`. `container_field_list[rhs]`.</span>
        <span class="tok-comment">/// main_token is the field name identifier.</span>
        <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
        container_field,
        <span class="tok-comment">/// `comptime lhs`. rhs unused.</span>
        @&quot;comptime&quot;,
        <span class="tok-comment">/// `nosuspend lhs`. rhs unused.</span>
        @&quot;nosuspend&quot;,
        <span class="tok-comment">/// `{lhs rhs}`. rhs or lhs can be omitted.</span>
        <span class="tok-comment">/// main_token points at the lbrace.</span>
        block_two,
        <span class="tok-comment">/// Same as block_two but there is known to be a semicolon before the rbrace.</span>
        block_two_semicolon,
        <span class="tok-comment">/// `{}`. `sub_list[lhs..rhs]`.</span>
        <span class="tok-comment">/// main_token points at the lbrace.</span>
        block,
        <span class="tok-comment">/// Same as block but there is known to be a semicolon before the rbrace.</span>
        block_semicolon,
        <span class="tok-comment">/// `asm(lhs)`. rhs is the token index of the rparen.</span>
        asm_simple,
        <span class="tok-comment">/// `asm(lhs, a)`. `Asm[rhs]`.</span>
        @&quot;asm&quot;,
        <span class="tok-comment">/// `[a] &quot;b&quot; (c)`. lhs is 0, rhs is token index of the rparen.</span>
        <span class="tok-comment">/// `[a] &quot;b&quot; (-&gt; lhs)`. rhs is token index of the rparen.</span>
        <span class="tok-comment">/// main_token is `a`.</span>
        asm_output,
        <span class="tok-comment">/// `[a] &quot;b&quot; (lhs)`. rhs is token index of the rparen.</span>
        <span class="tok-comment">/// main_token is `a`.</span>
        asm_input,
        <span class="tok-comment">/// `error.a`. lhs is token index of `.`. rhs is token index of `a`.</span>
        error_value,
        <span class="tok-comment">/// `lhs!rhs`. main_token is the `!`.</span>
        error_union,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isContainerField</span>(tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {
                .container_field_init,
                .container_field_align,
                .container_field,
                =&gt; <span class="tok-null">true</span>,

                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        rhs: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LocalVarDecl = <span class="tok-kw">struct</span> {
        type_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        align_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayTypeSentinel = <span class="tok-kw">struct</span> {
        sentinel: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        elem_type: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtrType = <span class="tok-kw">struct</span> {
        sentinel: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        align_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        addrspace_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtrTypeBitRange = <span class="tok-kw">struct</span> {
        sentinel: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        align_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        addrspace_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        bit_range_start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        bit_range_end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SubRange = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Index into sub_list.</span>
        start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Index into sub_list.</span>
        end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> If = <span class="tok-kw">struct</span> {
        then_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        else_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ContainerField = <span class="tok-kw">struct</span> {
        align_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        value_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GlobalVarDecl = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Populated if there is an explicit type ascription.</span>
        type_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if align(A) is present.</span>
        align_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if addrspace(A) is present.</span>
        addrspace_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if linksection(A) is present.</span>
        section_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">struct</span> {
        start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceSentinel = <span class="tok-kw">struct</span> {
        start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// May be 0 if the slice is &quot;open&quot;</span>
        end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        sentinel: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> While = <span class="tok-kw">struct</span> {
        cont_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        then_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        else_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WhileCont = <span class="tok-kw">struct</span> {
        cont_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        then_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> For = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        inputs: <span class="tok-type">u31</span>,
        has_else: <span class="tok-type">bool</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnProtoOne = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Populated if there is exactly 1 parameter. Otherwise there are 0 parameters.</span>
        param: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if align(A) is present.</span>
        align_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if addrspace(A) is present.</span>
        addrspace_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if linksection(A) is present.</span>
        section_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if callconv(A) is present.</span>
        callconv_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnProto = <span class="tok-kw">struct</span> {
        params_start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        params_end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if align(A) is present.</span>
        align_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if addrspace(A) is present.</span>
        addrspace_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if linksection(A) is present.</span>
        section_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if callconv(A) is present.</span>
        callconv_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Asm = <span class="tok-kw">struct</span> {
        items_start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        items_end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Needed to make lastToken() work.</span>
        rparen: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    };
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
