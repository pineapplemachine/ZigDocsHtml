<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.simd.html" class="active">simd</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.simd" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.simd</span><a href="#src.zig-std.simd">[src]</a></h1><div class="tldDocs"><p>SIMD (Single Instruction; Multiple Data) convenience functions.</p>
<p>May offer a potential boost in performance on some targets by performing
the same operation on multiple elements at once.</p>
<p>Some functions are known to not work on MIPS.</p>
</div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.simd.VectorIndex" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">VectorIndex</span><a href="#src.zig-std.simd.VectorIndex">[src]</a></h2><div class="tldDocs"><p>Returns the smallest type of unsigned ints capable of indexing any element within the given vector type.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>VectorType: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.VectorIndex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">VectorIndex</span>(<span class="tok-kw">comptime</span> VectorType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(VectorType) - <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.VectorCount" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">VectorCount</span><a href="#src.zig-std.simd.VectorCount">[src]</a></h2><div class="tldDocs"><p>Returns the smallest type of unsigned ints capable of holding the length of the given vector type.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>VectorType: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.VectorCount">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">VectorCount</span>(<span class="tok-kw">comptime</span> VectorType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(VectorType));
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.simd.suggestVectorLengthForCpu" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">suggestVectorLengthForCpu</span><a href="#src.zig-std.simd.suggestVectorLengthForCpu">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">suggestVectorLengthForCpu</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> cpu: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>) ?<span class="tok-type">comptime_int</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>cpu: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.suggestVectorLengthForCpu">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">suggestVectorLengthForCpu</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> cpu: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>) ?<span class="tok-type">comptime_int</span> {<span class="tok-comment">
    // This is guesswork, if you have better suggestions can add it or edit the current here
    </span><span class="tok-kw">const</span> element_bit_size = <span class="tok-builtin">@max</span>(<span class="tok-number">8</span>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwo">ceilPowerOfTwo</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@bitSizeOf</span>(T)) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
    <span class="tok-kw">const</span> vector_bit_size: <span class="tok-type">u16</span> = blk: {
        <span class="tok-kw">if</span> (cpu.arch.isX86()) {
            <span class="tok-kw">if</span> (T == <span class="tok-type">bool</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHas">featureSetHas</a>(cpu.features, .prefer_mask_registers)) <span class="tok-kw">return</span> <span class="tok-number">64</span>;
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> != .stage2_x86_64 <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHas">featureSetHas</a>(cpu.features, .avx512f) <span class="tok-kw">and</span> !<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHasAny">featureSetHasAny</a>(cpu.features, .{ .prefer_256_bit, .prefer_128_bit })) <span class="tok-kw">break</span> :blk <span class="tok-number">512</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHasAny">featureSetHasAny</a>(cpu.features, .{ .prefer_256_bit, .avx2 }) <span class="tok-kw">and</span> !<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHas">featureSetHas</a>(cpu.features, .prefer_128_bit)) <span class="tok-kw">break</span> :blk <span class="tok-number">256</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHas">featureSetHas</a>(cpu.features, .sse)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHasAny">featureSetHasAny</a>(cpu.features, .{ .mmx, .@&quot;3dnow&quot; })) <span class="tok-kw">break</span> :blk <span class="tok-number">64</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isArm()) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.arm.html">arm</a>.<a href="std.Target.arm.html#std.Target.arm.featureSetHas">featureSetHas</a>(cpu.features, .neon)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isAARCH64()) {<span class="tok-comment">
            // SVE allows up to 2048 bits in the specification, as of 2022 the most powerful machine has implemented 512-bit
            // I think is safer to just be on 128 until is more common
            // TODO: Check on this return when bigger values are more common
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.aarch64.html">aarch64</a>.<a href="std.Target.aarch64.html#std.Target.aarch64.featureSetHas">featureSetHas</a>(cpu.features, .sve)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.aarch64.html">aarch64</a>.<a href="std.Target.aarch64.html#std.Target.aarch64.featureSetHas">featureSetHas</a>(cpu.features, .neon)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isPowerPC()) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.powerpc.html">powerpc</a>.<a href="std.Target.powerpc.html#std.Target.powerpc.featureSetHas">featureSetHas</a>(cpu.features, .altivec)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isMIPS()) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.mips.html">mips</a>.<a href="std.Target.mips.html#std.Target.mips.featureSetHas">featureSetHas</a>(cpu.features, .msa)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;<span class="tok-comment">
            // TODO: Test MIPS capability to handle bigger vectors
            //       In theory MDMX and by extension mips3d have 32 registers of 64 bits which can use in parallel
            //       for multiple processing, but I don't know what's optimal here, if using
            //       the 2048 bits or using just 64 per vector or something in between
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.mips.html">mips</a>.<a href="std.Target.mips.html#std.Target.mips.featureSetHas">featureSetHas</a>(cpu.features, <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.mips.html">mips</a>.<a href="std.Target.mips.Feature.html">Feature</a>.<a href="#">mips3d</a>)) <span class="tok-kw">break</span> :blk <span class="tok-number">64</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isRISCV()) {<span class="tok-comment">
            // In RISC-V Vector Registers are length agnostic so there's no good way to determine the best size.
            // The usual vector length in most RISC-V cpus is 256 bits, however it can get to multiple kB.
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .v)) {
                <span class="tok-kw">var</span> vec_bit_length: <span class="tok-type">u32</span> = <span class="tok-number">256</span>;
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl32b)) {
                    vec_bit_length = <span class="tok-number">32</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl64b)) {
                    vec_bit_length = <span class="tok-number">64</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl128b)) {
                    vec_bit_length = <span class="tok-number">128</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl256b)) {
                    vec_bit_length = <span class="tok-number">256</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl512b)) {
                    vec_bit_length = <span class="tok-number">512</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl1024b)) {
                    vec_bit_length = <span class="tok-number">1024</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl2048b)) {
                    vec_bit_length = <span class="tok-number">2048</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl4096b)) {
                    vec_bit_length = <span class="tok-number">4096</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl8192b)) {
                    vec_bit_length = <span class="tok-number">8192</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl16384b)) {
                    vec_bit_length = <span class="tok-number">16384</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl32768b)) {
                    vec_bit_length = <span class="tok-number">32768</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl65536b)) {
                    vec_bit_length = <span class="tok-number">65536</span>;
                }
                <span class="tok-kw">break</span> :blk vec_bit_length;
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isSPARC()) {<span class="tok-comment">
            // TODO: Test Sparc capability to handle bigger vectors
            //       In theory Sparc have 32 registers of 64 bits which can use in parallel
            //       for multiple processing, but I don't know what's optimal here, if using
            //       the 2048 bits or using just 64 per vector or something in between
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.sparc.html">sparc</a>.<a href="std.Target.sparc.html#std.Target.sparc.featureSetHasAny">featureSetHasAny</a>(cpu.features, .{ .vis, .vis2, .vis3 })) <span class="tok-kw">break</span> :blk <span class="tok-number">64</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isWasm()) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.wasm.html">wasm</a>.<a href="std.Target.wasm.html#std.Target.wasm.featureSetHas">featureSetHas</a>(cpu.features, .simd128)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    };
    <span class="tok-kw">if</span> (vector_bit_size &lt;= element_bit_size) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">return</span> <span class="tok-builtin">@divExact</span>(vector_bit_size, element_bit_size);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.suggestVectorLength" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">suggestVectorLength</span><a href="#src.zig-std.simd.suggestVectorLength">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">suggestVectorLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) ?<span class="tok-type">comptime_int</span></code></pre></div><div class="tldDocs"><p>Suggests a target-dependant vector length for a given type, or null if scalars are recommended.
Not yet implemented for every CPU architecture.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.suggestVectorLength">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">suggestVectorLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) ?<span class="tok-type">comptime_int</span> {
    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.suggestVectorLengthForCpu">suggestVectorLengthForCpu</a>(T, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.iota" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iota</span><a href="#src.zig-std.simd.iota">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">iota</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> len: <span class="tok-type">usize</span>) <span class="tok-builtin">@Vector</span>(len, T)</code></pre></div><div class="tldDocs"><p>Returns a vector containing the first <code>len</code> integers in order from 0 to <code>len</code>-1.
For example, <code>iota(i32, 8)</code> will return a vector containing <code>.{0, 1, 2, 3, 4, 5, 6, 7}</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.iota">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">iota</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> len: <span class="tok-type">usize</span>) <span class="tok-builtin">@Vector</span>(len, T) {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> out: [len]T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;out, <span class="tok-number">0</span>..) |*element, i| {
            element.* = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
                .int =&gt; <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>(i)),
                .float =&gt; <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@floatFromInt</span>(i)),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't use type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot; in iota.&quot;</span>),
            };
        }
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(len, T), out);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.repeat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">repeat</span><a href="#src.zig-std.simd.repeat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">repeat</span>(<span class="tok-kw">comptime</span> len: <span class="tok-type">usize</span>, vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(len, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec)))</code></pre></div><div class="tldDocs"><p>Returns a vector containing the same elements as the input, but repeated until the desired length is reached.
For example, <code>repeat(8, [_]u32{1, 2, 3})</code> will return a vector containing <code>.{1, 2, 3, 1, 2, 3, 1, 2}</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.repeat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">repeat</span>(<span class="tok-kw">comptime</span> len: <span class="tok-type">usize</span>, vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(len, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) {
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, vec, <span class="tok-null">undefined</span>, <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, len) % <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(len, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(<a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec))))));
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.join" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">join</span><a href="#src.zig-std.simd.join">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(<a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a)) + <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(b)), <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(a)))</code></pre></div><div class="tldDocs"><p>Returns a vector containing all elements of the first vector at the lower indices followed by all elements of the second vector
at the higher indices.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.join">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(<a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a)) + <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(b)), <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(a))) {
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(a));
    <span class="tok-kw">const</span> a_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a));
    <span class="tok-kw">const</span> b_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(b));

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, a, b, <span class="tok-builtin">@as</span>([a_len]<span class="tok-type">i32</span>, <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, a_len)) ++ <span class="tok-builtin">@as</span>([b_len]<span class="tok-type">i32</span>, ~<a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, b_len)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.interlace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">interlace</span><a href="#src.zig-std.simd.interlace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">interlace</span>(vecs: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(<a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vecs[<span class="tok-number">0</span>])) * vecs.len, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vecs[<span class="tok-number">0</span>])))</code></pre></div><div class="tldDocs"><p>Returns a vector whose elements alternates between those of each input vector.
For example, <code>interlace(.{[4]u32{11, 12, 13, 14}, [4]u32{21, 22, 23, 24}})</code> returns a vector containing <code>.{11, 21, 12, 22, 13, 23, 14, 24}</code>.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.interlace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">interlace</span>(vecs: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(<a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vecs[<span class="tok-number">0</span>])) * vecs.len, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vecs[<span class="tok-number">0</span>]))) {<span class="tok-comment">
    // interlace doesn't work on MIPS, for some reason.
    // Notes from earlier debug attempt:
    //  The indices are correct. The problem seems to be with the @shuffle builtin.
    //  On MIPS, the test that interlaces small_base gives { 0, 2, 0, 0, 64, 255, 248, 200, 0, 0 }.
    //  Calling this with two inputs seems to work fine, but I'll let the compile error trigger for all inputs, just to be safe.
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">isMIPS</a>()) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO: Find out why interlace() doesn't work on MIPS&quot;</span>);

    <span class="tok-kw">const</span> VecType = <span class="tok-builtin">@TypeOf</span>(vecs[<span class="tok-number">0</span>]);
    <span class="tok-kw">const</span> vecs_arr = <span class="tok-builtin">@as</span>([vecs.len]VecType, vecs);
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vecs_arr[<span class="tok-number">0</span>]));

    <span class="tok-kw">if</span> (vecs_arr.len == <span class="tok-number">1</span>) <span class="tok-kw">return</span> vecs_arr[<span class="tok-number">0</span>];

    <span class="tok-kw">const</span> a_vec_count = (<span class="tok-number">1</span> + vecs_arr.len) &gt;&gt; <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b_vec_count = vecs_arr.len &gt;&gt; <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> a = <a href="std.simd.html#std.simd.interlace">interlace</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [a_vec_count]VecType, <span class="tok-builtin">@ptrCast</span>(vecs_arr[<span class="tok-number">0</span>..a_vec_count])).*);
    <span class="tok-kw">const</span> b = <a href="std.simd.html#std.simd.interlace">interlace</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [b_vec_count]VecType, <span class="tok-builtin">@ptrCast</span>(vecs_arr[a_vec_count..])).*);

    <span class="tok-kw">const</span> a_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a));
    <span class="tok-kw">const</span> b_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(b));
    <span class="tok-kw">const</span> len = a_len + b_len;

    <span class="tok-kw">const</span> indices = <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">const</span> Vi32 = <span class="tok-builtin">@Vector</span>(len, <span class="tok-type">i32</span>);
        <span class="tok-kw">const</span> count_up = <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, len);
        <span class="tok-kw">const</span> cycle = <span class="tok-builtin">@divFloor</span>(count_up, <span class="tok-builtin">@as</span>(Vi32, <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(vecs_arr.len))));
        <span class="tok-kw">const</span> select_mask = <a href="std.simd.html#std.simd.repeat">repeat</a>(len, <a href="std.simd.html#std.simd.join">join</a>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(a_vec_count, <span class="tok-type">bool</span>), <span class="tok-builtin">@splat</span>(<span class="tok-null">true</span>)), <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(b_vec_count, <span class="tok-type">bool</span>), <span class="tok-builtin">@splat</span>(<span class="tok-null">false</span>))));
        <span class="tok-kw">const</span> a_indices = count_up - cycle * <span class="tok-builtin">@as</span>(Vi32, <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(b_vec_count)));
        <span class="tok-kw">const</span> b_indices = <a href="std.simd.html#std.simd.shiftElementsRight">shiftElementsRight</a>(count_up - cycle * <span class="tok-builtin">@as</span>(Vi32, <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(a_vec_count))), a_vec_count, <span class="tok-number">0</span>);
        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@select</span>(<span class="tok-type">i32</span>, select_mask, a_indices, ~b_indices);
    };

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, a, b, indices);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.deinterlace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinterlace</span><a href="#src.zig-std.simd.deinterlace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinterlace</span>( <span class="tok-kw">comptime</span> vec_count: <span class="tok-type">usize</span>, interlaced: <span class="tok-kw">anytype</span>, ) [vec_count]<span class="tok-builtin">@Vector</span>( <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(interlaced)) / vec_count, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(interlaced)), )</code></pre></div><div class="tldDocs"><p>The contents of <code>interlaced</code> is evenly split between vec_count vectors that are returned as an array. They &quot;take turns&quot;,
receiving one element from <code>interlaced</code> at a time.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>vec_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.deinterlace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinterlace</span>(
    <span class="tok-kw">comptime</span> vec_count: <span class="tok-type">usize</span>,
    interlaced: <span class="tok-kw">anytype</span>,
) [vec_count]<span class="tok-builtin">@Vector</span>(
    <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(interlaced)) / vec_count,
    <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(interlaced)),
) {
    <span class="tok-kw">const</span> vec_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(interlaced)) / vec_count;
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(interlaced));

    <span class="tok-kw">var</span> out: [vec_count]<span class="tok-builtin">@Vector</span>(vec_len, Child) = <span class="tok-null">undefined</span>;

    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;<span class="tok-comment"> // for-loops don't work for this, apparently.
    </span><span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; out.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> indices = <span class="tok-kw">comptime</span> <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, vec_len) * <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(vec_len, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(vec_count))) + <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(vec_len, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(i)));
        out[i] = <span class="tok-builtin">@shuffle</span>(Child, interlaced, <span class="tok-null">undefined</span>, indices);
    }

    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.extract" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">extract</span><a href="#src.zig-std.simd.extract">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extract</span>( vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> first: <a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)), <span class="tok-kw">comptime</span> count: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)), ) <span class="tok-builtin">@Vector</span>(count, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec)))</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>first: <a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div><pre><code>count: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.extract">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extract</span>(
    vec: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> first: <a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)),
    <span class="tok-kw">comptime</span> count: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)),
) <span class="tok-builtin">@Vector</span>(count, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) {
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@intCast</span>(first)) + <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@intCast</span>(count)) &lt;= len);

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, vec, <span class="tok-null">undefined</span>, <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, count) + <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(count, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(first))));
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.mergeShift" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mergeShift</span><a href="#src.zig-std.simd.mergeShift">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mergeShift</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> shift: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(a, b))) <span class="tok-builtin">@TypeOf</span>(a, b)</code></pre></div><div class="tldDocs"><p>Joins two vectors, shifts them leftwards (towards lower indices) and extracts the leftmost elements into a vector the length of a and b.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>shift: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(a, b))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.mergeShift">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mergeShift</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> shift: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(a, b))) <span class="tok-builtin">@TypeOf</span>(a, b) {
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a, b));

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.extract">extract</a>(<a href="std.simd.html#std.simd.join">join</a>(a, b), shift, len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.shiftElementsRight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftElementsRight</span><a href="#src.zig-std.simd.shiftElementsRight">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftElementsRight</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)), shift_in: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec)</code></pre></div><div class="tldDocs"><p>Elements are shifted rightwards (towards higher indices). New elements are added to the left, and the rightmost elements are cut off
so that the length of the vector stays the same.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div><pre><code>shift_in: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.shiftElementsRight">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftElementsRight</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)), shift_in: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec) {<span class="tok-comment">
    // It may be possible to implement shifts and rotates with a runtime-friendly slice of two joined vectors, as the length of the
    // slice would be comptime-known. This would permit vector shifts and rotates by a non-comptime-known amount.
    // However, I am unsure whether compiler optimizations would handle that well enough on all platforms.
    </span><span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(V);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.mergeShift">mergeShift</a>(<span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(shift_in)), vec, len - amount);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.shiftElementsLeft" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftElementsLeft</span><a href="#src.zig-std.simd.shiftElementsLeft">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftElementsLeft</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)), shift_in: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec)</code></pre></div><div class="tldDocs"><p>Elements are shifted leftwards (towards lower indices). New elements are added to the right, and the leftmost elements are cut off
so that no elements with indices below 0 remain.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div><pre><code>shift_in: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.shiftElementsLeft">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftElementsLeft</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)), shift_in: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.mergeShift">mergeShift</a>(vec, <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(shift_in)), amount);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.rotateElementsLeft" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rotateElementsLeft</span><a href="#src.zig-std.simd.rotateElementsLeft">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotateElementsLeft</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec)</code></pre></div><div class="tldDocs"><p>Elements are shifted leftwards (towards lower indices). Elements that leave to the left will reappear to the right in the same order.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.rotateElementsLeft">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotateElementsLeft</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.mergeShift">mergeShift</a>(vec, vec, amount);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.rotateElementsRight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rotateElementsRight</span><a href="#src.zig-std.simd.rotateElementsRight">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotateElementsRight</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec)</code></pre></div><div class="tldDocs"><p>Elements are shifted rightwards (towards higher indices). Elements that leave to the right will reappear to the left in the same order.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.rotateElementsRight">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotateElementsRight</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.rotateElementsLeft">rotateElementsLeft</a>(vec, <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec)) - amount);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.reverseOrder" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reverseOrder</span><a href="#src.zig-std.simd.reverseOrder">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseOrder</span>(vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(vec)</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.reverseOrder">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseOrder</span>(vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, vec, <span class="tok-null">undefined</span>, <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(len, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intCast</span>(len)) - <span class="tok-number">1</span>)) - <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, len));
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.firstTrue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">firstTrue</span><a href="#src.zig-std.simd.firstTrue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstTrue</span>(vec: <span class="tok-kw">anytype</span>) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.firstTrue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstTrue</span>(vec: <span class="tok-kw">anytype</span>) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> IndexInt = <a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">if</span> (!<span class="tok-builtin">@reduce</span>(.Or, vec)) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
    <span class="tok-kw">const</span> all_max: <span class="tok-builtin">@Vector</span>(len, IndexInt) = <span class="tok-builtin">@splat</span>(~<span class="tok-builtin">@as</span>(IndexInt, <span class="tok-number">0</span>));
    <span class="tok-kw">const</span> indices = <span class="tok-builtin">@select</span>(IndexInt, vec, <a href="std.simd.html#std.simd.iota">iota</a>(IndexInt, len), all_max);
    <span class="tok-kw">return</span> <span class="tok-builtin">@reduce</span>(.Min, indices);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.lastTrue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lastTrue</span><a href="#src.zig-std.simd.lastTrue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastTrue</span>(vec: <span class="tok-kw">anytype</span>) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.lastTrue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastTrue</span>(vec: <span class="tok-kw">anytype</span>) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> IndexInt = <a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">if</span> (!<span class="tok-builtin">@reduce</span>(.Or, vec)) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">const</span> all_zeroes: <span class="tok-builtin">@Vector</span>(len, IndexInt) = <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>);
    <span class="tok-kw">const</span> indices = <span class="tok-builtin">@select</span>(IndexInt, vec, <a href="std.simd.html#std.simd.iota">iota</a>(IndexInt, len), all_zeroes);
    <span class="tok-kw">return</span> <span class="tok-builtin">@reduce</span>(.Max, indices);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.countTrues" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">countTrues</span><a href="#src.zig-std.simd.countTrues">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countTrues</span>(vec: <span class="tok-kw">anytype</span>) <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.countTrues">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countTrues</span>(vec: <span class="tok-kw">anytype</span>) <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> CountIntType = <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">const</span> all_ones: <span class="tok-builtin">@Vector</span>(len, CountIntType) = <span class="tok-builtin">@splat</span>(<span class="tok-number">1</span>);
    <span class="tok-kw">const</span> all_zeroes: <span class="tok-builtin">@Vector</span>(len, CountIntType) = <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>);

    <span class="tok-kw">const</span> one_if_true = <span class="tok-builtin">@select</span>(CountIntType, vec, all_ones, all_zeroes);
    <span class="tok-kw">return</span> <span class="tok-builtin">@reduce</span>(.Add, one_if_true);
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.firstIndexOfValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">firstIndexOfValue</span><a href="#src.zig-std.simd.firstIndexOfValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstIndexOfValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.firstIndexOfValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstIndexOfValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(vec == <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(value)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.lastIndexOfValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lastIndexOfValue</span><a href="#src.zig-std.simd.lastIndexOfValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.lastIndexOfValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.lastTrue">lastTrue</a>(vec == <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(value)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.countElementsWithValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">countElementsWithValue</span><a href="#src.zig-std.simd.countElementsWithValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countElementsWithValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.countElementsWithValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countElementsWithValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.countTrues">countTrues</a>(vec == <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(value)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.prefixScanWithFunc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">prefixScanWithFunc</span><a href="#src.zig-std.simd.prefixScanWithFunc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixScanWithFunc</span>( <span class="tok-kw">comptime</span> hop: <span class="tok-type">isize</span>, vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> ErrorType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> func: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(vec), <span class="tok-builtin">@TypeOf</span>(vec)) <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) <span class="tok-builtin">@TypeOf</span>(vec) <span class="tok-kw">else</span> ErrorType!<span class="tok-builtin">@TypeOf</span>(vec), <span class="tok-kw">comptime</span> identity: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec)), ) <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) <span class="tok-builtin">@TypeOf</span>(vec) <span class="tok-kw">else</span> ErrorType!<span class="tok-builtin">@TypeOf</span>(vec)</code></pre></div><div class="tldDocs"><p>Same as prefixScan, but with a user-provided, mathematically associative function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>hop: <span class="tok-type">isize</span></code></pre></div><div><pre><code>ErrorType: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>The error type that <code>func</code> might return. Set this to <code>void</code> if <code>func</code> doesn't return an error union.</p>
</div></div><div><pre><code>func: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(vec), <span class="tok-builtin">@TypeOf</span>(vec)) <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) <span class="tok-builtin">@TypeOf</span>(vec) <span class="tok-kw">else</span> ErrorType!<span class="tok-builtin">@TypeOf</span>(vec)</code></pre></div><div><pre><code>identity: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))</code></pre><div class="fieldDocs"><p>When one operand of the operation performed by <code>func</code> is this value, the result must equal the other operand.
For example, this should be 0 for addition or 1 for multiplication.</p>
</div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.prefixScanWithFunc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixScanWithFunc</span>(
    <span class="tok-kw">comptime</span> hop: <span class="tok-type">isize</span>,
    vec: <span class="tok-kw">anytype</span>,
    <span class="tok-comment">/// The error type that `func` might return. Set this to `void` if `func` doesn't return an error union.</span>
    <span class="tok-kw">comptime</span> ErrorType: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> func: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(vec), <span class="tok-builtin">@TypeOf</span>(vec)) <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) <span class="tok-builtin">@TypeOf</span>(vec) <span class="tok-kw">else</span> ErrorType!<span class="tok-builtin">@TypeOf</span>(vec),
    <span class="tok-comment">/// When one operand of the operation performed by `func` is this value, the result must equal the other operand.</span>
    <span class="tok-comment">/// For example, this should be 0 for addition or 1 for multiplication.</span>
    <span class="tok-kw">comptime</span> identity: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec)),
) <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) <span class="tok-builtin">@TypeOf</span>(vec) <span class="tok-kw">else</span> ErrorType!<span class="tok-builtin">@TypeOf</span>(vec) {<span class="tok-comment">
    // I haven't debugged this, but it might be a cousin of sorts to what's going on with interlace.
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">isMIPS</a>()) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO: Find out why prefixScan doesn't work on MIPS&quot;</span>);

    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">if</span> (hop == <span class="tok-number">0</span>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;hop can not be 0; you'd be going nowhere forever!&quot;</span>);
    <span class="tok-kw">const</span> abs_hop = <span class="tok-kw">if</span> (hop &lt; <span class="tok-number">0</span>) -hop <span class="tok-kw">else</span> hop;

    <span class="tok-kw">var</span> acc = vec;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> ((abs_hop &lt;&lt; i) &lt; len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> shifted = <span class="tok-kw">if</span> (hop &lt; <span class="tok-number">0</span>) <a href="std.simd.html#std.simd.shiftElementsLeft">shiftElementsLeft</a>(acc, abs_hop &lt;&lt; i, identity) <span class="tok-kw">else</span> <a href="std.simd.html#std.simd.shiftElementsRight">shiftElementsRight</a>(acc, abs_hop &lt;&lt; i, identity);

        acc = <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) func(acc, shifted) <span class="tok-kw">else</span> <span class="tok-kw">try</span> func(acc, shifted);
    }
    <span class="tok-kw">return</span> acc;
}</code></pre></details></div></div><div class="decl"><h2 id="std.simd.prefixScan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">prefixScan</span><a href="#src.zig-std.simd.prefixScan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixScan</span>(<span class="tok-kw">comptime</span> op: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.ReduceOp.html">ReduceOp</a>, <span class="tok-kw">comptime</span> hop: <span class="tok-type">isize</span>, vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(vec)</code></pre></div><div class="tldDocs"><p>Returns a vector whose elements are the result of performing the specified operation on the corresponding
element of the input vector and every hop'th element that came before it (or after, if hop is negative).
Supports the same operations as the @reduce() builtin. Takes O(logN) to compute.
The scan is not linear, which may affect floating point errors. This may affect the determinism of
algorithms that use this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>op: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.ReduceOp.html">ReduceOp</a></code></pre></div><div><pre><code>hop: <span class="tok-type">isize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.simd.prefixScan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixScan</span>(<span class="tok-kw">comptime</span> op: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.ReduceOp.html">ReduceOp</a>, <span class="tok-kw">comptime</span> hop: <span class="tok-type">isize</span>, vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">const</span> VecType = <span class="tok-builtin">@TypeOf</span>(vec);
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(VecType);

    <span class="tok-kw">const</span> identity = <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Child)) {
        .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">switch</span> (op) {
            .Or, .Xor =&gt; <span class="tok-null">false</span>,
            .And =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Invalid prefixScan operation &quot;</span> ++ <span class="tok-builtin">@tagName</span>(op) ++ <span class="tok-str">&quot; for vector of booleans.&quot;</span>),
        },
        .int =&gt; <span class="tok-kw">switch</span> (op) {
            .Max =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(Child),
            .Add, .Or, .Xor =&gt; <span class="tok-number">0</span>,
            .Mul =&gt; <span class="tok-number">1</span>,
            .And, .Min =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(Child),
        },
        .float =&gt; <span class="tok-kw">switch</span> (op) {
            .Max =&gt; -<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.inf">inf</a>(Child),
            .Add =&gt; <span class="tok-number">0</span>,
            .Mul =&gt; <span class="tok-number">1</span>,
            .Min =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.inf">inf</a>(Child),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Invalid prefixScan operation &quot;</span> ++ <span class="tok-builtin">@tagName</span>(op) ++ <span class="tok-str">&quot; for vector of floats.&quot;</span>),
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Invalid type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(VecType) ++ <span class="tok-str">&quot; for prefixScan.&quot;</span>),
    };

    <span class="tok-kw">const</span> fn_container = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">opFn</span>(a: VecType, b: VecType) VecType {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (Child == <span class="tok-type">bool</span>) <span class="tok-kw">switch</span> (op) {
                .And =&gt; <span class="tok-builtin">@select</span>(<span class="tok-type">bool</span>, a, b, <span class="tok-builtin">@as</span>(VecType, <span class="tok-builtin">@splat</span>(<span class="tok-null">false</span>))),
                .Or =&gt; <span class="tok-builtin">@select</span>(<span class="tok-type">bool</span>, a, <span class="tok-builtin">@as</span>(VecType, <span class="tok-builtin">@splat</span>(<span class="tok-null">true</span>)), b),
                .Xor =&gt; a != b,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (op) {
                .And =&gt; a &amp; b,
                .Or =&gt; a | b,
                .Xor =&gt; a ^ b,
                .Add =&gt; a + b,
                .Mul =&gt; a * b,
                .Min =&gt; <span class="tok-builtin">@min</span>(a, b),
                .Max =&gt; <span class="tok-builtin">@max</span>(a, b),
            };
        }
    };

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.prefixScanWithFunc">prefixScanWithFunc</a>(hop, vec, <span class="tok-type">void</span>, fn_container.opFn, identity);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.simd">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! SIMD (Single Instruction; Multiple Data) convenience functions.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! May offer a potential boost in performance on some targets by performing</span>
<span class="tok-comment">//! the same operation on multiple elements at once.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! Some functions are known to not work on MIPS.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">suggestVectorLengthForCpu</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> cpu: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>) ?<span class="tok-type">comptime_int</span> {<span class="tok-comment">
    // This is guesswork, if you have better suggestions can add it or edit the current here
    </span><span class="tok-kw">const</span> element_bit_size = <span class="tok-builtin">@max</span>(<span class="tok-number">8</span>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwo">ceilPowerOfTwo</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@bitSizeOf</span>(T)) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
    <span class="tok-kw">const</span> vector_bit_size: <span class="tok-type">u16</span> = blk: {
        <span class="tok-kw">if</span> (cpu.arch.isX86()) {
            <span class="tok-kw">if</span> (T == <span class="tok-type">bool</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHas">featureSetHas</a>(cpu.features, .prefer_mask_registers)) <span class="tok-kw">return</span> <span class="tok-number">64</span>;
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> != .stage2_x86_64 <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHas">featureSetHas</a>(cpu.features, .avx512f) <span class="tok-kw">and</span> !<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHasAny">featureSetHasAny</a>(cpu.features, .{ .prefer_256_bit, .prefer_128_bit })) <span class="tok-kw">break</span> :blk <span class="tok-number">512</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHasAny">featureSetHasAny</a>(cpu.features, .{ .prefer_256_bit, .avx2 }) <span class="tok-kw">and</span> !<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHas">featureSetHas</a>(cpu.features, .prefer_128_bit)) <span class="tok-kw">break</span> :blk <span class="tok-number">256</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHas">featureSetHas</a>(cpu.features, .sse)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.featureSetHasAny">featureSetHasAny</a>(cpu.features, .{ .mmx, .@&quot;3dnow&quot; })) <span class="tok-kw">break</span> :blk <span class="tok-number">64</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isArm()) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.arm.html">arm</a>.<a href="std.Target.arm.html#std.Target.arm.featureSetHas">featureSetHas</a>(cpu.features, .neon)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isAARCH64()) {<span class="tok-comment">
            // SVE allows up to 2048 bits in the specification, as of 2022 the most powerful machine has implemented 512-bit
            // I think is safer to just be on 128 until is more common
            // TODO: Check on this return when bigger values are more common
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.aarch64.html">aarch64</a>.<a href="std.Target.aarch64.html#std.Target.aarch64.featureSetHas">featureSetHas</a>(cpu.features, .sve)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.aarch64.html">aarch64</a>.<a href="std.Target.aarch64.html#std.Target.aarch64.featureSetHas">featureSetHas</a>(cpu.features, .neon)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isPowerPC()) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.powerpc.html">powerpc</a>.<a href="std.Target.powerpc.html#std.Target.powerpc.featureSetHas">featureSetHas</a>(cpu.features, .altivec)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isMIPS()) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.mips.html">mips</a>.<a href="std.Target.mips.html#std.Target.mips.featureSetHas">featureSetHas</a>(cpu.features, .msa)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;<span class="tok-comment">
            // TODO: Test MIPS capability to handle bigger vectors
            //       In theory MDMX and by extension mips3d have 32 registers of 64 bits which can use in parallel
            //       for multiple processing, but I don't know what's optimal here, if using
            //       the 2048 bits or using just 64 per vector or something in between
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.mips.html">mips</a>.<a href="std.Target.mips.html#std.Target.mips.featureSetHas">featureSetHas</a>(cpu.features, <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.mips.html">mips</a>.<a href="std.Target.mips.Feature.html">Feature</a>.<a href="#">mips3d</a>)) <span class="tok-kw">break</span> :blk <span class="tok-number">64</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isRISCV()) {<span class="tok-comment">
            // In RISC-V Vector Registers are length agnostic so there's no good way to determine the best size.
            // The usual vector length in most RISC-V cpus is 256 bits, however it can get to multiple kB.
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .v)) {
                <span class="tok-kw">var</span> vec_bit_length: <span class="tok-type">u32</span> = <span class="tok-number">256</span>;
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl32b)) {
                    vec_bit_length = <span class="tok-number">32</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl64b)) {
                    vec_bit_length = <span class="tok-number">64</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl128b)) {
                    vec_bit_length = <span class="tok-number">128</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl256b)) {
                    vec_bit_length = <span class="tok-number">256</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl512b)) {
                    vec_bit_length = <span class="tok-number">512</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl1024b)) {
                    vec_bit_length = <span class="tok-number">1024</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl2048b)) {
                    vec_bit_length = <span class="tok-number">2048</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl4096b)) {
                    vec_bit_length = <span class="tok-number">4096</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl8192b)) {
                    vec_bit_length = <span class="tok-number">8192</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl16384b)) {
                    vec_bit_length = <span class="tok-number">16384</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl32768b)) {
                    vec_bit_length = <span class="tok-number">32768</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.riscv.html">riscv</a>.<a href="std.Target.riscv.html#std.Target.riscv.featureSetHas">featureSetHas</a>(cpu.features, .zvl65536b)) {
                    vec_bit_length = <span class="tok-number">65536</span>;
                }
                <span class="tok-kw">break</span> :blk vec_bit_length;
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isSPARC()) {<span class="tok-comment">
            // TODO: Test Sparc capability to handle bigger vectors
            //       In theory Sparc have 32 registers of 64 bits which can use in parallel
            //       for multiple processing, but I don't know what's optimal here, if using
            //       the 2048 bits or using just 64 per vector or something in between
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.sparc.html">sparc</a>.<a href="std.Target.sparc.html#std.Target.sparc.featureSetHasAny">featureSetHasAny</a>(cpu.features, .{ .vis, .vis2, .vis3 })) <span class="tok-kw">break</span> :blk <span class="tok-number">64</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cpu.arch.isWasm()) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.wasm.html">wasm</a>.<a href="std.Target.wasm.html#std.Target.wasm.featureSetHas">featureSetHas</a>(cpu.features, .simd128)) <span class="tok-kw">break</span> :blk <span class="tok-number">128</span>;
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    };
    <span class="tok-kw">if</span> (vector_bit_size &lt;= element_bit_size) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">return</span> <span class="tok-builtin">@divExact</span>(vector_bit_size, element_bit_size);
}

<span class="tok-comment">/// Suggests a target-dependant vector length for a given type, or null if scalars are recommended.</span>
<span class="tok-comment">/// Not yet implemented for every CPU architecture.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">suggestVectorLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) ?<span class="tok-type">comptime_int</span> {
    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.suggestVectorLengthForCpu">suggestVectorLengthForCpu</a>(T, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;suggestVectorLengthForCpu works with signed and unsigned values&quot;</span> {
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> cpu = <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.html#std.Target.Cpu.baseline">baseline</a>(<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Cpu.html">Cpu</a>.<a href="std.Target.Cpu.Arch.html">Arch</a>.<a href="#">x86_64</a>, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>);
    <span class="tok-kw">comptime</span> cpu.features.addFeature(<span class="tok-builtin">@intFromEnum</span>(<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.Feature.html">Feature</a>.<a href="#">avx512f</a>));
    <span class="tok-kw">comptime</span> cpu.features.populateDependencies(&amp;<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.x86.html">x86</a>.<a href="std.Target.x86.html#std.Target.x86.all_features">all_features</a>);
    <span class="tok-kw">const</span> expected_len: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a>) {
        .stage2_x86_64 =&gt; <span class="tok-number">8</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-number">16</span>,
    };
    <span class="tok-kw">const</span> signed_integer_len = <a href="std.simd.html#std.simd.suggestVectorLengthForCpu">suggestVectorLengthForCpu</a>(<span class="tok-type">i32</span>, cpu).?;
    <span class="tok-kw">const</span> unsigned_integer_len = <a href="std.simd.html#std.simd.suggestVectorLengthForCpu">suggestVectorLengthForCpu</a>(<span class="tok-type">u32</span>, cpu).?;
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(expected_len, unsigned_integer_len);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(expected_len, signed_integer_len);
}

<span class="tok-kw">fn</span> <span class="tok-fn">vectorLength</span>(<span class="tok-kw">comptime</span> VectorType: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(VectorType)) {
        .vector =&gt; |info| info.len,
        .array =&gt; |info| info.len,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Invalid type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(VectorType)),
    };
}

<span class="tok-comment">/// Returns the smallest type of unsigned ints capable of indexing any element within the given vector type.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">VectorIndex</span>(<span class="tok-kw">comptime</span> VectorType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(VectorType) - <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Returns the smallest type of unsigned ints capable of holding the length of the given vector type.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">VectorCount</span>(<span class="tok-kw">comptime</span> VectorType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.IntFittingRange">IntFittingRange</a>(<span class="tok-number">0</span>, <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(VectorType));
}

<span class="tok-comment">/// Returns a vector containing the first `len` integers in order from 0 to `len`-1.</span>
<span class="tok-comment">/// For example, `iota(i32, 8)` will return a vector containing `.{0, 1, 2, 3, 4, 5, 6, 7}`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">iota</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> len: <span class="tok-type">usize</span>) <span class="tok-builtin">@Vector</span>(len, T) {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> out: [len]T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (&amp;out, <span class="tok-number">0</span>..) |*element, i| {
            element.* = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
                .int =&gt; <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>(i)),
                .float =&gt; <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@floatFromInt</span>(i)),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't use type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot; in iota.&quot;</span>),
            };
        }
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(len, T), out);
    }
}

<span class="tok-comment">/// Returns a vector containing the same elements as the input, but repeated until the desired length is reached.</span>
<span class="tok-comment">/// For example, `repeat(8, [_]u32{1, 2, 3})` will return a vector containing `.{1, 2, 3, 1, 2, 3, 1, 2}`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">repeat</span>(<span class="tok-kw">comptime</span> len: <span class="tok-type">usize</span>, vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(len, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) {
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, vec, <span class="tok-null">undefined</span>, <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, len) % <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(len, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(<a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec))))));
}

<span class="tok-comment">/// Returns a vector containing all elements of the first vector at the lower indices followed by all elements of the second vector</span>
<span class="tok-comment">/// at the higher indices.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(<a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a)) + <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(b)), <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(a))) {
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(a));
    <span class="tok-kw">const</span> a_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a));
    <span class="tok-kw">const</span> b_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(b));

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, a, b, <span class="tok-builtin">@as</span>([a_len]<span class="tok-type">i32</span>, <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, a_len)) ++ <span class="tok-builtin">@as</span>([b_len]<span class="tok-type">i32</span>, ~<a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, b_len)));
}

<span class="tok-comment">/// Returns a vector whose elements alternates between those of each input vector.</span>
<span class="tok-comment">/// For example, `interlace(.{[4]u32{11, 12, 13, 14}, [4]u32{21, 22, 23, 24}})` returns a vector containing `.{11, 21, 12, 22, 13, 23, 14, 24}`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">interlace</span>(vecs: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@Vector</span>(<a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vecs[<span class="tok-number">0</span>])) * vecs.len, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vecs[<span class="tok-number">0</span>]))) {<span class="tok-comment">
    // interlace doesn't work on MIPS, for some reason.
    // Notes from earlier debug attempt:
    //  The indices are correct. The problem seems to be with the @shuffle builtin.
    //  On MIPS, the test that interlaces small_base gives { 0, 2, 0, 0, 64, 255, 248, 200, 0, 0 }.
    //  Calling this with two inputs seems to work fine, but I'll let the compile error trigger for all inputs, just to be safe.
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">isMIPS</a>()) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO: Find out why interlace() doesn't work on MIPS&quot;</span>);

    <span class="tok-kw">const</span> VecType = <span class="tok-builtin">@TypeOf</span>(vecs[<span class="tok-number">0</span>]);
    <span class="tok-kw">const</span> vecs_arr = <span class="tok-builtin">@as</span>([vecs.len]VecType, vecs);
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vecs_arr[<span class="tok-number">0</span>]));

    <span class="tok-kw">if</span> (vecs_arr.len == <span class="tok-number">1</span>) <span class="tok-kw">return</span> vecs_arr[<span class="tok-number">0</span>];

    <span class="tok-kw">const</span> a_vec_count = (<span class="tok-number">1</span> + vecs_arr.len) &gt;&gt; <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b_vec_count = vecs_arr.len &gt;&gt; <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> a = <a href="std.simd.html#std.simd.interlace">interlace</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [a_vec_count]VecType, <span class="tok-builtin">@ptrCast</span>(vecs_arr[<span class="tok-number">0</span>..a_vec_count])).*);
    <span class="tok-kw">const</span> b = <a href="std.simd.html#std.simd.interlace">interlace</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [b_vec_count]VecType, <span class="tok-builtin">@ptrCast</span>(vecs_arr[a_vec_count..])).*);

    <span class="tok-kw">const</span> a_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a));
    <span class="tok-kw">const</span> b_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(b));
    <span class="tok-kw">const</span> len = a_len + b_len;

    <span class="tok-kw">const</span> indices = <span class="tok-kw">comptime</span> blk: {
        <span class="tok-kw">const</span> Vi32 = <span class="tok-builtin">@Vector</span>(len, <span class="tok-type">i32</span>);
        <span class="tok-kw">const</span> count_up = <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, len);
        <span class="tok-kw">const</span> cycle = <span class="tok-builtin">@divFloor</span>(count_up, <span class="tok-builtin">@as</span>(Vi32, <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(vecs_arr.len))));
        <span class="tok-kw">const</span> select_mask = <a href="std.simd.html#std.simd.repeat">repeat</a>(len, <a href="std.simd.html#std.simd.join">join</a>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(a_vec_count, <span class="tok-type">bool</span>), <span class="tok-builtin">@splat</span>(<span class="tok-null">true</span>)), <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(b_vec_count, <span class="tok-type">bool</span>), <span class="tok-builtin">@splat</span>(<span class="tok-null">false</span>))));
        <span class="tok-kw">const</span> a_indices = count_up - cycle * <span class="tok-builtin">@as</span>(Vi32, <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(b_vec_count)));
        <span class="tok-kw">const</span> b_indices = <a href="std.simd.html#std.simd.shiftElementsRight">shiftElementsRight</a>(count_up - cycle * <span class="tok-builtin">@as</span>(Vi32, <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(a_vec_count))), a_vec_count, <span class="tok-number">0</span>);
        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@select</span>(<span class="tok-type">i32</span>, select_mask, a_indices, ~b_indices);
    };

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, a, b, indices);
}

<span class="tok-comment">/// The contents of `interlaced` is evenly split between vec_count vectors that are returned as an array. They &quot;take turns&quot;,</span>
<span class="tok-comment">/// receiving one element from `interlaced` at a time.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinterlace</span>(
    <span class="tok-kw">comptime</span> vec_count: <span class="tok-type">usize</span>,
    interlaced: <span class="tok-kw">anytype</span>,
) [vec_count]<span class="tok-builtin">@Vector</span>(
    <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(interlaced)) / vec_count,
    <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(interlaced)),
) {
    <span class="tok-kw">const</span> vec_len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(interlaced)) / vec_count;
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(interlaced));

    <span class="tok-kw">var</span> out: [vec_count]<span class="tok-builtin">@Vector</span>(vec_len, Child) = <span class="tok-null">undefined</span>;

    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;<span class="tok-comment"> // for-loops don't work for this, apparently.
    </span><span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; out.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> indices = <span class="tok-kw">comptime</span> <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, vec_len) * <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(vec_len, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(vec_count))) + <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(vec_len, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(i)));
        out[i] = <span class="tok-builtin">@shuffle</span>(Child, interlaced, <span class="tok-null">undefined</span>, indices);
    }

    <span class="tok-kw">return</span> out;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extract</span>(
    vec: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> first: <a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)),
    <span class="tok-kw">comptime</span> count: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)),
) <span class="tok-builtin">@Vector</span>(count, <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) {
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@intCast</span>(first)) + <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@intCast</span>(count)) &lt;= len);

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, vec, <span class="tok-null">undefined</span>, <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, count) + <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(count, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@intCast</span>(first))));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector patterns&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86_64) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> base = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u32</span>){ <span class="tok-number">10</span>, <span class="tok-number">20</span>, <span class="tok-number">30</span>, <span class="tok-number">40</span> };
    <span class="tok-kw">const</span> other_base = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u32</span>){ <span class="tok-number">55</span>, <span class="tok-number">66</span>, <span class="tok-number">77</span>, <span class="tok-number">88</span> };

    <span class="tok-kw">const</span> small_bases = [<span class="tok-number">5</span>]<span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>){
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>){ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>){ <span class="tok-number">2</span>, <span class="tok-number">3</span> },
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>){ <span class="tok-number">4</span>, <span class="tok-number">5</span> },
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>){ <span class="tok-number">6</span>, <span class="tok-number">7</span> },
        <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>){ <span class="tok-number">8</span>, <span class="tok-number">9</span> },
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">6</span>]<span class="tok-type">u32</span>{ <span class="tok-number">10</span>, <span class="tok-number">20</span>, <span class="tok-number">30</span>, <span class="tok-number">40</span>, <span class="tok-number">10</span>, <span class="tok-number">20</span> }, <a href="std.simd.html#std.simd.repeat">repeat</a>(<span class="tok-number">6</span>, base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">8</span>]<span class="tok-type">u32</span>{ <span class="tok-number">10</span>, <span class="tok-number">20</span>, <span class="tok-number">30</span>, <span class="tok-number">40</span>, <span class="tok-number">55</span>, <span class="tok-number">66</span>, <span class="tok-number">77</span>, <span class="tok-number">88</span> }, <a href="std.simd.html#std.simd.join">join</a>(base, other_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">2</span>]<span class="tok-type">u32</span>{ <span class="tok-number">20</span>, <span class="tok-number">30</span> }, <a href="std.simd.html#std.simd.extract">extract</a>(base, <span class="tok-number">1</span>, <span class="tok-number">2</span>));

    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">isMIPS</a>()) {
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">8</span>]<span class="tok-type">u32</span>{ <span class="tok-number">10</span>, <span class="tok-number">55</span>, <span class="tok-number">20</span>, <span class="tok-number">66</span>, <span class="tok-number">30</span>, <span class="tok-number">77</span>, <span class="tok-number">40</span>, <span class="tok-number">88</span> }, <a href="std.simd.html#std.simd.interlace">interlace</a>(.{ base, other_base }));

        <span class="tok-kw">const</span> small_braid = <a href="std.simd.html#std.simd.interlace">interlace</a>(small_bases);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">10</span>]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">6</span>, <span class="tok-number">8</span>, <span class="tok-number">1</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">9</span> }, small_braid);
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(small_bases, <a href="std.simd.html#std.simd.deinterlace">deinterlace</a>(small_bases.len, small_braid));
    }
}

<span class="tok-comment">/// Joins two vectors, shifts them leftwards (towards lower indices) and extracts the leftmost elements into a vector the length of a and b.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mergeShift</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> shift: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(a, b))) <span class="tok-builtin">@TypeOf</span>(a, b) {
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(a, b));

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.extract">extract</a>(<a href="std.simd.html#std.simd.join">join</a>(a, b), shift, len);
}

<span class="tok-comment">/// Elements are shifted rightwards (towards higher indices). New elements are added to the left, and the rightmost elements are cut off</span>
<span class="tok-comment">/// so that the length of the vector stays the same.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftElementsRight</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)), shift_in: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec) {<span class="tok-comment">
    // It may be possible to implement shifts and rotates with a runtime-friendly slice of two joined vectors, as the length of the
    // slice would be comptime-known. This would permit vector shifts and rotates by a non-comptime-known amount.
    // However, I am unsure whether compiler optimizations would handle that well enough on all platforms.
    </span><span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(V);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.mergeShift">mergeShift</a>(<span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(shift_in)), vec, len - amount);
}

<span class="tok-comment">/// Elements are shifted leftwards (towards lower indices). New elements are added to the right, and the leftmost elements are cut off</span>
<span class="tok-comment">/// so that no elements with indices below 0 remain.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftElementsLeft</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)), shift_in: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.mergeShift">mergeShift</a>(vec, <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(shift_in)), amount);
}

<span class="tok-comment">/// Elements are shifted leftwards (towards lower indices). Elements that leave to the left will reappear to the right in the same order.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotateElementsLeft</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.mergeShift">mergeShift</a>(vec, vec, amount);
}

<span class="tok-comment">/// Elements are shifted rightwards (towards higher indices). Elements that leave to the right will reappear to the left in the same order.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotateElementsRight</span>(vec: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> amount: <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.rotateElementsLeft">rotateElementsLeft</a>(vec, <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec)) - amount);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseOrder</span>(vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">return</span> <span class="tok-builtin">@shuffle</span>(Child, vec, <span class="tok-null">undefined</span>, <span class="tok-builtin">@as</span>(<span class="tok-builtin">@Vector</span>(len, <span class="tok-type">i32</span>), <span class="tok-builtin">@splat</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intCast</span>(len)) - <span class="tok-number">1</span>)) - <a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">i32</span>, len));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector shifting&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86_64) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> base = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u32</span>){ <span class="tok-number">10</span>, <span class="tok-number">20</span>, <span class="tok-number">30</span>, <span class="tok-number">40</span> };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{ <span class="tok-number">30</span>, <span class="tok-number">40</span>, <span class="tok-number">999</span>, <span class="tok-number">999</span> }, <a href="std.simd.html#std.simd.shiftElementsLeft">shiftElementsLeft</a>(base, <span class="tok-number">2</span>, <span class="tok-number">999</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{ <span class="tok-number">999</span>, <span class="tok-number">999</span>, <span class="tok-number">10</span>, <span class="tok-number">20</span> }, <a href="std.simd.html#std.simd.shiftElementsRight">shiftElementsRight</a>(base, <span class="tok-number">2</span>, <span class="tok-number">999</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{ <span class="tok-number">20</span>, <span class="tok-number">30</span>, <span class="tok-number">40</span>, <span class="tok-number">10</span> }, <a href="std.simd.html#std.simd.rotateElementsLeft">rotateElementsLeft</a>(base, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{ <span class="tok-number">40</span>, <span class="tok-number">10</span>, <span class="tok-number">20</span>, <span class="tok-number">30</span> }, <a href="std.simd.html#std.simd.rotateElementsRight">rotateElementsRight</a>(base, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{ <span class="tok-number">40</span>, <span class="tok-number">30</span>, <span class="tok-number">20</span>, <span class="tok-number">10</span> }, <a href="std.simd.html#std.simd.reverseOrder">reverseOrder</a>(base));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstTrue</span>(vec: <span class="tok-kw">anytype</span>) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> IndexInt = <a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">if</span> (!<span class="tok-builtin">@reduce</span>(.Or, vec)) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
    <span class="tok-kw">const</span> all_max: <span class="tok-builtin">@Vector</span>(len, IndexInt) = <span class="tok-builtin">@splat</span>(~<span class="tok-builtin">@as</span>(IndexInt, <span class="tok-number">0</span>));
    <span class="tok-kw">const</span> indices = <span class="tok-builtin">@select</span>(IndexInt, vec, <a href="std.simd.html#std.simd.iota">iota</a>(IndexInt, len), all_max);
    <span class="tok-kw">return</span> <span class="tok-builtin">@reduce</span>(.Min, indices);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastTrue</span>(vec: <span class="tok-kw">anytype</span>) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> IndexInt = <a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">if</span> (!<span class="tok-builtin">@reduce</span>(.Or, vec)) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">const</span> all_zeroes: <span class="tok-builtin">@Vector</span>(len, IndexInt) = <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>);
    <span class="tok-kw">const</span> indices = <span class="tok-builtin">@select</span>(IndexInt, vec, <a href="std.simd.html#std.simd.iota">iota</a>(IndexInt, len), all_zeroes);
    <span class="tok-kw">return</span> <span class="tok-builtin">@reduce</span>(.Max, indices);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countTrues</span>(vec: <span class="tok-kw">anytype</span>) <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));
    <span class="tok-kw">const</span> CountIntType = <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">const</span> all_ones: <span class="tok-builtin">@Vector</span>(len, CountIntType) = <span class="tok-builtin">@splat</span>(<span class="tok-number">1</span>);
    <span class="tok-kw">const</span> all_zeroes: <span class="tok-builtin">@Vector</span>(len, CountIntType) = <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>);

    <span class="tok-kw">const</span> one_if_true = <span class="tok-builtin">@select</span>(CountIntType, vec, all_ones, all_zeroes);
    <span class="tok-kw">return</span> <span class="tok-builtin">@reduce</span>(.Add, one_if_true);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstIndexOfValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(vec == <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(value)));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) ?<a href="std.simd.html#std.simd.VectorIndex">VectorIndex</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.lastTrue">lastTrue</a>(vec == <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(value)));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">countElementsWithValue</span>(vec: <span class="tok-kw">anytype</span>, value: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec))) <a href="std.simd.html#std.simd.VectorCount">VectorCount</a>(<span class="tok-builtin">@TypeOf</span>(vec)) {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@TypeOf</span>(vec);

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.countTrues">countTrues</a>(vec == <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(value)));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector searching&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86_64) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> base = <span class="tok-builtin">@Vector</span>(<span class="tok-number">8</span>, <span class="tok-type">u32</span>){ <span class="tok-number">6</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">4</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">7</span> };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u3</span>, <span class="tok-number">1</span>), <a href="std.simd.html#std.simd.firstIndexOfValue">firstIndexOfValue</a>(base, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u3</span>, <span class="tok-number">4</span>), <a href="std.simd.html#std.simd.lastIndexOfValue">lastIndexOfValue</a>(base, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u3</span>, <span class="tok-null">null</span>), <a href="std.simd.html#std.simd.lastIndexOfValue">lastIndexOfValue</a>(base, <span class="tok-number">99</span>));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">3</span>), <a href="std.simd.html#std.simd.countElementsWithValue">countElementsWithValue</a>(base, <span class="tok-number">4</span>));
}

<span class="tok-comment">/// Same as prefixScan, but with a user-provided, mathematically associative function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixScanWithFunc</span>(
    <span class="tok-kw">comptime</span> hop: <span class="tok-type">isize</span>,
    vec: <span class="tok-kw">anytype</span>,
    <span class="tok-comment">/// The error type that `func` might return. Set this to `void` if `func` doesn't return an error union.</span>
    <span class="tok-kw">comptime</span> ErrorType: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> func: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(vec), <span class="tok-builtin">@TypeOf</span>(vec)) <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) <span class="tok-builtin">@TypeOf</span>(vec) <span class="tok-kw">else</span> ErrorType!<span class="tok-builtin">@TypeOf</span>(vec),
    <span class="tok-comment">/// When one operand of the operation performed by `func` is this value, the result must equal the other operand.</span>
    <span class="tok-comment">/// For example, this should be 0 for addition or 1 for multiplication.</span>
    <span class="tok-kw">comptime</span> identity: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(<span class="tok-builtin">@TypeOf</span>(vec)),
) <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) <span class="tok-builtin">@TypeOf</span>(vec) <span class="tok-kw">else</span> ErrorType!<span class="tok-builtin">@TypeOf</span>(vec) {<span class="tok-comment">
    // I haven't debugged this, but it might be a cousin of sorts to what's going on with interlace.
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">isMIPS</a>()) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO: Find out why prefixScan doesn't work on MIPS&quot;</span>);

    <span class="tok-kw">const</span> len = <a href="std.simd.html#std.simd.vectorLength">vectorLength</a>(<span class="tok-builtin">@TypeOf</span>(vec));

    <span class="tok-kw">if</span> (hop == <span class="tok-number">0</span>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;hop can not be 0; you'd be going nowhere forever!&quot;</span>);
    <span class="tok-kw">const</span> abs_hop = <span class="tok-kw">if</span> (hop &lt; <span class="tok-number">0</span>) -hop <span class="tok-kw">else</span> hop;

    <span class="tok-kw">var</span> acc = vec;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> ((abs_hop &lt;&lt; i) &lt; len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> shifted = <span class="tok-kw">if</span> (hop &lt; <span class="tok-number">0</span>) <a href="std.simd.html#std.simd.shiftElementsLeft">shiftElementsLeft</a>(acc, abs_hop &lt;&lt; i, identity) <span class="tok-kw">else</span> <a href="std.simd.html#std.simd.shiftElementsRight">shiftElementsRight</a>(acc, abs_hop &lt;&lt; i, identity);

        acc = <span class="tok-kw">if</span> (ErrorType == <span class="tok-type">void</span>) func(acc, shifted) <span class="tok-kw">else</span> <span class="tok-kw">try</span> func(acc, shifted);
    }
    <span class="tok-kw">return</span> acc;
}

<span class="tok-comment">/// Returns a vector whose elements are the result of performing the specified operation on the corresponding</span>
<span class="tok-comment">/// element of the input vector and every hop'th element that came before it (or after, if hop is negative).</span>
<span class="tok-comment">/// Supports the same operations as the @reduce() builtin. Takes O(logN) to compute.</span>
<span class="tok-comment">/// The scan is not linear, which may affect floating point errors. This may affect the determinism of</span>
<span class="tok-comment">/// algorithms that use this function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixScan</span>(<span class="tok-kw">comptime</span> op: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.ReduceOp.html">ReduceOp</a>, <span class="tok-kw">comptime</span> hop: <span class="tok-type">isize</span>, vec: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(vec) {
    <span class="tok-kw">const</span> VecType = <span class="tok-builtin">@TypeOf</span>(vec);
    <span class="tok-kw">const</span> Child = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Child">Child</a>(VecType);

    <span class="tok-kw">const</span> identity = <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Child)) {
        .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">switch</span> (op) {
            .Or, .Xor =&gt; <span class="tok-null">false</span>,
            .And =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Invalid prefixScan operation &quot;</span> ++ <span class="tok-builtin">@tagName</span>(op) ++ <span class="tok-str">&quot; for vector of booleans.&quot;</span>),
        },
        .int =&gt; <span class="tok-kw">switch</span> (op) {
            .Max =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(Child),
            .Add, .Or, .Xor =&gt; <span class="tok-number">0</span>,
            .Mul =&gt; <span class="tok-number">1</span>,
            .And, .Min =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(Child),
        },
        .float =&gt; <span class="tok-kw">switch</span> (op) {
            .Max =&gt; -<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.inf">inf</a>(Child),
            .Add =&gt; <span class="tok-number">0</span>,
            .Mul =&gt; <span class="tok-number">1</span>,
            .Min =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.inf">inf</a>(Child),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Invalid prefixScan operation &quot;</span> ++ <span class="tok-builtin">@tagName</span>(op) ++ <span class="tok-str">&quot; for vector of floats.&quot;</span>),
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Invalid type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(VecType) ++ <span class="tok-str">&quot; for prefixScan.&quot;</span>),
    };

    <span class="tok-kw">const</span> fn_container = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">opFn</span>(a: VecType, b: VecType) VecType {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (Child == <span class="tok-type">bool</span>) <span class="tok-kw">switch</span> (op) {
                .And =&gt; <span class="tok-builtin">@select</span>(<span class="tok-type">bool</span>, a, b, <span class="tok-builtin">@as</span>(VecType, <span class="tok-builtin">@splat</span>(<span class="tok-null">false</span>))),
                .Or =&gt; <span class="tok-builtin">@select</span>(<span class="tok-type">bool</span>, a, <span class="tok-builtin">@as</span>(VecType, <span class="tok-builtin">@splat</span>(<span class="tok-null">true</span>)), b),
                .Xor =&gt; a != b,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (op) {
                .And =&gt; a &amp; b,
                .Or =&gt; a | b,
                .Xor =&gt; a ^ b,
                .Add =&gt; a + b,
                .Mul =&gt; a * b,
                .Min =&gt; <span class="tok-builtin">@min</span>(a, b),
                .Max =&gt; <span class="tok-builtin">@max</span>(a, b),
            };
        }
    };

    <span class="tok-kw">return</span> <a href="std.simd.html#std.simd.prefixScanWithFunc">prefixScanWithFunc</a>(hop, vec, <span class="tok-type">void</span>, fn_container.opFn, identity);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector prefix scan&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86_64) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">if</span> ((<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a> == .armeb <span class="tok-kw">or</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a> == .thumbeb) <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_llvm) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment"> // https://github.com/ziglang/zig/issues/22060
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a> == .aarch64_be <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_llvm) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment"> // https://github.com/ziglang/zig/issues/21893

    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">isMIPS</a>()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> int_base = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">23</span>, <span class="tok-number">9</span>, -<span class="tok-number">21</span> };
    <span class="tok-kw">const</span> float_base = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>){ <span class="tok-number">2</span>, <span class="tok-number">0.5</span>, -<span class="tok-number">10</span>, <span class="tok-number">6.54321</span> };
    <span class="tok-kw">const</span> bool_base = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">bool</span>){ <span class="tok-null">true</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span> };

    <span class="tok-kw">const</span> ones: <span class="tok-builtin">@Vector</span>(<span class="tok-number">32</span>, <span class="tok-type">u8</span>) = <span class="tok-builtin">@splat</span>(<span class="tok-number">1</span>);

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.simd.html#std.simd.iota">iota</a>(<span class="tok-type">u8</span>, <span class="tok-number">32</span>) + ones, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Add, <span class="tok-number">1</span>, ones));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.And, <span class="tok-number">1</span>, int_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">31</span>, <span class="tok-number">31</span>, -<span class="tok-number">1</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Or, <span class="tok-number">1</span>, int_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">28</span>, <span class="tok-number">21</span>, -<span class="tok-number">2</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Xor, <span class="tok-number">1</span>, int_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">34</span>, <span class="tok-number">43</span>, <span class="tok-number">22</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Add, <span class="tok-number">1</span>, int_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">253</span>, <span class="tok-number">2277</span>, -<span class="tok-number">47817</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Mul, <span class="tok-number">1</span>, int_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">11</span>, <span class="tok-number">9</span>, -<span class="tok-number">21</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Min, <span class="tok-number">1</span>, int_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">23</span>, <span class="tok-number">23</span>, <span class="tok-number">23</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Max, <span class="tok-number">1</span>, int_base));<span class="tok-comment">

    // Trying to predict all inaccuracies when adding and multiplying floats with prefixScans would be a mess, so we don't test those.
    </span><span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>){ <span class="tok-number">2</span>, <span class="tok-number">0.5</span>, -<span class="tok-number">10</span>, -<span class="tok-number">10</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Min, <span class="tok-number">1</span>, float_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>){ <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">6.54321</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Max, <span class="tok-number">1</span>, float_base));

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">bool</span>){ <span class="tok-null">true</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span>, <span class="tok-null">false</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Xor, <span class="tok-number">1</span>, bool_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">bool</span>){ <span class="tok-null">true</span>, <span class="tok-null">true</span>, <span class="tok-null">true</span>, <span class="tok-null">true</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Or, <span class="tok-number">1</span>, bool_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">bool</span>){ <span class="tok-null">true</span>, <span class="tok-null">false</span>, <span class="tok-null">false</span>, <span class="tok-null">false</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.And, <span class="tok-number">1</span>, bool_base));

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">23</span>, <span class="tok-number">20</span>, <span class="tok-number">2</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Add, <span class="tok-number">2</span>, int_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">22</span>, <span class="tok-number">11</span>, -<span class="tok-number">12</span>, -<span class="tok-number">21</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Add, -<span class="tok-number">1</span>, int_base));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">11</span>, <span class="tok-number">23</span>, <span class="tok-number">9</span>, -<span class="tok-number">10</span> }, <a href="std.simd.html#std.simd.prefixScan">prefixScan</a>(.Add, <span class="tok-number">3</span>, int_base));
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
