<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.RingBuffer.html" class="active">RingBuffer</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.RingBuffer" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.RingBuffer</span><a href="#src.zig-std.RingBuffer">[src]</a></h1><div class="tldDocs"><p>This ring buffer stores read and write indices while being able to utilise
the full backing slice by incrementing the indices modulo twice the slice's
length and reducing indices modulo the slice's length on slice access. This
means that whether the ring buffer is full or empty can be distinguished by
looking at the difference between the read and write indices without adding
an extra boolean flag or having to reserve a slot in the buffer.</p>
<p>This ring buffer has not been implemented with thread safety in mind, and
therefore should not be assumed to be suitable for use cases involving
separate reader and writer threads.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.RingBuffer.Slice.html">std.RingBuffer.Slice</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>data: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>read_index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>write_index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.RingBuffer.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.RingBuffer.Error">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Full</dt></div><div><dt>ReadLengthInvalid</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.Error">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{ Full, ReadLengthInvalid }</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.RingBuffer.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.RingBuffer.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div class="tldDocs"><p>Allocate a new <code><a href="std.RingBuffer.html">RingBuffer</a></code>; <code>deinit()</code> should be called to free the buffer.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.RingBuffer.html">RingBuffer</a> {
    <span class="tok-kw">const</span> bytes = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, capacity);
    <span class="tok-kw">return</span> <a href="std.RingBuffer.html">RingBuffer</a>{
        .data = bytes,
        .write_index = <span class="tok-number">0</span>,
        .read_index = <span class="tok-number">0</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.RingBuffer.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Free the data backing a <code><a href="std.RingBuffer.html">RingBuffer</a></code>; must be passed the same <code><a href="std.mem.Allocator.html">Allocator</a></code> as
<code>init()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    allocator.free(self.data);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.mask" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mask</span><a href="#src.zig-std.RingBuffer.mask">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mask</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns <code>index</code> modulo the length of the backing slice.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.mask">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mask</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> index % self.data.len;
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.mask2" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mask2</span><a href="#src.zig-std.RingBuffer.mask2">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mask2</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns <code>index</code> modulo twice the length of the backing slice.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.mask2">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mask2</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> index % (<span class="tok-number">2</span> * self.data.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.write" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">write</span><a href="#src.zig-std.RingBuffer.write">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, byte: <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>byte</code> into the ring buffer. Returns <code>error.Full</code> if the ring
buffer is full.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>byte: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.write">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, byte: <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.isFull()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Full;
    self.writeAssumeCapacity(byte);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.writeAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeAssumeCapacity</span><a href="#src.zig-std.RingBuffer.writeAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, byte: <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>byte</code> into the ring buffer. If the ring buffer is full, the
oldest byte is overwritten.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>byte: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.writeAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, byte: <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.data[self.mask(self.write_index)] = byte;
    self.write_index = self.mask2(self.write_index + <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.writeSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeSlice</span><a href="#src.zig-std.RingBuffer.writeSlice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSlice</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>bytes</code> into the ring buffer. Returns <code>error.Full</code> if the ring
buffer does not have enough space, without writing any data.
Uses memcpy and so <code>bytes</code> must not overlap ring buffer data.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.writeSlice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSlice</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.len() + bytes.len &gt; self.data.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Full;
    self.writeSliceAssumeCapacity(bytes);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.writeSliceAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeSliceAssumeCapacity</span><a href="#src.zig-std.RingBuffer.writeSliceAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>bytes</code> into the ring buffer. If there is not enough space, older
bytes will be overwritten.
Uses memcpy and so <code>bytes</code> must not overlap ring buffer data.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.writeSliceAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(bytes.len &lt;= self.data.len);
    <span class="tok-kw">const</span> data_start = self.mask(self.write_index);
    <span class="tok-kw">const</span> part1_data_end = <span class="tok-builtin">@min</span>(data_start + bytes.len, self.data.len);
    <span class="tok-kw">const</span> part1_len = part1_data_end - data_start;
    <span class="tok-builtin">@memcpy</span>(self.data[data_start..part1_data_end], bytes[<span class="tok-number">0</span>..part1_len]);

    <span class="tok-kw">const</span> remaining = bytes.len - part1_len;
    <span class="tok-kw">const</span> to_write = <span class="tok-builtin">@min</span>(remaining, remaining % self.data.len + self.data.len);
    <span class="tok-kw">const</span> part2_bytes_start = bytes.len - to_write;
    <span class="tok-kw">const</span> part2_bytes_end = <span class="tok-builtin">@min</span>(part2_bytes_start + self.data.len, bytes.len);
    <span class="tok-kw">const</span> part2_len = part2_bytes_end - part2_bytes_start;
    <span class="tok-builtin">@memcpy</span>(self.data[<span class="tok-number">0</span>..part2_len], bytes[part2_bytes_start..part2_bytes_end]);
    <span class="tok-kw">if</span> (part2_bytes_end != bytes.len) {
        <span class="tok-kw">const</span> part3_len = bytes.len - part2_bytes_end;
        <span class="tok-builtin">@memcpy</span>(self.data[<span class="tok-number">0</span>..part3_len], bytes[part2_bytes_end..bytes.len]);
    }
    self.write_index = self.mask2(self.write_index + bytes.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.writeSliceForwards" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeSliceForwards</span><a href="#src.zig-std.RingBuffer.writeSliceForwards">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceForwards</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>bytes</code> into the ring buffer. Returns <code>error.Full</code> if the ring
buffer does not have enough space, without writing any data.
Uses copyForwards and can write slices from this RingBuffer into itself.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.writeSliceForwards">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceForwards</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.len() + bytes.len &gt; self.data.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Full;
    self.writeSliceForwardsAssumeCapacity(bytes);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.writeSliceForwardsAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeSliceForwardsAssumeCapacity</span><a href="#src.zig-std.RingBuffer.writeSliceForwardsAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceForwardsAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Write <code>bytes</code> into the ring buffer. If there is not enough space, older
bytes will be overwritten.
Uses copyForwards and can write slices from this RingBuffer into itself.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.writeSliceForwardsAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceForwardsAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(bytes.len &lt;= self.data.len);
    <span class="tok-kw">const</span> data_start = self.mask(self.write_index);
    <span class="tok-kw">const</span> part1_data_end = <span class="tok-builtin">@min</span>(data_start + bytes.len, self.data.len);
    <span class="tok-kw">const</span> part1_len = part1_data_end - data_start;
    <a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, self.data[data_start..], bytes[<span class="tok-number">0</span>..part1_len]);

    <span class="tok-kw">const</span> remaining = bytes.len - part1_len;
    <span class="tok-kw">const</span> to_write = <span class="tok-builtin">@min</span>(remaining, remaining % self.data.len + self.data.len);
    <span class="tok-kw">const</span> part2_bytes_start = bytes.len - to_write;
    <span class="tok-kw">const</span> part2_bytes_end = <span class="tok-builtin">@min</span>(part2_bytes_start + self.data.len, bytes.len);
    <a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, self.data[<span class="tok-number">0</span>..], bytes[part2_bytes_start..part2_bytes_end]);
    <span class="tok-kw">if</span> (part2_bytes_end != bytes.len)
        <a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, self.data[<span class="tok-number">0</span>..], bytes[part2_bytes_end..bytes.len]);
    self.write_index = self.mask2(self.write_index + bytes.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.read" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">read</span><a href="#src.zig-std.RingBuffer.read">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>) ?<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Consume a byte from the ring buffer and return it. Returns <code>null</code> if the
ring buffer is empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.read">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>) ?<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (self.isEmpty()) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.readAssumeLength();
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.readAssumeLength" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readAssumeLength</span><a href="#src.zig-std.RingBuffer.readAssumeLength">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Consume a byte from the ring buffer and return it; asserts that the buffer
is not empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.readAssumeLength">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.isEmpty());
    <span class="tok-kw">const</span> byte = self.data[self.mask(self.read_index)];
    self.read_index = self.mask2(self.read_index + <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> byte;
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.readFirst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readFirst</span><a href="#src.zig-std.RingBuffer.readFirst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFirst</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reads first <code>length</code> bytes written to the ring buffer into <code>dest</code>; Returns
Error.ReadLengthInvalid if length greater than ring or dest length
Uses memcpy and so <code>dest</code> must not overlap ring buffer data.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>dest: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.readFirst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFirst</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (length &gt; self.len() <span class="tok-kw">or</span> length &gt; dest.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadLengthInvalid;
    self.readFirstAssumeLength(dest, length);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.readFirstAssumeLength" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readFirstAssumeLength</span><a href="#src.zig-std.RingBuffer.readFirstAssumeLength">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFirstAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reads first <code>length</code> bytes written to the ring buffer into <code>dest</code>;
Asserts that length not greater than ring buffer or dest length
Uses memcpy and so <code>dest</code> must not overlap ring buffer data.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>dest: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.readFirstAssumeLength">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFirstAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= self.len() <span class="tok-kw">and</span> length &lt;= dest.len);
    <span class="tok-kw">const</span> slice = self.sliceAt(self.read_index, length);
    slice.copyTo(dest);
    self.read_index = self.mask2(self.read_index + length);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.readLast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readLast</span><a href="#src.zig-std.RingBuffer.readLast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLast</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reads last <code>length</code> bytes written to the ring buffer into <code>dest</code>; Returns
Error.ReadLengthInvalid if length greater than ring or dest length
Uses memcpy and so <code>dest</code> must not overlap ring buffer data.
Reduces write index by <code>length</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>dest: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.readLast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLast</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (length &gt; self.len() <span class="tok-kw">or</span> length &gt; dest.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadLengthInvalid;
    self.readLastAssumeLength(dest, length);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.readLastAssumeLength" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readLastAssumeLength</span><a href="#src.zig-std.RingBuffer.readLastAssumeLength">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLastAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reads last <code>length</code> bytes written to the ring buffer into <code>dest</code>;
Asserts that length not greater than ring buffer or dest length
Uses memcpy and so <code>dest</code> must not overlap ring buffer data.
Reduces write index by <code>length</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>dest: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.readLastAssumeLength">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLastAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= self.len() <span class="tok-kw">and</span> length &lt;= dest.len);
    <span class="tok-kw">const</span> slice = self.sliceLast(length);
    slice.copyTo(dest);
    self.write_index = <span class="tok-kw">if</span> (self.write_index &gt;= self.data.len)
        self.write_index - length
    <span class="tok-kw">else</span>
        self.mask(self.write_index + self.data.len - length);
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.isEmpty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isEmpty</span><a href="#src.zig-std.RingBuffer.isEmpty">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEmpty</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns <code>true</code> if the ring buffer is empty and <code>false</code> otherwise.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.RingBuffer.html">RingBuffer</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.isEmpty">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEmpty</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.write_index == self.read_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.isFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isFull</span><a href="#src.zig-std.RingBuffer.isFull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isFull</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns <code>true</code> if the ring buffer is full and <code>false</code> otherwise.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.RingBuffer.html">RingBuffer</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.isFull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isFull</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.mask2(self.write_index + self.data.len) == self.read_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.len" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.RingBuffer.len">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the length of data available for reading</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.RingBuffer.html">RingBuffer</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> wrap_offset = <span class="tok-number">2</span> * self.data.len * <span class="tok-builtin">@intFromBool</span>(self.write_index &lt; self.read_index);
    <span class="tok-kw">const</span> adjusted_write_index = self.write_index + wrap_offset;
    <span class="tok-kw">return</span> adjusted_write_index - self.read_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.sliceAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sliceAt</span><a href="#src.zig-std.RingBuffer.sliceAt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceAt</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, start_unmasked: <span class="tok-type">usize</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.Slice.html">Slice</a></code></pre></div><div class="tldDocs"><p>Returns a <code><a href="std.RingBuffer.Slice.html">Slice</a></code> for the region of the ring buffer starting at
<code>self.mask(start_unmasked)</code> with the specified length.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>start_unmasked: <span class="tok-type">usize</span></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.sliceAt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceAt</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, start_unmasked: <span class="tok-type">usize</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.Slice.html">Slice</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= self.data.len);
    <span class="tok-kw">const</span> slice1_start = self.mask(start_unmasked);
    <span class="tok-kw">const</span> slice1_end = <span class="tok-builtin">@min</span>(self.data.len, slice1_start + length);
    <span class="tok-kw">const</span> slice1 = self.data[slice1_start..slice1_end];
    <span class="tok-kw">const</span> slice2 = self.data[<span class="tok-number">0</span> .. length - slice1.len];
    <span class="tok-kw">return</span> <a href="std.RingBuffer.Slice.html">Slice</a>{
        .first = slice1,
        .second = slice2,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.RingBuffer.sliceLast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sliceLast</span><a href="#src.zig-std.RingBuffer.sliceLast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceLast</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.Slice.html">Slice</a></code></pre></div><div class="tldDocs"><p>Returns a <code><a href="std.RingBuffer.Slice.html">Slice</a></code> for the last <code>length</code> bytes written to the ring buffer.
Does not check that any bytes have been written into the region.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.RingBuffer.html">RingBuffer</a></code></pre></div><div><pre><code>length: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.RingBuffer.sliceLast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceLast</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.Slice.html">Slice</a> {
    <span class="tok-kw">return</span> self.sliceAt(self.write_index + self.data.len - length, length);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.RingBuffer">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! This ring buffer stores read and write indices while being able to utilise</span>
<span class="tok-comment">//! the full backing slice by incrementing the indices modulo twice the slice's</span>
<span class="tok-comment">//! length and reducing indices modulo the slice's length on slice access. This</span>
<span class="tok-comment">//! means that whether the ring buffer is full or empty can be distinguished by</span>
<span class="tok-comment">//! looking at the difference between the read and write indices without adding</span>
<span class="tok-comment">//! an extra boolean flag or having to reserve a slot in the buffer.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! This ring buffer has not been implemented with thread safety in mind, and</span>
<span class="tok-comment">//! therefore should not be assumed to be suitable for use cases involving</span>
<span class="tok-comment">//! separate reader and writer threads.</span>

<span class="tok-kw">const</span> Allocator = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem.Allocator;
<span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> copyForwards = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem.copyForwards;

<span class="tok-kw">const</span> RingBuffer = <span class="tok-builtin">@This</span>();

data: []<span class="tok-type">u8</span>,
read_index: <span class="tok-type">usize</span>,
write_index: <span class="tok-type">usize</span>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{ Full, ReadLengthInvalid };

<span class="tok-comment">/// Allocate a new `RingBuffer`; `deinit()` should be called to free the buffer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.RingBuffer.html">RingBuffer</a> {
    <span class="tok-kw">const</span> bytes = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, capacity);
    <span class="tok-kw">return</span> <a href="std.RingBuffer.html">RingBuffer</a>{
        .data = bytes,
        .write_index = <span class="tok-number">0</span>,
        .read_index = <span class="tok-number">0</span>,
    };
}

<span class="tok-comment">/// Free the data backing a `RingBuffer`; must be passed the same `Allocator` as</span>
<span class="tok-comment">/// `init()`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    allocator.free(self.data);
    self.* = <span class="tok-null">undefined</span>;
}

<span class="tok-comment">/// Returns `index` modulo the length of the backing slice.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mask</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> index % self.data.len;
}

<span class="tok-comment">/// Returns `index` modulo twice the length of the backing slice.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mask2</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> index % (<span class="tok-number">2</span> * self.data.len);
}

<span class="tok-comment">/// Write `byte` into the ring buffer. Returns `error.Full` if the ring</span>
<span class="tok-comment">/// buffer is full.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, byte: <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.isFull()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Full;
    self.writeAssumeCapacity(byte);
}

<span class="tok-comment">/// Write `byte` into the ring buffer. If the ring buffer is full, the</span>
<span class="tok-comment">/// oldest byte is overwritten.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, byte: <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    self.data[self.mask(self.write_index)] = byte;
    self.write_index = self.mask2(self.write_index + <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Write `bytes` into the ring buffer. Returns `error.Full` if the ring</span>
<span class="tok-comment">/// buffer does not have enough space, without writing any data.</span>
<span class="tok-comment">/// Uses memcpy and so `bytes` must not overlap ring buffer data.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSlice</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.len() + bytes.len &gt; self.data.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Full;
    self.writeSliceAssumeCapacity(bytes);
}

<span class="tok-comment">/// Write `bytes` into the ring buffer. If there is not enough space, older</span>
<span class="tok-comment">/// bytes will be overwritten.</span>
<span class="tok-comment">/// Uses memcpy and so `bytes` must not overlap ring buffer data.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(bytes.len &lt;= self.data.len);
    <span class="tok-kw">const</span> data_start = self.mask(self.write_index);
    <span class="tok-kw">const</span> part1_data_end = <span class="tok-builtin">@min</span>(data_start + bytes.len, self.data.len);
    <span class="tok-kw">const</span> part1_len = part1_data_end - data_start;
    <span class="tok-builtin">@memcpy</span>(self.data[data_start..part1_data_end], bytes[<span class="tok-number">0</span>..part1_len]);

    <span class="tok-kw">const</span> remaining = bytes.len - part1_len;
    <span class="tok-kw">const</span> to_write = <span class="tok-builtin">@min</span>(remaining, remaining % self.data.len + self.data.len);
    <span class="tok-kw">const</span> part2_bytes_start = bytes.len - to_write;
    <span class="tok-kw">const</span> part2_bytes_end = <span class="tok-builtin">@min</span>(part2_bytes_start + self.data.len, bytes.len);
    <span class="tok-kw">const</span> part2_len = part2_bytes_end - part2_bytes_start;
    <span class="tok-builtin">@memcpy</span>(self.data[<span class="tok-number">0</span>..part2_len], bytes[part2_bytes_start..part2_bytes_end]);
    <span class="tok-kw">if</span> (part2_bytes_end != bytes.len) {
        <span class="tok-kw">const</span> part3_len = bytes.len - part2_bytes_end;
        <span class="tok-builtin">@memcpy</span>(self.data[<span class="tok-number">0</span>..part3_len], bytes[part2_bytes_end..bytes.len]);
    }
    self.write_index = self.mask2(self.write_index + bytes.len);
}

<span class="tok-comment">/// Write `bytes` into the ring buffer. Returns `error.Full` if the ring</span>
<span class="tok-comment">/// buffer does not have enough space, without writing any data.</span>
<span class="tok-comment">/// Uses copyForwards and can write slices from this RingBuffer into itself.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceForwards</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.len() + bytes.len &gt; self.data.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Full;
    self.writeSliceForwardsAssumeCapacity(bytes);
}

<span class="tok-comment">/// Write `bytes` into the ring buffer. If there is not enough space, older</span>
<span class="tok-comment">/// bytes will be overwritten.</span>
<span class="tok-comment">/// Uses copyForwards and can write slices from this RingBuffer into itself.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSliceForwardsAssumeCapacity</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(bytes.len &lt;= self.data.len);
    <span class="tok-kw">const</span> data_start = self.mask(self.write_index);
    <span class="tok-kw">const</span> part1_data_end = <span class="tok-builtin">@min</span>(data_start + bytes.len, self.data.len);
    <span class="tok-kw">const</span> part1_len = part1_data_end - data_start;
    <a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, self.data[data_start..], bytes[<span class="tok-number">0</span>..part1_len]);

    <span class="tok-kw">const</span> remaining = bytes.len - part1_len;
    <span class="tok-kw">const</span> to_write = <span class="tok-builtin">@min</span>(remaining, remaining % self.data.len + self.data.len);
    <span class="tok-kw">const</span> part2_bytes_start = bytes.len - to_write;
    <span class="tok-kw">const</span> part2_bytes_end = <span class="tok-builtin">@min</span>(part2_bytes_start + self.data.len, bytes.len);
    <a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, self.data[<span class="tok-number">0</span>..], bytes[part2_bytes_start..part2_bytes_end]);
    <span class="tok-kw">if</span> (part2_bytes_end != bytes.len)
        <a href="std.mem.html#std.mem.copyForwards">copyForwards</a>(<span class="tok-type">u8</span>, self.data[<span class="tok-number">0</span>..], bytes[part2_bytes_end..bytes.len]);
    self.write_index = self.mask2(self.write_index + bytes.len);
}

<span class="tok-comment">/// Consume a byte from the ring buffer and return it. Returns `null` if the</span>
<span class="tok-comment">/// ring buffer is empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>) ?<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (self.isEmpty()) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.readAssumeLength();
}

<span class="tok-comment">/// Consume a byte from the ring buffer and return it; asserts that the buffer</span>
<span class="tok-comment">/// is not empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.isEmpty());
    <span class="tok-kw">const</span> byte = self.data[self.mask(self.read_index)];
    self.read_index = self.mask2(self.read_index + <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> byte;
}

<span class="tok-comment">/// Reads first `length` bytes written to the ring buffer into `dest`; Returns</span>
<span class="tok-comment">/// Error.ReadLengthInvalid if length greater than ring or dest length</span>
<span class="tok-comment">/// Uses memcpy and so `dest` must not overlap ring buffer data.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFirst</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (length &gt; self.len() <span class="tok-kw">or</span> length &gt; dest.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadLengthInvalid;
    self.readFirstAssumeLength(dest, length);
}

<span class="tok-comment">/// Reads first `length` bytes written to the ring buffer into `dest`;</span>
<span class="tok-comment">/// Asserts that length not greater than ring buffer or dest length</span>
<span class="tok-comment">/// Uses memcpy and so `dest` must not overlap ring buffer data.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFirstAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= self.len() <span class="tok-kw">and</span> length &lt;= dest.len);
    <span class="tok-kw">const</span> slice = self.sliceAt(self.read_index, length);
    slice.copyTo(dest);
    self.read_index = self.mask2(self.read_index + length);
}

<span class="tok-comment">/// Reads last `length` bytes written to the ring buffer into `dest`; Returns</span>
<span class="tok-comment">/// Error.ReadLengthInvalid if length greater than ring or dest length</span>
<span class="tok-comment">/// Uses memcpy and so `dest` must not overlap ring buffer data.</span>
<span class="tok-comment">/// Reduces write index by `length`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLast</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.html#std.RingBuffer.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (length &gt; self.len() <span class="tok-kw">or</span> length &gt; dest.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadLengthInvalid;
    self.readLastAssumeLength(dest, length);
}

<span class="tok-comment">/// Reads last `length` bytes written to the ring buffer into `dest`;</span>
<span class="tok-comment">/// Asserts that length not greater than ring buffer or dest length</span>
<span class="tok-comment">/// Uses memcpy and so `dest` must not overlap ring buffer data.</span>
<span class="tok-comment">/// Reduces write index by `length`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLastAssumeLength</span>(self: *<a href="std.RingBuffer.html">RingBuffer</a>, dest: []<span class="tok-type">u8</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= self.len() <span class="tok-kw">and</span> length &lt;= dest.len);
    <span class="tok-kw">const</span> slice = self.sliceLast(length);
    slice.copyTo(dest);
    self.write_index = <span class="tok-kw">if</span> (self.write_index &gt;= self.data.len)
        self.write_index - length
    <span class="tok-kw">else</span>
        self.mask(self.write_index + self.data.len - length);
}

<span class="tok-comment">/// Returns `true` if the ring buffer is empty and `false` otherwise.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEmpty</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.write_index == self.read_index;
}

<span class="tok-comment">/// Returns `true` if the ring buffer is full and `false` otherwise.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isFull</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.mask2(self.write_index + self.data.len) == self.read_index;
}

<span class="tok-comment">/// Returns the length of data available for reading</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> wrap_offset = <span class="tok-number">2</span> * self.data.len * <span class="tok-builtin">@intFromBool</span>(self.write_index &lt; self.read_index);
    <span class="tok-kw">const</span> adjusted_write_index = self.write_index + wrap_offset;
    <span class="tok-kw">return</span> adjusted_write_index - self.read_index;
}

<span class="tok-comment">/// A `Slice` represents a region of a ring buffer. The region is split into two</span>
<span class="tok-comment">/// sections as the ring buffer data will not be contiguous if the desired</span>
<span class="tok-comment">/// region wraps to the start of the backing slice.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">struct</span> {
    first: []<span class="tok-type">u8</span>,
    second: []<span class="tok-type">u8</span>,

    <span class="tok-comment">/// Copy data from `self` into `dest`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyTo</span>(self: <a href="std.RingBuffer.Slice.html">Slice</a>, dest: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
        <span class="tok-builtin">@memcpy</span>(dest[<span class="tok-number">0</span>..self.first.len], self.first);
        <span class="tok-builtin">@memcpy</span>(dest[self.first.len..][<span class="tok-number">0</span>..self.second.len], self.second);
    }
};

<span class="tok-comment">/// Returns a `Slice` for the region of the ring buffer starting at</span>
<span class="tok-comment">/// `self.mask(start_unmasked)` with the specified length.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceAt</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, start_unmasked: <span class="tok-type">usize</span>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.Slice.html">Slice</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= self.data.len);
    <span class="tok-kw">const</span> slice1_start = self.mask(start_unmasked);
    <span class="tok-kw">const</span> slice1_end = <span class="tok-builtin">@min</span>(self.data.len, slice1_start + length);
    <span class="tok-kw">const</span> slice1 = self.data[slice1_start..slice1_end];
    <span class="tok-kw">const</span> slice2 = self.data[<span class="tok-number">0</span> .. length - slice1.len];
    <span class="tok-kw">return</span> <a href="std.RingBuffer.Slice.html">Slice</a>{
        .first = slice1,
        .second = slice2,
    };
}

<span class="tok-comment">/// Returns a `Slice` for the last `length` bytes written to the ring buffer.</span>
<span class="tok-comment">/// Does not check that any bytes have been written into the region.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceLast</span>(self: <a href="std.RingBuffer.html">RingBuffer</a>, length: <span class="tok-type">usize</span>) <a href="std.RingBuffer.Slice.html">Slice</a> {
    <span class="tok-kw">return</span> self.sliceAt(self.write_index + self.data.len - length, length);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
