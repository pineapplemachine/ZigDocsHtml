<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.net.html" class="active">net</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.net" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.net</span><a href="#src.zig-std.net">[src]</a></h1><div class="tldDocs"><p>Cross-platform networking abstractions.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.net.Address.html">std.net.Address</a></li><li><a href="std.net.Ip4Address.html">std.net.Ip4Address</a></li><li><a href="std.net.Ip6Address.html">std.net.Ip6Address</a></li><li><a href="std.net.AddressList.html">std.net.AddressList</a></li><li><a href="std.net.Stream.html">std.net.Stream</a></li><li><a href="std.net.Server.html">std.net.Server</a></li></ul></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.net.has_unix_sockets" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">has_unix_sockets</span><a href="#src.zig-std.net.has_unix_sockets">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.has_unix_sockets">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> has_unix_sockets = <span class="tok-kw">switch</span> (<a href="std.net.html#std.net.native_os">native_os</a>) {
    .windows =&gt; <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">version_range</a>.<a href="#">windows</a>.<a href="#">isAtLeast</a>(.win10_rs4) <span class="tok-kw">orelse</span> <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
}</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.net.IPParseError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IPParseError</span><a href="#src.zig-std.net.IPParseError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Incomplete</dt></div><div><dt>InvalidCharacter</dt></div><div><dt>InvalidEnd</dt></div><div><dt>Overflow</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.IPParseError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPParseError = <span class="tok-kw">error</span>{
    Overflow,
    InvalidEnd,
    InvalidCharacter,
    Incomplete,
}</code></pre></details></div></div><div class="decl"><h2 id="std.net.IPv4ParseError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IPv4ParseError</span><a href="#src.zig-std.net.IPv4ParseError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Incomplete <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>InvalidCharacter <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>InvalidEnd <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>NonCanonical</dt></div><div><dt>Overflow <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.IPv4ParseError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPv4ParseError = <a href="std.net.html#std.net.IPParseError">IPParseError</a> || <span class="tok-kw">error</span>{NonCanonical}</code></pre></details></div></div><div class="decl"><h2 id="std.net.IPv6ParseError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IPv6ParseError</span><a href="#src.zig-std.net.IPv6ParseError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Incomplete <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>InvalidCharacter <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>InvalidEnd <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>InvalidIpv4Mapping</dt></div><div><dt>Overflow <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.IPv6ParseError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPv6ParseError = <a href="std.net.html#std.net.IPParseError">IPParseError</a> || <span class="tok-kw">error</span>{InvalidIpv4Mapping}</code></pre></details></div></div><div class="decl"><h2 id="std.net.IPv6InterfaceError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IPv6InterfaceError</span><a href="#src.zig-std.net.IPv6InterfaceError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AddressFamilyNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The implementation does not support the specified address family.</p>
</dd></div><div><dt>FileSystem <a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a></dt></div><div><dt>InterfaceNotFound <a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a></dt></div><div><dt>NameTooLong</dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Permission to create a socket of the specified type and/or
pro‐tocol is denied.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>ProtocolFamilyNotAvailable <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Unknown protocol, or protocol family not available.</p>
</dd></div><div><dt>ProtocolNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The protocol type or the specified protocol is not supported within this domain.</p>
</dd></div><div><dt>SocketTypeNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The socket type is not supported by the protocol.</p>
</dd></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Insufficient memory is available. The socket cannot be created until sufficient
resources are freed.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.IPv6InterfaceError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPv6InterfaceError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SocketError">SocketError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a> || <span class="tok-kw">error</span>{NameTooLong}</code></pre></details></div></div><div class="decl"><h2 id="std.net.IPv6ResolveError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">IPv6ResolveError</span><a href="#src.zig-std.net.IPv6ResolveError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AddressFamilyNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The implementation does not support the specified address family.</p>
</dd></div><div><dt>FileSystem <a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a></dt></div><div><dt>Incomplete <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>InterfaceNotFound <a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a></dt></div><div><dt>InvalidCharacter <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>InvalidEnd <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>InvalidIpv4Mapping <a href="std.net.html#std.net.IPv6ParseError">IPv6ParseError</a></dt></div><div><dt>NameTooLong <a href="std.net.html#std.net.IPv6InterfaceError">IPv6InterfaceError</a></dt></div><div><dt>Overflow <a href="std.net.html#std.net.IPParseError">IPParseError</a></dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Permission to create a socket of the specified type and/or
pro‐tocol is denied.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>ProtocolFamilyNotAvailable <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Unknown protocol, or protocol family not available.</p>
</dd></div><div><dt>ProtocolNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The protocol type or the specified protocol is not supported within this domain.</p>
</dd></div><div><dt>SocketTypeNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The socket type is not supported by the protocol.</p>
</dd></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Insufficient memory is available. The socket cannot be created until sufficient
resources are freed.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.IPv6ResolveError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPv6ResolveError = <a href="std.net.html#std.net.IPv6ParseError">IPv6ParseError</a> || <a href="std.net.html#std.net.IPv6InterfaceError">IPv6InterfaceError</a></code></pre></details></div></div><div class="decl"><h2 id="std.net.TcpConnectToHostError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TcpConnectToHostError</span><a href="#src.zig-std.net.TcpConnectToHostError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AddressFamilyNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The implementation does not support the specified address family.</p>
</dd></div><div><dt>AddressInUse <a href="std.posix.html#std.posix.BindError">BindError</a></dt><dd><p>The given address is already in use, or in the case of Internet domain sockets,
The  port number was specified as zero in the socket
address structure, but, upon attempting to bind to  an  ephemeral  port,  it  was
determined  that  all  port  numbers in the ephemeral port range are currently in
use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range ip(7).</p>
</dd></div><div><dt>AddressNotAvailable <a href="std.posix.html#std.posix.BindError">BindError</a></dt><dd><p>A nonexistent interface was requested or the requested address was not local.</p>
</dd></div><div><dt>AlreadyBound <a href="std.posix.html#std.posix.BindError">BindError</a></dt></div><div><dt>AlreadyConnected <a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a></dt><dd><p>The socket is already connected, and a specified option cannot be set while the socket is connected.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionPending <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Socket is non-blocking and already has a pending connection in progress.</p>
</dd></div><div><dt>ConnectionRefused <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>A connect() on a stream socket found no one listening on the remote address.</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Connection was reset by peer before connect could complete.</p>
</dd></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Timeout  while  attempting  connection.   The server may be too busy to accept new connections.  Note
that for IP sockets the timeout may be very long when syncookies are enabled on the server.</p>
</dd></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileDescriptorNotASocket <a href="std.posix.html#std.posix.BindError">BindError</a></dt></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileSystem <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>HostLacksNetworkAddresses <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>Incomplete <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InterfaceNotFound <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>InvalidCharacter <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>InvalidEnd <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>InvalidIPAddressFormat <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>InvalidIpv4Mapping <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>InvalidProtocolOption <a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a></dt><dd><p>The option is not supported by the protocol.</p>
</dd></div><div><dt>InvalidUtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NameServerFailure <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NetworkSubsystemFailed <a href="std.posix.html#std.posix.BindError">BindError</a></dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>NetworkUnreachable <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>NoDevice <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NonCanonical <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationNotSupported <a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>Overflow <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Permission to create a socket of the specified type and/or
pro‐tocol is denied.</p>
</dd></div><div><dt>PipeBusy <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>ProtocolFamilyNotAvailable <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Unknown protocol, or protocol family not available.</p>
</dd></div><div><dt>ProtocolNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The protocol type or the specified protocol is not supported within this domain.</p>
</dd></div><div><dt>ReadOnlyFileSystem <a href="std.posix.html#std.posix.BindError">BindError</a></dt><dd><p>The socket inode would reside on a read-only filesystem.</p>
</dd></div><div><dt>ServiceUnavailable <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>SharingViolation <a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a></dt></div><div><dt>SocketNotBound <a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a></dt></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SocketTypeNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The socket type is not supported by the protocol.</p>
</dd></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.BindError">BindError</a></dt><dd><p>Too many symbolic links were encountered in resolving addr.</p>
</dd></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>TemporaryNameServerFailure <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>TimeoutTooBig <a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a></dt><dd><p>The send and receive timeout values are too big to fit into the timeout fields in the socket structure.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnknownHostName <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.TcpConnectToHostError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TcpConnectToHostError = <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a> || <a href="std.net.html#std.net.TcpConnectToAddressError">TcpConnectToAddressError</a></code></pre></details></div></div><div class="decl"><h2 id="std.net.TcpConnectToAddressError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TcpConnectToAddressError</span><a href="#src.zig-std.net.TcpConnectToAddressError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AddressFamilyNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The implementation does not support the specified address family.</p>
</dd></div><div><dt>AddressInUse <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Local address is already in use.</p>
</dd></div><div><dt>AddressNotAvailable <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>(Internet  domain  sockets)  The  socket  referred  to  by sockfd had not previously been bound to an
address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers
in    the    ephemeral    port    range    are   currently   in   use.    See   the   discussion   of
/proc/sys/net/ipv4/ip_local_port_range in ip(7).</p>
</dd></div><div><dt>ConnectionPending <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Socket is non-blocking and already has a pending connection in progress.</p>
</dd></div><div><dt>ConnectionRefused <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>A connect() on a stream socket found no one listening on the remote address.</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Connection was reset by peer before connect could complete.</p>
</dd></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Timeout  while  attempting  connection.   The server may be too busy to accept new connections.  Note
that for IP sockets the timeout may be very long when syncookies are enabled on the server.</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>The given path for the unix socket does not exist.</p>
</dd></div><div><dt>NetworkUnreachable <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>Network is unreachable.</p>
</dd></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Permission to create a socket of the specified type and/or
pro‐tocol is denied.</p>
</dd></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The per-process limit on the number of open file descriptors has been reached.</p>
</dd></div><div><dt>ProtocolFamilyNotAvailable <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Unknown protocol, or protocol family not available.</p>
</dd></div><div><dt>ProtocolNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The protocol type or the specified protocol is not supported within this domain.</p>
</dd></div><div><dt>SocketTypeNotSupported <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The socket type is not supported by the protocol.</p>
</dd></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>The system-wide limit on the total number of open files has been reached.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.SocketError">SocketError</a></dt><dd><p>Insufficient memory is available. The socket cannot be created until sufficient
resources are freed.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ConnectError">ConnectError</a></dt><dd><p>This error occurs when no global event loop is configured,
and connecting to the socket would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.TcpConnectToAddressError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TcpConnectToAddressError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SocketError">SocketError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ConnectError">ConnectError</a></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.net.connectUnixSocket" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">connectUnixSocket</span><a href="#src.zig-std.net.connectUnixSocket">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectUnixSocket</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.net.Stream.html">Stream</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.connectUnixSocket">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectUnixSocket</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.net.Stream.html">Stream</a> {
    <span class="tok-kw">const</span> opt_non_block = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> sockfd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNIX</a>,
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a> | opt_non_block,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">errdefer</span> <a href="std.net.Stream.html">Stream</a>.<a href="std.net.Stream.html#std.net.Stream.close">close</a>(.{ .handle = sockfd });

    <span class="tok-kw">var</span> addr = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initUnix">initUnix</a>(path);
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(sockfd, &amp;addr.any, addr.getOsSockLen());

    <span class="tok-kw">return</span> .{ .handle = sockfd };
}</code></pre></details></div></div><div class="decl"><h2 id="std.net.tcpConnectToHost" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tcpConnectToHost</span><a href="#src.zig-std.net.tcpConnectToHost">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcpConnectToHost</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.TcpConnectToHostError">TcpConnectToHostError</a>!<a href="std.net.Stream.html">Stream</a></code></pre></div><div class="tldDocs"><p>All memory allocated with <code>allocator</code> will be freed before this function returns.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>port: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.tcpConnectToHost">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcpConnectToHost</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.TcpConnectToHostError">TcpConnectToHostError</a>!<a href="std.net.Stream.html">Stream</a> {
    <span class="tok-kw">const</span> list = <span class="tok-kw">try</span> <a href="std.net.html#std.net.getAddressList">getAddressList</a>(allocator, name, port);
    <span class="tok-kw">defer</span> list.deinit();

    <span class="tok-kw">if</span> (list.addrs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName;

    <span class="tok-kw">for</span> (list.addrs) |addr| {
        <span class="tok-kw">return</span> <a href="std.net.html#std.net.tcpConnectToAddress">tcpConnectToAddress</a>(addr) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.ConnectionRefused =&gt; {
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ConnectError">ConnectError</a>.<a href="#">ConnectionRefused</a>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.net.tcpConnectToAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tcpConnectToAddress</span><a href="#src.zig-std.net.tcpConnectToAddress">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcpConnectToAddress</span>(address: <a href="std.net.Address.html">Address</a>) <a href="std.net.html#std.net.TcpConnectToAddressError">TcpConnectToAddressError</a>!<a href="std.net.Stream.html">Stream</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>address: <a href="std.net.Address.html">Address</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.tcpConnectToAddress">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcpConnectToAddress</span>(address: <a href="std.net.Address.html">Address</a>) <a href="std.net.html#std.net.TcpConnectToAddressError">TcpConnectToAddressError</a>!<a href="std.net.Stream.html">Stream</a> {
    <span class="tok-kw">const</span> nonblock = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> sock_flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | nonblock |
        (<span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .windows) <span class="tok-number">0</span> <span class="tok-kw">else</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>);
    <span class="tok-kw">const</span> sockfd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, sock_flags, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IPPROTO">IPPROTO</a>.<a href="#">TCP</a>);
    <span class="tok-kw">errdefer</span> <a href="std.net.Stream.html">Stream</a>.<a href="std.net.Stream.html#std.net.Stream.close">close</a>(.{ .handle = sockfd });

    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(sockfd, &amp;address.any, address.getOsSockLen());

    <span class="tok-kw">return</span> <a href="std.net.Stream.html">Stream</a>{ .handle = sockfd };
}</code></pre></details></div></div><div class="decl"><h2 id="std.net.getAddressList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAddressList</span><a href="#src.zig-std.net.getAddressList">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAddressList</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a>!*<a href="std.net.AddressList.html">AddressList</a></code></pre></div><div class="tldDocs"><p>Call <code><a href="std.net.AddressList.html#std.net.AddressList.deinit">AddressList.deinit</a></code> on the result.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>port: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.getAddressList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAddressList</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a>!*<a href="std.net.AddressList.html">AddressList</a> {
    <span class="tok-kw">const</span> result = blk: {
        <span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(allocator);
        <span class="tok-kw">errdefer</span> arena.deinit();

        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> arena.allocator().create(<a href="std.net.AddressList.html">AddressList</a>);
        result.* = <a href="std.net.AddressList.html">AddressList</a>{
            .arena = arena,
            .addrs = <span class="tok-null">undefined</span>,
            .canon_name = <span class="tok-null">null</span>,
        };
        <span class="tok-kw">break</span> :blk result;
    };
    <span class="tok-kw">const</span> arena = result.arena.allocator();
    <span class="tok-kw">errdefer</span> result.deinit();

    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> name_c = <span class="tok-kw">try</span> allocator.dupeZ(<span class="tok-type">u8</span>, name);
        <span class="tok-kw">defer</span> allocator.free(name_c);

        <span class="tok-kw">const</span> port_c = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(allocator, <span class="tok-str">&quot;{}&quot;</span>, .{port});
        <span class="tok-kw">defer</span> allocator.free(port_c);

        <span class="tok-kw">const</span> ws2_32 = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>;
        <span class="tok-kw">const</span> hints: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.addrinfo">addrinfo</a> = .{
            .flags = .{ .NUMERICSERV = <span class="tok-null">true</span> },
            .family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNSPEC</a>,
            .socktype = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a>,
            .protocol = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IPPROTO">IPPROTO</a>.<a href="#">TCP</a>,
            .canonname = <span class="tok-null">null</span>,
            .addr = <span class="tok-null">null</span>,
            .addrlen = <span class="tok-number">0</span>,
            .next = <span class="tok-null">null</span>,
        };
        <span class="tok-kw">var</span> res: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.addrinfo">addrinfo</a> = <span class="tok-null">null</span>;
        <span class="tok-kw">var</span> first = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> rc = ws2_32.getaddrinfo(name_c.ptr, port_c.ptr, &amp;hints, &amp;res);
            <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.WinsockError.html">WinsockError</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(rc))))) {
                <span class="tok-builtin">@as</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.WinsockError.html">WinsockError</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>)) =&gt; <span class="tok-kw">break</span>,
                .WSATRY_AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TemporaryNameServerFailure,
                .WSANO_RECOVERY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameServerFailure,
                .WSAEAFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
                .WSA_NOT_ENOUGH_MEMORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                .WSAHOST_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName,
                .WSATYPE_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ServiceUnavailable,
                .WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
                .WSAESOCKTNOSUPPORT =&gt; <span class="tok-kw">unreachable</span>,
                .WSANOTINITIALISED =&gt; {
                    <span class="tok-kw">if</span> (!first) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
                    first = <span class="tok-null">false</span>;
                    <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.callWSAStartup">callWSAStartup</a>();
                    <span class="tok-kw">continue</span>;
                },
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">defer</span> ws2_32.freeaddrinfo(res);

        <span class="tok-kw">const</span> addr_count = blk: {
            <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> it = res;
            <span class="tok-kw">while</span> (it) |info| : (it = info.next) {
                <span class="tok-kw">if</span> (info.addr != <span class="tok-null">null</span>) {
                    count += <span class="tok-number">1</span>;
                }
            }
            <span class="tok-kw">break</span> :blk count;
        };
        result.addrs = <span class="tok-kw">try</span> arena.alloc(<a href="std.net.Address.html">Address</a>, addr_count);

        <span class="tok-kw">var</span> it = res;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (it) |info| : (it = info.next) {
            <span class="tok-kw">const</span> addr = info.addr <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            result.addrs[i] = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initPosix">initPosix</a>(<span class="tok-builtin">@alignCast</span>(addr));

            <span class="tok-kw">if</span> (info.canonname) |n| {
                <span class="tok-kw">if</span> (result.canon_name == <span class="tok-null">null</span>) {
                    result.canon_name = <span class="tok-kw">try</span> arena.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(n, <span class="tok-number">0</span>));
                }
            }
            i += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> name_c = <span class="tok-kw">try</span> allocator.dupeZ(<span class="tok-type">u8</span>, name);
        <span class="tok-kw">defer</span> allocator.free(name_c);

        <span class="tok-kw">const</span> port_c = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(allocator, <span class="tok-str">&quot;{}&quot;</span>, .{port});
        <span class="tok-kw">defer</span> allocator.free(port_c);

        <span class="tok-kw">const</span> hints: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.addrinfo">addrinfo</a> = .{
            .flags = .{ .NUMERICSERV = <span class="tok-null">true</span> },
            .family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNSPEC</a>,
            .socktype = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a>,
            .protocol = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IPPROTO">IPPROTO</a>.<a href="#">TCP</a>,
            .canonname = <span class="tok-null">null</span>,
            .addr = <span class="tok-null">null</span>,
            .addrlen = <span class="tok-number">0</span>,
            .next = <span class="tok-null">null</span>,
        };
        <span class="tok-kw">var</span> res: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.addrinfo">addrinfo</a> = <span class="tok-null">null</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getaddrinfo</a>(name_c.ptr, port_c.ptr, &amp;hints, &amp;res)) {
            <span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">EAI</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>)) =&gt; {},
            .ADDRFAMILY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HostLacksNetworkAddresses,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TemporaryNameServerFailure,
            .BADFLAGS =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid hints
            </span>.FAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameServerFailure,
            .FAMILY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .MEMORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            .NODATA =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HostLacksNetworkAddresses,
            .NONAME =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName,
            .SERVICE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ServiceUnavailable,
            .SOCKTYPE =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid socket type requested in hints
            </span>.SYSTEM =&gt; <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(-<span class="tok-number">1</span>)) {
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(e),
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (res) |some| <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">freeaddrinfo</a>(some);

        <span class="tok-kw">const</span> addr_count = blk: {
            <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> it = res;
            <span class="tok-kw">while</span> (it) |info| : (it = info.next) {
                <span class="tok-kw">if</span> (info.addr != <span class="tok-null">null</span>) {
                    count += <span class="tok-number">1</span>;
                }
            }
            <span class="tok-kw">break</span> :blk count;
        };
        result.addrs = <span class="tok-kw">try</span> arena.alloc(<a href="std.net.Address.html">Address</a>, addr_count);

        <span class="tok-kw">var</span> it = res;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (it) |info| : (it = info.next) {
            <span class="tok-kw">const</span> addr = info.addr <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            result.addrs[i] = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initPosix">initPosix</a>(<span class="tok-builtin">@alignCast</span>(addr));

            <span class="tok-kw">if</span> (info.canonname) |n| {
                <span class="tok-kw">if</span> (result.canon_name == <span class="tok-null">null</span>) {
                    result.canon_name = <span class="tok-kw">try</span> arena.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(n, <span class="tok-number">0</span>));
                }
            }
            i += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .linux) {
        <span class="tok-kw">const</span> family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNSPEC</a>;
        <span class="tok-kw">var</span> lookup_addrs = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>).init(allocator);
        <span class="tok-kw">defer</span> lookup_addrs.deinit();

        <span class="tok-kw">var</span> canon = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(arena);
        <span class="tok-kw">defer</span> canon.deinit();

        <span class="tok-kw">try</span> <a href="std.net.html#std.net.linuxLookupName">linuxLookupName</a>(&amp;lookup_addrs, &amp;canon, name, family, .{ .NUMERICSERV = <span class="tok-null">true</span> }, port);

        result.addrs = <span class="tok-kw">try</span> arena.alloc(<a href="std.net.Address.html">Address</a>, lookup_addrs.items.len);
        <span class="tok-kw">if</span> (canon.items.len != <span class="tok-number">0</span>) {
            result.canon_name = <span class="tok-kw">try</span> canon.toOwnedSlice();
        }

        <span class="tok-kw">for</span> (lookup_addrs.items, <span class="tok-number">0</span>..) |lookup_addr, i| {
            result.addrs[i] = lookup_addr.addr;
            <a href="std.debug.html#std.debug.assert">assert</a>(result.addrs[i].getPort() == port);
        }

        <span class="tok-kw">return</span> result;
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.net.getAddressList unimplemented for this OS&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.net.isValidHostName" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isValidHostName</span><a href="#src.zig-std.net.isValidHostName">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidHostName</span>(hostname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>hostname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.net.isValidHostName">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidHostName</span>(hostname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (hostname.len &gt;= <span class="tok-number">254</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ValidateSlice">utf8ValidateSlice</a>(hostname)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">for</span> (hostname) |byte| {
        <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.isAscii">isAscii</a>(byte) <span class="tok-kw">or</span> byte == <span class="tok-str">'.'</span> <span class="tok-kw">or</span> byte == <span class="tok-str">'-'</span> <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.isAlphanumeric">isAlphanumeric</a>(byte)) {
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.net">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Cross-platform networking abstractions.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> net = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> io = <a href="std.html">std</a>.<a href="std.io.html">io</a>;
<span class="tok-kw">const</span> native_endian = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>();
<span class="tok-kw">const</span> native_os = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;<span class="tok-comment">

// Windows 10 added support for unix sockets in build 17063, redstone 4 is the
// first release to support them.
</span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> has_unix_sockets = <span class="tok-kw">switch</span> (<a href="std.net.html#std.net.native_os">native_os</a>) {
    .windows =&gt; <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">version_range</a>.<a href="#">windows</a>.<a href="#">isAtLeast</a>(.win10_rs4) <span class="tok-kw">orelse</span> <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPParseError = <span class="tok-kw">error</span>{
    Overflow,
    InvalidEnd,
    InvalidCharacter,
    Incomplete,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPv4ParseError = <a href="std.net.html#std.net.IPParseError">IPParseError</a> || <span class="tok-kw">error</span>{NonCanonical};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPv6ParseError = <a href="std.net.html#std.net.IPParseError">IPParseError</a> || <span class="tok-kw">error</span>{InvalidIpv4Mapping};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPv6InterfaceError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SocketError">SocketError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IoCtl_SIOCGIFINDEX_Error">IoCtl_SIOCGIFINDEX_Error</a> || <span class="tok-kw">error</span>{NameTooLong};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IPv6ResolveError = <a href="std.net.html#std.net.IPv6ParseError">IPv6ParseError</a> || <a href="std.net.html#std.net.IPv6InterfaceError">IPv6InterfaceError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Address = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
    any: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    in: <a href="std.net.Ip4Address.html">Ip4Address</a>,
    in6: <a href="std.net.Ip6Address.html">Ip6Address</a>,
    un: <span class="tok-kw">if</span> (<a href="std.net.html#std.net.has_unix_sockets">has_unix_sockets</a>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">un</a> <span class="tok-kw">else</span> <span class="tok-type">void</span>,

    <span class="tok-comment">/// Parse the given IP address string into an Address value.</span>
    <span class="tok-comment">/// It is recommended to use `resolveIp` instead, to handle</span>
    <span class="tok-comment">/// IPv6 link-local unix addresses.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseIp</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) !<a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">if</span> (<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(name, port)) |ip4| <span class="tok-kw">return</span> ip4 <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.Overflow,
            <span class="tok-kw">error</span>.InvalidEnd,
            <span class="tok-kw">error</span>.InvalidCharacter,
            <span class="tok-kw">error</span>.Incomplete,
            <span class="tok-kw">error</span>.NonCanonical,
            =&gt; {},
        }

        <span class="tok-kw">if</span> (<a href="std.net.Address.html#std.net.Address.parseIp6">parseIp6</a>(name, port)) |ip6| <span class="tok-kw">return</span> ip6 <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.Overflow,
            <span class="tok-kw">error</span>.InvalidEnd,
            <span class="tok-kw">error</span>.InvalidCharacter,
            <span class="tok-kw">error</span>.Incomplete,
            <span class="tok-kw">error</span>.InvalidIpv4Mapping,
            =&gt; {},
        }

        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIPAddressFormat;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveIp</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) !<a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">if</span> (<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(name, port)) |ip4| <span class="tok-kw">return</span> ip4 <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.Overflow,
            <span class="tok-kw">error</span>.InvalidEnd,
            <span class="tok-kw">error</span>.InvalidCharacter,
            <span class="tok-kw">error</span>.Incomplete,
            <span class="tok-kw">error</span>.NonCanonical,
            =&gt; {},
        }

        <span class="tok-kw">if</span> (<a href="std.net.Address.html#std.net.Address.resolveIp6">resolveIp6</a>(name, port)) |ip6| <span class="tok-kw">return</span> ip6 <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.Overflow,
            <span class="tok-kw">error</span>.InvalidEnd,
            <span class="tok-kw">error</span>.InvalidCharacter,
            <span class="tok-kw">error</span>.Incomplete,
            <span class="tok-kw">error</span>.InvalidIpv4Mapping,
            =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        }

        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIPAddressFormat;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseExpectingFamily</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, family: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sa_family_t">sa_family_t</a>, port: <span class="tok-type">u16</span>) !<a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">switch</span> (family) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a> =&gt; <span class="tok-kw">return</span> <a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(name, port),
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a> =&gt; <span class="tok-kw">return</span> <a href="std.net.Address.html#std.net.Address.parseIp6">parseIp6</a>(name, port),
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNSPEC</a> =&gt; <span class="tok-kw">return</span> <a href="std.net.Address.html#std.net.Address.parseIp">parseIp</a>(name, port),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseIp6</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.IPv6ParseError">IPv6ParseError</a>!<a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">return</span> .{ .in6 = <span class="tok-kw">try</span> <a href="std.net.Ip6Address.html">Ip6Address</a>.<a href="std.net.Ip6Address.html#std.net.Ip6Address.parse">parse</a>(buf, port) };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveIp6</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.IPv6ResolveError">IPv6ResolveError</a>!<a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">return</span> .{ .in6 = <span class="tok-kw">try</span> <a href="std.net.Ip6Address.html">Ip6Address</a>.<a href="std.net.Ip6Address.html#std.net.Ip6Address.resolve">resolve</a>(buf, port) };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseIp4</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.IPv4ParseError">IPv4ParseError</a>!<a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">return</span> .{ .in = <span class="tok-kw">try</span> <a href="std.net.Ip4Address.html">Ip4Address</a>.<a href="std.net.Ip4Address.html#std.net.Ip4Address.parse">parse</a>(buf, port) };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initIp4</span>(addr: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">return</span> .{ .in = <a href="std.net.Ip4Address.html">Ip4Address</a>.<a href="std.net.Ip4Address.html#std.net.Ip4Address.init">init</a>(addr, port) };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initIp6</span>(addr: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>, flowinfo: <span class="tok-type">u32</span>, scope_id: <span class="tok-type">u32</span>) <a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">return</span> .{ .in6 = <a href="std.net.Ip6Address.html">Ip6Address</a>.<a href="std.net.Ip6Address.html#std.net.Ip6Address.init">init</a>(addr, port, flowinfo, scope_id) };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initUnix</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">var</span> sock_addr = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">un</a>{
            .family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNIX</a>,
            .path = <span class="tok-null">undefined</span>,
        };<span class="tok-comment">

        // Add 1 to ensure a terminating 0 is present in the path array for maximum portability.
        </span><span class="tok-kw">if</span> (path.len + <span class="tok-number">1</span> &gt; sock_addr.path.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-builtin">@memset</span>(&amp;sock_addr.path, <span class="tok-number">0</span>);
        <span class="tok-builtin">@memcpy</span>(sock_addr.path[<span class="tok-number">0</span>..path.len], path);

        <span class="tok-kw">return</span> .{ .un = sock_addr };
    }

    <span class="tok-comment">/// Returns the port in native endian.</span>
    <span class="tok-comment">/// Asserts that the address is ip4 or ip6.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPort</span>(self: <a href="std.net.Address.html">Address</a>) <span class="tok-type">u16</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.any.family) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a> =&gt; self.in.getPort(),
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a> =&gt; self.in6.getPort(),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-comment">/// `port` is native-endian.</span>
    <span class="tok-comment">/// Asserts that the address is ip4 or ip6.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPort</span>(self: *<a href="std.net.Address.html">Address</a>, port: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (self.any.family) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a> =&gt; self.in.setPort(port),
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a> =&gt; self.in6.setPort(port),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-comment">/// Asserts that `addr` is an IP address.</span>
    <span class="tok-comment">/// This function will read past the end of the pointer, with a size depending</span>
    <span class="tok-comment">/// on the address family.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initPosix</span>(addr: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>) <a href="std.net.Address.html">Address</a> {
        <span class="tok-kw">switch</span> (addr.family) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a> =&gt; <span class="tok-kw">return</span> <a href="std.net.Address.html">Address</a>{ .in = <a href="std.net.Ip4Address.html">Ip4Address</a>{ .sa = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>, <span class="tok-builtin">@ptrCast</span>(addr)).* } },
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a> =&gt; <span class="tok-kw">return</span> <a href="std.net.Address.html">Address</a>{ .in6 = <a href="std.net.Ip6Address.html">Ip6Address</a>{ .sa = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>, <span class="tok-builtin">@ptrCast</span>(addr)).* } },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.net.Address.html">Address</a>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        out_stream: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.invalidFmtError">invalidFmtError</a>(fmt, self);
        <span class="tok-kw">switch</span> (self.any.family) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a> =&gt; <span class="tok-kw">try</span> self.in.format(fmt, options, out_stream),
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a> =&gt; <span class="tok-kw">try</span> self.in6.format(fmt, options, out_stream),
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNIX</a> =&gt; {
                <span class="tok-kw">if</span> (!<a href="std.net.html#std.net.has_unix_sockets">has_unix_sockets</a>) {
                    <span class="tok-kw">unreachable</span>;
                }

                <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.format">format</a>(out_stream, <span class="tok-str">&quot;{s}&quot;</span>, .{<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;self.un.path, <span class="tok-number">0</span>)});
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <a href="std.net.Address.html">Address</a>, b: <a href="std.net.Address.html">Address</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> a_bytes = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;a.any))[<span class="tok-number">0</span>..a.getOsSockLen()];
        <span class="tok-kw">const</span> b_bytes = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;b.any))[<span class="tok-number">0</span>..b.getOsSockLen()];
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a_bytes, b_bytes);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOsSockLen</span>(self: <a href="std.net.Address.html">Address</a>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> {
        <span class="tok-kw">switch</span> (self.any.family) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a> =&gt; <span class="tok-kw">return</span> self.in.getOsSockLen(),
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a> =&gt; <span class="tok-kw">return</span> self.in6.getOsSockLen(),
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNIX</a> =&gt; {
                <span class="tok-kw">if</span> (!<a href="std.net.html#std.net.has_unix_sockets">has_unix_sockets</a>) {
                    <span class="tok-kw">unreachable</span>;
                }<span class="tok-comment">

                // Using the full length of the structure here is more portable than returning
                // the number of bytes actually used by the currently stored path.
                // This also is correct regardless if we are passing a socket address to the kernel
                // (e.g. in bind, connect, sendto) since we ensure the path is 0 terminated in
                // initUnix() or if we are receiving a socket address from the kernel and must
                // provide the full buffer size (e.g. getsockname, getpeername, recvfrom, accept).
                //
                // To access the path, std.mem.sliceTo(&amp;address.un.path, 0) should be used.
                </span><span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">un</a>)));
            },

            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ListenError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SocketError">SocketError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.BindError">BindError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ListenError">ListenError</a> ||
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.GetSockNameError">GetSockNameError</a>;

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ListenOptions = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// How many connections the kernel will accept on the application's behalf.</span>
        <span class="tok-comment">/// If more than this many connections pool in the kernel, clients will start</span>
        <span class="tok-comment">/// seeing &quot;Connection refused&quot;.</span>
        kernel_backlog: <span class="tok-type">u31</span> = <span class="tok-number">128</span>,
        <span class="tok-comment">/// Sets SO_REUSEADDR and SO_REUSEPORT on POSIX.</span>
        <span class="tok-comment">/// Sets SO_REUSEADDR on Windows, which is roughly equivalent.</span>
        reuse_address: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        <span class="tok-comment">/// Deprecated. Does the same thing as reuse_address.</span>
        reuse_port: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        force_nonblocking: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    };

    <span class="tok-comment">/// The returned `Server` has an open `stream`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">listen</span>(address: <a href="std.net.Address.html">Address</a>, options: <a href="std.net.Address.ListenOptions.html">ListenOptions</a>) <a href="std.net.Address.html#std.net.Address.ListenError">ListenError</a>!<a href="std.net.Server.html">Server</a> {
        <span class="tok-kw">const</span> nonblock: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (options.force_nonblocking) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a> <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> sock_flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a> | nonblock;
        <span class="tok-kw">const</span> proto: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (address.any.family == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNIX</a>) <span class="tok-number">0</span> <span class="tok-kw">else</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IPPROTO">IPPROTO</a>.<a href="#">TCP</a>;

        <span class="tok-kw">const</span> sockfd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, sock_flags, proto);
        <span class="tok-kw">var</span> s: <a href="std.net.Server.html">Server</a> = .{
            .listen_address = <span class="tok-null">undefined</span>,
            .stream = .{ .handle = sockfd },
        };
        <span class="tok-kw">errdefer</span> s.stream.close();

        <span class="tok-kw">if</span> (options.reuse_address <span class="tok-kw">or</span> options.reuse_port) {
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setsockopt">setsockopt</a>(
                sockfd,
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">SOCKET</a>,
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SO">SO</a>.<a href="#">REUSEADDR</a>,
                &amp;<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)),
            );
            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SO">SO</a>, <span class="tok-str">&quot;REUSEPORT&quot;</span>) <span class="tok-kw">and</span> address.any.family != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNIX</a>) {
                <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setsockopt">setsockopt</a>(
                    sockfd,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">SOCKET</a>,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SO">SO</a>.<a href="#">REUSEPORT</a>,
                    &amp;<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)),
                );
            }
        }

        <span class="tok-kw">var</span> socklen = address.getOsSockLen();
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.bind">bind</a>(sockfd, &amp;address.any, socklen);
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.listen">listen</a>(sockfd, options.kernel_backlog);
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getsockname">getsockname</a>(sockfd, &amp;s.listen_address.any, &amp;socklen);
        <span class="tok-kw">return</span> s;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Ip4Address = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    sa: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.IPv4ParseError">IPv4ParseError</a>!<a href="std.net.Ip4Address.html">Ip4Address</a> {
        <span class="tok-kw">var</span> result: <a href="std.net.Ip4Address.html">Ip4Address</a> = .{
            .sa = .{
                .port = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(<span class="tok-type">u16</span>, port),
                .addr = <span class="tok-null">undefined</span>,
            },
        };
        <span class="tok-kw">const</span> out_ptr = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;result.sa.addr);

        <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> index: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> saw_any_digits = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> has_zero_prefix = <span class="tok-null">false</span>;
        <span class="tok-kw">for</span> (buf) |c| {
            <span class="tok-kw">if</span> (c == <span class="tok-str">'.'</span>) {
                <span class="tok-kw">if</span> (!saw_any_digits) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;
                }
                <span class="tok-kw">if</span> (index == <span class="tok-number">3</span>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnd;
                }
                out_ptr[index] = x;
                index += <span class="tok-number">1</span>;
                x = <span class="tok-number">0</span>;
                saw_any_digits = <span class="tok-null">false</span>;
                has_zero_prefix = <span class="tok-null">false</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (c &gt;= <span class="tok-str">'0'</span> <span class="tok-kw">and</span> c &lt;= <span class="tok-str">'9'</span>) {
                <span class="tok-kw">if</span> (c == <span class="tok-str">'0'</span> <span class="tok-kw">and</span> !saw_any_digits) {
                    has_zero_prefix = <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (has_zero_prefix) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonCanonical;
                }
                saw_any_digits = <span class="tok-null">true</span>;
                x = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">u8</span>, x, <span class="tok-number">10</span>);
                x = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">u8</span>, x, c - <span class="tok-str">'0'</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;
            }
        }
        <span class="tok-kw">if</span> (index == <span class="tok-number">3</span> <span class="tok-kw">and</span> saw_any_digits) {
            out_ptr[index] = x;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Incomplete;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveIp</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) !<a href="std.net.Ip4Address.html">Ip4Address</a> {
        <span class="tok-kw">if</span> (<a href="std.net.Ip4Address.html#std.net.Ip4Address.parse">parse</a>(name, port)) |ip4| <span class="tok-kw">return</span> ip4 <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.Overflow,
            <span class="tok-kw">error</span>.InvalidEnd,
            <span class="tok-kw">error</span>.InvalidCharacter,
            <span class="tok-kw">error</span>.Incomplete,
            <span class="tok-kw">error</span>.NonCanonical,
            =&gt; {},
        }
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIPAddressFormat;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(addr: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.Ip4Address.html">Ip4Address</a> {
        <span class="tok-kw">return</span> <a href="std.net.Ip4Address.html">Ip4Address</a>{
            .sa = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>{
                .port = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(<span class="tok-type">u16</span>, port),
                .addr = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(&amp;addr)).*,
            },
        };
    }

    <span class="tok-comment">/// Returns the port in native endian.</span>
    <span class="tok-comment">/// Asserts that the address is ip4 or ip6.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPort</span>(self: <a href="std.net.Ip4Address.html">Ip4Address</a>) <span class="tok-type">u16</span> {
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, self.sa.port);
    }

    <span class="tok-comment">/// `port` is native-endian.</span>
    <span class="tok-comment">/// Asserts that the address is ip4 or ip6.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPort</span>(self: *<a href="std.net.Ip4Address.html">Ip4Address</a>, port: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
        self.sa.port = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(<span class="tok-type">u16</span>, port);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.net.Ip4Address.html">Ip4Address</a>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        out_stream: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.invalidFmtError">invalidFmtError</a>(fmt, self);
        _ = options;
        <span class="tok-kw">const</span> bytes = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [<span class="tok-number">4</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;self.sa.addr));
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.format">format</a>(out_stream, <span class="tok-str">&quot;{}.{}.{}.{}:{}&quot;</span>, .{
            bytes[<span class="tok-number">0</span>],
            bytes[<span class="tok-number">1</span>],
            bytes[<span class="tok-number">2</span>],
            bytes[<span class="tok-number">3</span>],
            self.getPort(),
        });
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOsSockLen</span>(self: <a href="std.net.Ip4Address.html">Ip4Address</a>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> {
        _ = self;
        <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Ip6Address = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    sa: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>,

    <span class="tok-comment">/// Parse a given IPv6 address string into an Address.</span>
    <span class="tok-comment">/// Assumes the Scope ID of the address is fully numeric.</span>
    <span class="tok-comment">/// For non-numeric addresses, see `resolveIp6`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.IPv6ParseError">IPv6ParseError</a>!<a href="std.net.Ip6Address.html">Ip6Address</a> {
        <span class="tok-kw">var</span> result = <a href="std.net.Ip6Address.html">Ip6Address</a>{
            .sa = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>{
                .scope_id = <span class="tok-number">0</span>,
                .port = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(<span class="tok-type">u16</span>, port),
                .flowinfo = <span class="tok-number">0</span>,
                .addr = <span class="tok-null">undefined</span>,
            },
        };
        <span class="tok-kw">var</span> ip_slice: *[<span class="tok-number">16</span>]<span class="tok-type">u8</span> = result.sa.addr[<span class="tok-number">0</span>..];

        <span class="tok-kw">var</span> tail: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">var</span> x: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> saw_any_digits = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> index: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> scope_id = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> abbrv = <span class="tok-null">false</span>;
        <span class="tok-kw">for</span> (buf, <span class="tok-number">0</span>..) |c, i| {
            <span class="tok-kw">if</span> (scope_id) {
                <span class="tok-kw">if</span> (c &gt;= <span class="tok-str">'0'</span> <span class="tok-kw">and</span> c &lt;= <span class="tok-str">'9'</span>) {
                    <span class="tok-kw">const</span> digit = c - <span class="tok-str">'0'</span>;
                    {
                        <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(result.sa.scope_id, <span class="tok-number">10</span>);
                        <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                        result.sa.scope_id = ov[<span class="tok-number">0</span>];
                    }
                    {
                        <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(result.sa.scope_id, digit);
                        <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                        result.sa.scope_id = ov[<span class="tok-number">0</span>];
                    }
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;
                }
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (c == <span class="tok-str">':'</span>) {
                <span class="tok-kw">if</span> (!saw_any_digits) {
                    <span class="tok-kw">if</span> (abbrv) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;<span class="tok-comment"> // ':::'
                    </span><span class="tok-kw">if</span> (i != <span class="tok-number">0</span>) abbrv = <span class="tok-null">true</span>;
                    <span class="tok-builtin">@memset</span>(ip_slice[index..], <span class="tok-number">0</span>);
                    ip_slice = tail[<span class="tok-number">0</span>..];
                    index = <span class="tok-number">0</span>;
                    <span class="tok-kw">continue</span>;
                }
                <span class="tok-kw">if</span> (index == <span class="tok-number">14</span>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnd;
                }
                ip_slice[index] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-number">8</span>));
                index += <span class="tok-number">1</span>;
                ip_slice[index] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x));
                index += <span class="tok-number">1</span>;

                x = <span class="tok-number">0</span>;
                saw_any_digits = <span class="tok-null">false</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (c == <span class="tok-str">'%'</span>) {
                <span class="tok-kw">if</span> (!saw_any_digits) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;
                }
                scope_id = <span class="tok-null">true</span>;
                saw_any_digits = <span class="tok-null">false</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (c == <span class="tok-str">'.'</span>) {
                <span class="tok-kw">if</span> (!abbrv <span class="tok-kw">or</span> ip_slice[<span class="tok-number">0</span>] != <span class="tok-number">0xff</span> <span class="tok-kw">or</span> ip_slice[<span class="tok-number">1</span>] != <span class="tok-number">0xff</span>) {<span class="tok-comment">
                    // must start with '::ffff:'
                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIpv4Mapping;
                }
                <span class="tok-kw">const</span> start_index = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(<span class="tok-type">u8</span>, buf[<span class="tok-number">0</span>..i], <span class="tok-str">':'</span>).? + <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> addr = (<a href="std.net.Ip4Address.html">Ip4Address</a>.<a href="std.net.Ip4Address.html#std.net.Ip4Address.parse">parse</a>(buf[start_index..], <span class="tok-number">0</span>) <span class="tok-kw">catch</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIpv4Mapping;
                }).sa.addr;
                ip_slice = result.sa.addr[<span class="tok-number">0</span>..];
                ip_slice[<span class="tok-number">10</span>] = <span class="tok-number">0xff</span>;
                ip_slice[<span class="tok-number">11</span>] = <span class="tok-number">0xff</span>;

                <span class="tok-kw">const</span> ptr = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [<span class="tok-number">1</span>]<span class="tok-type">u32</span>, &amp;addr)[<span class="tok-number">0</span>..]);

                ip_slice[<span class="tok-number">12</span>] = ptr[<span class="tok-number">0</span>];
                ip_slice[<span class="tok-number">13</span>] = ptr[<span class="tok-number">1</span>];
                ip_slice[<span class="tok-number">14</span>] = ptr[<span class="tok-number">2</span>];
                ip_slice[<span class="tok-number">15</span>] = ptr[<span class="tok-number">3</span>];
                <span class="tok-kw">return</span> result;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> digit = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.charToDigit">charToDigit</a>(c, <span class="tok-number">16</span>);
                {
                    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(x, <span class="tok-number">16</span>);
                    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    x = ov[<span class="tok-number">0</span>];
                }
                {
                    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(x, digit);
                    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    x = ov[<span class="tok-number">0</span>];
                }
                saw_any_digits = <span class="tok-null">true</span>;
            }
        }

        <span class="tok-kw">if</span> (!saw_any_digits <span class="tok-kw">and</span> !abbrv) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Incomplete;
        }
        <span class="tok-kw">if</span> (!abbrv <span class="tok-kw">and</span> index &lt; <span class="tok-number">14</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Incomplete;
        }

        <span class="tok-kw">if</span> (index == <span class="tok-number">14</span>) {
            ip_slice[<span class="tok-number">14</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-number">8</span>));
            ip_slice[<span class="tok-number">15</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x));
            <span class="tok-kw">return</span> result;
        } <span class="tok-kw">else</span> {
            ip_slice[index] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-number">8</span>));
            index += <span class="tok-number">1</span>;
            ip_slice[index] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x));
            index += <span class="tok-number">1</span>;
            <span class="tok-builtin">@memcpy</span>(result.sa.addr[<span class="tok-number">16</span> - index ..][<span class="tok-number">0</span>..index], ip_slice[<span class="tok-number">0</span>..index]);
            <span class="tok-kw">return</span> result;
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolve</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.IPv6ResolveError">IPv6ResolveError</a>!<a href="std.net.Ip6Address.html">Ip6Address</a> {<span class="tok-comment">
        // TODO: Unify the implementations of resolveIp6 and parseIp6.
        </span><span class="tok-kw">var</span> result = <a href="std.net.Ip6Address.html">Ip6Address</a>{
            .sa = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>{
                .scope_id = <span class="tok-number">0</span>,
                .port = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(<span class="tok-type">u16</span>, port),
                .flowinfo = <span class="tok-number">0</span>,
                .addr = <span class="tok-null">undefined</span>,
            },
        };
        <span class="tok-kw">var</span> ip_slice: *[<span class="tok-number">16</span>]<span class="tok-type">u8</span> = result.sa.addr[<span class="tok-number">0</span>..];

        <span class="tok-kw">var</span> tail: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">var</span> x: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> saw_any_digits = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> index: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> abbrv = <span class="tok-null">false</span>;

        <span class="tok-kw">var</span> scope_id = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> scope_id_value: [<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IFNAMESIZE">IFNAMESIZE</a> - <span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> scope_id_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

        <span class="tok-kw">for</span> (buf, <span class="tok-number">0</span>..) |c, i| {
            <span class="tok-kw">if</span> (scope_id) {<span class="tok-comment">
                // Handling of percent-encoding should be for an URI library.
                </span><span class="tok-kw">if</span> ((c &gt;= <span class="tok-str">'0'</span> <span class="tok-kw">and</span> c &lt;= <span class="tok-str">'9'</span>) <span class="tok-kw">or</span>
                    (c &gt;= <span class="tok-str">'A'</span> <span class="tok-kw">and</span> c &lt;= <span class="tok-str">'Z'</span>) <span class="tok-kw">or</span>
                    (c &gt;= <span class="tok-str">'a'</span> <span class="tok-kw">and</span> c &lt;= <span class="tok-str">'z'</span>) <span class="tok-kw">or</span>
                    (c == <span class="tok-str">'-'</span>) <span class="tok-kw">or</span> (c == <span class="tok-str">'.'</span>) <span class="tok-kw">or</span> (c == <span class="tok-str">'_'</span>) <span class="tok-kw">or</span> (c == <span class="tok-str">'~'</span>))
                {
                    <span class="tok-kw">if</span> (scope_id_index &gt;= scope_id_value.len) {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    }

                    scope_id_value[scope_id_index] = c;
                    scope_id_index += <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;
                }
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (c == <span class="tok-str">':'</span>) {
                <span class="tok-kw">if</span> (!saw_any_digits) {
                    <span class="tok-kw">if</span> (abbrv) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;<span class="tok-comment"> // ':::'
                    </span><span class="tok-kw">if</span> (i != <span class="tok-number">0</span>) abbrv = <span class="tok-null">true</span>;
                    <span class="tok-builtin">@memset</span>(ip_slice[index..], <span class="tok-number">0</span>);
                    ip_slice = tail[<span class="tok-number">0</span>..];
                    index = <span class="tok-number">0</span>;
                    <span class="tok-kw">continue</span>;
                }
                <span class="tok-kw">if</span> (index == <span class="tok-number">14</span>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEnd;
                }
                ip_slice[index] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-number">8</span>));
                index += <span class="tok-number">1</span>;
                ip_slice[index] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x));
                index += <span class="tok-number">1</span>;

                x = <span class="tok-number">0</span>;
                saw_any_digits = <span class="tok-null">false</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (c == <span class="tok-str">'%'</span>) {
                <span class="tok-kw">if</span> (!saw_any_digits) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;
                }
                scope_id = <span class="tok-null">true</span>;
                saw_any_digits = <span class="tok-null">false</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (c == <span class="tok-str">'.'</span>) {
                <span class="tok-kw">if</span> (!abbrv <span class="tok-kw">or</span> ip_slice[<span class="tok-number">0</span>] != <span class="tok-number">0xff</span> <span class="tok-kw">or</span> ip_slice[<span class="tok-number">1</span>] != <span class="tok-number">0xff</span>) {<span class="tok-comment">
                    // must start with '::ffff:'
                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIpv4Mapping;
                }
                <span class="tok-kw">const</span> start_index = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(<span class="tok-type">u8</span>, buf[<span class="tok-number">0</span>..i], <span class="tok-str">':'</span>).? + <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> addr = (<a href="std.net.Ip4Address.html">Ip4Address</a>.<a href="std.net.Ip4Address.html#std.net.Ip4Address.parse">parse</a>(buf[start_index..], <span class="tok-number">0</span>) <span class="tok-kw">catch</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIpv4Mapping;
                }).sa.addr;
                ip_slice = result.sa.addr[<span class="tok-number">0</span>..];
                ip_slice[<span class="tok-number">10</span>] = <span class="tok-number">0xff</span>;
                ip_slice[<span class="tok-number">11</span>] = <span class="tok-number">0xff</span>;

                <span class="tok-kw">const</span> ptr = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> [<span class="tok-number">1</span>]<span class="tok-type">u32</span>, &amp;addr)[<span class="tok-number">0</span>..]);

                ip_slice[<span class="tok-number">12</span>] = ptr[<span class="tok-number">0</span>];
                ip_slice[<span class="tok-number">13</span>] = ptr[<span class="tok-number">1</span>];
                ip_slice[<span class="tok-number">14</span>] = ptr[<span class="tok-number">2</span>];
                ip_slice[<span class="tok-number">15</span>] = ptr[<span class="tok-number">3</span>];
                <span class="tok-kw">return</span> result;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> digit = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.charToDigit">charToDigit</a>(c, <span class="tok-number">16</span>);
                {
                    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(x, <span class="tok-number">16</span>);
                    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    x = ov[<span class="tok-number">0</span>];
                }
                {
                    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(x, digit);
                    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                    x = ov[<span class="tok-number">0</span>];
                }
                saw_any_digits = <span class="tok-null">true</span>;
            }
        }

        <span class="tok-kw">if</span> (!saw_any_digits <span class="tok-kw">and</span> !abbrv) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Incomplete;
        }

        <span class="tok-kw">if</span> (scope_id <span class="tok-kw">and</span> scope_id_index == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Incomplete;
        }

        <span class="tok-kw">var</span> resolved_scope_id: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (scope_id_index &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> scope_id_str = scope_id_value[<span class="tok-number">0</span>..scope_id_index];
            resolved_scope_id = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u32</span>, scope_id_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| blk: {
                <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.InvalidCharacter) <span class="tok-kw">return</span> err;
                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> <a href="std.net.html#std.net.if_nametoindex">if_nametoindex</a>(scope_id_str);
            };
        }

        result.sa.scope_id = resolved_scope_id;

        <span class="tok-kw">if</span> (index == <span class="tok-number">14</span>) {
            ip_slice[<span class="tok-number">14</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-number">8</span>));
            ip_slice[<span class="tok-number">15</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x));
            <span class="tok-kw">return</span> result;
        } <span class="tok-kw">else</span> {
            ip_slice[index] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-number">8</span>));
            index += <span class="tok-number">1</span>;
            ip_slice[index] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(x));
            index += <span class="tok-number">1</span>;
            <span class="tok-builtin">@memcpy</span>(result.sa.addr[<span class="tok-number">16</span> - index ..][<span class="tok-number">0</span>..index], ip_slice[<span class="tok-number">0</span>..index]);
            <span class="tok-kw">return</span> result;
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(addr: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>, flowinfo: <span class="tok-type">u32</span>, scope_id: <span class="tok-type">u32</span>) <a href="std.net.Ip6Address.html">Ip6Address</a> {
        <span class="tok-kw">return</span> <a href="std.net.Ip6Address.html">Ip6Address</a>{
            .sa = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>{
                .addr = addr,
                .port = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(<span class="tok-type">u16</span>, port),
                .flowinfo = flowinfo,
                .scope_id = scope_id,
            },
        };
    }

    <span class="tok-comment">/// Returns the port in native endian.</span>
    <span class="tok-comment">/// Asserts that the address is ip4 or ip6.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPort</span>(self: <a href="std.net.Ip6Address.html">Ip6Address</a>) <span class="tok-type">u16</span> {
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, self.sa.port);
    }

    <span class="tok-comment">/// `port` is native-endian.</span>
    <span class="tok-comment">/// Asserts that the address is ip4 or ip6.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPort</span>(self: *<a href="std.net.Ip6Address.html">Ip6Address</a>, port: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
        self.sa.port = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(<span class="tok-type">u16</span>, port);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.net.Ip6Address.html">Ip6Address</a>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        out_stream: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.invalidFmtError">invalidFmtError</a>(fmt, self);
        _ = options;
        <span class="tok-kw">const</span> port = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, self.sa.port);
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, self.sa.addr[<span class="tok-number">0</span>..<span class="tok-number">12</span>], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0xff</span>, <span class="tok-number">0xff</span> })) {
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.format">format</a>(out_stream, <span class="tok-str">&quot;[::ffff:{}.{}.{}.{}]:{}&quot;</span>, .{
                self.sa.addr[<span class="tok-number">12</span>],
                self.sa.addr[<span class="tok-number">13</span>],
                self.sa.addr[<span class="tok-number">14</span>],
                self.sa.addr[<span class="tok-number">15</span>],
                port,
            });
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> big_endian_parts = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> [<span class="tok-number">8</span>]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;self.sa.addr));
        <span class="tok-kw">const</span> native_endian_parts = <span class="tok-kw">switch</span> (<a href="std.net.html#std.net.native_endian">native_endian</a>) {
            .big =&gt; big_endian_parts.*,
            .little =&gt; blk: {
                <span class="tok-kw">var</span> buf: [<span class="tok-number">8</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">for</span> (big_endian_parts, <span class="tok-number">0</span>..) |part, i| {
                    buf[i] = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, part);
                }
                <span class="tok-kw">break</span> :blk buf;
            },
        };<span class="tok-comment">

        // Find the longest zero run
        </span><span class="tok-kw">var</span> longest_start: <span class="tok-type">usize</span> = <span class="tok-number">8</span>;
        <span class="tok-kw">var</span> longest_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> current_start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> current_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

        <span class="tok-kw">for</span> (native_endian_parts, <span class="tok-number">0</span>..) |part, i| {
            <span class="tok-kw">if</span> (part == <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (current_len == <span class="tok-number">0</span>) {
                    current_start = i;
                }
                current_len += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (current_len &gt; longest_len) {
                    longest_start = current_start;
                    longest_len = current_len;
                }
            } <span class="tok-kw">else</span> {
                current_len = <span class="tok-number">0</span>;
            }
        }<span class="tok-comment">

        // Only compress if the longest zero run is 2 or more
        </span><span class="tok-kw">if</span> (longest_len &lt; <span class="tok-number">2</span>) {
            longest_start = <span class="tok-number">8</span>;
            longest_len = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;[&quot;</span>);
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> abbrv = <span class="tok-null">false</span>;
        <span class="tok-kw">while</span> (i &lt; native_endian_parts.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (i == longest_start) {<span class="tok-comment">
                // Emit &quot;::&quot; for the longest zero run
                </span><span class="tok-kw">if</span> (!abbrv) {
                    <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-str">&quot;::&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;:&quot;</span>);
                    abbrv = <span class="tok-null">true</span>;
                }
                i += longest_len - <span class="tok-number">1</span>;<span class="tok-comment"> // Skip the compressed range
                </span><span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">if</span> (abbrv) {
                abbrv = <span class="tok-null">false</span>;
            }
            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.format">format</a>(out_stream, <span class="tok-str">&quot;{x}&quot;</span>, .{native_endian_parts[i]});
            <span class="tok-kw">if</span> (i != native_endian_parts.len - <span class="tok-number">1</span>) {
                <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;:&quot;</span>);
            }
        }
        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.format">format</a>(out_stream, <span class="tok-str">&quot;]:{}&quot;</span>, .{port});
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOsSockLen</span>(self: <a href="std.net.Ip6Address.html">Ip6Address</a>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> {
        _ = self;
        <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connectUnixSocket</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.net.Stream.html">Stream</a> {
    <span class="tok-kw">const</span> opt_non_block = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> sockfd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNIX</a>,
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a> | opt_non_block,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">errdefer</span> <a href="std.net.Stream.html">Stream</a>.<a href="std.net.Stream.html#std.net.Stream.close">close</a>(.{ .handle = sockfd });

    <span class="tok-kw">var</span> addr = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initUnix">initUnix</a>(path);
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(sockfd, &amp;addr.any, addr.getOsSockLen());

    <span class="tok-kw">return</span> .{ .handle = sockfd };
}

<span class="tok-kw">fn</span> <span class="tok-fn">if_nametoindex</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.net.html#std.net.IPv6InterfaceError">IPv6InterfaceError</a>!<span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .linux) {
        <span class="tok-kw">var</span> ifr: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ifreq">ifreq</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> sockfd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNIX</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">DGRAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">defer</span> <a href="std.net.Stream.html">Stream</a>.<a href="std.net.Stream.html#std.net.Stream.close">close</a>(.{ .handle = sockfd });

        <span class="tok-builtin">@memcpy</span>(ifr.ifrn.name[<span class="tok-number">0</span>..name.len], name);
        ifr.ifrn.name[name.len] = <span class="tok-number">0</span>;<span class="tok-comment">

        // TODO investigate if this needs to be integrated with evented I/O.
        </span><span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ioctl_SIOCGIFINDEX">ioctl_SIOCGIFINDEX</a>(sockfd, &amp;ifr);

        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(ifr.ifru.ivalue);
    }

    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a>.<a href="#">isDarwin</a>()) {
        <span class="tok-kw">if</span> (name.len &gt;= <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IFNAMESIZE">IFNAMESIZE</a>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-kw">var</span> if_name: [<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IFNAMESIZE">IFNAMESIZE</a>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-builtin">@memcpy</span>(if_name[<span class="tok-number">0</span>..name.len], name);
        if_name[name.len] = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> if_slice = if_name[<span class="tok-number">0</span>..name.len :<span class="tok-number">0</span>];
        <span class="tok-kw">const</span> index = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.if_nametoindex">if_nametoindex</a>(if_slice);
        <span class="tok-kw">if</span> (index == <span class="tok-number">0</span>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InterfaceNotFound;
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(index));
    }

    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (name.len &gt;= <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IFNAMESIZE">IFNAMESIZE</a>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-kw">var</span> interface_name: [<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IFNAMESIZE">IFNAMESIZE</a>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-builtin">@memcpy</span>(interface_name[<span class="tok-number">0</span>..name.len], name);
        interface_name[name.len] = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> index = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.html#std.os.windows.ws2_32.if_nametoindex">if_nametoindex</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;interface_name));
        <span class="tok-kw">if</span> (index == <span class="tok-number">0</span>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InterfaceNotFound;
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.net.if_nametoindex unimplemented for this OS&quot;</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddressList = <span class="tok-kw">struct</span> {
    arena: <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>,
    addrs: []<a href="std.net.Address.html">Address</a>,
    canon_name: ?[]<span class="tok-type">u8</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.net.AddressList.html">AddressList</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Here we copy the arena allocator into stack memory, because
        // otherwise it would destroy itself while it was still working.
        </span><span class="tok-kw">var</span> arena = self.arena;
        arena.deinit();<span class="tok-comment">
        // self is destroyed
    </span>}
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TcpConnectToHostError = <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a> || <a href="std.net.html#std.net.TcpConnectToAddressError">TcpConnectToAddressError</a>;

<span class="tok-comment">/// All memory allocated with `allocator` will be freed before this function returns.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcpConnectToHost</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.TcpConnectToHostError">TcpConnectToHostError</a>!<a href="std.net.Stream.html">Stream</a> {
    <span class="tok-kw">const</span> list = <span class="tok-kw">try</span> <a href="std.net.html#std.net.getAddressList">getAddressList</a>(allocator, name, port);
    <span class="tok-kw">defer</span> list.deinit();

    <span class="tok-kw">if</span> (list.addrs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName;

    <span class="tok-kw">for</span> (list.addrs) |addr| {
        <span class="tok-kw">return</span> <a href="std.net.html#std.net.tcpConnectToAddress">tcpConnectToAddress</a>(addr) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.ConnectionRefused =&gt; {
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        };
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ConnectError">ConnectError</a>.<a href="#">ConnectionRefused</a>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TcpConnectToAddressError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SocketError">SocketError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ConnectError">ConnectError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tcpConnectToAddress</span>(address: <a href="std.net.Address.html">Address</a>) <a href="std.net.html#std.net.TcpConnectToAddressError">TcpConnectToAddressError</a>!<a href="std.net.Stream.html">Stream</a> {
    <span class="tok-kw">const</span> nonblock = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> sock_flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | nonblock |
        (<span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .windows) <span class="tok-number">0</span> <span class="tok-kw">else</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>);
    <span class="tok-kw">const</span> sockfd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, sock_flags, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IPPROTO">IPPROTO</a>.<a href="#">TCP</a>);
    <span class="tok-kw">errdefer</span> <a href="std.net.Stream.html">Stream</a>.<a href="std.net.Stream.html#std.net.Stream.close">close</a>(.{ .handle = sockfd });

    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(sockfd, &amp;address.any, address.getOsSockLen());

    <span class="tok-kw">return</span> <a href="std.net.Stream.html">Stream</a>{ .handle = sockfd };
}

<span class="tok-kw">const</span> GetAddressListError = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a> || <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SocketError">SocketError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.BindError">BindError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SetSockOptError">SetSockOptError</a> || <span class="tok-kw">error</span>{<span class="tok-comment">
    // TODO: break this up into error sets from the various underlying functions

    </span>TemporaryNameServerFailure,
    NameServerFailure,
    AddressFamilyNotSupported,
    UnknownHostName,
    ServiceUnavailable,
    Unexpected,

    HostLacksNetworkAddresses,

    InvalidCharacter,
    InvalidEnd,
    NonCanonical,
    Overflow,
    Incomplete,
    InvalidIpv4Mapping,
    InvalidIPAddressFormat,

    InterfaceNotFound,
    FileSystem,
};

<span class="tok-comment">/// Call `AddressList.deinit` on the result.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAddressList</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, port: <span class="tok-type">u16</span>) <a href="std.net.html#std.net.GetAddressListError">GetAddressListError</a>!*<a href="std.net.AddressList.html">AddressList</a> {
    <span class="tok-kw">const</span> result = blk: {
        <span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(allocator);
        <span class="tok-kw">errdefer</span> arena.deinit();

        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> arena.allocator().create(<a href="std.net.AddressList.html">AddressList</a>);
        result.* = <a href="std.net.AddressList.html">AddressList</a>{
            .arena = arena,
            .addrs = <span class="tok-null">undefined</span>,
            .canon_name = <span class="tok-null">null</span>,
        };
        <span class="tok-kw">break</span> :blk result;
    };
    <span class="tok-kw">const</span> arena = result.arena.allocator();
    <span class="tok-kw">errdefer</span> result.deinit();

    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> name_c = <span class="tok-kw">try</span> allocator.dupeZ(<span class="tok-type">u8</span>, name);
        <span class="tok-kw">defer</span> allocator.free(name_c);

        <span class="tok-kw">const</span> port_c = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(allocator, <span class="tok-str">&quot;{}&quot;</span>, .{port});
        <span class="tok-kw">defer</span> allocator.free(port_c);

        <span class="tok-kw">const</span> ws2_32 = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>;
        <span class="tok-kw">const</span> hints: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.addrinfo">addrinfo</a> = .{
            .flags = .{ .NUMERICSERV = <span class="tok-null">true</span> },
            .family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNSPEC</a>,
            .socktype = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a>,
            .protocol = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IPPROTO">IPPROTO</a>.<a href="#">TCP</a>,
            .canonname = <span class="tok-null">null</span>,
            .addr = <span class="tok-null">null</span>,
            .addrlen = <span class="tok-number">0</span>,
            .next = <span class="tok-null">null</span>,
        };
        <span class="tok-kw">var</span> res: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.addrinfo">addrinfo</a> = <span class="tok-null">null</span>;
        <span class="tok-kw">var</span> first = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> rc = ws2_32.getaddrinfo(name_c.ptr, port_c.ptr, &amp;hints, &amp;res);
            <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.WinsockError.html">WinsockError</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(rc))))) {
                <span class="tok-builtin">@as</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ws2_32.html">ws2_32</a>.<a href="std.os.windows.ws2_32.WinsockError.html">WinsockError</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>)) =&gt; <span class="tok-kw">break</span>,
                .WSATRY_AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TemporaryNameServerFailure,
                .WSANO_RECOVERY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameServerFailure,
                .WSAEAFNOSUPPORT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
                .WSA_NOT_ENOUGH_MEMORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                .WSAHOST_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName,
                .WSATYPE_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ServiceUnavailable,
                .WSAEINVAL =&gt; <span class="tok-kw">unreachable</span>,
                .WSAESOCKTNOSUPPORT =&gt; <span class="tok-kw">unreachable</span>,
                .WSANOTINITIALISED =&gt; {
                    <span class="tok-kw">if</span> (!first) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
                    first = <span class="tok-null">false</span>;
                    <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.callWSAStartup">callWSAStartup</a>();
                    <span class="tok-kw">continue</span>;
                },
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedWSAError">unexpectedWSAError</a>(err),
            }
        }
        <span class="tok-kw">defer</span> ws2_32.freeaddrinfo(res);

        <span class="tok-kw">const</span> addr_count = blk: {
            <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> it = res;
            <span class="tok-kw">while</span> (it) |info| : (it = info.next) {
                <span class="tok-kw">if</span> (info.addr != <span class="tok-null">null</span>) {
                    count += <span class="tok-number">1</span>;
                }
            }
            <span class="tok-kw">break</span> :blk count;
        };
        result.addrs = <span class="tok-kw">try</span> arena.alloc(<a href="std.net.Address.html">Address</a>, addr_count);

        <span class="tok-kw">var</span> it = res;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (it) |info| : (it = info.next) {
            <span class="tok-kw">const</span> addr = info.addr <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            result.addrs[i] = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initPosix">initPosix</a>(<span class="tok-builtin">@alignCast</span>(addr));

            <span class="tok-kw">if</span> (info.canonname) |n| {
                <span class="tok-kw">if</span> (result.canon_name == <span class="tok-null">null</span>) {
                    result.canon_name = <span class="tok-kw">try</span> arena.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(n, <span class="tok-number">0</span>));
                }
            }
            i += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> name_c = <span class="tok-kw">try</span> allocator.dupeZ(<span class="tok-type">u8</span>, name);
        <span class="tok-kw">defer</span> allocator.free(name_c);

        <span class="tok-kw">const</span> port_c = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(allocator, <span class="tok-str">&quot;{}&quot;</span>, .{port});
        <span class="tok-kw">defer</span> allocator.free(port_c);

        <span class="tok-kw">const</span> hints: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.addrinfo">addrinfo</a> = .{
            .flags = .{ .NUMERICSERV = <span class="tok-null">true</span> },
            .family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNSPEC</a>,
            .socktype = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a>,
            .protocol = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IPPROTO">IPPROTO</a>.<a href="#">TCP</a>,
            .canonname = <span class="tok-null">null</span>,
            .addr = <span class="tok-null">null</span>,
            .addrlen = <span class="tok-number">0</span>,
            .next = <span class="tok-null">null</span>,
        };
        <span class="tok-kw">var</span> res: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.addrinfo">addrinfo</a> = <span class="tok-null">null</span>;
        <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getaddrinfo</a>(name_c.ptr, port_c.ptr, &amp;hints, &amp;res)) {
            <span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">EAI</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>)) =&gt; {},
            .ADDRFAMILY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HostLacksNetworkAddresses,
            .AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TemporaryNameServerFailure,
            .BADFLAGS =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid hints
            </span>.FAIL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameServerFailure,
            .FAMILY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AddressFamilyNotSupported,
            .MEMORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            .NODATA =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HostLacksNetworkAddresses,
            .NONAME =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName,
            .SERVICE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ServiceUnavailable,
            .SOCKTYPE =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Invalid socket type requested in hints
            </span>.SYSTEM =&gt; <span class="tok-kw">switch</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.errno">errno</a>(-<span class="tok-number">1</span>)) {
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(e),
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (res) |some| <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">freeaddrinfo</a>(some);

        <span class="tok-kw">const</span> addr_count = blk: {
            <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> it = res;
            <span class="tok-kw">while</span> (it) |info| : (it = info.next) {
                <span class="tok-kw">if</span> (info.addr != <span class="tok-null">null</span>) {
                    count += <span class="tok-number">1</span>;
                }
            }
            <span class="tok-kw">break</span> :blk count;
        };
        result.addrs = <span class="tok-kw">try</span> arena.alloc(<a href="std.net.Address.html">Address</a>, addr_count);

        <span class="tok-kw">var</span> it = res;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (it) |info| : (it = info.next) {
            <span class="tok-kw">const</span> addr = info.addr <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            result.addrs[i] = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initPosix">initPosix</a>(<span class="tok-builtin">@alignCast</span>(addr));

            <span class="tok-kw">if</span> (info.canonname) |n| {
                <span class="tok-kw">if</span> (result.canon_name == <span class="tok-null">null</span>) {
                    result.canon_name = <span class="tok-kw">try</span> arena.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(n, <span class="tok-number">0</span>));
                }
            }
            i += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .linux) {
        <span class="tok-kw">const</span> family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">UNSPEC</a>;
        <span class="tok-kw">var</span> lookup_addrs = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>).init(allocator);
        <span class="tok-kw">defer</span> lookup_addrs.deinit();

        <span class="tok-kw">var</span> canon = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(arena);
        <span class="tok-kw">defer</span> canon.deinit();

        <span class="tok-kw">try</span> <a href="std.net.html#std.net.linuxLookupName">linuxLookupName</a>(&amp;lookup_addrs, &amp;canon, name, family, .{ .NUMERICSERV = <span class="tok-null">true</span> }, port);

        result.addrs = <span class="tok-kw">try</span> arena.alloc(<a href="std.net.Address.html">Address</a>, lookup_addrs.items.len);
        <span class="tok-kw">if</span> (canon.items.len != <span class="tok-number">0</span>) {
            result.canon_name = <span class="tok-kw">try</span> canon.toOwnedSlice();
        }

        <span class="tok-kw">for</span> (lookup_addrs.items, <span class="tok-number">0</span>..) |lookup_addr, i| {
            result.addrs[i] = lookup_addr.addr;
            <a href="std.debug.html#std.debug.assert">assert</a>(result.addrs[i].getPort() == port);
        }

        <span class="tok-kw">return</span> result;
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.net.getAddressList unimplemented for this OS&quot;</span>);
}

<span class="tok-kw">const</span> LookupAddr = <span class="tok-kw">struct</span> {
    addr: <a href="std.net.Address.html">Address</a>,
    sortkey: <span class="tok-type">i32</span> = <span class="tok-number">0</span>,
};

<span class="tok-kw">const</span> DAS_USABLE = <span class="tok-number">0x40000000</span>;
<span class="tok-kw">const</span> DAS_MATCHINGSCOPE = <span class="tok-number">0x20000000</span>;
<span class="tok-kw">const</span> DAS_MATCHINGLABEL = <span class="tok-number">0x10000000</span>;
<span class="tok-kw">const</span> DAS_PREC_SHIFT = <span class="tok-number">20</span>;
<span class="tok-kw">const</span> DAS_SCOPE_SHIFT = <span class="tok-number">16</span>;
<span class="tok-kw">const</span> DAS_PREFIX_SHIFT = <span class="tok-number">8</span>;
<span class="tok-kw">const</span> DAS_ORDER_SHIFT = <span class="tok-number">0</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">linuxLookupName</span>(
    addrs: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>),
    canon: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    opt_name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    family: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sa_family_t">sa_family_t</a>,
    flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AI">AI</a>,
    port: <span class="tok-type">u16</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (opt_name) |name| {<span class="tok-comment">
        // reject empty name and check len so it fits into temp bufs
        </span>canon.items.len = <span class="tok-number">0</span>;
        <span class="tok-kw">try</span> canon.appendSlice(name);
        <span class="tok-kw">if</span> (<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseExpectingFamily">parseExpectingFamily</a>(name, family, port)) |addr| {
            <span class="tok-kw">try</span> addrs.append(<a href="std.net.LookupAddr.html">LookupAddr</a>{ .addr = addr });
        } <span class="tok-kw">else</span> |name_err| <span class="tok-kw">if</span> (flags.NUMERICHOST) {
            <span class="tok-kw">return</span> name_err;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.net.html#std.net.linuxLookupNameFromHosts">linuxLookupNameFromHosts</a>(addrs, canon, name, family, port);
            <span class="tok-kw">if</span> (addrs.items.len == <span class="tok-number">0</span>) {<span class="tok-comment">
                // RFC 6761 Section 6.3.3
                // Name resolution APIs and libraries SHOULD recognize localhost
                // names as special and SHOULD always return the IP loopback address
                // for address queries and negative responses for all other query
                // types.

                // Check for equal to &quot;localhost(.)&quot; or ends in &quot;.localhost(.)&quot;
                </span><span class="tok-kw">const</span> localhost = <span class="tok-kw">if</span> (name[name.len - <span class="tok-number">1</span>] == <span class="tok-str">'.'</span>) <span class="tok-str">&quot;localhost.&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;localhost&quot;</span>;
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, name, localhost) <span class="tok-kw">and</span> (name.len == localhost.len <span class="tok-kw">or</span> name[name.len - localhost.len] == <span class="tok-str">'.'</span>)) {
                    <span class="tok-kw">try</span> addrs.append(<a href="std.net.LookupAddr.html">LookupAddr</a>{ .addr = .{ .in = <a href="std.net.Ip4Address.html">Ip4Address</a>.<a href="std.net.Ip4Address.html#std.net.Ip4Address.parse">parse</a>(<span class="tok-str">&quot;127.0.0.1&quot;</span>, port) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> } });
                    <span class="tok-kw">try</span> addrs.append(<a href="std.net.LookupAddr.html">LookupAddr</a>{ .addr = .{ .in6 = <a href="std.net.Ip6Address.html">Ip6Address</a>.<a href="std.net.Ip6Address.html#std.net.Ip6Address.parse">parse</a>(<span class="tok-str">&quot;::1&quot;</span>, port) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> } });
                    <span class="tok-kw">return</span>;
                }

                <span class="tok-kw">try</span> <a href="std.net.html#std.net.linuxLookupNameFromDnsSearch">linuxLookupNameFromDnsSearch</a>(addrs, canon, name, family, port);
            }
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> canon.resize(<span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.net.html#std.net.linuxLookupNameFromNull">linuxLookupNameFromNull</a>(addrs, family, flags, port);
    }
    <span class="tok-kw">if</span> (addrs.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName;<span class="tok-comment">

    // No further processing is needed if there are fewer than 2
    // results or if there are only IPv4 results.
    </span><span class="tok-kw">if</span> (addrs.items.len == <span class="tok-number">1</span> <span class="tok-kw">or</span> family == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>) <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> all_ip4 = <span class="tok-kw">for</span> (addrs.items) |addr| {
        <span class="tok-kw">if</span> (addr.addr.any.family != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>) <span class="tok-kw">break</span> <span class="tok-null">false</span>;
    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> (all_ip4) <span class="tok-kw">return</span>;<span class="tok-comment">

    // The following implements a subset of RFC 3484/6724 destination
    // address selection by generating a single 31-bit sort key for
    // each address. Rules 3, 4, and 7 are omitted for having
    // excessive runtime and code size cost and dubious benefit.
    // So far the label/precedence table cannot be customized.
    // This implementation is ported from musl libc.
    // A more idiomatic &quot;ziggy&quot; implementation would be welcome.
    </span><span class="tok-kw">for</span> (addrs.items, <span class="tok-number">0</span>..) |*addr, i| {
        <span class="tok-kw">var</span> key: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> sa6: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a> = <span class="tok-null">undefined</span>;
        <span class="tok-builtin">@memset</span>(<span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sa6))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>)], <span class="tok-number">0</span>);
        <span class="tok-kw">var</span> da6 = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>{
            .family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>,
            .scope_id = addr.addr.in6.sa.scope_id,
            .port = <span class="tok-number">65535</span>,
            .flowinfo = <span class="tok-number">0</span>,
            .addr = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">16</span>,
        };
        <span class="tok-kw">var</span> sa4: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a> = <span class="tok-null">undefined</span>;
        <span class="tok-builtin">@memset</span>(<span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sa4))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>)], <span class="tok-number">0</span>);
        <span class="tok-kw">var</span> da4 = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>{
            .family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>,
            .port = <span class="tok-number">65535</span>,
            .addr = <span class="tok-number">0</span>,
            .zero = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">8</span>,
        };
        <span class="tok-kw">var</span> sa: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> da: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> salen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> dalen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (addr.addr.any.family == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>) {
            da6.addr = addr.addr.in6.sa.addr;
            da = <span class="tok-builtin">@ptrCast</span>(&amp;da6);
            dalen = <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>);
            sa = <span class="tok-builtin">@ptrCast</span>(&amp;sa6);
            salen = <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>);
        } <span class="tok-kw">else</span> {
            sa6.addr[<span class="tok-number">0</span>..<span class="tok-number">12</span>].* = <span class="tok-str">&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff&quot;</span>.*;
            da6.addr[<span class="tok-number">0</span>..<span class="tok-number">12</span>].* = <span class="tok-str">&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff&quot;</span>.*;
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u32</span>, da6.addr[<span class="tok-number">12</span>..], addr.addr.in.sa.addr, <a href="std.net.html#std.net.native_endian">native_endian</a>);
            da4.addr = addr.addr.in.sa.addr;
            da = <span class="tok-builtin">@ptrCast</span>(&amp;da4);
            dalen = <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>);
            sa = <span class="tok-builtin">@ptrCast</span>(&amp;sa4);
            salen = <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>);
        }
        <span class="tok-kw">const</span> dpolicy = <a href="std.net.html#std.net.policyOf">policyOf</a>(da6.addr);
        <span class="tok-kw">const</span> dscope: <span class="tok-type">i32</span> = <a href="std.net.html#std.net.scopeOf">scopeOf</a>(da6.addr);
        <span class="tok-kw">const</span> dlabel = dpolicy.label;
        <span class="tok-kw">const</span> dprec: <span class="tok-type">i32</span> = dpolicy.prec;
        <span class="tok-kw">const</span> MAXADDRS = <span class="tok-number">3</span>;
        <span class="tok-kw">var</span> prefixlen: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> sock_flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">DGRAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>;
        <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(addr.addr.any.family, sock_flags, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.IPPROTO">IPPROTO</a>.<a href="#">UDP</a>)) |fd| syscalls: {
            <span class="tok-kw">defer</span> <a href="std.net.Stream.html">Stream</a>.<a href="std.net.Stream.html#std.net.Stream.close">close</a>(.{ .handle = fd });
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(fd, da, dalen) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :syscalls;
            key |= <a href="std.net.html#std.net.DAS_USABLE">DAS_USABLE</a>;
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getsockname">getsockname</a>(fd, sa, &amp;salen) <span class="tok-kw">catch</span> <span class="tok-kw">break</span> :syscalls;
            <span class="tok-kw">if</span> (addr.addr.any.family == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>) {
                <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u32</span>, sa6.addr[<span class="tok-number">12</span>..<span class="tok-number">16</span>], sa4.addr, <a href="std.net.html#std.net.native_endian">native_endian</a>);
            }
            <span class="tok-kw">if</span> (dscope == <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <a href="std.net.html#std.net.scopeOf">scopeOf</a>(sa6.addr))) key |= <a href="std.net.html#std.net.DAS_MATCHINGSCOPE">DAS_MATCHINGSCOPE</a>;
            <span class="tok-kw">if</span> (dlabel == <a href="std.net.html#std.net.labelOf">labelOf</a>(sa6.addr)) key |= <a href="std.net.html#std.net.DAS_MATCHINGLABEL">DAS_MATCHINGLABEL</a>;
            prefixlen = <a href="std.net.html#std.net.prefixMatch">prefixMatch</a>(sa6.addr, da6.addr);
        } <span class="tok-kw">else</span> |_| {}
        key |= dprec &lt;&lt; <a href="std.net.html#std.net.DAS_PREC_SHIFT">DAS_PREC_SHIFT</a>;
        key |= (<span class="tok-number">15</span> - dscope) &lt;&lt; <a href="std.net.html#std.net.DAS_SCOPE_SHIFT">DAS_SCOPE_SHIFT</a>;
        key |= prefixlen &lt;&lt; <a href="std.net.html#std.net.DAS_PREFIX_SHIFT">DAS_PREFIX_SHIFT</a>;
        key |= (MAXADDRS - <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intCast</span>(i))) &lt;&lt; <a href="std.net.html#std.net.DAS_ORDER_SHIFT">DAS_ORDER_SHIFT</a>;
        addr.sortkey = key;
    }
    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>, addrs.items, {}, <a href="std.net.html#std.net.addrCmpLessThan">addrCmpLessThan</a>);
}

<span class="tok-kw">const</span> Policy = <span class="tok-kw">struct</span> {
    addr: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>,
    len: <span class="tok-type">u8</span>,
    mask: <span class="tok-type">u8</span>,
    prec: <span class="tok-type">u8</span>,
    label: <span class="tok-type">u8</span>,
};

<span class="tok-kw">const</span> defined_policies = [_]<a href="std.net.Policy.html">Policy</a>{
    <a href="std.net.Policy.html">Policy</a>{
        .addr = <span class="tok-str">&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&quot;</span>.*,
        .len = <span class="tok-number">15</span>,
        .mask = <span class="tok-number">0xff</span>,
        .prec = <span class="tok-number">50</span>,
        .label = <span class="tok-number">0</span>,
    },
    <a href="std.net.Policy.html">Policy</a>{
        .addr = <span class="tok-str">&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x00\x00\x00\x00&quot;</span>.*,
        .len = <span class="tok-number">11</span>,
        .mask = <span class="tok-number">0xff</span>,
        .prec = <span class="tok-number">35</span>,
        .label = <span class="tok-number">4</span>,
    },
    <a href="std.net.Policy.html">Policy</a>{
        .addr = <span class="tok-str">&quot;\x20\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span>.*,
        .len = <span class="tok-number">1</span>,
        .mask = <span class="tok-number">0xff</span>,
        .prec = <span class="tok-number">30</span>,
        .label = <span class="tok-number">2</span>,
    },
    <a href="std.net.Policy.html">Policy</a>{
        .addr = <span class="tok-str">&quot;\x20\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span>.*,
        .len = <span class="tok-number">3</span>,
        .mask = <span class="tok-number">0xff</span>,
        .prec = <span class="tok-number">5</span>,
        .label = <span class="tok-number">5</span>,
    },
    <a href="std.net.Policy.html">Policy</a>{
        .addr = <span class="tok-str">&quot;\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span>.*,
        .len = <span class="tok-number">0</span>,
        .mask = <span class="tok-number">0xfe</span>,
        .prec = <span class="tok-number">3</span>,
        .label = <span class="tok-number">13</span>,
    },<span class="tok-comment">
    //  These are deprecated and/or returned to the address
    //  pool, so despite the RFC, treating them as special
    //  is probably wrong.
    // { &quot;&quot;, 11, 0xff, 1, 3 },
    // { &quot;\xfe\xc0&quot;, 1, 0xc0, 1, 11 },
    // { &quot;\x3f\xfe&quot;, 1, 0xff, 1, 12 },
    // Last rule must match all addresses to stop loop.
    </span><a href="std.net.Policy.html">Policy</a>{
        .addr = <span class="tok-str">&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span>.*,
        .len = <span class="tok-number">0</span>,
        .mask = <span class="tok-number">0</span>,
        .prec = <span class="tok-number">40</span>,
        .label = <span class="tok-number">1</span>,
    },
};

<span class="tok-kw">fn</span> <span class="tok-fn">policyOf</span>(a: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>) *<span class="tok-kw">const</span> <a href="std.net.Policy.html">Policy</a> {
    <span class="tok-kw">for</span> (&amp;<a href="std.net.html#std.net.defined_policies">defined_policies</a>) |*policy| {
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a[<span class="tok-number">0</span>..policy.len], policy.addr[<span class="tok-number">0</span>..policy.len])) <span class="tok-kw">continue</span>;
        <span class="tok-kw">if</span> ((a[policy.len] &amp; policy.mask) != policy.addr[policy.len]) <span class="tok-kw">continue</span>;
        <span class="tok-kw">return</span> policy;
    }
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">scopeOf</span>(a: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.IN6_IS_ADDR_MULTICAST">IN6_IS_ADDR_MULTICAST</a>(a)) <span class="tok-kw">return</span> a[<span class="tok-number">1</span>] &amp; <span class="tok-number">15</span>;
    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.IN6_IS_ADDR_LINKLOCAL">IN6_IS_ADDR_LINKLOCAL</a>(a)) <span class="tok-kw">return</span> <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.IN6_IS_ADDR_LOOPBACK">IN6_IS_ADDR_LOOPBACK</a>(a)) <span class="tok-kw">return</span> <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (<a href="std.net.html#std.net.IN6_IS_ADDR_SITELOCAL">IN6_IS_ADDR_SITELOCAL</a>(a)) <span class="tok-kw">return</span> <span class="tok-number">5</span>;
    <span class="tok-kw">return</span> <span class="tok-number">14</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">prefixMatch</span>(s: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>, d: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>) <span class="tok-type">u8</span> {<span class="tok-comment">
    // TODO: This FIXME inherited from porting from musl libc.
    // I don't want this to go into zig std lib 1.0.0.

    // FIXME: The common prefix length should be limited to no greater
    // than the nominal length of the prefix portion of the source
    // address. However the definition of the source prefix length is
    // not clear and thus this limiting is not yet implemented.
    </span><span class="tok-kw">var</span> i: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">128</span> <span class="tok-kw">and</span> ((s[i / <span class="tok-number">8</span>] ^ d[i / <span class="tok-number">8</span>]) &amp; (<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">128</span>) &gt;&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(i % <span class="tok-number">8</span>)))) == <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> i;
}

<span class="tok-kw">fn</span> <span class="tok-fn">labelOf</span>(a: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.net.html#std.net.policyOf">policyOf</a>(a).label;
}

<span class="tok-kw">fn</span> <span class="tok-fn">IN6_IS_ADDR_MULTICAST</span>(a: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a[<span class="tok-number">0</span>] == <span class="tok-number">0xff</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">IN6_IS_ADDR_LINKLOCAL</span>(a: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a[<span class="tok-number">0</span>] == <span class="tok-number">0xfe</span> <span class="tok-kw">and</span> (a[<span class="tok-number">1</span>] &amp; <span class="tok-number">0xc0</span>) == <span class="tok-number">0x80</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">IN6_IS_ADDR_LOOPBACK</span>(a: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a[<span class="tok-number">0</span>] == <span class="tok-number">0</span> <span class="tok-kw">and</span> a[<span class="tok-number">1</span>] == <span class="tok-number">0</span> <span class="tok-kw">and</span>
        a[<span class="tok-number">2</span>] == <span class="tok-number">0</span> <span class="tok-kw">and</span>
        a[<span class="tok-number">12</span>] == <span class="tok-number">0</span> <span class="tok-kw">and</span> a[<span class="tok-number">13</span>] == <span class="tok-number">0</span> <span class="tok-kw">and</span>
        a[<span class="tok-number">14</span>] == <span class="tok-number">0</span> <span class="tok-kw">and</span> a[<span class="tok-number">15</span>] == <span class="tok-number">1</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">IN6_IS_ADDR_SITELOCAL</span>(a: [<span class="tok-number">16</span>]<span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a[<span class="tok-number">0</span>] == <span class="tok-number">0xfe</span> <span class="tok-kw">and</span> (a[<span class="tok-number">1</span>] &amp; <span class="tok-number">0xc0</span>) == <span class="tok-number">0xc0</span>;
}<span class="tok-comment">

// Parameters `b` and `a` swapped to make this descending.
</span><span class="tok-kw">fn</span> <span class="tok-fn">addrCmpLessThan</span>(context: <span class="tok-type">void</span>, b: <a href="std.net.LookupAddr.html">LookupAddr</a>, a: <a href="std.net.LookupAddr.html">LookupAddr</a>) <span class="tok-type">bool</span> {
    _ = context;
    <span class="tok-kw">return</span> a.sortkey &lt; b.sortkey;
}

<span class="tok-kw">fn</span> <span class="tok-fn">linuxLookupNameFromNull</span>(
    addrs: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>),
    family: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sa_family_t">sa_family_t</a>,
    flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AI">AI</a>,
    port: <span class="tok-type">u16</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (flags.PASSIVE) {
        <span class="tok-kw">if</span> (family != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>) {
            (<span class="tok-kw">try</span> addrs.addOne()).* = <a href="std.net.LookupAddr.html">LookupAddr</a>{
                .addr = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initIp4">initIp4</a>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">4</span>, port),
            };
        }
        <span class="tok-kw">if</span> (family != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>) {
            (<span class="tok-kw">try</span> addrs.addOne()).* = <a href="std.net.LookupAddr.html">LookupAddr</a>{
                .addr = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initIp6">initIp6</a>([<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">16</span>, port, <span class="tok-number">0</span>, <span class="tok-number">0</span>),
            };
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">if</span> (family != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>) {
            (<span class="tok-kw">try</span> addrs.addOne()).* = <a href="std.net.LookupAddr.html">LookupAddr</a>{
                .addr = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initIp4">initIp4</a>([<span class="tok-number">4</span>]<span class="tok-type">u8</span>{ <span class="tok-number">127</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span> }, port),
            };
        }
        <span class="tok-kw">if</span> (family != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>) {
            (<span class="tok-kw">try</span> addrs.addOne()).* = <a href="std.net.LookupAddr.html">LookupAddr</a>{
                .addr = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initIp6">initIp6</a>(([<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">15</span>) ++ [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">1</span>}, port, <span class="tok-number">0</span>, <span class="tok-number">0</span>),
            };
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">linuxLookupNameFromHosts</span>(
    addrs: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>),
    canon: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    family: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sa_family_t">sa_family_t</a>,
    port: <span class="tok-type">u16</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsoluteZ">openFileAbsoluteZ</a>(<span class="tok-str">&quot;/etc/hosts&quot;</span>, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound,
        <span class="tok-kw">error</span>.NotDir,
        <span class="tok-kw">error</span>.AccessDenied,
        =&gt; <span class="tok-kw">return</span>,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">var</span> buffered_reader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.buffered_reader.html#std.io.buffered_reader.bufferedReader">bufferedReader</a>(file.reader());
    <span class="tok-kw">const</span> reader = buffered_reader.reader();
    <span class="tok-kw">var</span> line_buf: [<span class="tok-number">512</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (reader.readUntilDelimiterOrEof(&amp;line_buf, <span class="tok-str">'\n'</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.StreamTooLong =&gt; blk: {<span class="tok-comment">
            // Skip to the delimiter in the reader, to fix parsing
            </span><span class="tok-kw">try</span> reader.skipUntilDelimiterOrEof(<span class="tok-str">'\n'</span>);<span class="tok-comment">
            // Use the truncated line. A truncated comment or hostname will be handled correctly.
            </span><span class="tok-kw">break</span> :blk &amp;line_buf;
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    }) |line| {
        <span class="tok-kw">var</span> split_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">'#'</span>);
        <span class="tok-kw">const</span> no_comment_line = split_it.first();

        <span class="tok-kw">var</span> line_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, no_comment_line, <span class="tok-str">&quot; \t&quot;</span>);
        <span class="tok-kw">const</span> ip_text = line_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> first_name_text: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;
        <span class="tok-kw">while</span> (line_it.next()) |name_text| {
            <span class="tok-kw">if</span> (first_name_text == <span class="tok-null">null</span>) first_name_text = name_text;
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name_text, name)) {
                <span class="tok-kw">break</span>;
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">continue</span>;

        <span class="tok-kw">const</span> addr = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseExpectingFamily">parseExpectingFamily</a>(ip_text, family, port) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.Overflow,
            <span class="tok-kw">error</span>.InvalidEnd,
            <span class="tok-kw">error</span>.InvalidCharacter,
            <span class="tok-kw">error</span>.Incomplete,
            <span class="tok-kw">error</span>.InvalidIPAddressFormat,
            <span class="tok-kw">error</span>.InvalidIpv4Mapping,
            <span class="tok-kw">error</span>.NonCanonical,
            =&gt; <span class="tok-kw">continue</span>,
        };
        <span class="tok-kw">try</span> addrs.append(<a href="std.net.LookupAddr.html">LookupAddr</a>{ .addr = addr });<span class="tok-comment">

        // first name is canonical name
        </span><span class="tok-kw">const</span> name_text = first_name_text.?;
        <span class="tok-kw">if</span> (<a href="std.net.html#std.net.isValidHostName">isValidHostName</a>(name_text)) {
            canon.items.len = <span class="tok-number">0</span>;
            <span class="tok-kw">try</span> canon.appendSlice(name_text);
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidHostName</span>(hostname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (hostname.len &gt;= <span class="tok-number">254</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ValidateSlice">utf8ValidateSlice</a>(hostname)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">for</span> (hostname) |byte| {
        <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.isAscii">isAscii</a>(byte) <span class="tok-kw">or</span> byte == <span class="tok-str">'.'</span> <span class="tok-kw">or</span> byte == <span class="tok-str">'-'</span> <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.isAlphanumeric">isAlphanumeric</a>(byte)) {
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">linuxLookupNameFromDnsSearch</span>(
    addrs: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>),
    canon: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    family: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sa_family_t">sa_family_t</a>,
    port: <span class="tok-type">u16</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> rc: <a href="std.net.ResolvConf.html">ResolvConf</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">try</span> <a href="std.net.html#std.net.getResolvConf">getResolvConf</a>(addrs.allocator, &amp;rc);
    <span class="tok-kw">defer</span> rc.deinit();<span class="tok-comment">

    // Count dots, suppress search when &gt;=ndots or name ends in
    // a dot, which is an explicit request for global scope.
    </span><span class="tok-kw">var</span> dots: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (name) |byte| {
        <span class="tok-kw">if</span> (byte == <span class="tok-str">'.'</span>) dots += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">const</span> search = <span class="tok-kw">if</span> (dots &gt;= rc.ndots <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>))
        <span class="tok-str">&quot;&quot;</span>
    <span class="tok-kw">else</span>
        rc.search.items;

    <span class="tok-kw">var</span> canon_name = name;<span class="tok-comment">

    // Strip final dot for canon, fail if multiple trailing dots.
    </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, canon_name, <span class="tok-str">&quot;.&quot;</span>)) canon_name.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, canon_name, <span class="tok-str">&quot;.&quot;</span>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName;<span class="tok-comment">

    // Name with search domain appended is setup in canon[]. This both
    // provides the desired default canonical name (if the requested
    // name is not a CNAME record) and serves as a buffer for passing
    // the full requested name to name_from_dns.
    </span><span class="tok-kw">try</span> canon.resize(canon_name.len);
    <span class="tok-builtin">@memcpy</span>(canon.items, canon_name);
    <span class="tok-kw">try</span> canon.append(<span class="tok-str">'.'</span>);

    <span class="tok-kw">var</span> tok_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, search, <span class="tok-str">&quot; \t&quot;</span>);
    <span class="tok-kw">while</span> (tok_it.next()) |tok| {
        canon.shrinkRetainingCapacity(canon_name.len + <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> canon.appendSlice(tok);
        <span class="tok-kw">try</span> <a href="std.net.html#std.net.linuxLookupNameFromDns">linuxLookupNameFromDns</a>(addrs, canon, canon.items, family, rc, port);
        <span class="tok-kw">if</span> (addrs.items.len != <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    }

    canon.shrinkRetainingCapacity(canon_name.len);
    <span class="tok-kw">return</span> <a href="std.net.html#std.net.linuxLookupNameFromDns">linuxLookupNameFromDns</a>(addrs, canon, name, family, rc, port);
}

<span class="tok-kw">const</span> dpc_ctx = <span class="tok-kw">struct</span> {
    addrs: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>),
    canon: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    port: <span class="tok-type">u16</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">linuxLookupNameFromDns</span>(
    addrs: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>),
    canon: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    family: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sa_family_t">sa_family_t</a>,
    rc: <a href="std.net.ResolvConf.html">ResolvConf</a>,
    port: <span class="tok-type">u16</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> ctx = <a href="std.net.dpc_ctx.html">dpc_ctx</a>{
        .addrs = addrs,
        .canon = canon,
        .port = port,
    };
    <span class="tok-kw">const</span> AfRr = <span class="tok-kw">struct</span> {
        af: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sa_family_t">sa_family_t</a>,
        rr: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> afrrs = [_]AfRr{
        AfRr{ .af = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>, .rr = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RR">RR</a>.<a href="#">A</a> },
        AfRr{ .af = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>, .rr = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RR">RR</a>.<a href="#">AAAA</a> },
    };
    <span class="tok-kw">var</span> qbuf: [<span class="tok-number">2</span>][<span class="tok-number">280</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> abuf: [<span class="tok-number">2</span>][<span class="tok-number">512</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> qp: [<span class="tok-number">2</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> apbuf = [<span class="tok-number">2</span>][]<span class="tok-type">u8</span>{ &amp;abuf[<span class="tok-number">0</span>], &amp;abuf[<span class="tok-number">1</span>] };
    <span class="tok-kw">var</span> nq: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (afrrs) |afrr| {
        <span class="tok-kw">if</span> (family != afrr.af) {
            <span class="tok-kw">const</span> len = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.res_mkquery">res_mkquery</a>(<span class="tok-number">0</span>, name, <span class="tok-number">1</span>, afrr.rr, &amp;[_]<span class="tok-type">u8</span>{}, <span class="tok-null">null</span>, &amp;qbuf[nq]);
            qp[nq] = qbuf[nq][<span class="tok-number">0</span>..len];
            nq += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">var</span> ap = [<span class="tok-number">2</span>][]<span class="tok-type">u8</span>{ apbuf[<span class="tok-number">0</span>], apbuf[<span class="tok-number">1</span>] };
    ap[<span class="tok-number">0</span>].len = <span class="tok-number">0</span>;
    ap[<span class="tok-number">1</span>].len = <span class="tok-number">0</span>;

    <span class="tok-kw">try</span> <a href="std.net.html#std.net.resMSendRc">resMSendRc</a>(qp[<span class="tok-number">0</span>..nq], ap[<span class="tok-number">0</span>..nq], apbuf[<span class="tok-number">0</span>..nq], rc);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; nq) : (i += <span class="tok-number">1</span>) {
        <a href="std.net.html#std.net.dnsParse">dnsParse</a>(ap[i], ctx, <a href="std.net.html#std.net.dnsParseCallback">dnsParseCallback</a>) <span class="tok-kw">catch</span> {};
    }

    <span class="tok-kw">if</span> (addrs.items.len != <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">if</span> (ap[<span class="tok-number">0</span>].len &lt; <span class="tok-number">4</span> <span class="tok-kw">or</span> (ap[<span class="tok-number">0</span>][<span class="tok-number">3</span>] &amp; <span class="tok-number">15</span>) == <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TemporaryNameServerFailure;
    <span class="tok-kw">if</span> ((ap[<span class="tok-number">0</span>][<span class="tok-number">3</span>] &amp; <span class="tok-number">15</span>) == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownHostName;
    <span class="tok-kw">if</span> ((ap[<span class="tok-number">0</span>][<span class="tok-number">3</span>] &amp; <span class="tok-number">15</span>) == <span class="tok-number">3</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameServerFailure;
}

<span class="tok-kw">const</span> ResolvConf = <span class="tok-kw">struct</span> {
    attempts: <span class="tok-type">u32</span>,
    ndots: <span class="tok-type">u32</span>,
    timeout: <span class="tok-type">u32</span>,
    search: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    ns: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>),

    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(rc: *<a href="std.net.ResolvConf.html">ResolvConf</a>) <span class="tok-type">void</span> {
        rc.ns.deinit();
        rc.search.deinit();
        rc.* = <span class="tok-null">undefined</span>;
    }
};

<span class="tok-comment">/// Ignores lines longer than 512 bytes.</span>
<span class="tok-comment">/// TODO: https://github.com/ziglang/zig/issues/2765 and https://github.com/ziglang/zig/issues/2761</span>
<span class="tok-kw">fn</span> <span class="tok-fn">getResolvConf</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, rc: *<a href="std.net.ResolvConf.html">ResolvConf</a>) !<span class="tok-type">void</span> {
    rc.* = <a href="std.net.ResolvConf.html">ResolvConf</a>{
        .ns = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>).init(allocator),
        .search = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator),
        .ndots = <span class="tok-number">1</span>,
        .timeout = <span class="tok-number">5</span>,
        .attempts = <span class="tok-number">2</span>,
    };
    <span class="tok-kw">errdefer</span> rc.deinit();

    <span class="tok-kw">const</span> file = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsoluteZ">openFileAbsoluteZ</a>(<span class="tok-str">&quot;/etc/resolv.conf&quot;</span>, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound,
        <span class="tok-kw">error</span>.NotDir,
        <span class="tok-kw">error</span>.AccessDenied,
        =&gt; <span class="tok-kw">return</span> <a href="std.net.html#std.net.linuxLookupNameFromNumericUnspec">linuxLookupNameFromNumericUnspec</a>(&amp;rc.ns, <span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">53</span>),
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">var</span> buf_reader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.buffered_reader.html#std.io.buffered_reader.bufferedReader">bufferedReader</a>(file.reader());
    <span class="tok-kw">const</span> stream = buf_reader.reader();
    <span class="tok-kw">var</span> line_buf: [<span class="tok-number">512</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (stream.readUntilDelimiterOrEof(&amp;line_buf, <span class="tok-str">'\n'</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.StreamTooLong =&gt; blk: {<span class="tok-comment">
            // Skip to the delimiter in the stream, to fix parsing
            </span><span class="tok-kw">try</span> stream.skipUntilDelimiterOrEof(<span class="tok-str">'\n'</span>);<span class="tok-comment">
            // Give an empty line to the while loop, which will be skipped.
            </span><span class="tok-kw">break</span> :blk line_buf[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    }) |line| {
        <span class="tok-kw">const</span> no_comment_line = no_comment_line: {
            <span class="tok-kw">var</span> split = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">'#'</span>);
            <span class="tok-kw">break</span> :no_comment_line split.first();
        };
        <span class="tok-kw">var</span> line_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, no_comment_line, <span class="tok-str">&quot; \t&quot;</span>);

        <span class="tok-kw">const</span> token = line_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, token, <span class="tok-str">&quot;options&quot;</span>)) {
            <span class="tok-kw">while</span> (line_it.next()) |sub_tok| {
                <span class="tok-kw">var</span> colon_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, sub_tok, <span class="tok-str">':'</span>);
                <span class="tok-kw">const</span> name = colon_it.first();
                <span class="tok-kw">const</span> value_txt = colon_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
                <span class="tok-kw">const</span> value = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u8</span>, value_txt, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
                    // TODO https://github.com/ziglang/zig/issues/11812
                    </span><span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>),
                    <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">continue</span>,
                };
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;ndots&quot;</span>)) {
                    rc.ndots = <span class="tok-builtin">@min</span>(value, <span class="tok-number">15</span>);
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;attempts&quot;</span>)) {
                    rc.attempts = <span class="tok-builtin">@min</span>(value, <span class="tok-number">10</span>);
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;timeout&quot;</span>)) {
                    rc.timeout = <span class="tok-builtin">@min</span>(value, <span class="tok-number">60</span>);
                }
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, token, <span class="tok-str">&quot;nameserver&quot;</span>)) {
            <span class="tok-kw">const</span> ip_txt = line_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            <span class="tok-kw">try</span> <a href="std.net.html#std.net.linuxLookupNameFromNumericUnspec">linuxLookupNameFromNumericUnspec</a>(&amp;rc.ns, ip_txt, <span class="tok-number">53</span>);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, token, <span class="tok-str">&quot;domain&quot;</span>) <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, token, <span class="tok-str">&quot;search&quot;</span>)) {
            rc.search.items.len = <span class="tok-number">0</span>;
            <span class="tok-kw">try</span> rc.search.appendSlice(line_it.rest());
        }
    }

    <span class="tok-kw">if</span> (rc.ns.items.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <a href="std.net.html#std.net.linuxLookupNameFromNumericUnspec">linuxLookupNameFromNumericUnspec</a>(&amp;rc.ns, <span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">53</span>);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">linuxLookupNameFromNumericUnspec</span>(
    addrs: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.LookupAddr.html">LookupAddr</a>),
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    port: <span class="tok-type">u16</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> addr = <span class="tok-kw">try</span> <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.resolveIp">resolveIp</a>(name, port);
    (<span class="tok-kw">try</span> addrs.addOne()).* = <a href="std.net.LookupAddr.html">LookupAddr</a>{ .addr = addr };
}

<span class="tok-kw">fn</span> <span class="tok-fn">resMSendRc</span>(
    queries: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    answers: [][]<span class="tok-type">u8</span>,
    answer_bufs: []<span class="tok-kw">const</span> []<span class="tok-type">u8</span>,
    rc: <a href="std.net.ResolvConf.html">ResolvConf</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> timeout = <span class="tok-number">1000</span> * rc.timeout;
    <span class="tok-kw">const</span> attempts = rc.attempts;

    <span class="tok-kw">var</span> sl: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in</a>);
    <span class="tok-kw">var</span> family: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sa_family_t">sa_family_t</a> = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>;

    <span class="tok-kw">var</span> ns_list = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.net.Address.html">Address</a>).init(rc.ns.allocator);
    <span class="tok-kw">defer</span> ns_list.deinit();

    <span class="tok-kw">try</span> ns_list.resize(rc.ns.items.len);
    <span class="tok-kw">const</span> ns = ns_list.items;

    <span class="tok-kw">for</span> (rc.ns.items, <span class="tok-number">0</span>..) |iplit, i| {
        ns[i] = iplit.addr;
        <a href="std.debug.html#std.debug.assert">assert</a>(ns[i].getPort() == <span class="tok-number">53</span>);
        <span class="tok-kw">if</span> (iplit.addr.any.family != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>) {
            family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>;
        }
    }

    <span class="tok-kw">const</span> flags = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">DGRAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">NONBLOCK</a>;
    <span class="tok-kw">const</span> fd = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(family, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.AddressFamilyNotSupported =&gt; blk: {<span class="tok-comment">
            // Handle case where system lacks IPv6 support
            </span><span class="tok-kw">if</span> (family == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>) {
                family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>;
                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>, flags, <span class="tok-number">0</span>);
            }
            <span class="tok-kw">return</span> err;
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    <span class="tok-kw">defer</span> <a href="std.net.Stream.html">Stream</a>.<a href="std.net.Stream.html#std.net.Stream.close">close</a>(.{ .handle = fd });<span class="tok-comment">

    // Past this point, there are no errors. Each individual query will
    // yield either no reply (indicated by zero length) or an answer
    // packet which is up to the caller to interpret.

    // Convert any IPv4 addresses in a mixed environment to v4-mapped
    </span><span class="tok-kw">if</span> (family == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>) {
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setsockopt">setsockopt</a>(
            fd,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">IPV6</a>,
            <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IPV6.html">IPV6</a>.<a href="std.os.linux.IPV6.html#std.os.linux.IPV6.V6ONLY">V6ONLY</a>,
            &amp;<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">0</span>)),
        );
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..ns.len) |i| {
            <span class="tok-kw">if</span> (ns[i].any.family != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET</a>) <span class="tok-kw">continue</span>;
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u32</span>, ns[i].in6.sa.addr[<span class="tok-number">12</span>..], ns[i].in.sa.addr, <a href="std.net.html#std.net.native_endian">native_endian</a>);
            ns[i].in6.sa.addr[<span class="tok-number">0</span>..<span class="tok-number">12</span>].* = <span class="tok-str">&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff&quot;</span>.*;
            ns[i].any.family = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AF">AF</a>.<a href="#">INET6</a>;
            ns[i].in6.sa.flowinfo = <span class="tok-number">0</span>;
            ns[i].in6.sa.scope_id = <span class="tok-number">0</span>;
        }
        sl = <span class="tok-builtin">@sizeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>.<a href="#">in6</a>);
    }<span class="tok-comment">

    // Get local address and open/bind a socket
    </span><span class="tok-kw">var</span> sa: <a href="std.net.Address.html">Address</a> = <span class="tok-null">undefined</span>;
    <span class="tok-builtin">@memset</span>(<span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;sa))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<a href="std.net.Address.html">Address</a>)], <span class="tok-number">0</span>);
    sa.any.family = family;
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.bind">bind</a>(fd, &amp;sa.any, sl);

    <span class="tok-kw">var</span> pfd = [<span class="tok-number">1</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pollfd">pollfd</a>{<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pollfd">pollfd</a>{
        .fd = fd,
        .events = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.POLL">POLL</a>.<a href="#">IN</a>,
        .revents = <span class="tok-null">undefined</span>,
    }};
    <span class="tok-kw">const</span> retry_interval = timeout / attempts;
    <span class="tok-kw">var</span> next: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> t2: <span class="tok-type">u64</span> = <span class="tok-builtin">@bitCast</span>(<a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.milliTimestamp">milliTimestamp</a>());
    <span class="tok-kw">const</span> t0 = t2;
    <span class="tok-kw">var</span> t1 = t2 - retry_interval;

    <span class="tok-kw">var</span> servfail_retry: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;

    outer: <span class="tok-kw">while</span> (t2 - t0 &lt; timeout) : (t2 = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.milliTimestamp">milliTimestamp</a>()))) {
        <span class="tok-kw">if</span> (t2 - t1 &gt;= retry_interval) {<span class="tok-comment">
            // Query all configured nameservers in parallel
            </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (i &lt; queries.len) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (answers[i].len == <span class="tok-number">0</span>) {
                    <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">while</span> (j &lt; ns.len) : (j += <span class="tok-number">1</span>) {
                        _ = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sendto">sendto</a>(fd, queries[i], <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.MSG">MSG</a>.<a href="#">NOSIGNAL</a>, &amp;ns[j].any, sl) <span class="tok-kw">catch</span> <span class="tok-null">undefined</span>;
                    }
                }
            }
            t1 = t2;
            servfail_retry = <span class="tok-number">2</span> * queries.len;
        }<span class="tok-comment">

        // Wait for a response, or until time to retry
        </span><span class="tok-kw">const</span> clamped_timeout = <span class="tok-builtin">@min</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u31</span>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>)), t1 + retry_interval - t2);
        <span class="tok-kw">const</span> nevents = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.poll">poll</a>(&amp;pfd, clamped_timeout) <span class="tok-kw">catch</span> <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (nevents == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">var</span> sl_copy = sl;
            <span class="tok-kw">const</span> rlen = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.recvfrom">recvfrom</a>(fd, answer_bufs[next], <span class="tok-number">0</span>, &amp;sa.any, &amp;sl_copy) <span class="tok-kw">catch</span> <span class="tok-kw">break</span>;<span class="tok-comment">

            // Ignore non-identifiable packets
            </span><span class="tok-kw">if</span> (rlen &lt; <span class="tok-number">4</span>) <span class="tok-kw">continue</span>;<span class="tok-comment">

            // Ignore replies from addresses we didn't send to
            </span><span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (j &lt; ns.len <span class="tok-kw">and</span> !ns[j].eql(sa)) : (j += <span class="tok-number">1</span>) {}
            <span class="tok-kw">if</span> (j == ns.len) <span class="tok-kw">continue</span>;<span class="tok-comment">

            // Find which query this answer goes with, if any
            </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = next;
            <span class="tok-kw">while</span> (i &lt; queries.len <span class="tok-kw">and</span> (answer_bufs[next][<span class="tok-number">0</span>] != queries[i][<span class="tok-number">0</span>] <span class="tok-kw">or</span>
                answer_bufs[next][<span class="tok-number">1</span>] != queries[i][<span class="tok-number">1</span>])) : (i += <span class="tok-number">1</span>)
            {}

            <span class="tok-kw">if</span> (i == queries.len) <span class="tok-kw">continue</span>;
            <span class="tok-kw">if</span> (answers[i].len != <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;<span class="tok-comment">

            // Only accept positive or negative responses;
            // retry immediately on server failure, and ignore
            // all other codes such as refusal.
            </span><span class="tok-kw">switch</span> (answer_bufs[next][<span class="tok-number">3</span>] &amp; <span class="tok-number">15</span>) {
                <span class="tok-number">0</span>, <span class="tok-number">3</span> =&gt; {},
                <span class="tok-number">2</span> =&gt; <span class="tok-kw">if</span> (servfail_retry != <span class="tok-number">0</span>) {
                    servfail_retry -= <span class="tok-number">1</span>;
                    _ = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sendto">sendto</a>(fd, queries[i], <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.MSG">MSG</a>.<a href="#">NOSIGNAL</a>, &amp;ns[j].any, sl) <span class="tok-kw">catch</span> <span class="tok-null">undefined</span>;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
            }<span class="tok-comment">

            // Store answer in the right slot, or update next
            // available temp slot if it's already in place.
            </span>answers[i].len = rlen;
            <span class="tok-kw">if</span> (i == next) {
                <span class="tok-kw">while</span> (next &lt; queries.len <span class="tok-kw">and</span> answers[next].len != <span class="tok-number">0</span>) : (next += <span class="tok-number">1</span>) {}
            } <span class="tok-kw">else</span> {
                <span class="tok-builtin">@memcpy</span>(answer_bufs[i][<span class="tok-number">0</span>..rlen], answer_bufs[next][<span class="tok-number">0</span>..rlen]);
            }

            <span class="tok-kw">if</span> (next == queries.len) <span class="tok-kw">break</span> :outer;
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">dnsParse</span>(
    r: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ctx: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> callback: <span class="tok-kw">anytype</span>,
) !<span class="tok-type">void</span> {<span class="tok-comment">
    // This implementation is ported from musl libc.
    // A more idiomatic &quot;ziggy&quot; implementation would be welcome.
    </span><span class="tok-kw">if</span> (r.len &lt; <span class="tok-number">12</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
    <span class="tok-kw">if</span> ((r[<span class="tok-number">3</span>] &amp; <span class="tok-number">15</span>) != <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">var</span> p = r.ptr + <span class="tok-number">12</span>;
    <span class="tok-kw">var</span> qdcount = r[<span class="tok-number">4</span>] * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">256</span>) + r[<span class="tok-number">5</span>];
    <span class="tok-kw">var</span> ancount = r[<span class="tok-number">6</span>] * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">256</span>) + r[<span class="tok-number">7</span>];
    <span class="tok-kw">if</span> (qdcount + ancount &gt; <span class="tok-number">64</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
    <span class="tok-kw">while</span> (qdcount != <span class="tok-number">0</span>) {
        qdcount -= <span class="tok-number">1</span>;
        <span class="tok-kw">while</span> (<span class="tok-builtin">@intFromPtr</span>(p) - <span class="tok-builtin">@intFromPtr</span>(r.ptr) &lt; r.len <span class="tok-kw">and</span> p[<span class="tok-number">0</span>] -% <span class="tok-number">1</span> &lt; <span class="tok-number">127</span>) p += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (p[<span class="tok-number">0</span>] &gt; <span class="tok-number">193</span> <span class="tok-kw">or</span> (p[<span class="tok-number">0</span>] == <span class="tok-number">193</span> <span class="tok-kw">and</span> p[<span class="tok-number">1</span>] &gt; <span class="tok-number">254</span>) <span class="tok-kw">or</span> <span class="tok-builtin">@intFromPtr</span>(p) &gt; <span class="tok-builtin">@intFromPtr</span>(r.ptr) + r.len - <span class="tok-number">6</span>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
        p += <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>) + <span class="tok-builtin">@intFromBool</span>(p[<span class="tok-number">0</span>] != <span class="tok-number">0</span>);
    }
    <span class="tok-kw">while</span> (ancount != <span class="tok-number">0</span>) {
        ancount -= <span class="tok-number">1</span>;
        <span class="tok-kw">while</span> (<span class="tok-builtin">@intFromPtr</span>(p) - <span class="tok-builtin">@intFromPtr</span>(r.ptr) &lt; r.len <span class="tok-kw">and</span> p[<span class="tok-number">0</span>] -% <span class="tok-number">1</span> &lt; <span class="tok-number">127</span>) p += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (p[<span class="tok-number">0</span>] &gt; <span class="tok-number">193</span> <span class="tok-kw">or</span> (p[<span class="tok-number">0</span>] == <span class="tok-number">193</span> <span class="tok-kw">and</span> p[<span class="tok-number">1</span>] &gt; <span class="tok-number">254</span>) <span class="tok-kw">or</span> <span class="tok-builtin">@intFromPtr</span>(p) &gt; <span class="tok-builtin">@intFromPtr</span>(r.ptr) + r.len - <span class="tok-number">6</span>)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
        p += <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) + <span class="tok-builtin">@intFromBool</span>(p[<span class="tok-number">0</span>] != <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> len = p[<span class="tok-number">8</span>] * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">256</span>) + p[<span class="tok-number">9</span>];
        <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromPtr</span>(p) + len &gt; <span class="tok-builtin">@intFromPtr</span>(r.ptr) + r.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsPacket;
        <span class="tok-kw">try</span> callback(ctx, p[<span class="tok-number">1</span>], p[<span class="tok-number">10</span>..][<span class="tok-number">0</span>..len], r);
        p += <span class="tok-number">10</span> + len;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">dnsParseCallback</span>(ctx: <a href="std.net.dpc_ctx.html">dpc_ctx</a>, rr: <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, packet: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (rr) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RR">RR</a>.<a href="#">A</a> =&gt; {
            <span class="tok-kw">if</span> (data.len != <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsARecord;
            <span class="tok-kw">const</span> new_addr = <span class="tok-kw">try</span> ctx.addrs.addOne();
            new_addr.* = <a href="std.net.LookupAddr.html">LookupAddr</a>{
                .addr = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initIp4">initIp4</a>(data[<span class="tok-number">0</span>..<span class="tok-number">4</span>].*, ctx.port),
            };
        },
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RR">RR</a>.<a href="#">AAAA</a> =&gt; {
            <span class="tok-kw">if</span> (data.len != <span class="tok-number">16</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDnsAAAARecord;
            <span class="tok-kw">const</span> new_addr = <span class="tok-kw">try</span> ctx.addrs.addOne();
            new_addr.* = <a href="std.net.LookupAddr.html">LookupAddr</a>{
                .addr = <a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initIp6">initIp6</a>(data[<span class="tok-number">0</span>..<span class="tok-number">16</span>].*, ctx.port, <span class="tok-number">0</span>, <span class="tok-number">0</span>),
            };
        },
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RR">RR</a>.<a href="#">CNAME</a> =&gt; {
            <span class="tok-kw">var</span> tmp: [<span class="tok-number">256</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
            // Returns len of compressed name. strlen to get canon name.
            </span>_ = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.dn_expand">dn_expand</a>(packet, data, &amp;tmp);
            <span class="tok-kw">const</span> canon_name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;tmp, <span class="tok-number">0</span>);
            <span class="tok-kw">if</span> (<a href="std.net.html#std.net.isValidHostName">isValidHostName</a>(canon_name)) {
                ctx.canon.items.len = <span class="tok-number">0</span>;
                <span class="tok-kw">try</span> ctx.canon.appendSlice(canon_name);
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stream = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Underlying platform-defined type which may or may not be</span>
    <span class="tok-comment">/// interchangeable with a file system file descriptor.</span>
    handle: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(s: <a href="std.net.Stream.html">Stream</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (<a href="std.net.html#std.net.native_os">native_os</a>) {
            .windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.closesocket">closesocket</a>(s.handle) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(s.handle),
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a>;
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a>;

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(<a href="std.net.Stream.html">Stream</a>, <a href="std.posix.html#std.posix.ReadError">ReadError</a>, <a href="std.net.Stream.html#std.net.Stream.read">read</a>);
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(<a href="std.net.Stream.html">Stream</a>, <a href="std.posix.html#std.posix.WriteError">WriteError</a>, <a href="std.net.Stream.html#std.net.Stream.write">write</a>);

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(self: <a href="std.net.Stream.html">Stream</a>) <a href="std.net.Stream.html#std.net.Stream.Reader">Reader</a> {
        <span class="tok-kw">return</span> .{ .context = self };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: <a href="std.net.Stream.html">Stream</a>) <a href="std.net.Stream.html#std.net.Stream.Writer">Writer</a> {
        <span class="tok-kw">return</span> .{ .context = self };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: <a href="std.net.Stream.html">Stream</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .windows) {
            <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, buffer, <span class="tok-null">null</span>);
        }

        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.read">read</a>(self.handle, buffer);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(s: <a href="std.net.Stream.html">Stream</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .windows) {<span class="tok-comment">
            // TODO improve this to use ReadFileScatter
            </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
            <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(s.handle, first.base[<span class="tok-number">0</span>..first.len], <span class="tok-null">null</span>);
        }

        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readv">readv</a>(s.handle, iovecs);
    }

    <span class="tok-comment">/// Returns the number of bytes read. If the number read is smaller than</span>
    <span class="tok-comment">/// `buffer.len`, it means the stream reached the end. Reaching the end of</span>
    <span class="tok-comment">/// a stream is not an error condition.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(s: <a href="std.net.Stream.html">Stream</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <a href="std.net.Stream.html#std.net.Stream.readAtLeast">readAtLeast</a>(s, buffer, buffer.len);
    }

    <span class="tok-comment">/// Returns the number of bytes read, calling the underlying read function</span>
    <span class="tok-comment">/// the minimal number of times until the buffer has at least `len` bytes</span>
    <span class="tok-comment">/// filled. If the number read is less than `len` it means the stream</span>
    <span class="tok-comment">/// reached the end. Reaching the end of the stream is not an error</span>
    <span class="tok-comment">/// condition.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAtLeast</span>(s: <a href="std.net.Stream.html">Stream</a>, buffer: []<span class="tok-type">u8</span>, len: <span class="tok-type">usize</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(len &lt;= buffer.len);
        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index &lt; len) {
            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> s.read(buffer[index..]);
            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            index += amt;
        }
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-comment">/// TODO in evented I/O mode, this implementation incorrectly uses the event loop's</span>
    <span class="tok-comment">/// file system thread instead of non-blocking. It needs to be reworked to properly</span>
    <span class="tok-comment">/// use non-blocking I/O.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: <a href="std.net.Stream.html">Stream</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (<a href="std.net.html#std.net.native_os">native_os</a> == .windows) {
            <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, buffer, <span class="tok-null">null</span>);
        }

        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.write">write</a>(self.handle, buffer);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(self: <a href="std.net.Stream.html">Stream</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index &lt; bytes.len) {
            index += <span class="tok-kw">try</span> self.write(bytes[index..]);
        }
    }

    <span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
    <span class="tok-comment">/// See equivalent function: `std.fs.File.writev`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(self: <a href="std.net.Stream.html">Stream</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.writev">writev</a>(self.handle, iovecs);
    }

    <span class="tok-comment">/// The `iovecs` parameter is mutable because this function needs to mutate the fields in</span>
    <span class="tok-comment">/// order to handle partial writes from the underlying OS layer.</span>
    <span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
    <span class="tok-comment">/// See equivalent function: `std.fs.File.writevAll`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writevAll</span>(self: <a href="std.net.Stream.html">Stream</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.writev(iovecs[i..]);
            <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
                amt -= iovecs[i].len;
                i += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span>;
            }
            iovecs[i].base += amt;
            iovecs[i].len -= amt;
        }
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Server = <span class="tok-kw">struct</span> {
    listen_address: <a href="std.net.Address.html">Address</a>,
    stream: <a href="std.html">std</a>.<a href="std.net.html">net</a>.<a href="std.net.Stream.html">Stream</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Connection = <span class="tok-kw">struct</span> {
        stream: <a href="std.html">std</a>.<a href="std.net.html">net</a>.<a href="std.net.Stream.html">Stream</a>,
        address: <a href="std.net.Address.html">Address</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(s: *<a href="std.net.Server.html">Server</a>) <span class="tok-type">void</span> {
        s.stream.close();
        s.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AcceptError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AcceptError">AcceptError</a>;

    <span class="tok-comment">/// Blocks until a client connects to the server. The returned `Connection` has</span>
    <span class="tok-comment">/// an open stream.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept</span>(s: *<a href="std.net.Server.html">Server</a>) <a href="std.posix.html#std.posix.AcceptError">AcceptError</a>!<a href="std.net.Server.Connection.html">Connection</a> {
        <span class="tok-kw">var</span> accepted_addr: <a href="std.net.Address.html">Address</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> addr_len: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = <span class="tok-builtin">@sizeOf</span>(<a href="std.net.Address.html">Address</a>);
        <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.accept">accept</a>(s.stream.handle, &amp;accepted_addr.any, &amp;addr_len, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>);
        <span class="tok-kw">return</span> .{
            .stream = .{ .handle = fd },
            .address = accepted_addr,
        };
    }
};

<span class="tok-kw">test</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .wasi) {
        _ = <a href="std.net.Server.html">Server</a>;
        _ = <a href="std.net.Stream.html">Stream</a>;
        _ = <a href="std.net.Address.html">Address</a>;
        _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;net/test.zig&quot;</span>);
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
