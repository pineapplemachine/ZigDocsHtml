<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.AstGen.html" class="active">AstGen</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.AstGen" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zig.AstGen</span><a href="#src.zig-std.zig.AstGen">[src]</a></h1><div class="tldDocs"><p>Ingests an AST and produces ZIR code.</p>
</div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>nodes_need_rl: *<span class="tok-kw">const</span> <a href="std.zig.AstRlAnnotate.html">AstRlAnnotate</a>.<a href="std.zig.AstRlAnnotate.html#std.zig.AstRlAnnotate.RlNeededSet">RlNeededSet</a></code></pre><div class="fieldDocs"><p>The set of nodes which, given the choice, must expose a result pointer to
sub-expressions. See <code><a href="std.zig.AstRlAnnotate.html">AstRlAnnotate</a></code> for details.</p>
</div></div><div><pre><code>instructions: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>) = .{}</code></pre></div><div><pre><code>extra: <a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty</code></pre></div><div><pre><code>string_bytes: <a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty</code></pre></div><div><pre><code>source_offset: <span class="tok-type">u32</span> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Tracks the current byte offset within the source file.
Used to populate line deltas in the ZIR. AstGen maintains
this &quot;cursor&quot; throughout the entire AST lowering process in order
to avoid starting over the line/column scan for every declaration, which
would be O(N^2).</p>
</div></div><div><pre><code>source_line: <span class="tok-type">u32</span> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Tracks the corresponding line of <code>source_offset</code>.
This value is absolute.</p>
</div></div><div><pre><code>source_column: <span class="tok-type">u32</span> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Tracks the corresponding column of <code>source_offset</code>.
This value is absolute.</p>
</div></div><div><pre><code>arena: <a href="std.mem.Allocator.html">Allocator</a></code></pre><div class="fieldDocs"><p>Used for temporary allocations; freed after AstGen is complete.
The resulting ZIR code has no references to anything in this arena.</p>
</div></div><div><pre><code>string_table: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(<span class="tok-type">u32</span>, <span class="tok-type">void</span>, <a href="std.hash_map.StringIndexContext.html">StringIndexContext</a>, <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>) = .empty</code></pre></div><div><pre><code>compile_errors: <a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CompileErrors.html">CompileErrors</a>.<a href="std.zig.Zir.Inst.CompileErrors.Item.html">Item</a>) = .empty</code></pre></div><div><pre><code>fn_block: ?*<a href="std.zig.AstGen.GenZir.html">GenZir</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>The topmost block of the current function.</p>
</div></div><div><pre><code>fn_var_args: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>within_fn: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Whether we are somewhere within a function. If <code>true</code>, any container decls may be
generic and thus must be tunneled through closure.</p>
</div></div><div><pre><code>fn_ret_ty: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = .none</code></pre><div class="fieldDocs"><p>The return type of the current function. This may be a trivial <code>Ref</code>, or
otherwise it refers to a <code>ret_type</code> instruction.</p>
</div></div><div><pre><code>imports: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) = .empty</code></pre><div class="fieldDocs"><p>Maps string table indexes to the first <code>@import</code> ZIR instruction
that uses this string as the operand.</p>
</div></div><div><pre><code>scratch: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty</code></pre><div class="fieldDocs"><p>Used for temporary storage when building payloads.</p>
</div></div><div><pre><code>ref_table: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) = .empty</code></pre><div class="fieldDocs"><p>Whenever a <code>ref</code> instruction is needed, it is created and saved in this
table instead of being immediately appended to the current block body.
Then, when the instruction is being added to the parent block (typically from
setBlockBody), if it has a ref_table entry, then the ref instruction is added
there. This makes sure two properties are upheld:</p>
<ol>
<li>All pointers to the same locals return the same address. This is required
to be compliant with the language specification.</li>
<li><code>ref</code> instructions will dominate their uses. This is a required property
of ZIR.
The key is the ref operand; the value is the ref instruction.</li>
</ol>
</div></div><div><pre><code>src_hasher: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a></code></pre><div class="fieldDocs"><p>Any information which should trigger invalidation of incremental compilation
data should be used to update this hasher. The result is the final source
hash of the enclosing declaration/etc.</p>
</div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.zig.AstGen.generate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">generate</span><a href="#src.zig-std.zig.AstGen.generate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generate</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, tree: <a href="std.zig.Ast.html">Ast</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.Zir.html">Zir</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.AstGen.generate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generate</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, tree: <a href="std.zig.Ast.html">Ast</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.Zir.html">Zir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.mode == .zig);

    <span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(gpa);
    <span class="tok-kw">defer</span> arena.deinit();

    <span class="tok-kw">var</span> nodes_need_rl = <span class="tok-kw">try</span> <a href="std.zig.AstRlAnnotate.html">AstRlAnnotate</a>.<a href="std.zig.AstRlAnnotate.html#std.zig.AstRlAnnotate.annotate">annotate</a>(gpa, arena.allocator(), tree);
    <span class="tok-kw">defer</span> nodes_need_rl.deinit(gpa);

    <span class="tok-kw">var</span> astgen: <a href="std.zig.AstGen.html">AstGen</a> = .{
        .gpa = gpa,
        .arena = arena.allocator(),
        .tree = &amp;tree,
        .nodes_need_rl = &amp;nodes_need_rl,
        .src_hasher = <span class="tok-null">undefined</span>,<span class="tok-comment"> // `structDeclInner` for the root struct will set this
    </span>};
    <span class="tok-kw">defer</span> astgen.deinit(gpa);<span class="tok-comment">

    // String table index 0 is reserved for `NullTerminatedString.empty`.
    </span><span class="tok-kw">try</span> astgen.string_bytes.append(gpa, <span class="tok-number">0</span>);<span class="tok-comment">

    // We expect at least as many ZIR instructions and extra data items
    // as AST nodes.
    </span><span class="tok-kw">try</span> astgen.instructions.ensureTotalCapacity(gpa, tree.nodes.len);<span class="tok-comment">

    // First few indexes of extra are reserved and set at the end.
    </span><span class="tok-kw">const</span> reserved_count = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.ExtraIndex.html">ExtraIndex</a>).@&quot;enum&quot;.fields.len;
    <span class="tok-kw">try</span> astgen.extra.ensureTotalCapacity(gpa, tree.nodes.len + reserved_count);
    astgen.extra.items.len += reserved_count;

    <span class="tok-kw">var</span> top_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Top.html">Top</a> = .{};

    <span class="tok-kw">var</span> gz_instructions: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) = .empty;
    <span class="tok-kw">var</span> gen_scope: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .is_comptime = <span class="tok-null">true</span>,
        .parent = &amp;top_scope.base,
        .anon_name_strategy = .parent,
        .decl_node_index = <span class="tok-number">0</span>,
        .decl_line = <span class="tok-number">0</span>,
        .astgen = &amp;astgen,
        .instructions = &amp;gz_instructions,
        .instructions_top = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">defer</span> gz_instructions.deinit(gpa);<span class="tok-comment">

    // The AST -&gt; ZIR lowering process assumes an AST that does not have any parse errors.
    // Parse errors, or AstGen errors in the root struct, are considered &quot;fatal&quot;, so we emit no ZIR.
    </span><span class="tok-kw">const</span> fatal = <span class="tok-kw">if</span> (tree.errors.len == <span class="tok-number">0</span>) fatal: {
        <span class="tok-kw">if</span> (<a href="std.zig.AstGen.html">AstGen</a>.<a href="std.zig.AstGen.html#std.zig.AstGen.structDeclInner">structDeclInner</a>(
            &amp;gen_scope,
            &amp;gen_scope.base,
            <span class="tok-number">0</span>,
            tree.containerDeclRoot(),
            .auto,
            <span class="tok-number">0</span>,
        )) |struct_decl_ref| {
            <a href="std.debug.html#std.debug.assert">assert</a>(struct_decl_ref.toIndex().? == .main_struct_inst);
            <span class="tok-kw">break</span> :fatal <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">error</span>.AnalysisFail =&gt; <span class="tok-kw">break</span> :fatal <span class="tok-null">true</span>,<span class="tok-comment"> // Handled via compile_errors below.
        </span>}
    } <span class="tok-kw">else</span> fatal: {
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.lowerAstErrors">lowerAstErrors</a>(&amp;astgen);
        <span class="tok-kw">break</span> :fatal <span class="tok-null">true</span>;
    };

    <span class="tok-kw">const</span> err_index = <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.ExtraIndex.html">ExtraIndex</a>.<a href="#">compile_errors</a>);
    <span class="tok-kw">if</span> (astgen.compile_errors.items.len == <span class="tok-number">0</span>) {
        astgen.extra.items[err_index] = <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-number">1</span> + astgen.compile_errors.items.len *
            <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CompileErrors.html">CompileErrors</a>.<a href="std.zig.Zir.Inst.CompileErrors.Item.html">Item</a>).@&quot;struct&quot;.fields.len);

        astgen.extra.items[err_index] = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CompileErrors.html">CompileErrors</a>{
            .items_len = <span class="tok-builtin">@intCast</span>(astgen.compile_errors.items.len),
        });

        <span class="tok-kw">for</span> (astgen.compile_errors.items) |item| {
            _ = astgen.addExtraAssumeCapacity(item);
        }
    }

    <span class="tok-kw">const</span> imports_index = <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.ExtraIndex.html">ExtraIndex</a>.<a href="#">imports</a>);
    <span class="tok-kw">if</span> (astgen.imports.count() == <span class="tok-number">0</span>) {
        astgen.extra.items[imports_index] = <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Imports.html">Imports</a>).@&quot;struct&quot;.fields.len +
            astgen.imports.count() * <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Imports.html">Imports</a>.<a href="std.zig.Zir.Inst.Imports.Item.html">Item</a>).@&quot;struct&quot;.fields.len);

        astgen.extra.items[imports_index] = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Imports.html">Imports</a>{
            .imports_len = <span class="tok-builtin">@intCast</span>(astgen.imports.count()),
        });

        <span class="tok-kw">var</span> it = astgen.imports.iterator();
        <span class="tok-kw">while</span> (it.next()) |entry| {
            _ = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Imports.html">Imports</a>.<a href="std.zig.Zir.Inst.Imports.Item.html">Item</a>{
                .name = entry.key_ptr.*,
                .token = entry.value_ptr.*,
            });
        }
    }

    <span class="tok-kw">return</span> .{
        .instructions = <span class="tok-kw">if</span> (fatal) .empty <span class="tok-kw">else</span> astgen.instructions.toOwnedSlice(),
        .string_bytes = <span class="tok-kw">try</span> astgen.string_bytes.toOwnedSlice(gpa),
        .extra = <span class="tok-kw">try</span> astgen.extra.toOwnedSlice(gpa),
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.AstGen">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Ingests an AST and produces ZIR code.</span>
<span class="tok-kw">const</span> AstGen = <span class="tok-builtin">@This</span>();

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> Ast = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Ast.html">Ast</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> ArrayListUnmanaged = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>;
<span class="tok-kw">const</span> StringIndexAdapter = <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.StringIndexAdapter.html">StringIndexAdapter</a>;
<span class="tok-kw">const</span> StringIndexContext = <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.StringIndexContext.html">StringIndexContext</a>;

<span class="tok-kw">const</span> isPrimitive = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.primitives.html">primitives</a>.<a href="std.zig.primitives.html#std.zig.primitives.isPrimitive">isPrimitive</a>;

<span class="tok-kw">const</span> Zir = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Zir.html">Zir</a>;
<span class="tok-kw">const</span> BuiltinFn = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.BuiltinFn.html">BuiltinFn</a>;
<span class="tok-kw">const</span> AstRlAnnotate = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.AstRlAnnotate.html">AstRlAnnotate</a>;

gpa: <a href="std.mem.Allocator.html">Allocator</a>,
tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>,
<span class="tok-comment">/// The set of nodes which, given the choice, must expose a result pointer to</span>
<span class="tok-comment">/// sub-expressions. See `AstRlAnnotate` for details.</span>
nodes_need_rl: *<span class="tok-kw">const</span> <a href="std.zig.AstRlAnnotate.html">AstRlAnnotate</a>.<a href="std.zig.AstRlAnnotate.html#std.zig.AstRlAnnotate.RlNeededSet">RlNeededSet</a>,
instructions: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>) = .{},
extra: <a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty,
string_bytes: <a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty,
<span class="tok-comment">/// Tracks the current byte offset within the source file.</span>
<span class="tok-comment">/// Used to populate line deltas in the ZIR. AstGen maintains</span>
<span class="tok-comment">/// this &quot;cursor&quot; throughout the entire AST lowering process in order</span>
<span class="tok-comment">/// to avoid starting over the line/column scan for every declaration, which</span>
<span class="tok-comment">/// would be O(N^2).</span>
source_offset: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
<span class="tok-comment">/// Tracks the corresponding line of `source_offset`.</span>
<span class="tok-comment">/// This value is absolute.</span>
source_line: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
<span class="tok-comment">/// Tracks the corresponding column of `source_offset`.</span>
<span class="tok-comment">/// This value is absolute.</span>
source_column: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
<span class="tok-comment">/// Used for temporary allocations; freed after AstGen is complete.</span>
<span class="tok-comment">/// The resulting ZIR code has no references to anything in this arena.</span>
arena: <a href="std.mem.Allocator.html">Allocator</a>,
string_table: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(<span class="tok-type">u32</span>, <span class="tok-type">void</span>, <a href="std.hash_map.StringIndexContext.html">StringIndexContext</a>, <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>) = .empty,
compile_errors: <a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CompileErrors.html">CompileErrors</a>.<a href="std.zig.Zir.Inst.CompileErrors.Item.html">Item</a>) = .empty,
<span class="tok-comment">/// The topmost block of the current function.</span>
fn_block: ?*<a href="std.zig.AstGen.GenZir.html">GenZir</a> = <span class="tok-null">null</span>,
fn_var_args: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// Whether we are somewhere within a function. If `true`, any container decls may be</span>
<span class="tok-comment">/// generic and thus must be tunneled through closure.</span>
within_fn: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// The return type of the current function. This may be a trivial `Ref`, or</span>
<span class="tok-comment">/// otherwise it refers to a `ret_type` instruction.</span>
fn_ret_ty: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = .none,
<span class="tok-comment">/// Maps string table indexes to the first `@import` ZIR instruction</span>
<span class="tok-comment">/// that uses this string as the operand.</span>
imports: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) = .empty,
<span class="tok-comment">/// Used for temporary storage when building payloads.</span>
scratch: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty,
<span class="tok-comment">/// Whenever a `ref` instruction is needed, it is created and saved in this</span>
<span class="tok-comment">/// table instead of being immediately appended to the current block body.</span>
<span class="tok-comment">/// Then, when the instruction is being added to the parent block (typically from</span>
<span class="tok-comment">/// setBlockBody), if it has a ref_table entry, then the ref instruction is added</span>
<span class="tok-comment">/// there. This makes sure two properties are upheld:</span>
<span class="tok-comment">/// 1. All pointers to the same locals return the same address. This is required</span>
<span class="tok-comment">///    to be compliant with the language specification.</span>
<span class="tok-comment">/// 2. `ref` instructions will dominate their uses. This is a required property</span>
<span class="tok-comment">///    of ZIR.</span>
<span class="tok-comment">/// The key is the ref operand; the value is the ref instruction.</span>
ref_table: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) = .empty,
<span class="tok-comment">/// Any information which should trigger invalidation of incremental compilation</span>
<span class="tok-comment">/// data should be used to update this hasher. The result is the final source</span>
<span class="tok-comment">/// hash of the enclosing declaration/etc.</span>
src_hasher: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>,

<span class="tok-kw">const</span> InnerError = <span class="tok-kw">error</span>{ OutOfMemory, AnalysisFail };

<span class="tok-kw">fn</span> <span class="tok-fn">addExtra</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, extra: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> fields = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<span class="tok-builtin">@TypeOf</span>(extra));
    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(astgen.gpa, fields.len);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtraAssumeCapacity">addExtraAssumeCapacity</a>(astgen, extra);
}

<span class="tok-kw">fn</span> <span class="tok-fn">addExtraAssumeCapacity</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, extra: <span class="tok-kw">anytype</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> fields = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<span class="tok-builtin">@TypeOf</span>(extra));
    <span class="tok-kw">const</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(astgen.extra.items.len);
    astgen.extra.items.len += fields.len;
    <a href="std.zig.AstGen.html#std.zig.AstGen.setExtra">setExtra</a>(astgen, extra_index, extra);
    <span class="tok-kw">return</span> extra_index;
}

<span class="tok-kw">fn</span> <span class="tok-fn">setExtra</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, index: <span class="tok-type">usize</span>, extra: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> fields = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<span class="tok-builtin">@TypeOf</span>(extra));
    <span class="tok-kw">var</span> i = index;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {
        astgen.extra.items[i] = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
            <span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@field</span>(extra, field.name),

            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>.<a href="std.zig.Zir.Inst.Declaration.Name.html">Name</a>,
            <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.SimpleComptimeReason.html">SimpleComptimeReason</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            =&gt; <span class="tok-builtin">@intFromEnum</span>(<span class="tok-builtin">@field</span>(extra, field.name)),

            <span class="tok-type">i32</span>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Call.html">Call</a>.<a href="std.zig.Zir.Inst.Call.Flags.html">Flags</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BuiltinCall.html">BuiltinCall</a>.<a href="std.zig.Zir.Inst.BuiltinCall.Flags.html">Flags</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.Bits.html">Bits</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlockErrUnion.html">SwitchBlockErrUnion</a>.<a href="std.zig.Zir.Inst.SwitchBlockErrUnion.Bits.html">Bits</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FuncFancy.html">FuncFancy</a>.<a href="std.zig.Zir.Inst.FuncFancy.Bits.html">Bits</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Param.html">Param</a>.<a href="std.zig.Zir.Inst.Param.Type.html">Type</a>,
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Func.html">Func</a>.<a href="std.zig.Zir.Inst.Func.RetTy.html">RetTy</a>,
            =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@field</span>(extra, field.name)),

            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type&quot;</span>),
        };
        i += <span class="tok-number">1</span>;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">reserveExtra</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, size: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(astgen.extra.items.len);
    <span class="tok-kw">try</span> astgen.extra.resize(astgen.gpa, extra_index + size);
    <span class="tok-kw">return</span> extra_index;
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendRefs</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, refs: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> astgen.extra.appendSlice(astgen.gpa, <span class="tok-builtin">@ptrCast</span>(refs));
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendRefsAssumeCapacity</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, refs: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>) <span class="tok-type">void</span> {
    astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(refs));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generate</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, tree: <a href="std.zig.Ast.html">Ast</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.Zir.html">Zir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.mode == .zig);

    <span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(gpa);
    <span class="tok-kw">defer</span> arena.deinit();

    <span class="tok-kw">var</span> nodes_need_rl = <span class="tok-kw">try</span> <a href="std.zig.AstRlAnnotate.html">AstRlAnnotate</a>.<a href="std.zig.AstRlAnnotate.html#std.zig.AstRlAnnotate.annotate">annotate</a>(gpa, arena.allocator(), tree);
    <span class="tok-kw">defer</span> nodes_need_rl.deinit(gpa);

    <span class="tok-kw">var</span> astgen: <a href="std.zig.AstGen.html">AstGen</a> = .{
        .gpa = gpa,
        .arena = arena.allocator(),
        .tree = &amp;tree,
        .nodes_need_rl = &amp;nodes_need_rl,
        .src_hasher = <span class="tok-null">undefined</span>,<span class="tok-comment"> // `structDeclInner` for the root struct will set this
    </span>};
    <span class="tok-kw">defer</span> astgen.deinit(gpa);<span class="tok-comment">

    // String table index 0 is reserved for `NullTerminatedString.empty`.
    </span><span class="tok-kw">try</span> astgen.string_bytes.append(gpa, <span class="tok-number">0</span>);<span class="tok-comment">

    // We expect at least as many ZIR instructions and extra data items
    // as AST nodes.
    </span><span class="tok-kw">try</span> astgen.instructions.ensureTotalCapacity(gpa, tree.nodes.len);<span class="tok-comment">

    // First few indexes of extra are reserved and set at the end.
    </span><span class="tok-kw">const</span> reserved_count = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.ExtraIndex.html">ExtraIndex</a>).@&quot;enum&quot;.fields.len;
    <span class="tok-kw">try</span> astgen.extra.ensureTotalCapacity(gpa, tree.nodes.len + reserved_count);
    astgen.extra.items.len += reserved_count;

    <span class="tok-kw">var</span> top_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Top.html">Top</a> = .{};

    <span class="tok-kw">var</span> gz_instructions: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) = .empty;
    <span class="tok-kw">var</span> gen_scope: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .is_comptime = <span class="tok-null">true</span>,
        .parent = &amp;top_scope.base,
        .anon_name_strategy = .parent,
        .decl_node_index = <span class="tok-number">0</span>,
        .decl_line = <span class="tok-number">0</span>,
        .astgen = &amp;astgen,
        .instructions = &amp;gz_instructions,
        .instructions_top = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">defer</span> gz_instructions.deinit(gpa);<span class="tok-comment">

    // The AST -&gt; ZIR lowering process assumes an AST that does not have any parse errors.
    // Parse errors, or AstGen errors in the root struct, are considered &quot;fatal&quot;, so we emit no ZIR.
    </span><span class="tok-kw">const</span> fatal = <span class="tok-kw">if</span> (tree.errors.len == <span class="tok-number">0</span>) fatal: {
        <span class="tok-kw">if</span> (<a href="std.zig.AstGen.html">AstGen</a>.<a href="std.zig.AstGen.html#std.zig.AstGen.structDeclInner">structDeclInner</a>(
            &amp;gen_scope,
            &amp;gen_scope.base,
            <span class="tok-number">0</span>,
            tree.containerDeclRoot(),
            .auto,
            <span class="tok-number">0</span>,
        )) |struct_decl_ref| {
            <a href="std.debug.html#std.debug.assert">assert</a>(struct_decl_ref.toIndex().? == .main_struct_inst);
            <span class="tok-kw">break</span> :fatal <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">error</span>.AnalysisFail =&gt; <span class="tok-kw">break</span> :fatal <span class="tok-null">true</span>,<span class="tok-comment"> // Handled via compile_errors below.
        </span>}
    } <span class="tok-kw">else</span> fatal: {
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.lowerAstErrors">lowerAstErrors</a>(&amp;astgen);
        <span class="tok-kw">break</span> :fatal <span class="tok-null">true</span>;
    };

    <span class="tok-kw">const</span> err_index = <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.ExtraIndex.html">ExtraIndex</a>.<a href="#">compile_errors</a>);
    <span class="tok-kw">if</span> (astgen.compile_errors.items.len == <span class="tok-number">0</span>) {
        astgen.extra.items[err_index] = <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-number">1</span> + astgen.compile_errors.items.len *
            <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CompileErrors.html">CompileErrors</a>.<a href="std.zig.Zir.Inst.CompileErrors.Item.html">Item</a>).@&quot;struct&quot;.fields.len);

        astgen.extra.items[err_index] = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CompileErrors.html">CompileErrors</a>{
            .items_len = <span class="tok-builtin">@intCast</span>(astgen.compile_errors.items.len),
        });

        <span class="tok-kw">for</span> (astgen.compile_errors.items) |item| {
            _ = astgen.addExtraAssumeCapacity(item);
        }
    }

    <span class="tok-kw">const</span> imports_index = <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.ExtraIndex.html">ExtraIndex</a>.<a href="#">imports</a>);
    <span class="tok-kw">if</span> (astgen.imports.count() == <span class="tok-number">0</span>) {
        astgen.extra.items[imports_index] = <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Imports.html">Imports</a>).@&quot;struct&quot;.fields.len +
            astgen.imports.count() * <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Imports.html">Imports</a>.<a href="std.zig.Zir.Inst.Imports.Item.html">Item</a>).@&quot;struct&quot;.fields.len);

        astgen.extra.items[imports_index] = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Imports.html">Imports</a>{
            .imports_len = <span class="tok-builtin">@intCast</span>(astgen.imports.count()),
        });

        <span class="tok-kw">var</span> it = astgen.imports.iterator();
        <span class="tok-kw">while</span> (it.next()) |entry| {
            _ = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Imports.html">Imports</a>.<a href="std.zig.Zir.Inst.Imports.Item.html">Item</a>{
                .name = entry.key_ptr.*,
                .token = entry.value_ptr.*,
            });
        }
    }

    <span class="tok-kw">return</span> .{
        .instructions = <span class="tok-kw">if</span> (fatal) .empty <span class="tok-kw">else</span> astgen.instructions.toOwnedSlice(),
        .string_bytes = <span class="tok-kw">try</span> astgen.string_bytes.toOwnedSlice(gpa),
        .extra = <span class="tok-kw">try</span> astgen.extra.toOwnedSlice(gpa),
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    astgen.instructions.deinit(gpa);
    astgen.extra.deinit(gpa);
    astgen.string_table.deinit(gpa);
    astgen.string_bytes.deinit(gpa);
    astgen.compile_errors.deinit(gpa);
    astgen.imports.deinit(gpa);
    astgen.scratch.deinit(gpa);
    astgen.ref_table.deinit(gpa);
}

<span class="tok-kw">const</span> ResultInfo = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The semantics requested for the result location</span>
    rl: <a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>,

    <span class="tok-comment">/// The &quot;operator&quot; consuming the result location</span>
    ctx: <a href="std.zig.AstGen.ResultInfo.Context.html">Context</a> = .none,

    <span class="tok-comment">/// Turns a `coerced_ty` back into a `ty`. Should be called at branch points</span>
    <span class="tok-comment">/// such as if and switch expressions.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">br</span>(ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>) <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (ri.rl) {
            .coerced_ty =&gt; |ty| .{
                .rl = .{ .ty = ty },
                .ctx = ri.ctx,
            },
            <span class="tok-kw">else</span> =&gt; ri,
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">zirTag</span>(ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>) <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> {
        <span class="tok-kw">switch</span> (ri.rl) {
            .ty =&gt; <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (ri.ctx) {
                .shift_op =&gt; .as_shift_operand,
                <span class="tok-kw">else</span> =&gt; .as_node,
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">const</span> Loc = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        <span class="tok-comment">/// The expression is the right-hand side of assignment to `_`. Only the side-effects of the</span>
        <span class="tok-comment">/// expression should be generated. The result instruction from the expression must</span>
        <span class="tok-comment">/// be ignored.</span>
        discard,
        <span class="tok-comment">/// The expression has an inferred type, and it will be evaluated as an rvalue.</span>
        none,
        <span class="tok-comment">/// The expression will be coerced into this type, but it will be evaluated as an rvalue.</span>
        ty: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Same as `ty` but it is guaranteed that Sema will additionally perform the coercion,</span>
        <span class="tok-comment">/// so no `as` instruction needs to be emitted.</span>
        coerced_ty: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// The expression must generate a pointer rather than a value. For example, the left hand side</span>
        <span class="tok-comment">/// of an assignment uses this kind of result location.</span>
        ref,
        <span class="tok-comment">/// The expression must generate a pointer rather than a value, and the pointer will be coerced</span>
        <span class="tok-comment">/// by other code to this type, which is guaranteed by earlier instructions to be a pointer type.</span>
        ref_coerced_ty: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// The expression must store its result into this typed pointer. The result instruction</span>
        <span class="tok-comment">/// from the expression must be ignored.</span>
        ptr: <a href="std.zig.AstGen.ResultInfo.Loc.PtrResultLoc.html">PtrResultLoc</a>,
        <span class="tok-comment">/// The expression must store its result into this allocation, which has an inferred type.</span>
        <span class="tok-comment">/// The result instruction from the expression must be ignored.</span>
        <span class="tok-comment">/// Always an instruction with tag `alloc_inferred`.</span>
        inferred_ptr: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// The expression has a sequence of pointers to store its results into due to a destructure</span>
        <span class="tok-comment">/// operation. Each of these pointers may or may not have an inferred type.</span>
        destructure: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The AST node of the destructure operation itself.</span>
            src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            <span class="tok-comment">/// The pointers to store results into.</span>
            components: []<span class="tok-kw">const</span> <a href="std.zig.AstGen.ResultInfo.Loc.DestructureComponent.html">DestructureComponent</a>,
        },

        <span class="tok-kw">const</span> DestructureComponent = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            typed_ptr: <a href="std.zig.AstGen.ResultInfo.Loc.PtrResultLoc.html">PtrResultLoc</a>,
            inferred_ptr: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            discard,
        };

        <span class="tok-kw">const</span> PtrResultLoc = <span class="tok-kw">struct</span> {
            inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            src_node: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">null</span>,
        };

        <span class="tok-comment">/// Find the result type for a cast builtin given the result location.</span>
        <span class="tok-comment">/// If the location does not have a known result type, returns `null`.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">resultType</span>(rl: <a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>, gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !?<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (rl) {
                .discard, .none, .ref, .inferred_ptr, .destructure =&gt; <span class="tok-null">null</span>,
                .ty, .coerced_ty =&gt; |ty_ref| ty_ref,
                .ref_coerced_ty =&gt; |ptr_ty| <span class="tok-kw">try</span> gz.addUnNode(.elem_type, ptr_ty, node),
                .ptr =&gt; |ptr| {
                    <span class="tok-kw">const</span> ptr_ty = <span class="tok-kw">try</span> gz.addUnNode(.typeof, ptr.inst, node);
                    <span class="tok-kw">return</span> <span class="tok-kw">try</span> gz.addUnNode(.elem_type, ptr_ty, node);
                },
            };
        }

        <span class="tok-comment">/// Find the result type for a cast builtin given the result location.</span>
        <span class="tok-comment">/// If the location does not have a known result type, emits an error on</span>
        <span class="tok-comment">/// the given node.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">resultTypeForCast</span>(rl: <a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>, gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, builtin_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
            <span class="tok-kw">const</span> astgen = gz.astgen;
            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> rl.resultType(gz, node)) |ty| <span class="tok-kw">return</span> ty;
            <span class="tok-kw">switch</span> (rl) {
                .destructure =&gt; |destructure| <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;{s} must have a known result type&quot;</span>, .{builtin_name}, &amp;.{
                    <span class="tok-kw">try</span> astgen.errNoteNode(destructure.src_node, <span class="tok-str">&quot;destructure expressions do not provide a single result type&quot;</span>, .{}),
                    <span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;use @as to provide explicit result type&quot;</span>, .{}),
                }),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;{s} must have a known result type&quot;</span>, .{builtin_name}, &amp;.{
                    <span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;use @as to provide explicit result type&quot;</span>, .{}),
                }),
            }
        }
    };

    <span class="tok-kw">const</span> Context = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// The expression is the operand to a return expression.</span>
        @&quot;return&quot;,
        <span class="tok-comment">/// The expression is the input to an error-handling operator (if-else, try, or catch).</span>
        error_handling_expr,
        <span class="tok-comment">/// The expression is the right-hand side of a shift operation.</span>
        shift_op,
        <span class="tok-comment">/// The expression is an argument in a function call.</span>
        fn_arg,
        <span class="tok-comment">/// The expression is the right-hand side of an initializer for a `const` variable</span>
        const_init,
        <span class="tok-comment">/// The expression is the right-hand side of an assignment expression.</span>
        assignment,
        <span class="tok-comment">/// No specific operator in particular.</span>
        none,
    };
};

<span class="tok-kw">const</span> coerced_align_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .{ .coerced_ty = .u29_type } };
<span class="tok-kw">const</span> coerced_linksection_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .{ .coerced_ty = .slice_const_u8_type } };
<span class="tok-kw">const</span> coerced_type_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .{ .coerced_ty = .type_type } };
<span class="tok-kw">const</span> coerced_bool_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .{ .coerced_ty = .bool_type } };

<span class="tok-kw">fn</span> <span class="tok-fn">typeExpr</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, type_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_type_ri">coerced_type_ri</a>, type_node, .<span class="tok-type">type</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">reachableTypeExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    type_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    reachable_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExprComptime">reachableExprComptime</a>(gz, scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_type_ri">coerced_type_ri</a>, type_node, reachable_node, .<span class="tok-type">type</span>);
}

<span class="tok-comment">/// Same as `expr` but fails with a compile error if the result type is `noreturn`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">reachableExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    reachable_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExprComptime">reachableExprComptime</a>(gz, scope, ri, node, reachable_node, <span class="tok-null">null</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">reachableExprComptime</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    reachable_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-comment">/// If `null`, the expression is not evaluated in a comptime context.</span>
    comptime_reason: ?<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.SimpleComptimeReason.html">SimpleComptimeReason</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> result_inst = <span class="tok-kw">if</span> (comptime_reason) |r|
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, ri, node, r)
    <span class="tok-kw">else</span>
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, ri, node);

    <span class="tok-kw">if</span> (gz.refIsNoReturn(result_inst)) {
        <span class="tok-kw">try</span> gz.astgen.appendErrorNodeNotes(reachable_node, <span class="tok-str">&quot;unreachable code&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{
            <span class="tok-kw">try</span> gz.astgen.errNoteNode(node, <span class="tok-str">&quot;control flow is diverted here&quot;</span>, .{}),
        });
    }
    <span class="tok-kw">return</span> result_inst;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lvalExpr</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">switch</span> (node_tags[node]) {
        .root =&gt; <span class="tok-kw">unreachable</span>,
        .@&quot;usingnamespace&quot; =&gt; <span class="tok-kw">unreachable</span>,
        .test_decl =&gt; <span class="tok-kw">unreachable</span>,
        .global_var_decl =&gt; <span class="tok-kw">unreachable</span>,
        .local_var_decl =&gt; <span class="tok-kw">unreachable</span>,
        .simple_var_decl =&gt; <span class="tok-kw">unreachable</span>,
        .aligned_var_decl =&gt; <span class="tok-kw">unreachable</span>,
        .switch_case =&gt; <span class="tok-kw">unreachable</span>,
        .switch_case_inline =&gt; <span class="tok-kw">unreachable</span>,
        .switch_case_one =&gt; <span class="tok-kw">unreachable</span>,
        .switch_case_inline_one =&gt; <span class="tok-kw">unreachable</span>,
        .container_field_init =&gt; <span class="tok-kw">unreachable</span>,
        .container_field_align =&gt; <span class="tok-kw">unreachable</span>,
        .container_field =&gt; <span class="tok-kw">unreachable</span>,
        .asm_output =&gt; <span class="tok-kw">unreachable</span>,
        .asm_input =&gt; <span class="tok-kw">unreachable</span>,

        .assign,
        .assign_destructure,
        .assign_bit_and,
        .assign_bit_or,
        .assign_shl,
        .assign_shl_sat,
        .assign_shr,
        .assign_bit_xor,
        .assign_div,
        .assign_sub,
        .assign_sub_wrap,
        .assign_sub_sat,
        .assign_mod,
        .assign_add,
        .assign_add_wrap,
        .assign_add_sat,
        .assign_mul,
        .assign_mul_wrap,
        .assign_mul_sat,
        .add,
        .add_wrap,
        .add_sat,
        .sub,
        .sub_wrap,
        .sub_sat,
        .mul,
        .mul_wrap,
        .mul_sat,
        .div,
        .mod,
        .bit_and,
        .bit_or,
        .shl,
        .shl_sat,
        .shr,
        .bit_xor,
        .bang_equal,
        .equal_equal,
        .greater_than,
        .greater_or_equal,
        .less_than,
        .less_or_equal,
        .array_cat,
        .array_mult,
        .bool_and,
        .bool_or,
        .@&quot;asm&quot;,
        .asm_simple,
        .string_literal,
        .number_literal,
        .call,
        .call_comma,
        .async_call,
        .async_call_comma,
        .call_one,
        .call_one_comma,
        .async_call_one,
        .async_call_one_comma,
        .unreachable_literal,
        .@&quot;return&quot;,
        .@&quot;if&quot;,
        .if_simple,
        .@&quot;while&quot;,
        .while_simple,
        .while_cont,
        .bool_not,
        .address_of,
        .optional_type,
        .block,
        .block_semicolon,
        .block_two,
        .block_two_semicolon,
        .@&quot;break&quot;,
        .ptr_type_aligned,
        .ptr_type_sentinel,
        .ptr_type,
        .ptr_type_bit_range,
        .array_type,
        .array_type_sentinel,
        .enum_literal,
        .multiline_string_literal,
        .char_literal,
        .@&quot;defer&quot;,
        .@&quot;errdefer&quot;,
        .@&quot;catch&quot;,
        .error_union,
        .merge_error_sets,
        .switch_range,
        .for_range,
        .@&quot;await&quot;,
        .bit_not,
        .negation,
        .negation_wrap,
        .@&quot;resume&quot;,
        .@&quot;try&quot;,
        .slice,
        .slice_open,
        .slice_sentinel,
        .array_init_one,
        .array_init_one_comma,
        .array_init_dot_two,
        .array_init_dot_two_comma,
        .array_init_dot,
        .array_init_dot_comma,
        .array_init,
        .array_init_comma,
        .struct_init_one,
        .struct_init_one_comma,
        .struct_init_dot_two,
        .struct_init_dot_two_comma,
        .struct_init_dot,
        .struct_init_dot_comma,
        .struct_init,
        .struct_init_comma,
        .@&quot;switch&quot;,
        .switch_comma,
        .@&quot;for&quot;,
        .for_simple,
        .@&quot;suspend&quot;,
        .@&quot;continue&quot;,
        .fn_proto_simple,
        .fn_proto_multi,
        .fn_proto_one,
        .fn_proto,
        .fn_decl,
        .anyframe_type,
        .anyframe_literal,
        .error_set_decl,
        .container_decl,
        .container_decl_trailing,
        .container_decl_two,
        .container_decl_two_trailing,
        .container_decl_arg,
        .container_decl_arg_trailing,
        .tagged_union,
        .tagged_union_trailing,
        .tagged_union_two,
        .tagged_union_two_trailing,
        .tagged_union_enum_tag,
        .tagged_union_enum_tag_trailing,
        .@&quot;comptime&quot;,
        .@&quot;nosuspend&quot;,
        .error_value,
        =&gt; <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;invalid left-hand side to assignment&quot;</span>, .{}),

        .builtin_call,
        .builtin_call_comma,
        .builtin_call_two,
        .builtin_call_two_comma,
        =&gt; {
            <span class="tok-kw">const</span> builtin_token = main_tokens[node];
            <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);<span class="tok-comment">
            // If the builtin is an invalid name, we don't cause an error here; instead
            // let it pass, and the error will be &quot;invalid builtin function&quot; later.
            </span><span class="tok-kw">if</span> (<a href="std.zig.BuiltinFn.html">BuiltinFn</a>.<a href="std.zig.BuiltinFn.html#std.zig.BuiltinFn.list">list</a>.<a href="#">get</a>(builtin_name)) |info| {
                <span class="tok-kw">if</span> (!info.allows_lvalue) {
                    <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;invalid left-hand side to assignment&quot;</span>, .{});
                }
            }
        },<span class="tok-comment">

        // These can be assigned to.
        </span>.unwrap_optional,
        .deref,
        .field_access,
        .array_access,
        .identifier,
        .grouped_expression,
        .@&quot;orelse&quot;,
        =&gt; {},
    }
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, node);
}

<span class="tok-comment">/// Turn Zig AST into untyped ZIR instructions.</span>
<span class="tok-comment">/// When `rl` is discard, ptr, inferred_ptr, or inferred_ptr, the</span>
<span class="tok-comment">/// result instruction can be used to inspect whether it is isNoReturn() but that is it,</span>
<span class="tok-comment">/// it must otherwise not be used.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">expr</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);

    <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;
    <span class="tok-kw">defer</span> gz.anon_name_strategy = prev_anon_name_strategy;
    <span class="tok-kw">if</span> (!<a href="std.zig.AstGen.html#std.zig.AstGen.nodeUsesAnonNameStrategy">nodeUsesAnonNameStrategy</a>(tree, node)) {
        gz.anon_name_strategy = .anon;
    }

    <span class="tok-kw">switch</span> (node_tags[node]) {
        .root =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Top-level declaration.
        </span>.@&quot;usingnamespace&quot; =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Top-level declaration.
        </span>.test_decl =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Top-level declaration.
        </span>.container_field_init =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Top-level declaration.
        </span>.container_field_align =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Top-level declaration.
        </span>.container_field =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Top-level declaration.
        </span>.fn_decl =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Top-level declaration.

        </span>.global_var_decl =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `blockExpr`.
        </span>.local_var_decl =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `blockExpr`.
        </span>.simple_var_decl =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `blockExpr`.
        </span>.aligned_var_decl =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `blockExpr`.
        </span>.@&quot;defer&quot; =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `blockExpr`.
        </span>.@&quot;errdefer&quot; =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `blockExpr`.

        </span>.switch_case =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `switchExpr`.
        </span>.switch_case_inline =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `switchExpr`.
        </span>.switch_case_one =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `switchExpr`.
        </span>.switch_case_inline_one =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `switchExpr`.
        </span>.switch_range =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `switchExpr`.

        </span>.asm_output =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `asmExpr`.
        </span>.asm_input =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `asmExpr`.

        </span>.for_range =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Handled in `forExpr`.

        </span>.assign =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assign">assign</a>(gz, scope, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },

        .assign_destructure =&gt; {<span class="tok-comment">
            // Note that this variant does not declare any new var/const: that
            // variant is handled by `blockExprStmts`.
            </span><span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignDestructure">assignDestructure</a>(gz, scope, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },

        .assign_shl =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignShift">assignShift</a>(gz, scope, node, .shl);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_shl_sat =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignShiftSat">assignShiftSat</a>(gz, scope, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_shr =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignShift">assignShift</a>(gz, scope, node, .shr);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },

        .assign_bit_and =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .bit_and);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_bit_or =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .bit_or);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_bit_xor =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .xor);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_div =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .div);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_sub =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .sub);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_sub_wrap =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .subwrap);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_sub_sat =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .sub_sat);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_mod =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .mod_rem);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_add =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .add);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_add_wrap =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .addwrap);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_add_sat =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .add_sat);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_mul =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .mul);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_mul_wrap =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .mulwrap);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .assign_mul_sat =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, node, .mul_sat);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },<span class="tok-comment">

        // zig fmt: off
        </span>.shl =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.shiftOp">shiftOp</a>(gz, scope, ri, node, node_datas[node].lhs, node_datas[node].rhs, .shl),
        .shr =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.shiftOp">shiftOp</a>(gz, scope, ri, node, node_datas[node].lhs, node_datas[node].rhs, .shr),

        .add      =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .add),
        .add_wrap =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .addwrap),
        .add_sat  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .add_sat),
        .sub      =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .sub),
        .sub_wrap =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .subwrap),
        .sub_sat  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .sub_sat),
        .mul      =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .mul),
        .mul_wrap =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .mulwrap),
        .mul_sat  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .mul_sat),
        .div      =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .div),
        .mod      =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .mod_rem),
        .shl_sat  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .shl_sat),

        .bit_and          =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .bit_and),
        .bit_or           =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .bit_or),
        .bit_xor          =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .xor),
        .bang_equal       =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .cmp_neq),
        .equal_equal      =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .cmp_eq),
        .greater_than     =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .cmp_gt),
        .greater_or_equal =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .cmp_gte),
        .less_than        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .cmp_lt),
        .less_or_equal    =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .cmp_lte),
        .array_cat        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleBinOp">simpleBinOp</a>(gz, scope, ri, node, .array_cat),

        .array_mult =&gt; {<span class="tok-comment">
            // This syntax form does not currently use the result type in the language specification.
            // However, the result type can be used to emit more optimal code for large multiplications by
            // having Sema perform a coercion before the multiplication operation.
            </span><span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.array_mul, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ArrayMul.html">ArrayMul</a>{
                .res_ty = <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)) |t| t <span class="tok-kw">else</span> .none,
                .lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node_datas[node].lhs),
                .rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[node].rhs, .array_mul_factor),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },

        .error_union, .merge_error_sets =&gt; |tag| {
            <span class="tok-kw">const</span> inst_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (tag) {
                .error_union =&gt; .error_union_type,
                .merge_error_sets =&gt; .merge_error_sets,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            };
            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableTypeExpr">reachableTypeExpr</a>(gz, scope, node_datas[node].lhs, node);
            <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableTypeExpr">reachableTypeExpr</a>(gz, scope, node_datas[node].rhs, node);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(inst_tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{ .lhs = lhs, .rhs = rhs });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },

        .bool_and =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.boolBinOp">boolBinOp</a>(gz, scope, ri, node, .bool_br_and),
        .bool_or  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.boolBinOp">boolBinOp</a>(gz, scope, ri, node, .bool_br_or),

        .bool_not =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_bool_ri">coerced_bool_ri</a>, node_datas[node].lhs, .bool_not),
        .bit_not  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none }, node_datas[node].lhs, .bit_not),

        .negation      =&gt; <span class="tok-kw">return</span>   <a href="std.zig.AstGen.html#std.zig.AstGen.negation">negation</a>(gz, scope, ri, node),
        .negation_wrap =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none }, node_datas[node].lhs, .negate_wrap),

        .identifier =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.identifier">identifier</a>(gz, scope, ri, node, <span class="tok-null">null</span>),

        .asm_simple,
        .@&quot;asm&quot;,
        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.asmExpr">asmExpr</a>(gz, scope, ri, node, tree.fullAsm(node).?),

        .string_literal           =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.stringLiteral">stringLiteral</a>(gz, ri, node),
        .multiline_string_literal =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.multilineStringLiteral">multilineStringLiteral</a>(gz, ri, node),

        .number_literal =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.numberLiteral">numberLiteral</a>(gz, ri, node, node, .positive),<span class="tok-comment">
        // zig fmt: on

        </span>.builtin_call_two, .builtin_call_two_comma =&gt; {
            <span class="tok-kw">if</span> (node_datas[node].lhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> params = [_]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>{};
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.builtinCall">builtinCall</a>(gz, scope, ri, node, &amp;params, <span class="tok-null">false</span>);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (node_datas[node].rhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> params = [_]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>{node_datas[node].lhs};
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.builtinCall">builtinCall</a>(gz, scope, ri, node, &amp;params, <span class="tok-null">false</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> params = [_]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>{ node_datas[node].lhs, node_datas[node].rhs };
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.builtinCall">builtinCall</a>(gz, scope, ri, node, &amp;params, <span class="tok-null">false</span>);
            }
        },
        .builtin_call, .builtin_call_comma =&gt; {
            <span class="tok-kw">const</span> params = tree.extra_data[node_datas[node].lhs..node_datas[node].rhs];
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.builtinCall">builtinCall</a>(gz, scope, ri, node, params, <span class="tok-null">false</span>);
        },

        .call_one,
        .call_one_comma,
        .async_call_one,
        .async_call_one_comma,
        .call,
        .call_comma,
        .async_call,
        .async_call_comma,
        =&gt; {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.callExpr">callExpr</a>(gz, scope, ri, .none, node, tree.fullCall(&amp;buf, node).?);
        },

        .unreachable_literal =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, node);
            _ = <span class="tok-kw">try</span> gz.addAsIndex(.{
                .tag = .@&quot;unreachable&quot;,
                .data = .{ .@&quot;unreachable&quot; = .{
                    .src_node = gz.nodeIndexToRelative(node),
                } },
            });
            <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
        },
        .@&quot;return&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.ret">ret</a>(gz, scope, node),
        .field_access =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fieldAccess">fieldAccess</a>(gz, scope, ri, node),

        .if_simple,
        .@&quot;if&quot;,
        =&gt; {
            <span class="tok-kw">const</span> if_full = tree.fullIf(node).?;
            no_switch_on_err: {
                <span class="tok-kw">const</span> error_token = if_full.error_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">const</span> full_switch = tree.fullSwitch(if_full.ast.else_expr) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">if</span> (full_switch.label_token != <span class="tok-null">null</span>) <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">if</span> (node_tags[full_switch.ast.condition] != .identifier) <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(error_token), tree.tokenSlice(main_tokens[full_switch.ast.condition]))) <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.switchExprErrUnion">switchExprErrUnion</a>(gz, scope, ri.br(), node, .@&quot;if&quot;);
            }
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.ifExpr">ifExpr</a>(gz, scope, ri.br(), node, if_full);
        },

        .while_simple,
        .while_cont,
        .@&quot;while&quot;,
        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.whileExpr">whileExpr</a>(gz, scope, ri.br(), node, tree.fullWhile(node).?, <span class="tok-null">false</span>),

        .for_simple, .@&quot;for&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.forExpr">forExpr</a>(gz, scope, ri.br(), node, tree.fullFor(node).?, <span class="tok-null">false</span>),

        .slice_open,
        .slice,
        .slice_sentinel,
        =&gt; {
            <span class="tok-kw">const</span> full = tree.fullSlice(node).?;
            <span class="tok-kw">if</span> (full.ast.end != <span class="tok-number">0</span> <span class="tok-kw">and</span>
                node_tags[full.ast.sliced] == .slice_open <span class="tok-kw">and</span>
                <a href="std.zig.AstGen.html#std.zig.AstGen.nodeIsTriviallyZero">nodeIsTriviallyZero</a>(tree, full.ast.start))
            {
                <span class="tok-kw">const</span> lhs_extra = tree.sliceOpen(full.ast.sliced).ast;

                <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, lhs_extra.sliced);
                <span class="tok-kw">const</span> start = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, lhs_extra.start);
                <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
                <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, full.ast.end);
                <span class="tok-kw">const</span> sentinel = <span class="tok-kw">if</span> (full.ast.sentinel != <span class="tok-number">0</span>) <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, full.ast.sentinel) <span class="tok-kw">else</span> .none;
                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_length, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SliceLength.html">SliceLength</a>{
                    .lhs = lhs,
                    .start = start,
                    .len = len,
                    .start_src_node_offset = gz.nodeIndexToRelative(full.ast.sliced),
                    .sentinel = sentinel,
                });
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
            }
            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, full.ast.sliced);

            <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
            <span class="tok-kw">const</span> start = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, full.ast.start);
            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (full.ast.end != <span class="tok-number">0</span>) <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, full.ast.end) <span class="tok-kw">else</span> .none;
            <span class="tok-kw">const</span> sentinel = <span class="tok-kw">if</span> (full.ast.sentinel != <span class="tok-number">0</span>) s: {
                <span class="tok-kw">const</span> sentinel_ty = <span class="tok-kw">try</span> gz.addUnNode(.slice_sentinel_ty, lhs, node);
                <span class="tok-kw">break</span> :s <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = sentinel_ty } }, full.ast.sentinel);
            } <span class="tok-kw">else</span> .none;
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
            <span class="tok-kw">if</span> (sentinel != .none) {
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_sentinel, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SliceSentinel.html">SliceSentinel</a>{
                    .lhs = lhs,
                    .start = start,
                    .end = end,
                    .sentinel = sentinel,
                });
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (end != .none) {
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_end, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SliceEnd.html">SliceEnd</a>{
                    .lhs = lhs,
                    .start = start,
                    .end = end,
                });
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_start, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SliceStart.html">SliceStart</a>{
                    .lhs = lhs,
                    .start = start,
                });
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
            }
        },

        .deref =&gt; {
            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node_datas[node].lhs);
            _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_deref, lhs, node);
            <span class="tok-kw">switch</span> (ri.rl) {
                .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> lhs,
                <span class="tok-kw">else</span> =&gt; {
                    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.load, lhs, node);
                    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
                },
            }
        },
        .address_of =&gt; {
            <span class="tok-kw">const</span> operand_rl: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a> = <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)) |res_ty_inst| rl: {
                _ = <span class="tok-kw">try</span> gz.addUnTok(.validate_ref_ty, res_ty_inst, tree.firstToken(node));
                <span class="tok-kw">break</span> :rl .{ .ref_coerced_ty = res_ty_inst };
            } <span class="tok-kw">else</span> .ref;
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = operand_rl }, node_datas[node].lhs);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .optional_type =&gt; {
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, node_datas[node].lhs);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.optional_type, operand, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .unwrap_optional =&gt; <span class="tok-kw">switch</span> (ri.rl) {
            .ref, .ref_coerced_ty =&gt; {
                <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, node_datas[node].lhs);

                <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);

                <span class="tok-kw">return</span> gz.addUnNode(.optional_payload_safe_ptr, lhs, node);
            },
            <span class="tok-kw">else</span> =&gt; {
                <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node_datas[node].lhs);

                <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);

                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addUnNode(.optional_payload_safe, lhs, node), node);
            },
        },
        .block_two, .block_two_semicolon =&gt; {
            <span class="tok-kw">const</span> statements = [<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>{ node_datas[node].lhs, node_datas[node].rhs };
            <span class="tok-kw">if</span> (node_datas[node].lhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExpr">blockExpr</a>(gz, scope, ri, node, statements[<span class="tok-number">0</span>..<span class="tok-number">0</span>], .normal);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (node_datas[node].rhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExpr">blockExpr</a>(gz, scope, ri, node, statements[<span class="tok-number">0</span>..<span class="tok-number">1</span>], .normal);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExpr">blockExpr</a>(gz, scope, ri, node, statements[<span class="tok-number">0</span>..<span class="tok-number">2</span>], .normal);
            }
        },
        .block, .block_semicolon =&gt; {
            <span class="tok-kw">const</span> statements = tree.extra_data[node_datas[node].lhs..node_datas[node].rhs];
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExpr">blockExpr</a>(gz, scope, ri, node, statements, .normal);
        },
        .enum_literal =&gt; <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)) |res_ty| {
            <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(main_tokens[node]);
            <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> gz.addPlNode(.decl_literal, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Field.html">Field</a>{
                .lhs = res_ty,
                .field_name_start = str_index,
            });
            <span class="tok-kw">switch</span> (ri.rl) {
                .discard, .none, .ref =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // no result type
                </span>.ty, .coerced_ty =&gt; <span class="tok-kw">return</span> res,<span class="tok-comment"> // `decl_literal` does the coercion for us
                </span>.ref_coerced_ty, .ptr, .inferred_ptr, .destructure =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, res, node),
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleStrTok">simpleStrTok</a>(gz, ri, main_tokens[node], node, .enum_literal),
        .error_value =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleStrTok">simpleStrTok</a>(gz, ri, node_datas[node].rhs, node, .error_value),<span class="tok-comment">
        // TODO restore this when implementing https://github.com/ziglang/zig/issues/6025
        // .anyframe_literal =&gt; return rvalue(gz, ri, .anyframe_type, node),
        </span>.anyframe_literal =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.anyframe_type, .void_type, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .anyframe_type =&gt; {
            <span class="tok-kw">const</span> return_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, node_datas[node].rhs);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.anyframe_type, return_type, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .@&quot;catch&quot; =&gt; {
            <span class="tok-kw">const</span> catch_token = main_tokens[node];
            <span class="tok-kw">const</span> payload_token: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-kw">if</span> (token_tags[catch_token + <span class="tok-number">1</span>] == .pipe)
                catch_token + <span class="tok-number">2</span>
            <span class="tok-kw">else</span>
                <span class="tok-null">null</span>;
            no_switch_on_err: {
                <span class="tok-kw">const</span> capture_token = payload_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">const</span> full_switch = tree.fullSwitch(node_datas[node].rhs) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">if</span> (full_switch.label_token != <span class="tok-null">null</span>) <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">if</span> (node_tags[full_switch.ast.condition] != .identifier) <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(capture_token), tree.tokenSlice(main_tokens[full_switch.ast.condition]))) <span class="tok-kw">break</span> :no_switch_on_err;
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.switchExprErrUnion">switchExprErrUnion</a>(gz, scope, ri.br(), node, .@&quot;catch&quot;);
            }
            <span class="tok-kw">switch</span> (ri.rl) {
                .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.orelseCatchExpr">orelseCatchExpr</a>(
                    gz,
                    scope,
                    ri,
                    node,
                    node_datas[node].lhs,
                    .is_non_err_ptr,
                    .err_union_payload_unsafe_ptr,
                    .err_union_code_ptr,
                    node_datas[node].rhs,
                    payload_token,
                ),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.orelseCatchExpr">orelseCatchExpr</a>(
                    gz,
                    scope,
                    ri,
                    node,
                    node_datas[node].lhs,
                    .is_non_err,
                    .err_union_payload_unsafe,
                    .err_union_code,
                    node_datas[node].rhs,
                    payload_token,
                ),
            }
        },
        .@&quot;orelse&quot; =&gt; <span class="tok-kw">switch</span> (ri.rl) {
            .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.orelseCatchExpr">orelseCatchExpr</a>(
                gz,
                scope,
                ri,
                node,
                node_datas[node].lhs,
                .is_non_null_ptr,
                .optional_payload_unsafe_ptr,
                <span class="tok-null">undefined</span>,
                node_datas[node].rhs,
                <span class="tok-null">null</span>,
            ),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.orelseCatchExpr">orelseCatchExpr</a>(
                gz,
                scope,
                ri,
                node,
                node_datas[node].lhs,
                .is_non_null,
                .optional_payload_unsafe,
                <span class="tok-null">undefined</span>,
                node_datas[node].rhs,
                <span class="tok-null">null</span>,
            ),
        },

        .ptr_type_aligned,
        .ptr_type_sentinel,
        .ptr_type,
        .ptr_type_bit_range,
        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.ptrType">ptrType</a>(gz, scope, ri, node, tree.fullPtrType(node).?),

        .container_decl,
        .container_decl_trailing,
        .container_decl_arg,
        .container_decl_arg_trailing,
        .container_decl_two,
        .container_decl_two_trailing,
        .tagged_union,
        .tagged_union_trailing,
        .tagged_union_enum_tag,
        .tagged_union_enum_tag_trailing,
        .tagged_union_two,
        .tagged_union_two_trailing,
        =&gt; {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.containerDecl">containerDecl</a>(gz, scope, ri, node, tree.fullContainerDecl(&amp;buf, node).?);
        },

        .@&quot;break&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.breakExpr">breakExpr</a>(gz, scope, node),
        .@&quot;continue&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.continueExpr">continueExpr</a>(gz, scope, node),
        .grouped_expression =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, ri, node_datas[node].lhs),
        .array_type =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayType">arrayType</a>(gz, scope, ri, node),
        .array_type_sentinel =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayTypeSentinel">arrayTypeSentinel</a>(gz, scope, ri, node),
        .char_literal =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.charLiteral">charLiteral</a>(gz, ri, node),
        .error_set_decl =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.errorSetDecl">errorSetDecl</a>(gz, ri, node),
        .array_access =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayAccess">arrayAccess</a>(gz, scope, ri, node),
        .@&quot;comptime&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExprAst">comptimeExprAst</a>(gz, scope, ri, node),
        .@&quot;switch&quot;, .switch_comma =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.switchExpr">switchExpr</a>(gz, scope, ri.br(), node, tree.fullSwitch(node).?),

        .@&quot;nosuspend&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.nosuspendExpr">nosuspendExpr</a>(gz, scope, ri, node),
        .@&quot;suspend&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.suspendExpr">suspendExpr</a>(gz, scope, node),
        .@&quot;await&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.awaitExpr">awaitExpr</a>(gz, scope, ri, node),
        .@&quot;resume&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.resumeExpr">resumeExpr</a>(gz, scope, ri, node),

        .@&quot;try&quot; =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.tryExpr">tryExpr</a>(gz, scope, ri, node, node_datas[node].lhs),

        .array_init_one,
        .array_init_one_comma,
        .array_init_dot_two,
        .array_init_dot_two_comma,
        .array_init_dot,
        .array_init_dot_comma,
        .array_init,
        .array_init_comma,
        =&gt; {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExpr">arrayInitExpr</a>(gz, scope, ri, node, tree.fullArrayInit(&amp;buf, node).?);
        },

        .struct_init_one,
        .struct_init_one_comma,
        .struct_init_dot_two,
        .struct_init_dot_two_comma,
        .struct_init_dot,
        .struct_init_dot_comma,
        .struct_init,
        .struct_init_comma,
        =&gt; {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExpr">structInitExpr</a>(gz, scope, ri, node, tree.fullStructInit(&amp;buf, node).?);
        },

        .fn_proto_simple,
        .fn_proto_multi,
        .fn_proto_one,
        .fn_proto,
        =&gt; {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fnProtoExpr">fnProtoExpr</a>(gz, scope, ri, node, tree.fullFnProto(&amp;buf, node).?);
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">nosuspendExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> body_node = node_datas[node].lhs;
    <a href="std.debug.html#std.debug.assert">assert</a>(body_node != <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (gz.nosuspend_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">try</span> astgen.appendErrorNodeNotes(node, <span class="tok-str">&quot;redundant nosuspend block&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{
            <span class="tok-kw">try</span> astgen.errNoteNode(gz.nosuspend_node, <span class="tok-str">&quot;other nosuspend block here&quot;</span>, .{}),
        });
    }
    gz.nosuspend_node = node;
    <span class="tok-kw">defer</span> gz.nosuspend_node = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, ri, body_node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">suspendExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> body_node = node_datas[node].lhs;

    <span class="tok-kw">if</span> (gz.nosuspend_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;suspend inside nosuspend block&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{
            <span class="tok-kw">try</span> astgen.errNoteNode(gz.nosuspend_node, <span class="tok-str">&quot;nosuspend block here&quot;</span>, .{}),
        });
    }
    <span class="tok-kw">if</span> (gz.suspend_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot suspend inside suspend block&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{
            <span class="tok-kw">try</span> astgen.errNoteNode(gz.suspend_node, <span class="tok-str">&quot;other suspend block here&quot;</span>, .{}),
        });
    }
    <a href="std.debug.html#std.debug.assert">assert</a>(body_node != <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> suspend_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.suspend_block, node);
    <span class="tok-kw">try</span> gz.instructions.append(gpa, suspend_inst);

    <span class="tok-kw">var</span> suspend_scope = gz.makeSubBlock(scope);
    suspend_scope.suspend_node = node;
    <span class="tok-kw">defer</span> suspend_scope.unstack();

    <span class="tok-kw">const</span> body_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;suspend_scope, &amp;suspend_scope.base, .{ .rl = .none }, body_node, .normal);
    <span class="tok-kw">if</span> (!gz.refIsNoReturn(body_result)) {
        _ = <span class="tok-kw">try</span> suspend_scope.addBreak(.break_inline, suspend_inst, .void_value);
    }
    <span class="tok-kw">try</span> suspend_scope.setBlockBody(suspend_inst);

    <span class="tok-kw">return</span> suspend_inst.toRef();
}

<span class="tok-kw">fn</span> <span class="tok-fn">awaitExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> rhs_node = node_datas[node].lhs;

    <span class="tok-kw">if</span> (gz.suspend_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot await inside suspend block&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{
            <span class="tok-kw">try</span> astgen.errNoteNode(gz.suspend_node, <span class="tok-str">&quot;suspend block here&quot;</span>, .{}),
        });
    }
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, rhs_node);
    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (gz.nosuspend_node != <span class="tok-number">0</span>)
        <span class="tok-kw">try</span> gz.addExtendedPayload(.await_nosuspend, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
            .node = gz.nodeIndexToRelative(node),
            .operand = operand,
        })
    <span class="tok-kw">else</span>
        <span class="tok-kw">try</span> gz.addUnNode(.@&quot;await&quot;, operand, node);

    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">resumeExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> rhs_node = node_datas[node].lhs;
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, rhs_node);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.@&quot;resume&quot;, operand, node);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">fnProtoExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    fn_proto: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">if</span> (fn_proto.name_token) |some| {
        <span class="tok-kw">return</span> astgen.failTok(some, <span class="tok-str">&quot;function type cannot have a name&quot;</span>, .{});
    }

    <span class="tok-kw">if</span> (fn_proto.ast.align_expr != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNode(fn_proto.ast.align_expr, <span class="tok-str">&quot;function type cannot have an alignment&quot;</span>, .{});
    }

    <span class="tok-kw">if</span> (fn_proto.ast.addrspace_expr != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNode(fn_proto.ast.addrspace_expr, <span class="tok-str">&quot;function type cannot have an addrspace&quot;</span>, .{});
    }

    <span class="tok-kw">if</span> (fn_proto.ast.section_expr != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNode(fn_proto.ast.section_expr, <span class="tok-str">&quot;function type cannot have a linksection&quot;</span>, .{});
    }

    <span class="tok-kw">const</span> maybe_bang = tree.firstToken(fn_proto.ast.return_type) - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> is_inferred_error = token_tags[maybe_bang] == .bang;
    <span class="tok-kw">if</span> (is_inferred_error) {
        <span class="tok-kw">return</span> astgen.failTok(maybe_bang, <span class="tok-str">&quot;function type cannot have an inferred error set&quot;</span>, .{});
    }

    <span class="tok-kw">const</span> is_extern = blk: {
        <span class="tok-kw">const</span> maybe_extern_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :blk token_tags[maybe_extern_token] == .keyword_extern;
    };
    <a href="std.debug.html#std.debug.assert">assert</a>(!is_extern);

    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fnProtoExprInner">fnProtoExprInner</a>(gz, scope, ri, node, fn_proto, <span class="tok-null">false</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">fnProtoExprInner</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    fn_proto: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a>,
    implicit_ccc: <span class="tok-type">bool</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> block_scope.unstack();

    <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_inline, node);

    <span class="tok-kw">var</span> noalias_bits: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> is_var_args = is_var_args: {
        <span class="tok-kw">var</span> param_type_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> it = fn_proto.iterate(tree);
        <span class="tok-kw">while</span> (it.next()) |param| : (param_type_i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> is_comptime = <span class="tok-kw">if</span> (param.comptime_noalias) |token| <span class="tok-kw">switch</span> (token_tags[token]) {
                .keyword_noalias =&gt; is_comptime: {
                    noalias_bits |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>) &lt;&lt; (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u5</span>, param_type_i) <span class="tok-kw">orelse</span>
                        <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;this compiler implementation only supports 'noalias' on the first 32 parameters&quot;</span>, .{}));
                    <span class="tok-kw">break</span> :is_comptime <span class="tok-null">false</span>;
                },
                .keyword_comptime =&gt; <span class="tok-null">true</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
            } <span class="tok-kw">else</span> <span class="tok-null">false</span>;

            <span class="tok-kw">const</span> is_anytype = <span class="tok-kw">if</span> (param.anytype_ellipsis3) |token| blk: {
                <span class="tok-kw">switch</span> (token_tags[token]) {
                    .keyword_anytype =&gt; <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>,
                    .ellipsis3 =&gt; <span class="tok-kw">break</span> :is_var_args <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            } <span class="tok-kw">else</span> <span class="tok-null">false</span>;

            <span class="tok-kw">const</span> param_name = <span class="tok-kw">if</span> (param.name_token) |name_token| blk: {
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, tree.tokenSlice(name_token)))
                    <span class="tok-kw">break</span> :blk .empty;

                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> astgen.identAsString(name_token);
            } <span class="tok-kw">else</span> .empty;

            <span class="tok-kw">if</span> (is_anytype) {
                <span class="tok-kw">const</span> name_token = param.name_token <span class="tok-kw">orelse</span> param.anytype_ellipsis3.?;

                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_comptime)
                    .param_anytype_comptime
                <span class="tok-kw">else</span>
                    .param_anytype;
                _ = <span class="tok-kw">try</span> block_scope.addStrTok(tag, param_name, name_token);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> param_type_node = param.type_expr;
                <a href="std.debug.html#std.debug.assert">assert</a>(param_type_node != <span class="tok-number">0</span>);
                <span class="tok-kw">var</span> param_gz = block_scope.makeSubBlock(scope);
                <span class="tok-kw">defer</span> param_gz.unstack();
                param_gz.is_comptime = <span class="tok-null">true</span>;
                <span class="tok-kw">const</span> param_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;param_gz, scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_type_ri">coerced_type_ri</a>, param_type_node, .normal);
                <span class="tok-kw">const</span> param_inst_expected: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len + <span class="tok-number">1</span>);
                _ = <span class="tok-kw">try</span> param_gz.addBreakWithSrcNode(.break_inline, param_inst_expected, param_type, param_type_node);
                <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
                <span class="tok-kw">const</span> name_token = param.name_token <span class="tok-kw">orelse</span> main_tokens[param_type_node];
                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_comptime) .param_comptime <span class="tok-kw">else</span> .param;<span class="tok-comment">
                // We pass `prev_param_insts` as `&amp;.{}` here because a function prototype can't refer to previous
                // arguments (we haven't set up scopes here).
                </span><span class="tok-kw">const</span> param_inst = <span class="tok-kw">try</span> block_scope.addParam(&amp;param_gz, &amp;.{}, <span class="tok-null">false</span>, tag, name_token, param_name);
                <a href="std.debug.html#std.debug.assert">assert</a>(param_inst_expected == param_inst);
            }
        }
        <span class="tok-kw">break</span> :is_var_args <span class="tok-null">false</span>;
    };

    <span class="tok-kw">const</span> cc: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">if</span> (fn_proto.ast.callconv_expr != <span class="tok-number">0</span>)
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(
            &amp;block_scope,
            scope,
            .{ .rl = .{ .coerced_ty = <span class="tok-kw">try</span> block_scope.addBuiltinValue(fn_proto.ast.callconv_expr, .calling_convention) } },
            fn_proto.ast.callconv_expr,
            .@&quot;callconv&quot;,
        )
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (implicit_ccc)
        <span class="tok-kw">try</span> block_scope.addBuiltinValue(node, .calling_convention_c)
    <span class="tok-kw">else</span>
        .none;

    <span class="tok-kw">const</span> ret_ty = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(&amp;block_scope, scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_type_ri">coerced_type_ri</a>, fn_proto.ast.return_type, .function_ret_ty);

    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> block_scope.addFunc(.{
        .src_node = fn_proto.ast.proto_node,

        .cc_ref = cc,
        .cc_gz = <span class="tok-null">null</span>,
        .ret_ref = ret_ty,
        .ret_gz = <span class="tok-null">null</span>,

        .ret_param_refs = &amp;.{},
        .param_insts = &amp;.{},
        .ret_ty_is_generic = <span class="tok-null">false</span>,

        .param_block = block_inst,
        .body_gz = <span class="tok-null">null</span>,
        .is_var_args = is_var_args,
        .is_inferred_error = <span class="tok-null">false</span>,
        .is_noinline = <span class="tok-null">false</span>,
        .noalias_bits = noalias_bits,

        .proto_hash = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ignored for `body_gz == null`
    </span>});

    _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, block_inst, result);
    <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);
    <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, block_inst);

    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, block_inst.toRef(), fn_proto.ast.proto_node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">arrayInitExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    array_init: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);

    <a href="std.debug.html#std.debug.assert">assert</a>(array_init.ast.elements.len != <span class="tok-number">0</span>);<span class="tok-comment"> // Otherwise it would be struct init.

    </span><span class="tok-kw">const</span> array_ty: Zir.Inst.Ref, <span class="tok-kw">const</span> elem_ty: Zir.Inst.Ref = inst: {
        <span class="tok-kw">if</span> (array_init.ast.type_expr == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :inst .{ .none, .none };

        infer: {
            <span class="tok-kw">const</span> array_type: Ast.full.ArrayType = tree.fullArrayType(array_init.ast.type_expr) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :infer;<span class="tok-comment">
            // This intentionally does not support `@&quot;_&quot;` syntax.
            </span><span class="tok-kw">if</span> (node_tags[array_type.ast.elem_count] == .identifier <span class="tok-kw">and</span>
                mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[array_type.ast.elem_count]), <span class="tok-str">&quot;_&quot;</span>))
            {
                <span class="tok-kw">const</span> len_inst = <span class="tok-kw">try</span> gz.addInt(array_init.ast.elements.len);
                <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope, array_type.ast.elem_type);
                <span class="tok-kw">if</span> (array_type.ast.sentinel == <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> array_type_inst = <span class="tok-kw">try</span> gz.addPlNode(.array_type, array_init.ast.type_expr, Zir.Inst.Bin{
                        .lhs = len_inst,
                        .rhs = elem_type,
                    });
                    <span class="tok-kw">break</span> :inst .{ array_type_inst, elem_type };
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .ty = elem_type } }, array_type.ast.sentinel, .array_sentinel);
                    <span class="tok-kw">const</span> array_type_inst = <span class="tok-kw">try</span> gz.addPlNode(
                        .array_type_sentinel,
                        array_init.ast.type_expr,
                        Zir.Inst.ArrayTypeSentinel{
                            .len = len_inst,
                            .elem_type = elem_type,
                            .sentinel = sentinel,
                        },
                    );
                    <span class="tok-kw">break</span> :inst .{ array_type_inst, elem_type };
                }
            }
        }
        <span class="tok-kw">const</span> array_type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, array_init.ast.type_expr);
        _ = <span class="tok-kw">try</span> gz.addPlNode(.validate_array_init_ty, node, Zir.Inst.ArrayInit{
            .ty = array_type_inst,
            .init_count = <span class="tok-builtin">@intCast</span>(array_init.ast.elements.len),
        });
        <span class="tok-kw">break</span> :inst .{ array_type_inst, .none };
    };

    <span class="tok-kw">if</span> (array_ty != .none) {<span class="tok-comment">
        // Typed inits do not use RLS for language simplicity.
        </span><span class="tok-kw">switch</span> (ri.rl) {
            .discard =&gt; {
                <span class="tok-kw">if</span> (elem_ty != .none) {
                    <span class="tok-kw">const</span> elem_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .{ .ty = elem_ty } };
                    <span class="tok-kw">for</span> (array_init.ast.elements) |elem_init| {
                        _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, elem_ri, elem_init);
                    }
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">for</span> (array_init.ast.elements, <span class="tok-number">0</span>..) |elem_init, i| {
                        <span class="tok-kw">const</span> this_elem_ty = <span class="tok-kw">try</span> gz.add(.{
                            .tag = .array_init_elem_type,
                            .data = .{ .bin = .{
                                .lhs = array_ty,
                                .rhs = <span class="tok-builtin">@enumFromInt</span>(i),
                            } },
                        });
                        _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = this_elem_ty } }, elem_init);
                    }
                }
                <span class="tok-kw">return</span> .void_value;
            },
            .ref =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExprTyped">arrayInitExprTyped</a>(gz, scope, node, array_init.ast.elements, array_ty, elem_ty, <span class="tok-null">true</span>),
            <span class="tok-kw">else</span> =&gt; {
                <span class="tok-kw">const</span> array_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExprTyped">arrayInitExprTyped</a>(gz, scope, node, array_init.ast.elements, array_ty, elem_ty, <span class="tok-null">false</span>);
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, array_inst, node);
            },
        }
    }

    <span class="tok-kw">switch</span> (ri.rl) {
        .none =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExprAnon">arrayInitExprAnon</a>(gz, scope, node, array_init.ast.elements),
        .discard =&gt; {
            <span class="tok-kw">for</span> (array_init.ast.elements) |elem_init| {
                _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .discard }, elem_init);
            }
            <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">void_value</a>;
        },
        .ref =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExprAnon">arrayInitExprAnon</a>(gz, scope, node, array_init.ast.elements);
            <span class="tok-kw">return</span> gz.addUnTok(.ref, result, tree.firstToken(node));
        },
        .ref_coerced_ty =&gt; |ptr_ty_inst| {
            <span class="tok-kw">const</span> dest_arr_ty_inst = <span class="tok-kw">try</span> gz.addPlNode(.validate_array_init_ref_ty, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ArrayInitRefTy.html">ArrayInitRefTy</a>{
                .ptr_ty = ptr_ty_inst,
                .elem_count = <span class="tok-builtin">@intCast</span>(array_init.ast.elements.len),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExprTyped">arrayInitExprTyped</a>(gz, scope, node, array_init.ast.elements, dest_arr_ty_inst, .none, <span class="tok-null">true</span>);
        },
        .ty, .coerced_ty =&gt; |result_ty_inst| {
            _ = <span class="tok-kw">try</span> gz.addPlNode(.validate_array_init_result_ty, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ArrayInit.html">ArrayInit</a>{
                .ty = result_ty_inst,
                .init_count = <span class="tok-builtin">@intCast</span>(array_init.ast.elements.len),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExprTyped">arrayInitExprTyped</a>(gz, scope, node, array_init.ast.elements, result_ty_inst, .none, <span class="tok-null">false</span>);
        },
        .ptr =&gt; |ptr| {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExprPtr">arrayInitExprPtr</a>(gz, scope, node, array_init.ast.elements, ptr.inst);
            <span class="tok-kw">return</span> .void_value;
        },
        .inferred_ptr =&gt; {<span class="tok-comment">
            // We can't get elem pointers of an untyped inferred alloc, so must perform a
            // standard anonymous initialization followed by an rvalue store.
            // See corresponding logic in structInitExpr.
            </span><span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.arrayInitExprAnon">arrayInitExprAnon</a>(gz, scope, node, array_init.ast.elements);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .destructure =&gt; |destructure| {<span class="tok-comment">
            // Untyped init - destructure directly into result pointers
            </span><span class="tok-kw">if</span> (array_init.ast.elements.len != destructure.components.len) {
                <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;expected {} elements for destructure, found {}&quot;</span>, .{
                    destructure.components.len,
                    array_init.ast.elements.len,
                }, &amp;.{
                    <span class="tok-kw">try</span> astgen.errNoteNode(destructure.src_node, <span class="tok-str">&quot;result destructured here&quot;</span>, .{}),
                });
            }
            <span class="tok-kw">for</span> (array_init.ast.elements, destructure.components) |elem_init, ds_comp| {
                <span class="tok-kw">const</span> elem_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = <span class="tok-kw">switch</span> (ds_comp) {
                    .typed_ptr =&gt; |ptr_rl| .{ .ptr = ptr_rl },
                    .inferred_ptr =&gt; |ptr_inst| .{ .inferred_ptr = ptr_inst },
                    .discard =&gt; .discard,
                } };
                _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, elem_ri, elem_init);
            }
            <span class="tok-kw">return</span> .void_value;
        },
    }
}

<span class="tok-comment">/// An array initialization expression using an `array_init_anon` instruction.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">arrayInitExprAnon</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;

    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.MultiOp.html">MultiOp</a>{
        .operands_len = <span class="tok-builtin">@intCast</span>(elements.len),
    });
    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(astgen, elements.len);

    <span class="tok-kw">for</span> (elements) |elem_init| {
        <span class="tok-kw">const</span> elem_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, elem_init);
        astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(elem_ref);
        extra_index += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(.array_init_anon, node, payload_index);
}

<span class="tok-comment">/// An array initialization expression using an `array_init` or `array_init_ref` instruction.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">arrayInitExprTyped</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ty_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    maybe_elem_ty_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    is_ref: <span class="tok-type">bool</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;

    <span class="tok-kw">const</span> len = elements.len + <span class="tok-number">1</span>;<span class="tok-comment"> // +1 for type
    </span><span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.MultiOp.html">MultiOp</a>{
        .operands_len = <span class="tok-builtin">@intCast</span>(len),
    });
    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(astgen, len);
    astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(ty_inst);
    extra_index += <span class="tok-number">1</span>;

    <span class="tok-kw">if</span> (maybe_elem_ty_inst != .none) {
        <span class="tok-kw">const</span> elem_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .{ .coerced_ty = maybe_elem_ty_inst } };
        <span class="tok-kw">for</span> (elements) |elem_init| {
            <span class="tok-kw">const</span> elem_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, elem_ri, elem_init);
            astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(elem_inst);
            extra_index += <span class="tok-number">1</span>;
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">for</span> (elements, <span class="tok-number">0</span>..) |elem_init, i| {
            <span class="tok-kw">const</span> ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .{ .coerced_ty = <span class="tok-kw">try</span> gz.add(.{
                .tag = .array_init_elem_type,
                .data = .{ .bin = .{
                    .lhs = ty_inst,
                    .rhs = <span class="tok-builtin">@enumFromInt</span>(i),
                } },
            }) } };

            <span class="tok-kw">const</span> elem_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, ri, elem_init);
            astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(elem_inst);
            extra_index += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_ref) .array_init_ref <span class="tok-kw">else</span> .array_init;
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(tag, node, payload_index);
}

<span class="tok-comment">/// An array initialization expression using element pointers.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">arrayInitExprPtr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ptr_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> astgen = gz.astgen;

    <span class="tok-kw">const</span> array_ptr_inst = <span class="tok-kw">try</span> gz.addUnNode(.opt_eu_base_ptr_init, ptr_inst, node);

    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Block.html">Block</a>{
        .body_len = <span class="tok-builtin">@intCast</span>(elements.len),
    });
    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(astgen, elements.len);

    <span class="tok-kw">for</span> (elements, <span class="tok-number">0</span>..) |elem_init, i| {
        <span class="tok-kw">const</span> elem_ptr_inst = <span class="tok-kw">try</span> gz.addPlNode(.array_init_elem_ptr, elem_init, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ElemPtrImm.html">ElemPtrImm</a>{
            .ptr = array_ptr_inst,
            .index = <span class="tok-builtin">@intCast</span>(i),
        });
        astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(elem_ptr_inst.toIndex().?);
        extra_index += <span class="tok-number">1</span>;
        _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ptr = .{ .inst = elem_ptr_inst } } }, elem_init);
    }

    _ = <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(.validate_ptr_array_init, node, payload_index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">structInitExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    struct_init: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;

    <span class="tok-kw">if</span> (struct_init.ast.type_expr == <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (struct_init.ast.fields.len == <span class="tok-number">0</span>) {<span class="tok-comment">
            // Anonymous init with no fields.
            </span><span class="tok-kw">switch</span> (ri.rl) {
                .discard =&gt; <span class="tok-kw">return</span> .void_value,
                .ref_coerced_ty =&gt; |ptr_ty_inst| <span class="tok-kw">return</span> gz.addUnNode(.struct_init_empty_ref_result, ptr_ty_inst, node),
                .ty, .coerced_ty =&gt; |ty_inst| <span class="tok-kw">return</span> gz.addUnNode(.struct_init_empty_result, ty_inst, node),
                .ptr =&gt; {<span class="tok-comment">
                    // TODO: should we modify this to use RLS for the field stores here?
                    </span><span class="tok-kw">const</span> ty_inst = (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)).?;
                    <span class="tok-kw">const</span> val = <span class="tok-kw">try</span> gz.addUnNode(.struct_init_empty_result, ty_inst, node);
                    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, val, node);
                },
                .none, .ref, .inferred_ptr =&gt; {
                    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .empty_tuple, node);
                },
                .destructure =&gt; |destructure| {
                    <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;empty initializer cannot be destructured&quot;</span>, .{}, &amp;.{
                        <span class="tok-kw">try</span> astgen.errNoteNode(destructure.src_node, <span class="tok-str">&quot;result destructured here&quot;</span>, .{}),
                    });
                },
            }
        }
    } <span class="tok-kw">else</span> array: {
        <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
        <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
        <span class="tok-kw">const</span> array_type: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a> = tree.fullArrayType(struct_init.ast.type_expr) <span class="tok-kw">orelse</span> {
            <span class="tok-kw">if</span> (struct_init.ast.fields.len == <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> ty_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, struct_init.ast.type_expr);
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.struct_init_empty, ty_inst, node);
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
            }
            <span class="tok-kw">break</span> :array;
        };
        <span class="tok-kw">const</span> is_inferred_array_len = node_tags[array_type.ast.elem_count] == .identifier <span class="tok-kw">and</span><span class="tok-comment">
            // This intentionally does not support `@&quot;_&quot;` syntax.
            </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[array_type.ast.elem_count]), <span class="tok-str">&quot;_&quot;</span>);
        <span class="tok-kw">if</span> (struct_init.ast.fields.len == <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (is_inferred_array_len) {
                <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, array_type.ast.elem_type);
                <span class="tok-kw">const</span> array_type_inst = <span class="tok-kw">if</span> (array_type.ast.sentinel == <span class="tok-number">0</span>) blk: {
                    <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> gz.addPlNode(.array_type, struct_init.ast.type_expr, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                        .lhs = .zero_usize,
                        .rhs = elem_type,
                    });
                } <span class="tok-kw">else</span> blk: {
                    <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .ty = elem_type } }, array_type.ast.sentinel, .array_sentinel);
                    <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> gz.addPlNode(
                        .array_type_sentinel,
                        struct_init.ast.type_expr,
                        <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ArrayTypeSentinel.html">ArrayTypeSentinel</a>{
                            .len = .zero_usize,
                            .elem_type = elem_type,
                            .sentinel = sentinel,
                        },
                    );
                };
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.struct_init_empty, array_type_inst, node);
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
            }
            <span class="tok-kw">const</span> ty_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, struct_init.ast.type_expr);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.struct_init_empty, ty_inst, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> astgen.failNode(
                struct_init.ast.type_expr,
                <span class="tok-str">&quot;initializing array with struct syntax&quot;</span>,
                .{},
            );
        }
    }

    {
        <span class="tok-kw">var</span> sfba = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-number">256</span>, astgen.arena);
        <span class="tok-kw">const</span> sfba_allocator = sfba.get();

        <span class="tok-kw">var</span> duplicate_names = <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, <a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>)).init(sfba_allocator);
        <span class="tok-kw">try</span> duplicate_names.ensureTotalCapacity(<span class="tok-builtin">@intCast</span>(struct_init.ast.fields.len));<span class="tok-comment">

        // When there aren't errors, use this to avoid a second iteration.
        </span><span class="tok-kw">var</span> any_duplicate = <span class="tok-null">false</span>;

        <span class="tok-kw">for</span> (struct_init.ast.fields) |field| {
            <span class="tok-kw">const</span> name_token = tree.firstToken(field) - <span class="tok-number">2</span>;
            <span class="tok-kw">const</span> name_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);

            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> duplicate_names.getOrPut(name_index);

            <span class="tok-kw">if</span> (gop.found_existing) {
                <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, name_token);
                any_duplicate = <span class="tok-null">true</span>;
            } <span class="tok-kw">else</span> {
                gop.value_ptr.* = .{};
                <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, name_token);
            }
        }

        <span class="tok-kw">if</span> (any_duplicate) {
            <span class="tok-kw">var</span> it = duplicate_names.iterator();

            <span class="tok-kw">while</span> (it.next()) |entry| {
                <span class="tok-kw">const</span> record = entry.value_ptr.*;
                <span class="tok-kw">if</span> (record.items.len &gt; <span class="tok-number">1</span>) {
                    <span class="tok-kw">var</span> error_notes = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u32</span>).init(astgen.arena);

                    <span class="tok-kw">for</span> (record.items[<span class="tok-number">1</span>..]) |duplicate| {
                        <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteTok(duplicate, <span class="tok-str">&quot;duplicate name here&quot;</span>, .{}));
                    }

                    <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;struct declared here&quot;</span>, .{}));

                    <span class="tok-kw">try</span> astgen.appendErrorTokNotes(
                        record.items[<span class="tok-number">0</span>],
                        <span class="tok-str">&quot;duplicate struct field name&quot;</span>,
                        .{},
                        error_notes.items,
                    );
                }
            }

            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;
        }
    }

    <span class="tok-kw">if</span> (struct_init.ast.type_expr != <span class="tok-number">0</span>) {<span class="tok-comment">
        // Typed inits do not use RLS for language simplicity.
        </span><span class="tok-kw">const</span> ty_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, struct_init.ast.type_expr);
        _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_struct_init_ty, ty_inst, node);
        <span class="tok-kw">switch</span> (ri.rl) {
            .ref =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExprTyped">structInitExprTyped</a>(gz, scope, node, struct_init, ty_inst, <span class="tok-null">true</span>),
            <span class="tok-kw">else</span> =&gt; {
                <span class="tok-kw">const</span> struct_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExprTyped">structInitExprTyped</a>(gz, scope, node, struct_init, ty_inst, <span class="tok-null">false</span>);
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, struct_inst, node);
            },
        }
    }

    <span class="tok-kw">switch</span> (ri.rl) {
        .none =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExprAnon">structInitExprAnon</a>(gz, scope, node, struct_init),
        .discard =&gt; {<span class="tok-comment">
            // Even if discarding we must perform side-effects.
            </span><span class="tok-kw">for</span> (struct_init.ast.fields) |field_init| {
                _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .discard }, field_init);
            }
            <span class="tok-kw">return</span> .void_value;
        },
        .ref =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExprAnon">structInitExprAnon</a>(gz, scope, node, struct_init);
            <span class="tok-kw">return</span> gz.addUnTok(.ref, result, tree.firstToken(node));
        },
        .ref_coerced_ty =&gt; |ptr_ty_inst| {
            <span class="tok-kw">const</span> result_ty_inst = <span class="tok-kw">try</span> gz.addUnNode(.elem_type, ptr_ty_inst, node);
            _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_struct_init_result_ty, result_ty_inst, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExprTyped">structInitExprTyped</a>(gz, scope, node, struct_init, result_ty_inst, <span class="tok-null">true</span>);
        },
        .ty, .coerced_ty =&gt; |result_ty_inst| {
            _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_struct_init_result_ty, result_ty_inst, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExprTyped">structInitExprTyped</a>(gz, scope, node, struct_init, result_ty_inst, <span class="tok-null">false</span>);
        },
        .ptr =&gt; |ptr| {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExprPtr">structInitExprPtr</a>(gz, scope, node, struct_init, ptr.inst);
            <span class="tok-kw">return</span> .void_value;
        },
        .inferred_ptr =&gt; {<span class="tok-comment">
            // We can't get field pointers of an untyped inferred alloc, so must perform a
            // standard anonymous initialization followed by an rvalue store.
            // See corresponding logic in arrayInitExpr.
            </span><span class="tok-kw">const</span> struct_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structInitExprAnon">structInitExprAnon</a>(gz, scope, node, struct_init);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, struct_inst, node);
        },
        .destructure =&gt; |destructure| {<span class="tok-comment">
            // This is an untyped init, so is an actual struct, which does
            // not support destructuring.
            </span><span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;struct value cannot be destructured&quot;</span>, .{}, &amp;.{
                <span class="tok-kw">try</span> astgen.errNoteNode(destructure.src_node, <span class="tok-str">&quot;result destructured here&quot;</span>, .{}),
            });
        },
    }
}

<span class="tok-comment">/// A struct initialization expression using a `struct_init_anon` instruction.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">structInitExprAnon</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    struct_init: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;

    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructInitAnon.html">StructInitAnon</a>{
        .abs_node = node,
        .abs_line = astgen.source_line,
        .fields_len = <span class="tok-builtin">@intCast</span>(struct_init.ast.fields.len),
    });
    <span class="tok-kw">const</span> field_size = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructInitAnon.html">StructInitAnon</a>.<a href="std.zig.Zir.Inst.StructInitAnon.Item.html">Item</a>).@&quot;struct&quot;.fields.len;
    <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(astgen, struct_init.ast.fields.len * field_size);

    <span class="tok-kw">for</span> (struct_init.ast.fields) |field_init| {
        <span class="tok-kw">const</span> name_token = tree.firstToken(field_init) - <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);
        <a href="std.zig.AstGen.html#std.zig.AstGen.setExtra">setExtra</a>(astgen, extra_index, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructInitAnon.html">StructInitAnon</a>.<a href="std.zig.Zir.Inst.StructInitAnon.Item.html">Item</a>{
            .field_name = str_index,
            .init = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, field_init),
        });
        extra_index += field_size;
    }

    <span class="tok-kw">return</span> gz.addPlNodePayloadIndex(.struct_init_anon, node, payload_index);
}

<span class="tok-comment">/// A struct initialization expression using a `struct_init` or `struct_init_ref` instruction.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">structInitExprTyped</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    struct_init: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a>,
    ty_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    is_ref: <span class="tok-type">bool</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;

    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructInit.html">StructInit</a>{
        .abs_node = node,
        .abs_line = astgen.source_line,
        .fields_len = <span class="tok-builtin">@intCast</span>(struct_init.ast.fields.len),
    });
    <span class="tok-kw">const</span> field_size = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructInit.html">StructInit</a>.<a href="std.zig.Zir.Inst.StructInit.Item.html">Item</a>).@&quot;struct&quot;.fields.len;
    <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(astgen, struct_init.ast.fields.len * field_size);

    <span class="tok-kw">for</span> (struct_init.ast.fields) |field_init| {
        <span class="tok-kw">const</span> name_token = tree.firstToken(field_init) - <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);
        <span class="tok-kw">const</span> field_ty_inst = <span class="tok-kw">try</span> gz.addPlNode(.struct_init_field_type, field_init, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldType.html">FieldType</a>{
            .container_type = ty_inst,
            .name_start = str_index,
        });
        <a href="std.zig.AstGen.html#std.zig.AstGen.setExtra">setExtra</a>(astgen, extra_index, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructInit.html">StructInit</a>.<a href="std.zig.Zir.Inst.StructInit.Item.html">Item</a>{
            .field_type = field_ty_inst.toIndex().?,
            .init = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = field_ty_inst } }, field_init),
        });
        extra_index += field_size;
    }

    <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_ref) .struct_init_ref <span class="tok-kw">else</span> .struct_init;
    <span class="tok-kw">return</span> gz.addPlNodePayloadIndex(tag, node, payload_index);
}

<span class="tok-comment">/// A struct initialization expression using field pointers.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">structInitExprPtr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    struct_init: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a>,
    ptr_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;

    <span class="tok-kw">const</span> struct_ptr_inst = <span class="tok-kw">try</span> gz.addUnNode(.opt_eu_base_ptr_init, ptr_inst, node);

    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Block.html">Block</a>{
        .body_len = <span class="tok-builtin">@intCast</span>(struct_init.ast.fields.len),
    });
    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(astgen, struct_init.ast.fields.len);

    <span class="tok-kw">for</span> (struct_init.ast.fields) |field_init| {
        <span class="tok-kw">const</span> name_token = tree.firstToken(field_init) - <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);
        <span class="tok-kw">const</span> field_ptr = <span class="tok-kw">try</span> gz.addPlNode(.struct_init_field_ptr, field_init, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Field.html">Field</a>{
            .lhs = struct_ptr_inst,
            .field_name_start = str_index,
        });
        astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(field_ptr.toIndex().?);
        extra_index += <span class="tok-number">1</span>;
        _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ptr = .{ .inst = field_ptr } } }, field_init);
    }

    _ = <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(.validate_ptr_struct_init, node, payload_index);
}

<span class="tok-comment">/// This explicitly calls expr in a comptime scope by wrapping it in a `block_comptime` if</span>
<span class="tok-comment">/// necessary. It should be used whenever we need to force compile-time evaluation of something,</span>
<span class="tok-comment">/// such as a type.</span>
<span class="tok-comment">/// The function corresponding to `comptime` expression syntax is `comptimeExprAst`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">comptimeExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    reason: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.SimpleComptimeReason.html">SimpleComptimeReason</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr2">comptimeExpr2</a>(gz, scope, ri, node, node, reason);
}

<span class="tok-comment">/// Like `comptimeExpr`, but draws a distinction between `node`, the expression to evaluate at comptime,</span>
<span class="tok-comment">/// and `src_node`, the node to attach to the `block_comptime`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">comptimeExpr2</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    reason: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.SimpleComptimeReason.html">SimpleComptimeReason</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">if</span> (gz.is_comptime) {<span class="tok-comment">
        // No need to change anything!
        </span><span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, ri, node);
    }<span class="tok-comment">

    // There's an optimization here: if the body will be evaluated at comptime regardless, there's
    // no need to wrap it in a block. This is hard to determine in general, but we can identify a
    // common subset of trivially comptime expressions to take down the size of the ZIR a bit.
    </span><span class="tok-kw">const</span> tree = gz.astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">switch</span> (node_tags[node]) {
        .identifier =&gt; {<span class="tok-comment">
            // Many identifiers can be handled without a `block_comptime`, so `AstGen.identifier` has
            // special handling for this case.
            </span><span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.identifier">identifier</a>(gz, scope, ri, node, .{ .src_node = src_node, .reason = reason });
        },<span class="tok-comment">

        // These are leaf nodes which are always comptime-known.
        </span>.number_literal,
        .char_literal,
        .string_literal,
        .multiline_string_literal,
        .enum_literal,
        .error_value,
        .anyframe_literal,
        .error_set_decl,<span class="tok-comment">
        // These nodes are not leaves, but will force comptime evaluation of all sub-expressions, and
        // hence behave the same regardless of whether they're in a comptime scope.
        </span>.error_union,
        .merge_error_sets,
        .optional_type,
        .anyframe_type,
        .ptr_type_aligned,
        .ptr_type_sentinel,
        .ptr_type,
        .ptr_type_bit_range,
        .array_type,
        .array_type_sentinel,
        .fn_proto_simple,
        .fn_proto_multi,
        .fn_proto_one,
        .fn_proto,
        .container_decl,
        .container_decl_trailing,
        .container_decl_arg,
        .container_decl_arg_trailing,
        .container_decl_two,
        .container_decl_two_trailing,
        .tagged_union,
        .tagged_union_trailing,
        .tagged_union_enum_tag,
        .tagged_union_enum_tag_trailing,
        .tagged_union_two,
        .tagged_union_two_trailing,
        =&gt; {<span class="tok-comment">
            // No need to worry about result location here, we're not creating a comptime block!
            </span><span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, ri, node);
        },<span class="tok-comment">

        // Lastly, for labelled blocks, avoid emitting a labelled block directly inside this
        // comptime block, because that would be silly! Note that we don't bother doing this for
        // unlabelled blocks, since they don't generate blocks at comptime anyway (see `blockExpr`).
        </span>.block_two, .block_two_semicolon, .block, .block_semicolon =&gt; {
            <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
            <span class="tok-kw">const</span> lbrace = main_tokens[node];<span class="tok-comment">
            // Careful! We can't pass in the real result location here, since it may
            // refer to runtime memory. A runtime-to-comptime boundary has to remove
            // result location information, compute the result, and copy it to the true
            // result location at runtime. We do this below as well.
            </span><span class="tok-kw">const</span> ty_only_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{
                .ctx = ri.ctx,
                .rl = <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)) |res_ty|
                    .{ .coerced_ty = res_ty }
                <span class="tok-kw">else</span>
                    .none,
            };
            <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span>
                token_tags[lbrace - <span class="tok-number">2</span>] == .identifier)
            {
                <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
                <span class="tok-kw">switch</span> (node_tags[node]) {
                    .block_two, .block_two_semicolon =&gt; {
                        <span class="tok-kw">const</span> stmts: [<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = .{ node_datas[node].lhs, node_datas[node].rhs };
                        <span class="tok-kw">const</span> stmt_slice = <span class="tok-kw">if</span> (stmts[<span class="tok-number">0</span>] == <span class="tok-number">0</span>)
                            stmts[<span class="tok-number">0</span>..<span class="tok-number">0</span>]
                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (stmts[<span class="tok-number">1</span>] == <span class="tok-number">0</span>)
                            stmts[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
                        <span class="tok-kw">else</span>
                            stmts[<span class="tok-number">0</span>..<span class="tok-number">2</span>];

                        <span class="tok-kw">const</span> block_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.labeledBlockExpr">labeledBlockExpr</a>(gz, scope, ty_only_ri, node, stmt_slice, <span class="tok-null">true</span>, .normal);
                        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, block_ref, node);
                    },
                    .block, .block_semicolon =&gt; {
                        <span class="tok-kw">const</span> stmts = tree.extra_data[node_datas[node].lhs..node_datas[node].rhs];<span class="tok-comment">
                        // Replace result location and copy back later - see above.
                        </span><span class="tok-kw">const</span> block_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.labeledBlockExpr">labeledBlockExpr</a>(gz, scope, ty_only_ri, node, stmts, <span class="tok-null">true</span>, .normal);
                        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, block_ref, node);
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            }
        },<span class="tok-comment">

        // In other cases, we don't optimize anything - we need a wrapper comptime block.
        </span><span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(scope);
    block_scope.is_comptime = <span class="tok-null">true</span>;
    <span class="tok-kw">defer</span> block_scope.unstack();

    <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_comptime, src_node);<span class="tok-comment">
    // Replace result location and copy back later - see above.
    </span><span class="tok-kw">const</span> ty_only_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{
        .ctx = ri.ctx,
        .rl = <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, src_node)) |res_ty|
            .{ .coerced_ty = res_ty }
        <span class="tok-kw">else</span>
            .none,
    };
    <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;block_scope, scope, ty_only_ri, node, .normal);
    <span class="tok-kw">if</span> (!gz.refIsNoReturn(block_result)) {
        _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, block_inst, block_result);
    }
    <span class="tok-kw">try</span> block_scope.setBlockComptimeBody(block_inst, reason);
    <span class="tok-kw">try</span> gz.instructions.append(gz.astgen.gpa, block_inst);

    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, block_inst.toRef(), src_node);
}

<span class="tok-comment">/// This one is for an actual `comptime` syntax, and will emit a compile error if</span>
<span class="tok-comment">/// the scope is already known to be comptime-evaluated.</span>
<span class="tok-comment">/// See `comptimeExpr` for the helper function for calling expr in a comptime scope.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">comptimeExprAst</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">if</span> (gz.is_comptime) {
        <span class="tok-kw">try</span> astgen.appendErrorNode(node, <span class="tok-str">&quot;redundant comptime keyword in already comptime scope&quot;</span>, .{});
    }
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> body_node = node_datas[node].lhs;
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr2">comptimeExpr2</a>(gz, scope, ri, body_node, node, .comptime_keyword);
}

<span class="tok-comment">/// Restore the error return trace index. Performs the restore only if the result is a non-error or</span>
<span class="tok-comment">/// if the result location is a non-error-handling expression.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">restoreErrRetIndex</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    bt: <a href="std.zig.AstGen.GenZir.html">GenZir</a>.<a href="std.zig.AstGen.GenZir.BranchTarget.html">BranchTarget</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    result: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> op = <span class="tok-kw">switch</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.nodeMayEvalToError">nodeMayEvalToError</a>(gz.astgen.tree, node)) {
        .always =&gt; <span class="tok-kw">return</span>,<span class="tok-comment"> // never restore/pop
        </span>.never =&gt; .none,<span class="tok-comment"> // always restore/pop
        </span>.maybe =&gt; <span class="tok-kw">switch</span> (ri.ctx) {
            .error_handling_expr, .@&quot;return&quot;, .fn_arg, .const_init =&gt; <span class="tok-kw">switch</span> (ri.rl) {
                .ptr =&gt; |ptr_res| <span class="tok-kw">try</span> gz.addUnNode(.load, ptr_res.inst, node),
                .inferred_ptr =&gt; blk: {<span class="tok-comment">
                    // This is a terrible workaround for Sema's inability to load from a .alloc_inferred ptr
                    // before its type has been resolved. There is no valid operand to use here, so error
                    // traces will be popped prematurely.
                    // TODO: Update this to do a proper load from the rl_ptr, once Sema can support it.
                    </span><span class="tok-kw">break</span> :blk .none;
                },
                .destructure =&gt; <span class="tok-kw">return</span>,<span class="tok-comment"> // value must be a tuple or array, so never restore/pop
                </span><span class="tok-kw">else</span> =&gt; result,
            },
            <span class="tok-kw">else</span> =&gt; .none,<span class="tok-comment"> // always restore/pop
        </span>},
    };
    _ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(bt, .{ .if_non_error = op }, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">breakExpr</span>(parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, parent_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> break_label = node_datas[node].lhs;
    <span class="tok-kw">const</span> rhs = node_datas[node].rhs;<span class="tok-comment">

    // Look for the label in the scope.
    </span><span class="tok-kw">var</span> scope = parent_scope;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (scope.tag) {
            .gen_zir =&gt; {
                <span class="tok-kw">const</span> block_gz = scope.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?;

                <span class="tok-kw">if</span> (block_gz.cur_defer_node != <span class="tok-number">0</span>) {<span class="tok-comment">
                    // We are breaking out of a `defer` block.
                    </span><span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot break out of defer expression&quot;</span>, .{}, &amp;.{
                        <span class="tok-kw">try</span> astgen.errNoteNode(
                            block_gz.cur_defer_node,
                            <span class="tok-str">&quot;defer expression here&quot;</span>,
                            .{},
                        ),
                    });
                }

                <span class="tok-kw">const</span> block_inst = blk: {
                    <span class="tok-kw">if</span> (break_label != <span class="tok-number">0</span>) {
                        <span class="tok-kw">if</span> (block_gz.label) |*label| {
                            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> astgen.tokenIdentEql(label.token, break_label)) {
                                label.used = <span class="tok-null">true</span>;
                                <span class="tok-kw">break</span> :blk label.block_inst;
                            }
                        }
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (block_gz.break_block.unwrap()) |i| {
                        <span class="tok-kw">break</span> :blk i;
                    }<span class="tok-comment">
                    // If not the target, start over with the parent
                    </span>scope = block_gz.parent;
                    <span class="tok-kw">continue</span>;
                };<span class="tok-comment">
                // If we made it here, this block is the target of the break expr

                </span><span class="tok-kw">const</span> break_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (block_gz.is_inline)
                    .break_inline
                <span class="tok-kw">else</span>
                    .@&quot;break&quot;;

                <span class="tok-kw">if</span> (rhs == <span class="tok-number">0</span>) {
                    _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(parent_gz, block_gz.break_result_info, .void_value, node);

                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(parent_gz, scope, parent_scope, .normal_only);<span class="tok-comment">

                    // As our last action before the break, &quot;pop&quot; the error trace if needed
                    </span><span class="tok-kw">if</span> (!block_gz.is_comptime)
                        _ = <span class="tok-kw">try</span> parent_gz.addRestoreErrRetIndex(.{ .block = block_inst }, .always, node);

                    _ = <span class="tok-kw">try</span> parent_gz.addBreak(break_tag, block_inst, .void_value);
                    <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
                }

                <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(parent_gz, parent_scope, block_gz.break_result_info, rhs, node);

                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(parent_gz, scope, parent_scope, .normal_only);<span class="tok-comment">

                // As our last action before the break, &quot;pop&quot; the error trace if needed
                </span><span class="tok-kw">if</span> (!block_gz.is_comptime)
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.restoreErrRetIndex">restoreErrRetIndex</a>(parent_gz, .{ .block = block_inst }, block_gz.break_result_info, rhs, operand);

                <span class="tok-kw">switch</span> (block_gz.break_result_info.rl) {
                    .ptr =&gt; {<span class="tok-comment">
                        // In this case we don't have any mechanism to intercept it;
                        // we assume the result location is written, and we break with void.
                        </span>_ = <span class="tok-kw">try</span> parent_gz.addBreak(break_tag, block_inst, .void_value);
                    },
                    .discard =&gt; {
                        _ = <span class="tok-kw">try</span> parent_gz.addBreak(break_tag, block_inst, .void_value);
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        _ = <span class="tok-kw">try</span> parent_gz.addBreakWithSrcNode(break_tag, block_inst, operand, rhs);
                    },
                }
                <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
            },
            .local_val =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?.parent,
            .local_ptr =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?.parent,
            .namespace =&gt; <span class="tok-kw">break</span>,
            .defer_normal, .defer_error =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
            .top =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
    <span class="tok-kw">if</span> (break_label != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> label_name = <span class="tok-kw">try</span> astgen.identifierTokenString(break_label);
        <span class="tok-kw">return</span> astgen.failTok(break_label, <span class="tok-str">&quot;label not found: '{s}'&quot;</span>, .{label_name});
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;break expression outside loop&quot;</span>, .{});
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">continueExpr</span>(parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, parent_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> break_label = node_datas[node].lhs;
    <span class="tok-kw">const</span> rhs = node_datas[node].rhs;

    <span class="tok-kw">if</span> (break_label == <span class="tok-number">0</span> <span class="tok-kw">and</span> rhs != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;cannot continue with operand without label&quot;</span>, .{});
    }<span class="tok-comment">

    // Look for the label in the scope.
    </span><span class="tok-kw">var</span> scope = parent_scope;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (scope.tag) {
            .gen_zir =&gt; {
                <span class="tok-kw">const</span> gen_zir = scope.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?;

                <span class="tok-kw">if</span> (gen_zir.cur_defer_node != <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot continue out of defer expression&quot;</span>, .{}, &amp;.{
                        <span class="tok-kw">try</span> astgen.errNoteNode(
                            gen_zir.cur_defer_node,
                            <span class="tok-str">&quot;defer expression here&quot;</span>,
                            .{},
                        ),
                    });
                }
                <span class="tok-kw">const</span> continue_block = gen_zir.continue_block.unwrap() <span class="tok-kw">orelse</span> {
                    scope = gen_zir.parent;
                    <span class="tok-kw">continue</span>;
                };
                <span class="tok-kw">if</span> (break_label != <span class="tok-number">0</span>) blk: {
                    <span class="tok-kw">if</span> (gen_zir.label) |*label| {
                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> astgen.tokenIdentEql(label.token, break_label)) {
                            <span class="tok-kw">const</span> maybe_switch_tag = astgen.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(label.block_inst)];
                            <span class="tok-kw">if</span> (rhs != <span class="tok-number">0</span>) <span class="tok-kw">switch</span> (maybe_switch_tag) {
                                .switch_block, .switch_block_ref =&gt; {},
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;cannot continue loop with operand&quot;</span>, .{}),
                            } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (maybe_switch_tag) {
                                .switch_block, .switch_block_ref =&gt; <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;cannot continue switch without operand&quot;</span>, .{}),
                                <span class="tok-kw">else</span> =&gt; {},
                            }

                            label.used = <span class="tok-null">true</span>;
                            label.used_for_continue = <span class="tok-null">true</span>;
                            <span class="tok-kw">break</span> :blk;
                        }
                    }<span class="tok-comment">
                    // found continue but either it has a different label, or no label
                    </span>scope = gen_zir.parent;
                    <span class="tok-kw">continue</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (gen_zir.label) |label| {<span class="tok-comment">
                    // This `continue` is unlabeled. If the gz we've found corresponds to a labeled
                    // `switch`, ignore it and continue to parent scopes.
                    </span><span class="tok-kw">switch</span> (astgen.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(label.block_inst)]) {
                        .switch_block, .switch_block_ref =&gt; {
                            scope = gen_zir.parent;
                            <span class="tok-kw">continue</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; {},
                    }
                }

                <span class="tok-kw">if</span> (rhs != <span class="tok-number">0</span>) {<span class="tok-comment">
                    // We need to figure out the result info to use.
                    // The type should match
                    </span><span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(parent_gz, parent_scope, gen_zir.continue_result_info, rhs, node);

                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(parent_gz, scope, parent_scope, .normal_only);<span class="tok-comment">

                    // As our last action before the continue, &quot;pop&quot; the error trace if needed
                    </span><span class="tok-kw">if</span> (!gen_zir.is_comptime)
                        _ = <span class="tok-kw">try</span> parent_gz.addRestoreErrRetIndex(.{ .block = continue_block }, .always, node);

                    _ = <span class="tok-kw">try</span> parent_gz.addBreakWithSrcNode(.switch_continue, continue_block, operand, rhs);
                    <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
                }

                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(parent_gz, scope, parent_scope, .normal_only);

                <span class="tok-kw">const</span> break_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (gen_zir.is_inline)
                    .break_inline
                <span class="tok-kw">else</span>
                    .@&quot;break&quot;;
                <span class="tok-kw">if</span> (break_tag == .break_inline) {
                    _ = <span class="tok-kw">try</span> parent_gz.addUnNode(.check_comptime_control_flow, continue_block.toRef(), node);
                }<span class="tok-comment">

                // As our last action before the continue, &quot;pop&quot; the error trace if needed
                </span><span class="tok-kw">if</span> (!gen_zir.is_comptime)
                    _ = <span class="tok-kw">try</span> parent_gz.addRestoreErrRetIndex(.{ .block = continue_block }, .always, node);

                _ = <span class="tok-kw">try</span> parent_gz.addBreak(break_tag, continue_block, .void_value);
                <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
            },
            .local_val =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?.parent,
            .local_ptr =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?.parent,
            .defer_normal, .defer_error =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
            .namespace =&gt; <span class="tok-kw">break</span>,
            .top =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
    <span class="tok-kw">if</span> (break_label != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> label_name = <span class="tok-kw">try</span> astgen.identifierTokenString(break_label);
        <span class="tok-kw">return</span> astgen.failTok(break_label, <span class="tok-str">&quot;label not found: '{s}'&quot;</span>, .{label_name});
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;continue expression outside loop&quot;</span>, .{});
    }
}

<span class="tok-comment">/// Similar to `expr`, but intended for use when `gz` corresponds to a body</span>
<span class="tok-comment">/// which will contain only this node's code. Differs from `expr` in that if the</span>
<span class="tok-comment">/// root expression is an unlabeled block, does not emit an actual block.</span>
<span class="tok-comment">/// Instead, the block contents are emitted directly into `gz`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">fullBodyExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    block_kind: <a href="std.zig.AstGen.BlockKind.html">BlockKind</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> tree = gz.astgen.tree;
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> stmt_buf: [<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> statements: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-kw">switch</span> (node_tags[node]) {
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, ri, node),
        .block_two, .block_two_semicolon =&gt; <span class="tok-kw">if</span> (node_datas[node].lhs == <span class="tok-number">0</span>) s: {
            <span class="tok-kw">break</span> :s &amp;.{};
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (node_datas[node].rhs == <span class="tok-number">0</span>) s: {
            stmt_buf[<span class="tok-number">0</span>] = node_datas[node].lhs;
            <span class="tok-kw">break</span> :s stmt_buf[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
        } <span class="tok-kw">else</span> s: {
            stmt_buf[<span class="tok-number">0</span>] = node_datas[node].lhs;
            stmt_buf[<span class="tok-number">1</span>] = node_datas[node].rhs;
            <span class="tok-kw">break</span> :s stmt_buf[<span class="tok-number">0</span>..<span class="tok-number">2</span>];
        },
        .block, .block_semicolon =&gt; tree.extra_data[node_datas[node].lhs..node_datas[node].rhs],
    };

    <span class="tok-kw">const</span> lbrace = main_tokens[node];
    <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span>
        token_tags[lbrace - <span class="tok-number">2</span>] == .identifier)
    {<span class="tok-comment">
        // Labeled blocks are tricky - forwarding result location information properly is non-trivial,
        // plus if this block is exited with a `break_inline` we aren't allowed multiple breaks. This
        // case is rare, so just treat it as a normal expression and create a nested block.
        </span><span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExpr">blockExpr</a>(gz, scope, ri, node, statements, block_kind);
    }

    <span class="tok-kw">var</span> sub_gz = gz.makeSubBlock(scope);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExprStmts">blockExprStmts</a>(&amp;sub_gz, &amp;sub_gz.base, statements, block_kind);

    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
}

<span class="tok-kw">const</span> BlockKind = <span class="tok-kw">enum</span> { normal, allow_branch_hint };

<span class="tok-kw">fn</span> <span class="tok-fn">blockExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    block_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    statements: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    kind: <a href="std.zig.AstGen.BlockKind.html">BlockKind</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> lbrace = main_tokens[block_node];
    <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span>
        token_tags[lbrace - <span class="tok-number">2</span>] == .identifier)
    {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.labeledBlockExpr">labeledBlockExpr</a>(gz, scope, ri, block_node, statements, <span class="tok-null">false</span>, kind);
    }

    <span class="tok-kw">if</span> (!gz.is_comptime) {<span class="tok-comment">
        // Since this block is unlabeled, its control flow is effectively linear and we
        // can *almost* get away with inlining the block here. However, we actually need
        // to preserve the .block for Sema, to properly pop the error return trace.

        </span><span class="tok-kw">const</span> block_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = .block;
        <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(block_tag, block_node);
        <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, block_inst);

        <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(scope);
        <span class="tok-kw">defer</span> block_scope.unstack();

        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExprStmts">blockExprStmts</a>(&amp;block_scope, &amp;block_scope.base, statements, kind);

        <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {<span class="tok-comment">
            // As our last action before the break, &quot;pop&quot; the error trace if needed
            </span>_ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.{ .block = block_inst }, .always, block_node);<span class="tok-comment">
            // No `rvalue` call here, as the block result is always `void`, so we do that below.
            </span>_ = <span class="tok-kw">try</span> block_scope.addBreak(.@&quot;break&quot;, block_inst, .void_value);
        }

        <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">var</span> sub_gz = gz.makeSubBlock(scope);
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExprStmts">blockExprStmts</a>(&amp;sub_gz, &amp;sub_gz.base, statements, kind);
    }

    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, block_node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">checkLabelRedefinition</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, parent_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, label: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) !<span class="tok-type">void</span> {<span class="tok-comment">
    // Look for the label in the scope.
    </span><span class="tok-kw">var</span> scope = parent_scope;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (scope.tag) {
            .gen_zir =&gt; {
                <span class="tok-kw">const</span> gen_zir = scope.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?;
                <span class="tok-kw">if</span> (gen_zir.label) |prev_label| {
                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> astgen.tokenIdentEql(label, prev_label.token)) {
                        <span class="tok-kw">const</span> label_name = <span class="tok-kw">try</span> astgen.identifierTokenString(label);
                        <span class="tok-kw">return</span> astgen.failTokNotes(label, <span class="tok-str">&quot;redefinition of label '{s}'&quot;</span>, .{
                            label_name,
                        }, &amp;[_]<span class="tok-type">u32</span>{
                            <span class="tok-kw">try</span> astgen.errNoteTok(
                                prev_label.token,
                                <span class="tok-str">&quot;previous definition here&quot;</span>,
                                .{},
                            ),
                        });
                    }
                }
                scope = gen_zir.parent;
            },
            .local_val =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?.parent,
            .local_ptr =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?.parent,
            .defer_normal, .defer_error =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
            .namespace =&gt; <span class="tok-kw">break</span>,
            .top =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">labeledBlockExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    parent_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    block_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    statements: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    force_comptime: <span class="tok-type">bool</span>,
    block_kind: <a href="std.zig.AstGen.BlockKind.html">BlockKind</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> lbrace = main_tokens[block_node];
    <span class="tok-kw">const</span> label_token = lbrace - <span class="tok-number">2</span>;
    <a href="std.debug.html#std.debug.assert">assert</a>(token_tags[label_token] == .identifier);

    <span class="tok-kw">try</span> astgen.checkLabelRedefinition(parent_scope, label_token);

    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(block_node);
    <span class="tok-kw">const</span> block_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{
        .rl = <span class="tok-kw">switch</span> (ri.rl) {
            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(gz, block_node)).? },
            .inferred_ptr =&gt; .none,
            <span class="tok-kw">else</span> =&gt; ri.rl,
        },
        .ctx = ri.ctx,
    };<span class="tok-comment">
    // We need to call `rvalue` to write through to the pointer only if we had a
    // result pointer and aren't forwarding it.
    </span><span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>).@&quot;union&quot;.tag_type.?;
    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);<span class="tok-comment">

    // Reserve the Block ZIR instruction index so that we can put it into the GenZir struct
    // so that break statements can reference it.
    </span><span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(<span class="tok-kw">if</span> (force_comptime) .block_comptime <span class="tok-kw">else</span> .block, block_node);
    <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, block_inst);
    <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(parent_scope);
    block_scope.is_inline = force_comptime;
    block_scope.label = <a href="std.zig.AstGen.GenZir.html">GenZir</a>.<a href="std.zig.AstGen.GenZir.Label.html">Label</a>{
        .token = label_token,
        .block_inst = block_inst,
    };
    block_scope.setBreakResultInfo(block_ri);
    <span class="tok-kw">if</span> (force_comptime) block_scope.is_comptime = <span class="tok-null">true</span>;
    <span class="tok-kw">defer</span> block_scope.unstack();

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.blockExprStmts">blockExprStmts</a>(&amp;block_scope, &amp;block_scope.base, statements, block_kind);
    <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {<span class="tok-comment">
        // As our last action before the return, &quot;pop&quot; the error trace if needed
        </span>_ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.{ .block = block_inst }, .always, block_node);
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, block_scope.break_result_info, .void_value, block_node);
        <span class="tok-kw">const</span> break_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (force_comptime) .break_inline <span class="tok-kw">else</span> .@&quot;break&quot;;
        _ = <span class="tok-kw">try</span> block_scope.addBreak(break_tag, block_inst, result);
    }

    <span class="tok-kw">if</span> (!block_scope.label.?.used) {
        <span class="tok-kw">try</span> astgen.appendErrorTok(label_token, <span class="tok-str">&quot;unused block label&quot;</span>, .{});
    }

    <span class="tok-kw">if</span> (force_comptime) {
        <span class="tok-kw">try</span> block_scope.setBlockComptimeBody(block_inst, .comptime_keyword);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);
    }

    <span class="tok-kw">if</span> (need_result_rvalue) {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, block_inst.toRef(), block_node);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> block_inst.toRef();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">blockExprStmts</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, parent_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, statements: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, block_kind: <a href="std.zig.AstGen.BlockKind.html">BlockKind</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_data = tree.nodes.items(.data);

    <span class="tok-kw">if</span> (statements.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

    <span class="tok-kw">var</span> block_arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(gz.astgen.gpa);
    <span class="tok-kw">defer</span> block_arena.deinit();
    <span class="tok-kw">const</span> block_arena_allocator = block_arena.allocator();

    <span class="tok-kw">var</span> noreturn_src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> scope = parent_scope;
    <span class="tok-kw">for</span> (statements, <span class="tok-number">0</span>..) |statement, stmt_idx| {
        <span class="tok-kw">if</span> (noreturn_src_node != <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> astgen.appendErrorNodeNotes(
                statement,
                <span class="tok-str">&quot;unreachable code&quot;</span>,
                .{},
                &amp;[_]<span class="tok-type">u32</span>{
                    <span class="tok-kw">try</span> astgen.errNoteNode(
                        noreturn_src_node,
                        <span class="tok-str">&quot;control flow is diverted here&quot;</span>,
                        .{},
                    ),
                },
            );
        }
        <span class="tok-kw">const</span> allow_branch_hint = <span class="tok-kw">switch</span> (block_kind) {
            .normal =&gt; <span class="tok-null">false</span>,
            .allow_branch_hint =&gt; stmt_idx == <span class="tok-number">0</span>,
        };
        <span class="tok-kw">var</span> inner_node = statement;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">switch</span> (node_tags[inner_node]) {<span class="tok-comment">
                // zig fmt: off
                </span>.global_var_decl,
                .local_var_decl,
                .simple_var_decl,
                .aligned_var_decl, =&gt; scope = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.varDecl">varDecl</a>(gz, scope, statement, block_arena_allocator, tree.fullVarDecl(statement).?),

                .assign_destructure =&gt; scope = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignDestructureMaybeDecls">assignDestructureMaybeDecls</a>(gz, scope, statement, block_arena_allocator),

                .@&quot;defer&quot;    =&gt; scope = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.deferStmt">deferStmt</a>(gz, scope, statement, block_arena_allocator, .defer_normal),
                .@&quot;errdefer&quot; =&gt; scope = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.deferStmt">deferStmt</a>(gz, scope, statement, block_arena_allocator, .defer_error),

                .assign =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assign">assign</a>(gz, scope, statement),

                .assign_shl =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignShift">assignShift</a>(gz, scope, statement, .shl),
                .assign_shr =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignShift">assignShift</a>(gz, scope, statement, .shr),

                .assign_bit_and  =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .bit_and),
                .assign_bit_or   =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .bit_or),
                .assign_bit_xor  =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .xor),
                .assign_div      =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .div),
                .assign_sub      =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .sub),
                .assign_sub_wrap =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .subwrap),
                .assign_mod      =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .mod_rem),
                .assign_add      =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .add),
                .assign_add_wrap =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .addwrap),
                .assign_mul      =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .mul),
                .assign_mul_wrap =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.assignOp">assignOp</a>(gz, scope, statement, .mulwrap),

                .grouped_expression =&gt; {
                    inner_node = node_data[statement].lhs;
                    <span class="tok-kw">continue</span>;
                },

                .while_simple,
                .while_cont,
                .@&quot;while&quot;, =&gt; _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.whileExpr">whileExpr</a>(gz, scope, .{ .rl = .none }, inner_node, tree.fullWhile(inner_node).?, <span class="tok-null">true</span>),

                .for_simple,
                .@&quot;for&quot;, =&gt; _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.forExpr">forExpr</a>(gz, scope, .{ .rl = .none }, inner_node, tree.fullFor(inner_node).?, <span class="tok-null">true</span>),<span class="tok-comment">

                // These cases are here to allow branch hints.
                </span>.builtin_call_two, .builtin_call_two_comma =&gt; {
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, inner_node);
                    <span class="tok-kw">const</span> ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .none };
                    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (node_data[inner_node].lhs == <span class="tok-number">0</span>) r: {
                        <span class="tok-kw">break</span> :r <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.builtinCall">builtinCall</a>(gz, scope, ri, inner_node, &amp;.{}, allow_branch_hint);
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (node_data[inner_node].rhs == <span class="tok-number">0</span>) r: {
                        <span class="tok-kw">break</span> :r <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.builtinCall">builtinCall</a>(gz, scope, ri, inner_node, &amp;.{node_data[inner_node].lhs}, allow_branch_hint);
                    } <span class="tok-kw">else</span> r: {
                        <span class="tok-kw">break</span> :r <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.builtinCall">builtinCall</a>(gz, scope, ri, inner_node, &amp;.{
                            node_data[inner_node].lhs,
                            node_data[inner_node].rhs,
                        }, allow_branch_hint);
                    };
                    noreturn_src_node = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addEnsureResult">addEnsureResult</a>(gz, result, inner_node);
                },
                .builtin_call, .builtin_call_comma =&gt; {
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, inner_node);
                    <span class="tok-kw">const</span> ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .none };
                    <span class="tok-kw">const</span> params = tree.extra_data[node_data[inner_node].lhs..node_data[inner_node].rhs];
                    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.builtinCall">builtinCall</a>(gz, scope, ri, inner_node, params, allow_branch_hint);
                    noreturn_src_node = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addEnsureResult">addEnsureResult</a>(gz, result, inner_node);
                },

                <span class="tok-kw">else</span> =&gt; noreturn_src_node = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.unusedResultExpr">unusedResultExpr</a>(gz, scope, inner_node),<span class="tok-comment">
                // zig fmt: on
            </span>}
            <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">if</span> (noreturn_src_node == <span class="tok-number">0</span>) {
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(gz, parent_scope, scope, .normal_only);
    }
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(gz, parent_scope, scope);
}

<span class="tok-comment">/// Returns AST source node of the thing that is noreturn if the statement is</span>
<span class="tok-comment">/// definitely `noreturn`. Otherwise returns 0.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">unusedResultExpr</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, statement: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, statement);<span class="tok-comment">
    // We need to emit an error if the result is not `noreturn` or `void`, but
    // we want to avoid adding the ZIR instruction if possible for performance.
    </span><span class="tok-kw">const</span> maybe_unused_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, statement);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addEnsureResult">addEnsureResult</a>(gz, maybe_unused_result, statement);
}

<span class="tok-kw">fn</span> <span class="tok-fn">addEnsureResult</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, maybe_unused_result: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>, statement: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> {
    <span class="tok-kw">var</span> noreturn_src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> elide_check = <span class="tok-kw">if</span> (maybe_unused_result.toIndex()) |inst| b: {<span class="tok-comment">
        // Note that this array becomes invalid after appending more items to it
        // in the above while loop.
        </span><span class="tok-kw">const</span> zir_tags = gz.astgen.instructions.items(.tag);
        <span class="tok-kw">switch</span> (zir_tags[<span class="tok-builtin">@intFromEnum</span>(inst)]) {<span class="tok-comment">
            // For some instructions, modify the zir data
            // so we can avoid a separate ensure_result_used instruction.
            </span>.call, .field_call =&gt; {
                <span class="tok-kw">const</span> break_extra = gz.astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index;
                <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fieldIndex">fieldIndex</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Call.html">Call</a>, <span class="tok-str">&quot;flags&quot;</span>) ==
                    <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fieldIndex">fieldIndex</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldCall.html">FieldCall</a>, <span class="tok-str">&quot;flags&quot;</span>));
                <span class="tok-kw">const</span> flags: *<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Call.html">Call</a>.<a href="std.zig.Zir.Inst.Call.Flags.html">Flags</a> = <span class="tok-builtin">@ptrCast</span>(&amp;gz.astgen.extra.items[
                    break_extra + <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fieldIndex">fieldIndex</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Call.html">Call</a>, <span class="tok-str">&quot;flags&quot;</span>).?
                ]);
                flags.ensure_result_used = <span class="tok-null">true</span>;
                <span class="tok-kw">break</span> :b <span class="tok-null">true</span>;
            },
            .builtin_call =&gt; {
                <span class="tok-kw">const</span> break_extra = gz.astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index;
                <span class="tok-kw">const</span> flags: *<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BuiltinCall.html">BuiltinCall</a>.<a href="std.zig.Zir.Inst.BuiltinCall.Flags.html">Flags</a> = <span class="tok-builtin">@ptrCast</span>(&amp;gz.astgen.extra.items[
                    break_extra + <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fieldIndex">fieldIndex</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BuiltinCall.html">BuiltinCall</a>, <span class="tok-str">&quot;flags&quot;</span>).?
                ]);
                flags.ensure_result_used = <span class="tok-null">true</span>;
                <span class="tok-kw">break</span> :b <span class="tok-null">true</span>;
            },<span class="tok-comment">

            // ZIR instructions that might be a type other than `noreturn` or `void`.
            </span>.add,
            .addwrap,
            .add_sat,
            .add_unsafe,
            .param,
            .param_comptime,
            .param_anytype,
            .param_anytype_comptime,
            .alloc,
            .alloc_mut,
            .alloc_comptime_mut,
            .alloc_inferred,
            .alloc_inferred_mut,
            .alloc_inferred_comptime,
            .alloc_inferred_comptime_mut,
            .make_ptr_const,
            .array_cat,
            .array_mul,
            .array_type,
            .array_type_sentinel,
            .elem_type,
            .indexable_ptr_elem_type,
            .vec_arr_elem_type,
            .vector_type,
            .indexable_ptr_len,
            .anyframe_type,
            .as_node,
            .as_shift_operand,
            .bit_and,
            .bitcast,
            .bit_or,
            .block,
            .block_comptime,
            .block_inline,
            .declaration,
            .suspend_block,
            .loop,
            .bool_br_and,
            .bool_br_or,
            .bool_not,
            .cmp_lt,
            .cmp_lte,
            .cmp_eq,
            .cmp_gte,
            .cmp_gt,
            .cmp_neq,
            .decl_ref,
            .decl_val,
            .load,
            .div,
            .elem_ptr,
            .elem_val,
            .elem_ptr_node,
            .elem_val_node,
            .elem_val_imm,
            .field_ptr,
            .field_val,
            .field_ptr_named,
            .field_val_named,
            .func,
            .func_inferred,
            .func_fancy,
            .int,
            .int_big,
            .float,
            .float128,
            .int_type,
            .is_non_null,
            .is_non_null_ptr,
            .is_non_err,
            .is_non_err_ptr,
            .ret_is_non_err,
            .mod_rem,
            .mul,
            .mulwrap,
            .mul_sat,
            .ref,
            .shl,
            .shl_sat,
            .shr,
            .str,
            .sub,
            .subwrap,
            .sub_sat,
            .negate,
            .negate_wrap,
            .typeof,
            .typeof_builtin,
            .xor,
            .optional_type,
            .optional_payload_safe,
            .optional_payload_unsafe,
            .optional_payload_safe_ptr,
            .optional_payload_unsafe_ptr,
            .err_union_payload_unsafe,
            .err_union_payload_unsafe_ptr,
            .err_union_code,
            .err_union_code_ptr,
            .ptr_type,
            .enum_literal,
            .decl_literal,
            .decl_literal_no_coerce,
            .merge_error_sets,
            .error_union_type,
            .bit_not,
            .error_value,
            .slice_start,
            .slice_end,
            .slice_sentinel,
            .slice_length,
            .slice_sentinel_ty,
            .import,
            .switch_block,
            .switch_block_ref,
            .switch_block_err_union,
            .union_init,
            .field_type_ref,
            .error_set_decl,
            .enum_from_int,
            .int_from_enum,
            .type_info,
            .size_of,
            .bit_size_of,
            .typeof_log2_int_type,
            .int_from_ptr,
            .align_of,
            .int_from_bool,
            .embed_file,
            .error_name,
            .sqrt,
            .sin,
            .cos,
            .tan,
            .exp,
            .exp2,
            .log,
            .log2,
            .log10,
            .abs,
            .floor,
            .ceil,
            .trunc,
            .round,
            .tag_name,
            .type_name,
            .frame_type,
            .frame_size,
            .int_from_float,
            .float_from_int,
            .ptr_from_int,
            .float_cast,
            .int_cast,
            .ptr_cast,
            .truncate,
            .has_decl,
            .has_field,
            .clz,
            .ctz,
            .pop_count,
            .byte_swap,
            .bit_reverse,
            .div_exact,
            .div_floor,
            .div_trunc,
            .mod,
            .rem,
            .shl_exact,
            .shr_exact,
            .bit_offset_of,
            .offset_of,
            .splat,
            .reduce,
            .shuffle,
            .atomic_load,
            .atomic_rmw,
            .mul_add,
            .max,
            .min,
            .c_import,
            .@&quot;resume&quot;,
            .@&quot;await&quot;,
            .ret_err_value_code,
            .ret_ptr,
            .ret_type,
            .for_len,
            .@&quot;try&quot;,
            .try_ptr,
            .opt_eu_base_ptr_init,
            .coerce_ptr_elem_ty,
            .struct_init_empty,
            .struct_init_empty_result,
            .struct_init_empty_ref_result,
            .struct_init_anon,
            .struct_init,
            .struct_init_ref,
            .struct_init_field_type,
            .struct_init_field_ptr,
            .array_init_anon,
            .array_init,
            .array_init_ref,
            .validate_array_init_ref_ty,
            .array_init_elem_type,
            .array_init_elem_ptr,
            =&gt; <span class="tok-kw">break</span> :b <span class="tok-null">false</span>,

            .extended =&gt; <span class="tok-kw">switch</span> (gz.astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(inst)].extended.opcode) {
                .breakpoint,
                .disable_instrumentation,
                .disable_intrinsics,
                .set_float_mode,
                .branch_hint,
                =&gt; <span class="tok-kw">break</span> :b <span class="tok-null">true</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :b <span class="tok-null">false</span>,
            },<span class="tok-comment">

            // ZIR instructions that are always `noreturn`.
            </span>.@&quot;break&quot;,
            .break_inline,
            .condbr,
            .condbr_inline,
            .compile_error,
            .ret_node,
            .ret_load,
            .ret_implicit,
            .ret_err_value,
            .@&quot;unreachable&quot;,
            .repeat,
            .repeat_inline,
            .panic,
            .trap,
            .check_comptime_control_flow,
            .switch_continue,
            =&gt; {
                noreturn_src_node = statement;
                <span class="tok-kw">break</span> :b <span class="tok-null">true</span>;
            },<span class="tok-comment">

            // ZIR instructions that are always `void`.
            </span>.dbg_stmt,
            .dbg_var_ptr,
            .dbg_var_val,
            .ensure_result_used,
            .ensure_result_non_error,
            .ensure_err_union_payload_void,
            .@&quot;export&quot;,
            .set_eval_branch_quota,
            .atomic_store,
            .store_node,
            .store_to_inferred_ptr,
            .resolve_inferred_alloc,
            .set_runtime_safety,
            .memcpy,
            .memset,
            .validate_deref,
            .validate_destructure,
            .save_err_ret_index,
            .restore_err_ret_index_unconditional,
            .restore_err_ret_index_fn_entry,
            .validate_struct_init_ty,
            .validate_struct_init_result_ty,
            .validate_ptr_struct_init,
            .validate_array_init_ty,
            .validate_array_init_result_ty,
            .validate_ptr_array_init,
            .validate_ref_ty,
            .validate_const,
            =&gt; <span class="tok-kw">break</span> :b <span class="tok-null">true</span>,

            .@&quot;defer&quot; =&gt; <span class="tok-kw">unreachable</span>,
            .defer_err_code =&gt; <span class="tok-kw">unreachable</span>,
        }
    } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (maybe_unused_result) {
        .none =&gt; <span class="tok-kw">unreachable</span>,

        .unreachable_value =&gt; b: {
            noreturn_src_node = statement;
            <span class="tok-kw">break</span> :b <span class="tok-null">true</span>;
        },

        .void_value =&gt; <span class="tok-null">true</span>,

        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">if</span> (!elide_check) {
        _ = <span class="tok-kw">try</span> gz.addUnNode(.ensure_result_used, maybe_unused_result, statement);
    }
    <span class="tok-kw">return</span> noreturn_src_node;
}

<span class="tok-kw">fn</span> <span class="tok-fn">countDefers</span>(outer_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, inner_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>) <span class="tok-kw">struct</span> {
    have_any: <span class="tok-type">bool</span>,
    have_normal: <span class="tok-type">bool</span>,
    have_err: <span class="tok-type">bool</span>,
    need_err_code: <span class="tok-type">bool</span>,
} {
    <span class="tok-kw">var</span> have_normal = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> have_err = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> need_err_code = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> scope = inner_scope;
    <span class="tok-kw">while</span> (scope != outer_scope) {
        <span class="tok-kw">switch</span> (scope.tag) {
            .gen_zir =&gt; scope = scope.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?.parent,
            .local_val =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?.parent,
            .local_ptr =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?.parent,
            .defer_normal =&gt; {
                <span class="tok-kw">const</span> defer_scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?;
                scope = defer_scope.parent;

                have_normal = <span class="tok-null">true</span>;
            },
            .defer_error =&gt; {
                <span class="tok-kw">const</span> defer_scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?;
                scope = defer_scope.parent;

                have_err = <span class="tok-null">true</span>;

                <span class="tok-kw">const</span> have_err_payload = defer_scope.remapped_err_code != .none;
                need_err_code = need_err_code <span class="tok-kw">or</span> have_err_payload;
            },
            .namespace =&gt; <span class="tok-kw">unreachable</span>,
            .top =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
    <span class="tok-kw">return</span> .{
        .have_any = have_normal <span class="tok-kw">or</span> have_err,
        .have_normal = have_normal,
        .have_err = have_err,
        .need_err_code = need_err_code,
    };
}

<span class="tok-kw">const</span> DefersToEmit = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    both: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,<span class="tok-comment"> // err code
    </span>both_sans_err,
    normal_only,
};

<span class="tok-kw">fn</span> <span class="tok-fn">genDefers</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    outer_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    inner_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    which_ones: <a href="std.zig.AstGen.DefersToEmit.html">DefersToEmit</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gpa = gz.astgen.gpa;

    <span class="tok-kw">var</span> scope = inner_scope;
    <span class="tok-kw">while</span> (scope != outer_scope) {
        <span class="tok-kw">switch</span> (scope.tag) {
            .gen_zir =&gt; scope = scope.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?.parent,
            .local_val =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?.parent,
            .local_ptr =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?.parent,
            .defer_normal =&gt; {
                <span class="tok-kw">const</span> defer_scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?;
                scope = defer_scope.parent;
                <span class="tok-kw">try</span> gz.addDefer(defer_scope.index, defer_scope.len);
            },
            .defer_error =&gt; {
                <span class="tok-kw">const</span> defer_scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?;
                scope = defer_scope.parent;
                <span class="tok-kw">switch</span> (which_ones) {
                    .both_sans_err =&gt; {
                        <span class="tok-kw">try</span> gz.addDefer(defer_scope.index, defer_scope.len);
                    },
                    .both =&gt; |err_code| {
                        <span class="tok-kw">if</span> (defer_scope.remapped_err_code.unwrap()) |remapped_err_code| {
                            <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
                            <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

                            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> gz.astgen.addExtra(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.DeferErrCode.html">DeferErrCode</a>{
                                .remapped_err_code = remapped_err_code,
                                .index = defer_scope.index,
                                .len = defer_scope.len,
                            });
                            <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
                            gz.astgen.instructions.appendAssumeCapacity(.{
                                .tag = .defer_err_code,
                                .data = .{ .defer_err_code = .{
                                    .err_code = err_code,
                                    .payload_index = payload_index,
                                } },
                            });
                            gz.instructions.appendAssumeCapacity(new_index);
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">try</span> gz.addDefer(defer_scope.index, defer_scope.len);
                        }
                    },
                    .normal_only =&gt; <span class="tok-kw">continue</span>,
                }
            },
            .namespace =&gt; <span class="tok-kw">unreachable</span>,
            .top =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">checkUsed</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, outer_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, inner_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> astgen = gz.astgen;

    <span class="tok-kw">var</span> scope = inner_scope;
    <span class="tok-kw">while</span> (scope != outer_scope) {
        <span class="tok-kw">switch</span> (scope.tag) {
            .gen_zir =&gt; scope = scope.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?.parent,
            .local_val =&gt; {
                <span class="tok-kw">const</span> s = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?;
                <span class="tok-kw">if</span> (s.used == <span class="tok-number">0</span> <span class="tok-kw">and</span> s.discarded == <span class="tok-number">0</span>) {
                    <span class="tok-kw">try</span> astgen.appendErrorTok(s.token_src, <span class="tok-str">&quot;unused {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(s.id_cat)});
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (s.used != <span class="tok-number">0</span> <span class="tok-kw">and</span> s.discarded != <span class="tok-number">0</span>) {
                    <span class="tok-kw">try</span> astgen.appendErrorTokNotes(s.discarded, <span class="tok-str">&quot;pointless discard of {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(s.id_cat)}, &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> gz.astgen.errNoteTok(s.used, <span class="tok-str">&quot;used here&quot;</span>, .{}),
                    });
                }
                scope = s.parent;
            },
            .local_ptr =&gt; {
                <span class="tok-kw">const</span> s = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?;
                <span class="tok-kw">if</span> (s.used == <span class="tok-number">0</span> <span class="tok-kw">and</span> s.discarded == <span class="tok-number">0</span>) {
                    <span class="tok-kw">try</span> astgen.appendErrorTok(s.token_src, <span class="tok-str">&quot;unused {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(s.id_cat)});
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">if</span> (s.used != <span class="tok-number">0</span> <span class="tok-kw">and</span> s.discarded != <span class="tok-number">0</span>) {
                        <span class="tok-kw">try</span> astgen.appendErrorTokNotes(s.discarded, <span class="tok-str">&quot;pointless discard of {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(s.id_cat)}, &amp;[_]<span class="tok-type">u32</span>{
                            <span class="tok-kw">try</span> astgen.errNoteTok(s.used, <span class="tok-str">&quot;used here&quot;</span>, .{}),
                        });
                    }
                    <span class="tok-kw">if</span> (s.id_cat == .@&quot;local variable&quot; <span class="tok-kw">and</span> !s.used_as_lvalue) {
                        <span class="tok-kw">try</span> astgen.appendErrorTokNotes(s.token_src, <span class="tok-str">&quot;local variable is never mutated&quot;</span>, .{}, &amp;.{
                            <span class="tok-kw">try</span> astgen.errNoteTok(s.token_src, <span class="tok-str">&quot;consider using 'const'&quot;</span>, .{}),
                        });
                    }
                }

                scope = s.parent;
            },
            .defer_normal, .defer_error =&gt; scope = scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
            .namespace =&gt; <span class="tok-kw">unreachable</span>,
            .top =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">deferStmt</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    block_arena: <a href="std.mem.Allocator.html">Allocator</a>,
    scope_tag: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!*<a href="std.zig.AstGen.Scope.html">Scope</a> {
    <span class="tok-kw">var</span> defer_gen = gz.makeSubBlock(scope);
    defer_gen.cur_defer_node = node;
    defer_gen.any_defer_node = node;
    <span class="tok-kw">defer</span> defer_gen.unstack();

    <span class="tok-kw">const</span> tree = gz.astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> expr_node = node_datas[node].rhs;

    <span class="tok-kw">const</span> payload_token = node_datas[node].lhs;
    <span class="tok-kw">var</span> local_val_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> opt_remapped_err_code: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.OptionalIndex.html">OptionalIndex</a> = .none;
    <span class="tok-kw">const</span> have_err_code = scope_tag == .defer_error <span class="tok-kw">and</span> payload_token != <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">if</span> (!have_err_code) &amp;defer_gen.base <span class="tok-kw">else</span> blk: {
        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> gz.astgen.identAsString(payload_token);
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(payload_token), <span class="tok-str">&quot;_&quot;</span>)) {
            <span class="tok-kw">try</span> gz.astgen.appendErrorTok(payload_token, <span class="tok-str">&quot;discard of error capture; omit it instead&quot;</span>, .{});
            <span class="tok-kw">break</span> :blk &amp;defer_gen.base;
        }
        <span class="tok-kw">const</span> remapped_err_code: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        opt_remapped_err_code = remapped_err_code.toOptional();
        <span class="tok-kw">try</span> gz.astgen.instructions.append(gz.astgen.gpa, .{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .value_placeholder,
                .small = <span class="tok-null">undefined</span>,
                .operand = <span class="tok-null">undefined</span>,
            } },
        });
        <span class="tok-kw">const</span> remapped_err_code_ref = remapped_err_code.toRef();
        local_val_scope = .{
            .parent = &amp;defer_gen.base,
            .gen_zir = gz,
            .name = ident_name,
            .inst = remapped_err_code_ref,
            .token_src = payload_token,
            .id_cat = .capture,
        };
        <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_val, ident_name, remapped_err_code_ref);
        <span class="tok-kw">break</span> :blk &amp;local_val_scope.base;
    };
    _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.unusedResultExpr">unusedResultExpr</a>(&amp;defer_gen, sub_scope, expr_node);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(gz, scope, sub_scope);
    _ = <span class="tok-kw">try</span> defer_gen.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), .void_value);

    <span class="tok-kw">const</span> body = defer_gen.instructionsSlice();
    <span class="tok-kw">const</span> extra_insts: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-kw">if</span> (opt_remapped_err_code.unwrap()) |ec| &amp;.{ec} <span class="tok-kw">else</span> &amp;.{};
    <span class="tok-kw">const</span> body_len = gz.astgen.countBodyLenAfterFixupsExtraRefs(body, extra_insts);

    <span class="tok-kw">const</span> index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(gz.astgen.extra.items.len);
    <span class="tok-kw">try</span> gz.astgen.extra.ensureUnusedCapacity(gz.astgen.gpa, body_len);
    gz.astgen.appendBodyWithFixupsExtraRefsArrayList(&amp;gz.astgen.extra, body, extra_insts);

    <span class="tok-kw">const</span> defer_scope = <span class="tok-kw">try</span> block_arena.create(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>);

    defer_scope.* = .{
        .base = .{ .tag = scope_tag },
        .parent = scope,
        .index = index,
        .len = body_len,
        .remapped_err_code = opt_remapped_err_code,
    };
    <span class="tok-kw">return</span> &amp;defer_scope.base;
}

<span class="tok-kw">fn</span> <span class="tok-fn">varDecl</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    block_arena: <a href="std.mem.Allocator.html">Allocator</a>,
    var_decl: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!*<a href="std.zig.AstGen.Scope.html">Scope</a> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, node);
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);

    <span class="tok-kw">const</span> name_token = var_decl.ast.mut_token + <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(name_token);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_name_raw, <span class="tok-str">&quot;_&quot;</span>)) {
        <span class="tok-kw">return</span> astgen.failTok(name_token, <span class="tok-str">&quot;'_' used as an identifier without @\&quot;_\&quot; syntax&quot;</span>, .{});
    }
    <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(name_token);

    <span class="tok-kw">try</span> astgen.detectLocalShadowing(
        scope,
        ident_name,
        name_token,
        ident_name_raw,
        <span class="tok-kw">if</span> (token_tags[var_decl.ast.mut_token] == .keyword_const) .@&quot;local constant&quot; <span class="tok-kw">else</span> .@&quot;local variable&quot;,
    );

    <span class="tok-kw">if</span> (var_decl.ast.init_node == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;variables must be initialized&quot;</span>, .{});
    }

    <span class="tok-kw">if</span> (var_decl.ast.addrspace_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failTok(main_tokens[var_decl.ast.addrspace_node], <span class="tok-str">&quot;cannot set address space of local variable '{s}'&quot;</span>, .{ident_name_raw});
    }

    <span class="tok-kw">if</span> (var_decl.ast.section_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failTok(main_tokens[var_decl.ast.section_node], <span class="tok-str">&quot;cannot set section of local variable '{s}'&quot;</span>, .{ident_name_raw});
    }

    <span class="tok-kw">const</span> align_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">if</span> (var_decl.ast.align_node != <span class="tok-number">0</span>)
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_align_ri">coerced_align_ri</a>, var_decl.ast.align_node)
    <span class="tok-kw">else</span>
        .none;

    <span class="tok-kw">switch</span> (token_tags[var_decl.ast.mut_token]) {
        .keyword_const =&gt; {
            <span class="tok-kw">if</span> (var_decl.comptime_token) |comptime_token| {
                <span class="tok-kw">try</span> astgen.appendErrorTok(comptime_token, <span class="tok-str">&quot;'comptime const' is redundant; instead wrap the initialization expression with 'comptime'&quot;</span>, .{});
            }<span class="tok-comment">

            // `comptime const` is a non-fatal error; treat it like the init was marked `comptime`.
            </span><span class="tok-kw">const</span> force_comptime = var_decl.comptime_token != <span class="tok-null">null</span>;<span class="tok-comment">

            // Depending on the type of AST the initialization expression is, we may need an lvalue
            // or an rvalue as a result location. If it is an rvalue, we can use the instruction as
            // the variable, no memory location needed.
            </span><span class="tok-kw">const</span> type_node = var_decl.ast.type_node;
            <span class="tok-kw">if</span> (align_inst == .none <span class="tok-kw">and</span>
                !astgen.nodes_need_rl.contains(node))
            {
                <span class="tok-kw">const</span> result_info: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (type_node != <span class="tok-number">0</span>) .{
                    .rl = .{ .ty = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, type_node) },
                    .ctx = .const_init,
                } <span class="tok-kw">else</span> .{ .rl = .none, .ctx = .const_init };
                <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;
                gz.anon_name_strategy = .dbg_var;
                <span class="tok-kw">const</span> init_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExprComptime">reachableExprComptime</a>(gz, scope, result_info, var_decl.ast.init_node, node, <span class="tok-kw">if</span> (force_comptime) .comptime_keyword <span class="tok-kw">else</span> <span class="tok-null">null</span>);
                gz.anon_name_strategy = prev_anon_name_strategy;

                _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_const, init_inst, var_decl.ast.init_node);
                <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_val, ident_name, init_inst);<span class="tok-comment">

                // The const init expression may have modified the error return trace, so signal
                // to Sema that it should save the new index for restoring later.
                </span><span class="tok-kw">if</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.nodeMayAppendToErrorTrace">nodeMayAppendToErrorTrace</a>(tree, var_decl.ast.init_node))
                    _ = <span class="tok-kw">try</span> gz.addSaveErrRetIndex(.{ .if_of_error_type = init_inst });

                <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> block_arena.create(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>);
                sub_scope.* = .{
                    .parent = scope,
                    .gen_zir = gz,
                    .name = ident_name,
                    .inst = init_inst,
                    .token_src = name_token,
                    .id_cat = .@&quot;local constant&quot;,
                };
                <span class="tok-kw">return</span> &amp;sub_scope.base;
            }

            <span class="tok-kw">const</span> is_comptime = gz.is_comptime <span class="tok-kw">or</span>
                tree.nodes.items(.tag)[var_decl.ast.init_node] == .@&quot;comptime&quot;;

            <span class="tok-kw">const</span> init_rl: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a> = <span class="tok-kw">if</span> (type_node != <span class="tok-number">0</span>) init_rl: {
                <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, type_node);
                <span class="tok-kw">if</span> (align_inst == .none) {
                    <span class="tok-kw">break</span> :init_rl .{ .ptr = .{ .inst = <span class="tok-kw">try</span> gz.addUnNode(.alloc, type_inst, node) } };
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">break</span> :init_rl .{ .ptr = .{ .inst = <span class="tok-kw">try</span> gz.addAllocExtended(.{
                        .node = node,
                        .type_inst = type_inst,
                        .align_inst = align_inst,
                        .is_const = <span class="tok-null">true</span>,
                        .is_comptime = is_comptime,
                    }) } };
                }
            } <span class="tok-kw">else</span> init_rl: {
                <span class="tok-kw">const</span> alloc_inst = <span class="tok-kw">if</span> (align_inst == .none) ptr: {
                    <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_comptime)
                        .alloc_inferred_comptime
                    <span class="tok-kw">else</span>
                        .alloc_inferred;
                    <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addNode(tag, node);
                } <span class="tok-kw">else</span> ptr: {
                    <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addAllocExtended(.{
                        .node = node,
                        .type_inst = .none,
                        .align_inst = align_inst,
                        .is_const = <span class="tok-null">true</span>,
                        .is_comptime = is_comptime,
                    });
                };
                <span class="tok-kw">break</span> :init_rl .{ .inferred_ptr = alloc_inst };
            };
            <span class="tok-kw">const</span> var_ptr: Zir.Inst.Ref, <span class="tok-kw">const</span> resolve_inferred: <span class="tok-type">bool</span> = <span class="tok-kw">switch</span> (init_rl) {
                .ptr =&gt; |ptr| .{ ptr.inst, <span class="tok-null">false</span> },
                .inferred_ptr =&gt; |inst| .{ inst, <span class="tok-null">true</span> },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            };
            <span class="tok-kw">const</span> init_result_info: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = init_rl, .ctx = .const_init };

            <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;
            gz.anon_name_strategy = .dbg_var;
            <span class="tok-kw">defer</span> gz.anon_name_strategy = prev_anon_name_strategy;
            <span class="tok-kw">const</span> init_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExprComptime">reachableExprComptime</a>(gz, scope, init_result_info, var_decl.ast.init_node, node, <span class="tok-kw">if</span> (force_comptime) .comptime_keyword <span class="tok-kw">else</span> <span class="tok-null">null</span>);<span class="tok-comment">

            // The const init expression may have modified the error return trace, so signal
            // to Sema that it should save the new index for restoring later.
            </span><span class="tok-kw">if</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.nodeMayAppendToErrorTrace">nodeMayAppendToErrorTrace</a>(tree, var_decl.ast.init_node))
                _ = <span class="tok-kw">try</span> gz.addSaveErrRetIndex(.{ .if_of_error_type = init_inst });

            <span class="tok-kw">const</span> const_ptr = <span class="tok-kw">if</span> (resolve_inferred)
                <span class="tok-kw">try</span> gz.addUnNode(.resolve_inferred_alloc, var_ptr, node)
            <span class="tok-kw">else</span>
                <span class="tok-kw">try</span> gz.addUnNode(.make_ptr_const, var_ptr, node);

            <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_ptr, ident_name, const_ptr);

            <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> block_arena.create(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>);
            sub_scope.* = .{
                .parent = scope,
                .gen_zir = gz,
                .name = ident_name,
                .ptr = const_ptr,
                .token_src = name_token,
                .maybe_comptime = <span class="tok-null">true</span>,
                .id_cat = .@&quot;local constant&quot;,
            };
            <span class="tok-kw">return</span> &amp;sub_scope.base;
        },
        .keyword_var =&gt; {
            <span class="tok-kw">if</span> (var_decl.comptime_token != <span class="tok-null">null</span> <span class="tok-kw">and</span> gz.is_comptime)
                <span class="tok-kw">return</span> astgen.failTok(var_decl.comptime_token.?, <span class="tok-str">&quot;'comptime var' is redundant in comptime scope&quot;</span>, .{});
            <span class="tok-kw">const</span> is_comptime = var_decl.comptime_token != <span class="tok-null">null</span> <span class="tok-kw">or</span> gz.is_comptime;
            <span class="tok-kw">const</span> alloc: Zir.Inst.Ref, <span class="tok-kw">const</span> resolve_inferred: <span class="tok-type">bool</span>, <span class="tok-kw">const</span> result_info: ResultInfo = <span class="tok-kw">if</span> (var_decl.ast.type_node != <span class="tok-number">0</span>) a: {
                <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, var_decl.ast.type_node);
                <span class="tok-kw">const</span> alloc = alloc: {
                    <span class="tok-kw">if</span> (align_inst == .none) {
                        <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime)
                            .alloc_comptime_mut
                        <span class="tok-kw">else</span>
                            .alloc_mut;
                        <span class="tok-kw">break</span> :alloc <span class="tok-kw">try</span> gz.addUnNode(tag, type_inst, node);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">break</span> :alloc <span class="tok-kw">try</span> gz.addAllocExtended(.{
                            .node = node,
                            .type_inst = type_inst,
                            .align_inst = align_inst,
                            .is_const = <span class="tok-null">false</span>,
                            .is_comptime = is_comptime,
                        });
                    }
                };
                <span class="tok-kw">break</span> :a .{ alloc, <span class="tok-null">false</span>, .{ .rl = .{ .ptr = .{ .inst = alloc } } } };
            } <span class="tok-kw">else</span> a: {
                <span class="tok-kw">const</span> alloc = alloc: {
                    <span class="tok-kw">if</span> (align_inst == .none) {
                        <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime)
                            .alloc_inferred_comptime_mut
                        <span class="tok-kw">else</span>
                            .alloc_inferred_mut;
                        <span class="tok-kw">break</span> :alloc <span class="tok-kw">try</span> gz.addNode(tag, node);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">break</span> :alloc <span class="tok-kw">try</span> gz.addAllocExtended(.{
                            .node = node,
                            .type_inst = .none,
                            .align_inst = align_inst,
                            .is_const = <span class="tok-null">false</span>,
                            .is_comptime = is_comptime,
                        });
                    }
                };
                <span class="tok-kw">break</span> :a .{ alloc, <span class="tok-null">true</span>, .{ .rl = .{ .inferred_ptr = alloc } } };
            };
            <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;
            gz.anon_name_strategy = .dbg_var;
            _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExprComptime">reachableExprComptime</a>(
                gz,
                scope,
                result_info,
                var_decl.ast.init_node,
                node,
                <span class="tok-kw">if</span> (var_decl.comptime_token != <span class="tok-null">null</span>) .comptime_keyword <span class="tok-kw">else</span> <span class="tok-null">null</span>,
            );
            gz.anon_name_strategy = prev_anon_name_strategy;
            <span class="tok-kw">const</span> final_ptr: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">if</span> (resolve_inferred) ptr: {
                <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addUnNode(.resolve_inferred_alloc, alloc, node);
            } <span class="tok-kw">else</span> alloc;

            <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_ptr, ident_name, final_ptr);

            <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> block_arena.create(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>);
            sub_scope.* = .{
                .parent = scope,
                .gen_zir = gz,
                .name = ident_name,
                .ptr = final_ptr,
                .token_src = name_token,
                .maybe_comptime = is_comptime,
                .id_cat = .@&quot;local variable&quot;,
            };
            <span class="tok-kw">return</span> &amp;sub_scope.base;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">emitDbgNode</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !<span class="tok-type">void</span> {<span class="tok-comment">
    // The instruction emitted here is for debugging runtime code.
    // If the current block will be evaluated only during semantic analysis
    // then no dbg_stmt ZIR instruction is needed.
    </span><span class="tok-kw">if</span> (gz.is_comptime) <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> astgen = gz.astgen;
    astgen.advanceSourceCursorToNode(node);
    <span class="tok-kw">const</span> line = astgen.source_line - gz.decl_line;
    <span class="tok-kw">const</span> column = astgen.source_column;
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, .{ line, column });
}

<span class="tok-kw">fn</span> <span class="tok-fn">assign</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, infix_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, infix_node);
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);

    <span class="tok-kw">const</span> lhs = node_datas[infix_node].lhs;
    <span class="tok-kw">const</span> rhs = node_datas[infix_node].rhs;
    <span class="tok-kw">if</span> (node_tags[lhs] == .identifier) {<span class="tok-comment">
        // This intentionally does not support `@&quot;_&quot;` syntax.
        </span><span class="tok-kw">const</span> ident_name = tree.tokenSlice(main_tokens[lhs]);
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;_&quot;</span>)) {
            _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .discard, .ctx = .assignment }, rhs);
            <span class="tok-kw">return</span>;
        }
    }
    <span class="tok-kw">const</span> lvalue = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.lvalExpr">lvalExpr</a>(gz, scope, lhs);
    _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ptr = .{
        .inst = lvalue,
        .src_node = infix_node,
    } } }, rhs);
}

<span class="tok-comment">/// Handles destructure assignments where no LHS is a `const` or `var` decl.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">assignDestructure</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, node);
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);

    <span class="tok-kw">const</span> full = tree.assignDestructure(node);
    <span class="tok-kw">if</span> (full.comptime_token != <span class="tok-null">null</span> <span class="tok-kw">and</span> gz.is_comptime) {
        <span class="tok-kw">return</span> astgen.appendErrorNode(node, <span class="tok-str">&quot;redundant comptime keyword in already comptime scope&quot;</span>, .{});
    }<span class="tok-comment">

    // If this expression is marked comptime, we must wrap the whole thing in a comptime block.
    </span><span class="tok-kw">var</span> gz_buf: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> inner_gz = <span class="tok-kw">if</span> (full.comptime_token) |_| bs: {
        gz_buf = gz.makeSubBlock(scope);
        gz_buf.is_comptime = <span class="tok-null">true</span>;
        <span class="tok-kw">break</span> :bs &amp;gz_buf;
    } <span class="tok-kw">else</span> gz;
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (full.comptime_token) |_| inner_gz.unstack();

    <span class="tok-kw">const</span> rl_components = <span class="tok-kw">try</span> astgen.arena.alloc(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>.<a href="std.zig.AstGen.ResultInfo.Loc.DestructureComponent.html">DestructureComponent</a>, full.ast.variables.len);
    <span class="tok-kw">for</span> (rl_components, full.ast.variables) |*variable_rl, variable_node| {
        <span class="tok-kw">if</span> (node_tags[variable_node] == .identifier) {<span class="tok-comment">
            // This intentionally does not support `@&quot;_&quot;` syntax.
            </span><span class="tok-kw">const</span> ident_name = tree.tokenSlice(main_tokens[variable_node]);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;_&quot;</span>)) {
                variable_rl.* = .discard;
                <span class="tok-kw">continue</span>;
            }
        }
        variable_rl.* = .{ .typed_ptr = .{
            .inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.lvalExpr">lvalExpr</a>(inner_gz, scope, variable_node),
            .src_node = variable_node,
        } };
    }

    <span class="tok-kw">const</span> ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .{ .destructure = .{
        .src_node = node,
        .components = rl_components,
    } } };

    _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(inner_gz, scope, ri, full.ast.value_expr);

    <span class="tok-kw">if</span> (full.comptime_token) |_| {
        <span class="tok-kw">const</span> comptime_block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_comptime, node);
        _ = <span class="tok-kw">try</span> inner_gz.addBreak(.break_inline, comptime_block_inst, .void_value);
        <span class="tok-kw">try</span> inner_gz.setBlockComptimeBody(comptime_block_inst, .comptime_keyword);
        <span class="tok-kw">try</span> gz.instructions.append(gz.astgen.gpa, comptime_block_inst);
    }
}

<span class="tok-comment">/// Handles destructure assignments where the LHS may contain `const` or `var` decls.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">assignDestructureMaybeDecls</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    block_arena: <a href="std.mem.Allocator.html">Allocator</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!*<a href="std.zig.AstGen.Scope.html">Scope</a> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, node);
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);

    <span class="tok-kw">const</span> full = tree.assignDestructure(node);
    <span class="tok-kw">if</span> (full.comptime_token != <span class="tok-null">null</span> <span class="tok-kw">and</span> gz.is_comptime) {
        <span class="tok-kw">try</span> astgen.appendErrorNode(node, <span class="tok-str">&quot;redundant comptime keyword in already comptime scope&quot;</span>, .{});
    }

    <span class="tok-kw">const</span> is_comptime = full.comptime_token != <span class="tok-null">null</span> <span class="tok-kw">or</span> gz.is_comptime;
    <span class="tok-kw">const</span> value_is_comptime = node_tags[full.ast.value_expr] == .@&quot;comptime&quot;;<span class="tok-comment">

    // When declaring consts via a destructure, we always use a result pointer.
    // This avoids the need to create tuple types, and is also likely easier to
    // optimize, since it's a bit tricky for the optimizer to &quot;split up&quot; the
    // value into individual pointer writes down the line.

    // We know this rl information won't live past the evaluation of this
    // expression, so it may as well go in the block arena.
    </span><span class="tok-kw">const</span> rl_components = <span class="tok-kw">try</span> block_arena.alloc(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>.<a href="std.zig.AstGen.ResultInfo.Loc.DestructureComponent.html">DestructureComponent</a>, full.ast.variables.len);
    <span class="tok-kw">var</span> any_non_const_variables = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> any_lvalue_expr = <span class="tok-null">false</span>;
    <span class="tok-kw">for</span> (rl_components, full.ast.variables) |*variable_rl, variable_node| {
        <span class="tok-kw">switch</span> (node_tags[variable_node]) {
            .identifier =&gt; {<span class="tok-comment">
                // This intentionally does not support `@&quot;_&quot;` syntax.
                </span><span class="tok-kw">const</span> ident_name = tree.tokenSlice(main_tokens[variable_node]);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;_&quot;</span>)) {
                    any_non_const_variables = <span class="tok-null">true</span>;
                    variable_rl.* = .discard;
                    <span class="tok-kw">continue</span>;
                }
            },
            .global_var_decl, .local_var_decl, .simple_var_decl, .aligned_var_decl =&gt; {
                <span class="tok-kw">const</span> full_var_decl = tree.fullVarDecl(variable_node).?;

                <span class="tok-kw">const</span> name_token = full_var_decl.ast.mut_token + <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(name_token);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_name_raw, <span class="tok-str">&quot;_&quot;</span>)) {
                    <span class="tok-kw">return</span> astgen.failTok(name_token, <span class="tok-str">&quot;'_' used as an identifier without @\&quot;_\&quot; syntax&quot;</span>, .{});
                }<span class="tok-comment">

                // We detect shadowing in the second pass over these, while we're creating scopes.

                </span><span class="tok-kw">if</span> (full_var_decl.ast.addrspace_node != <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> astgen.failTok(main_tokens[full_var_decl.ast.addrspace_node], <span class="tok-str">&quot;cannot set address space of local variable '{s}'&quot;</span>, .{ident_name_raw});
                }
                <span class="tok-kw">if</span> (full_var_decl.ast.section_node != <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> astgen.failTok(main_tokens[full_var_decl.ast.section_node], <span class="tok-str">&quot;cannot set section of local variable '{s}'&quot;</span>, .{ident_name_raw});
                }

                <span class="tok-kw">const</span> is_const = <span class="tok-kw">switch</span> (token_tags[full_var_decl.ast.mut_token]) {
                    .keyword_var =&gt; <span class="tok-null">false</span>,
                    .keyword_const =&gt; <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
                <span class="tok-kw">if</span> (!is_const) any_non_const_variables = <span class="tok-null">true</span>;<span class="tok-comment">

                // We also mark `const`s as comptime if the RHS is definitely comptime-known.
                </span><span class="tok-kw">const</span> this_variable_comptime = is_comptime <span class="tok-kw">or</span> (is_const <span class="tok-kw">and</span> value_is_comptime);

                <span class="tok-kw">const</span> align_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">if</span> (full_var_decl.ast.align_node != <span class="tok-number">0</span>)
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_align_ri">coerced_align_ri</a>, full_var_decl.ast.align_node)
                <span class="tok-kw">else</span>
                    .none;

                <span class="tok-kw">if</span> (full_var_decl.ast.type_node != <span class="tok-number">0</span>) {<span class="tok-comment">
                    // Typed alloc
                    </span><span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, full_var_decl.ast.type_node);
                    <span class="tok-kw">const</span> ptr = <span class="tok-kw">if</span> (align_inst == .none) ptr: {
                        <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_const)
                            .alloc
                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this_variable_comptime)
                            .alloc_comptime_mut
                        <span class="tok-kw">else</span>
                            .alloc_mut;
                        <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addUnNode(tag, type_inst, node);
                    } <span class="tok-kw">else</span> <span class="tok-kw">try</span> gz.addAllocExtended(.{
                        .node = node,
                        .type_inst = type_inst,
                        .align_inst = align_inst,
                        .is_const = is_const,
                        .is_comptime = this_variable_comptime,
                    });
                    variable_rl.* = .{ .typed_ptr = .{ .inst = ptr } };
                } <span class="tok-kw">else</span> {<span class="tok-comment">
                    // Inferred alloc
                    </span><span class="tok-kw">const</span> ptr = <span class="tok-kw">if</span> (align_inst == .none) ptr: {
                        <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_const) tag: {
                            <span class="tok-kw">break</span> :tag <span class="tok-kw">if</span> (this_variable_comptime) .alloc_inferred_comptime <span class="tok-kw">else</span> .alloc_inferred;
                        } <span class="tok-kw">else</span> tag: {
                            <span class="tok-kw">break</span> :tag <span class="tok-kw">if</span> (this_variable_comptime) .alloc_inferred_comptime_mut <span class="tok-kw">else</span> .alloc_inferred_mut;
                        };
                        <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addNode(tag, node);
                    } <span class="tok-kw">else</span> <span class="tok-kw">try</span> gz.addAllocExtended(.{
                        .node = node,
                        .type_inst = .none,
                        .align_inst = align_inst,
                        .is_const = is_const,
                        .is_comptime = this_variable_comptime,
                    });
                    variable_rl.* = .{ .inferred_ptr = ptr };
                }

                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; {},
        }<span class="tok-comment">
        // This variable is just an lvalue expression.
        // We will fill in its result pointer later, inside a comptime block.
        </span>any_non_const_variables = <span class="tok-null">true</span>;
        any_lvalue_expr = <span class="tok-null">true</span>;
        variable_rl.* = .{ .typed_ptr = .{
            .inst = <span class="tok-null">undefined</span>,
            .src_node = variable_node,
        } };
    }

    <span class="tok-kw">if</span> (full.comptime_token != <span class="tok-null">null</span> <span class="tok-kw">and</span> !any_non_const_variables) {
        <span class="tok-kw">try</span> astgen.appendErrorTok(full.comptime_token.?, <span class="tok-str">&quot;'comptime const' is redundant; instead wrap the initialization expression with 'comptime'&quot;</span>, .{});<span class="tok-comment">
        // Note that this is non-fatal; we will still evaluate at comptime.
    </span>}<span class="tok-comment">

    // If this expression is marked comptime, we must wrap it in a comptime block.
    </span><span class="tok-kw">var</span> gz_buf: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> inner_gz = <span class="tok-kw">if</span> (full.comptime_token) |_| bs: {
        gz_buf = gz.makeSubBlock(scope);
        gz_buf.is_comptime = <span class="tok-null">true</span>;
        <span class="tok-kw">break</span> :bs &amp;gz_buf;
    } <span class="tok-kw">else</span> gz;
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (full.comptime_token) |_| inner_gz.unstack();

    <span class="tok-kw">if</span> (any_lvalue_expr) {<span class="tok-comment">
        // At least one variable was an lvalue expr. Iterate again in order to
        // evaluate the lvalues from within the possible block_comptime.
        </span><span class="tok-kw">for</span> (rl_components, full.ast.variables) |*variable_rl, variable_node| {
            <span class="tok-kw">if</span> (variable_rl.* != .typed_ptr) <span class="tok-kw">continue</span>;
            <span class="tok-kw">switch</span> (node_tags[variable_node]) {
                .global_var_decl, .local_var_decl, .simple_var_decl, .aligned_var_decl =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-kw">else</span> =&gt; {},
            }
            variable_rl.typed_ptr.inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.lvalExpr">lvalExpr</a>(inner_gz, scope, variable_node);
        }
    }<span class="tok-comment">

    // We can't give a reasonable anon name strategy for destructured inits, so
    // leave it at its default of `.anon`.
    </span>_ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(inner_gz, scope, .{ .rl = .{ .destructure = .{
        .src_node = node,
        .components = rl_components,
    } } }, full.ast.value_expr, node);

    <span class="tok-kw">if</span> (full.comptime_token) |_| {<span class="tok-comment">
        // Finish the block_comptime. Inferred alloc resolution etc will occur
        // in the parent block.
        </span><span class="tok-kw">const</span> comptime_block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_comptime, node);
        _ = <span class="tok-kw">try</span> inner_gz.addBreak(.break_inline, comptime_block_inst, .void_value);
        <span class="tok-kw">try</span> inner_gz.setBlockComptimeBody(comptime_block_inst, .comptime_keyword);
        <span class="tok-kw">try</span> gz.instructions.append(gz.astgen.gpa, comptime_block_inst);
    }<span class="tok-comment">

    // Now, iterate over the variable exprs to construct any new scopes.
    // If there were any inferred allocations, resolve them.
    // If there were any `const` decls, make the pointer constant.
    </span><span class="tok-kw">var</span> cur_scope = scope;
    <span class="tok-kw">for</span> (rl_components, full.ast.variables) |variable_rl, variable_node| {
        <span class="tok-kw">switch</span> (node_tags[variable_node]) {
            .local_var_decl, .simple_var_decl, .aligned_var_decl =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,<span class="tok-comment"> // We were mutating an existing lvalue - nothing to do
        </span>}
        <span class="tok-kw">const</span> full_var_decl = tree.fullVarDecl(variable_node).?;
        <span class="tok-kw">const</span> raw_ptr, <span class="tok-kw">const</span> resolve_inferred = <span class="tok-kw">switch</span> (variable_rl) {
            .discard =&gt; <span class="tok-kw">unreachable</span>,
            .typed_ptr =&gt; |typed_ptr| .{ typed_ptr.inst, <span class="tok-null">false</span> },
            .inferred_ptr =&gt; |ptr_inst| .{ ptr_inst, <span class="tok-null">true</span> },
        };
        <span class="tok-kw">const</span> is_const = <span class="tok-kw">switch</span> (token_tags[full_var_decl.ast.mut_token]) {
            .keyword_var =&gt; <span class="tok-null">false</span>,
            .keyword_const =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };<span class="tok-comment">

        // If the alloc was inferred, resolve it. If the alloc was const, make it const.
        </span><span class="tok-kw">const</span> final_ptr = <span class="tok-kw">if</span> (resolve_inferred)
            <span class="tok-kw">try</span> gz.addUnNode(.resolve_inferred_alloc, raw_ptr, variable_node)
        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (is_const)
            <span class="tok-kw">try</span> gz.addUnNode(.make_ptr_const, raw_ptr, node)
        <span class="tok-kw">else</span>
            raw_ptr;

        <span class="tok-kw">const</span> name_token = full_var_decl.ast.mut_token + <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(name_token);
        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(name_token);
        <span class="tok-kw">try</span> astgen.detectLocalShadowing(
            cur_scope,
            ident_name,
            name_token,
            ident_name_raw,
            <span class="tok-kw">if</span> (is_const) .@&quot;local constant&quot; <span class="tok-kw">else</span> .@&quot;local variable&quot;,
        );
        <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_ptr, ident_name, final_ptr);<span class="tok-comment">
        // Finally, create the scope.
        </span><span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> block_arena.create(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>);
        sub_scope.* = .{
            .parent = cur_scope,
            .gen_zir = gz,
            .name = ident_name,
            .ptr = final_ptr,
            .token_src = name_token,
            .maybe_comptime = is_const <span class="tok-kw">or</span> is_comptime,
            .id_cat = <span class="tok-kw">if</span> (is_const) .@&quot;local constant&quot; <span class="tok-kw">else</span> .@&quot;local variable&quot;,
        };
        cur_scope = &amp;sub_scope.base;
    }

    <span class="tok-kw">return</span> cur_scope;
}

<span class="tok-kw">fn</span> <span class="tok-fn">assignOp</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    infix_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    op_inst_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, infix_node);
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">const</span> lhs_ptr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.lvalExpr">lvalExpr</a>(gz, scope, node_datas[infix_node].lhs);

    <span class="tok-kw">const</span> cursor = <span class="tok-kw">switch</span> (op_inst_tag) {
        .add, .sub, .mul, .div, .mod_rem =&gt; <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, infix_node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,
    };
    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> gz.addUnNode(.load, lhs_ptr, infix_node);

    <span class="tok-kw">const</span> rhs_res_ty = <span class="tok-kw">switch</span> (op_inst_tag) {
        .add,
        .sub,
        =&gt; <span class="tok-kw">try</span> gz.add(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .inplace_arith_result_ty,
                .small = <span class="tok-builtin">@intFromEnum</span>(<span class="tok-builtin">@as</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.InplaceOp.html">InplaceOp</a>, <span class="tok-kw">switch</span> (op_inst_tag) {
                    .add =&gt; .add_eq,
                    .sub =&gt; .sub_eq,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                })),
                .operand = <span class="tok-builtin">@intFromEnum</span>(lhs),
            } },
        }),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> gz.addUnNode(.typeof, lhs, infix_node),<span class="tok-comment"> // same as LHS type
    </span>};<span class="tok-comment">
    // Not `coerced_ty` since `add`/etc won't coerce to this type.
    </span><span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = rhs_res_ty } }, node_datas[infix_node].rhs);

    <span class="tok-kw">switch</span> (op_inst_tag) {
        .add, .sub, .mul, .div, .mod_rem =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(op_inst_tag, infix_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = lhs,
        .rhs = rhs,
    });
    _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, infix_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = lhs_ptr,
        .rhs = result,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">assignShift</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    infix_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    op_inst_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, infix_node);
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">const</span> lhs_ptr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.lvalExpr">lvalExpr</a>(gz, scope, node_datas[infix_node].lhs);
    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> gz.addUnNode(.load, lhs_ptr, infix_node);
    <span class="tok-kw">const</span> rhs_type = <span class="tok-kw">try</span> gz.addUnNode(.typeof_log2_int_type, lhs, infix_node);
    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = rhs_type } }, node_datas[infix_node].rhs);

    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(op_inst_tag, infix_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = lhs,
        .rhs = rhs,
    });
    _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, infix_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = lhs_ptr,
        .rhs = result,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">assignShiftSat</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, infix_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, infix_node);
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">const</span> lhs_ptr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.lvalExpr">lvalExpr</a>(gz, scope, node_datas[infix_node].lhs);
    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> gz.addUnNode(.load, lhs_ptr, infix_node);<span class="tok-comment">
    // Saturating shift-left allows any integer type for both the LHS and RHS.
    </span><span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node_datas[infix_node].rhs);

    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.shl_sat, infix_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = lhs,
        .rhs = rhs,
    });
    _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, infix_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = lhs_ptr,
        .rhs = result,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">ptrType</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ptr_info: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">if</span> (ptr_info.size == .c <span class="tok-kw">and</span> ptr_info.allowzero_token != <span class="tok-null">null</span>) {
        <span class="tok-kw">return</span> gz.astgen.failTok(ptr_info.allowzero_token.?, <span class="tok-str">&quot;C pointers always allow address zero&quot;</span>, .{});
    }

    <span class="tok-kw">const</span> source_offset = gz.astgen.source_offset;
    <span class="tok-kw">const</span> source_line = gz.astgen.source_line;
    <span class="tok-kw">const</span> source_column = gz.astgen.source_column;
    <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, ptr_info.ast.child_type);

    <span class="tok-kw">var</span> sentinel_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = .none;
    <span class="tok-kw">var</span> align_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = .none;
    <span class="tok-kw">var</span> addrspace_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = .none;
    <span class="tok-kw">var</span> bit_start_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = .none;
    <span class="tok-kw">var</span> bit_end_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = .none;
    <span class="tok-kw">var</span> trailing_count: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">if</span> (ptr_info.ast.sentinel != <span class="tok-number">0</span>) {<span class="tok-comment">
        // These attributes can appear in any order and they all come before the
        // element type so we need to reset the source cursor before generating them.
        </span>gz.astgen.source_offset = source_offset;
        gz.astgen.source_line = source_line;
        gz.astgen.source_column = source_column;

        sentinel_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(
            gz,
            scope,
            .{ .rl = .{ .ty = elem_type } },
            ptr_info.ast.sentinel,
            <span class="tok-kw">switch</span> (ptr_info.size) {
                .slice =&gt; .slice_sentinel,
                <span class="tok-kw">else</span> =&gt; .pointer_sentinel,
            },
        );
        trailing_count += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">if</span> (ptr_info.ast.addrspace_node != <span class="tok-number">0</span>) {
        gz.astgen.source_offset = source_offset;
        gz.astgen.source_line = source_line;
        gz.astgen.source_column = source_column;

        <span class="tok-kw">const</span> addrspace_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(ptr_info.ast.addrspace_node, .address_space);
        addrspace_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = addrspace_ty } }, ptr_info.ast.addrspace_node, .@&quot;addrspace&quot;);
        trailing_count += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">if</span> (ptr_info.ast.align_node != <span class="tok-number">0</span>) {
        gz.astgen.source_offset = source_offset;
        gz.astgen.source_line = source_line;
        gz.astgen.source_column = source_column;

        align_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_align_ri">coerced_align_ri</a>, ptr_info.ast.align_node, .@&quot;align&quot;);
        trailing_count += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">if</span> (ptr_info.ast.bit_range_start != <span class="tok-number">0</span>) {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr_info.ast.bit_range_end != <span class="tok-number">0</span>);
        bit_start_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .u16_type } }, ptr_info.ast.bit_range_start, .<span class="tok-type">type</span>);
        bit_end_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .u16_type } }, ptr_info.ast.bit_range_end, .<span class="tok-type">type</span>);
        trailing_count += <span class="tok-number">2</span>;
    }

    <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
    <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> gz.astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.PtrType.html">PtrType</a>).@&quot;struct&quot;.fields.len +
        trailing_count);

    <span class="tok-kw">const</span> payload_index = gz.astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.PtrType.html">PtrType</a>{
        .elem_type = elem_type,
        .src_node = gz.nodeIndexToRelative(node),
    });
    <span class="tok-kw">if</span> (sentinel_ref != .none) {
        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(sentinel_ref));
    }
    <span class="tok-kw">if</span> (align_ref != .none) {
        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(align_ref));
    }
    <span class="tok-kw">if</span> (addrspace_ref != .none) {
        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(addrspace_ref));
    }
    <span class="tok-kw">if</span> (bit_start_ref != .none) {
        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(bit_start_ref));
        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(bit_end_ref));
    }

    <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
    <span class="tok-kw">const</span> result = new_index.toRef();
    gz.astgen.instructions.appendAssumeCapacity(.{ .tag = .ptr_type, .data = .{
        .ptr_type = .{
            .flags = .{
                .is_allowzero = ptr_info.allowzero_token != <span class="tok-null">null</span>,
                .is_mutable = ptr_info.const_token == <span class="tok-null">null</span>,
                .is_volatile = ptr_info.volatile_token != <span class="tok-null">null</span>,
                .has_sentinel = sentinel_ref != .none,
                .has_align = align_ref != .none,
                .has_addrspace = addrspace_ref != .none,
                .has_bit_range = bit_start_ref != .none,
            },
            .size = ptr_info.size,
            .payload_index = payload_index,
        },
    } });
    gz.instructions.appendAssumeCapacity(new_index);

    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">arrayType</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);

    <span class="tok-kw">const</span> len_node = node_datas[node].lhs;
    <span class="tok-kw">if</span> (node_tags[len_node] == .identifier <span class="tok-kw">and</span>
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[len_node]), <span class="tok-str">&quot;_&quot;</span>))
    {
        <span class="tok-kw">return</span> astgen.failNode(len_node, <span class="tok-str">&quot;unable to infer array size&quot;</span>, .{});
    }
    <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExprComptime">reachableExprComptime</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, len_node, node, .<span class="tok-type">type</span>);
    <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, node_datas[node].rhs);

    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.array_type, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = len,
        .rhs = elem_type,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">arrayTypeSentinel</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> extra = tree.extraData(node_datas[node].rhs, <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ArrayTypeSentinel.html">ArrayTypeSentinel</a>);

    <span class="tok-kw">const</span> len_node = node_datas[node].lhs;
    <span class="tok-kw">if</span> (node_tags[len_node] == .identifier <span class="tok-kw">and</span>
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[len_node]), <span class="tok-str">&quot;_&quot;</span>))
    {
        <span class="tok-kw">return</span> astgen.failNode(len_node, <span class="tok-str">&quot;unable to infer array size&quot;</span>, .{});
    }
    <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExprComptime">reachableExprComptime</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, len_node, node, .array_length);
    <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, extra.elem_type);
    <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExprComptime">reachableExprComptime</a>(gz, scope, .{ .rl = .{ .coerced_ty = elem_type } }, extra.sentinel, node, .array_sentinel);

    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.array_type_sentinel, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ArrayTypeSentinel.html">ArrayTypeSentinel</a>{
        .len = len,
        .elem_type = elem_type,
        .sentinel = sentinel,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">const</span> WipMembers = <span class="tok-kw">struct</span> {
    payload: *<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
    payload_top: <span class="tok-type">usize</span>,
    field_bits_start: <span class="tok-type">u32</span>,
    fields_start: <span class="tok-type">u32</span>,
    fields_end: <span class="tok-type">u32</span>,
    decl_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
    field_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,

    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, payload: *<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>), decl_count: <span class="tok-type">u32</span>, field_count: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> bits_per_field: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> max_field_size: <span class="tok-type">u32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.AstGen.WipMembers.html">Self</a> {
        <span class="tok-kw">const</span> payload_top: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(payload.items.len);
        <span class="tok-kw">const</span> field_bits_start = payload_top + decl_count;
        <span class="tok-kw">const</span> fields_start = field_bits_start + <span class="tok-kw">if</span> (bits_per_field &gt; <span class="tok-number">0</span>) blk: {
            <span class="tok-kw">const</span> fields_per_u32 = <span class="tok-number">32</span> / bits_per_field;
            <span class="tok-kw">break</span> :blk (field_count + fields_per_u32 - <span class="tok-number">1</span>) / fields_per_u32;
        } <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> payload_end = fields_start + field_count * max_field_size;
        <span class="tok-kw">try</span> payload.resize(gpa, payload_end);
        <span class="tok-kw">return</span> .{
            .payload = payload,
            .payload_top = payload_top,
            .field_bits_start = field_bits_start,
            .fields_start = fields_start,
            .fields_end = fields_start,
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">nextDecl</span>(self: *<a href="std.zig.AstGen.WipMembers.html">Self</a>, decl_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) <span class="tok-type">void</span> {
        self.payload.items[self.payload_top + self.decl_index] = <span class="tok-builtin">@intFromEnum</span>(decl_inst);
        self.decl_index += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">nextField</span>(self: *<a href="std.zig.AstGen.WipMembers.html">Self</a>, <span class="tok-kw">comptime</span> bits_per_field: <span class="tok-type">u32</span>, bits: [bits_per_field]<span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> fields_per_u32 = <span class="tok-number">32</span> / bits_per_field;
        <span class="tok-kw">const</span> index = self.field_bits_start + self.field_index / fields_per_u32;
        <a href="std.debug.html#std.debug.assert">assert</a>(index &lt; self.fields_start);
        <span class="tok-kw">var</span> bit_bag: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (self.field_index % fields_per_u32 == <span class="tok-number">0</span>) <span class="tok-number">0</span> <span class="tok-kw">else</span> self.payload.items[index];
        bit_bag &gt;&gt;= bits_per_field;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; bits_per_field) : (i += <span class="tok-number">1</span>) {
            bit_bag |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intFromBool</span>(bits[i])) &lt;&lt; (<span class="tok-number">32</span> - bits_per_field + i);
        }
        self.payload.items[index] = bit_bag;
        self.field_index += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">appendToField</span>(self: *<a href="std.zig.AstGen.WipMembers.html">Self</a>, data: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.fields_end &lt; self.payload.items.len);
        self.payload.items[self.fields_end] = data;
        self.fields_end += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">finishBits</span>(self: *<a href="std.zig.AstGen.WipMembers.html">Self</a>, <span class="tok-kw">comptime</span> bits_per_field: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (bits_per_field &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> fields_per_u32 = <span class="tok-number">32</span> / bits_per_field;
            <span class="tok-kw">const</span> empty_field_slots = fields_per_u32 - (self.field_index % fields_per_u32);
            <span class="tok-kw">if</span> (self.field_index &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> empty_field_slots &lt; fields_per_u32) {
                <span class="tok-kw">const</span> index = self.field_bits_start + self.field_index / fields_per_u32;
                self.payload.items[index] &gt;&gt;= <span class="tok-builtin">@intCast</span>(empty_field_slots * bits_per_field);
            }
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">declsSlice</span>(self: *<a href="std.zig.AstGen.WipMembers.html">Self</a>) []<span class="tok-type">u32</span> {
        <span class="tok-kw">return</span> self.payload.items[self.payload_top..][<span class="tok-number">0</span>..self.decl_index];
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fieldsSlice</span>(self: *<a href="std.zig.AstGen.WipMembers.html">Self</a>) []<span class="tok-type">u32</span> {
        <span class="tok-kw">return</span> self.payload.items[self.field_bits_start..self.fields_end];
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.AstGen.WipMembers.html">Self</a>) <span class="tok-type">void</span> {
        self.payload.items.len = self.payload_top;
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">fnDecl</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    wip_members: *<a href="std.zig.AstGen.WipMembers.html">WipMembers</a>,
    decl_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    body_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    fn_proto: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> old_hasher = astgen.src_hasher;
    <span class="tok-kw">defer</span> astgen.src_hasher = old_hasher;
    astgen.src_hasher = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>.<a href="std.crypto.blake3.Blake3.html#std.crypto.blake3.Blake3.init">init</a>(.{});<span class="tok-comment">
    // We don't add the full source yet, because we also need the prototype hash!
    // The source slice is added towards the *end* of this function.
    </span>astgen.src_hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;astgen.source_column));<span class="tok-comment">

    // missing function name already checked in scanContainer()
    </span><span class="tok-kw">const</span> fn_name_token = fn_proto.name_token.?;<span class="tok-comment">

    // We insert this at the beginning so that its instruction index marks the
    // start of the top level declaration.
    </span><span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeDeclaration(fn_proto.ast.proto_node);
    astgen.advanceSourceCursorToNode(decl_node);

    <span class="tok-kw">const</span> saved_cursor = astgen.saveSourceCursor();

    <span class="tok-kw">const</span> decl_column = astgen.source_column;<span class="tok-comment">

    // Set this now, since parameter types, return type, etc may be generic.
    </span><span class="tok-kw">const</span> prev_within_fn = astgen.within_fn;
    <span class="tok-kw">defer</span> astgen.within_fn = prev_within_fn;
    astgen.within_fn = <span class="tok-null">true</span>;

    <span class="tok-kw">const</span> is_pub = fn_proto.visib_token != <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> is_export = blk: {
        <span class="tok-kw">const</span> maybe_export_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :blk token_tags[maybe_export_token] == .keyword_export;
    };
    <span class="tok-kw">const</span> is_extern = blk: {
        <span class="tok-kw">const</span> maybe_extern_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :blk token_tags[maybe_extern_token] == .keyword_extern;
    };
    <span class="tok-kw">const</span> has_inline_keyword = blk: {
        <span class="tok-kw">const</span> maybe_inline_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :blk token_tags[maybe_inline_token] == .keyword_inline;
    };
    <span class="tok-kw">const</span> lib_name = <span class="tok-kw">if</span> (fn_proto.lib_name) |lib_name_token| blk: {
        <span class="tok-kw">const</span> lib_name_str = <span class="tok-kw">try</span> astgen.strLitAsString(lib_name_token);
        <span class="tok-kw">const</span> lib_name_slice = astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(lib_name_str.index)..][<span class="tok-number">0</span>..lib_name_str.len];
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, lib_name_slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> astgen.failTok(lib_name_token, <span class="tok-str">&quot;library name cannot contain null bytes&quot;</span>, .{});
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lib_name_str.len == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> astgen.failTok(lib_name_token, <span class="tok-str">&quot;library name cannot be empty&quot;</span>, .{});
        }
        <span class="tok-kw">break</span> :blk lib_name_str.index;
    } <span class="tok-kw">else</span> .empty;
    <span class="tok-kw">if</span> (fn_proto.ast.callconv_expr != <span class="tok-number">0</span> <span class="tok-kw">and</span> has_inline_keyword) {
        <span class="tok-kw">return</span> astgen.failNode(
            fn_proto.ast.callconv_expr,
            <span class="tok-str">&quot;explicit callconv incompatible with inline keyword&quot;</span>,
            .{},
        );
    }
    <span class="tok-kw">const</span> maybe_bang = tree.firstToken(fn_proto.ast.return_type) - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> is_inferred_error = token_tags[maybe_bang] == .bang;
    <span class="tok-kw">if</span> (body_node == <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (!is_extern) {
            <span class="tok-kw">return</span> astgen.failTok(fn_proto.ast.fn_token, <span class="tok-str">&quot;non-extern function has no body&quot;</span>, .{});
        }
        <span class="tok-kw">if</span> (is_inferred_error) {
            <span class="tok-kw">return</span> astgen.failTok(maybe_bang, <span class="tok-str">&quot;function prototype may not have inferred error set&quot;</span>, .{});
        }
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(!is_extern);<span class="tok-comment"> // validated by parser (TODO why???)
    </span>}

    wip_members.nextDecl(decl_inst);

    <span class="tok-kw">var</span> type_gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .is_comptime = <span class="tok-null">true</span>,
        .decl_node_index = fn_proto.ast.proto_node,
        .decl_line = astgen.source_line,
        .parent = scope,
        .astgen = astgen,
        .instructions = gz.instructions,
        .instructions_top = gz.instructions.items.len,
    };
    <span class="tok-kw">defer</span> type_gz.unstack();

    <span class="tok-kw">if</span> (is_extern) {<span class="tok-comment">
        // We include a function *type*, not a value.
        </span><span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fnProtoExprInner">fnProtoExprInner</a>(&amp;type_gz, &amp;type_gz.base, .{ .rl = .none }, decl_node, fn_proto, <span class="tok-null">true</span>);
        _ = <span class="tok-kw">try</span> type_gz.addBreakWithSrcNode(.break_inline, decl_inst, type_inst, decl_node);
    }

    <span class="tok-kw">var</span> align_gz = type_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> align_gz.unstack();

    <span class="tok-kw">if</span> (fn_proto.ast.align_expr != <span class="tok-number">0</span>) {
        astgen.restoreSourceCursor(saved_cursor);
        <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;align_gz, &amp;align_gz.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_align_ri">coerced_align_ri</a>, fn_proto.ast.align_expr);
        _ = <span class="tok-kw">try</span> align_gz.addBreakWithSrcNode(.break_inline, decl_inst, inst, decl_node);
    }

    <span class="tok-kw">var</span> linksection_gz = align_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> linksection_gz.unstack();

    <span class="tok-kw">if</span> (fn_proto.ast.section_expr != <span class="tok-number">0</span>) {
        astgen.restoreSourceCursor(saved_cursor);
        <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;linksection_gz, &amp;linksection_gz.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_linksection_ri">coerced_linksection_ri</a>, fn_proto.ast.section_expr);
        _ = <span class="tok-kw">try</span> linksection_gz.addBreakWithSrcNode(.break_inline, decl_inst, inst, decl_node);
    }

    <span class="tok-kw">var</span> addrspace_gz = linksection_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> addrspace_gz.unstack();

    <span class="tok-kw">if</span> (fn_proto.ast.addrspace_expr != <span class="tok-number">0</span>) {
        astgen.restoreSourceCursor(saved_cursor);
        <span class="tok-kw">const</span> addrspace_ty = <span class="tok-kw">try</span> addrspace_gz.addBuiltinValue(fn_proto.ast.addrspace_expr, .address_space);
        <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;addrspace_gz, &amp;addrspace_gz.base, .{ .rl = .{ .coerced_ty = addrspace_ty } }, fn_proto.ast.addrspace_expr);
        _ = <span class="tok-kw">try</span> addrspace_gz.addBreakWithSrcNode(.break_inline, decl_inst, inst, decl_node);
    }

    <span class="tok-kw">var</span> value_gz = addrspace_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> value_gz.unstack();

    <span class="tok-kw">if</span> (!is_extern) {<span class="tok-comment">
        // We include a function *value*, not a type.
        </span>astgen.restoreSourceCursor(saved_cursor);
        <span class="tok-kw">try</span> astgen.fnDeclInner(&amp;value_gz, &amp;value_gz.base, saved_cursor, decl_inst, decl_node, body_node, fn_proto);
    }<span class="tok-comment">

    // *Now* we can incorporate the full source code into the hasher.
    </span>astgen.src_hasher.update(tree.getNodeSource(decl_node));

    <span class="tok-kw">var</span> hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
    astgen.src_hasher.final(&amp;hash);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setDeclaration">setDeclaration</a>(decl_inst, .{
        .src_hash = hash,
        .src_line = type_gz.decl_line,
        .src_column = decl_column,

        .kind = .@&quot;const&quot;,
        .name = <span class="tok-kw">try</span> astgen.identAsString(fn_name_token),
        .is_pub = is_pub,
        .is_threadlocal = <span class="tok-null">false</span>,
        .linkage = <span class="tok-kw">if</span> (is_extern) .@&quot;extern&quot; <span class="tok-kw">else</span> <span class="tok-kw">if</span> (is_export) .@&quot;export&quot; <span class="tok-kw">else</span> .normal,
        .lib_name = lib_name,

        .type_gz = &amp;type_gz,
        .align_gz = &amp;align_gz,
        .linksection_gz = &amp;linksection_gz,
        .addrspace_gz = &amp;addrspace_gz,
        .value_gz = &amp;value_gz,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">fnDeclInner</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    decl_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    saved_cursor: <a href="std.zig.AstGen.SourceCursor.html">SourceCursor</a>,
    decl_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
    decl_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    body_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    fn_proto: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> is_noinline = blk: {
        <span class="tok-kw">const</span> maybe_noinline_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :blk token_tags[maybe_noinline_token] == .keyword_noinline;
    };
    <span class="tok-kw">const</span> has_inline_keyword = blk: {
        <span class="tok-kw">const</span> maybe_inline_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :blk token_tags[maybe_inline_token] == .keyword_inline;
    };
    <span class="tok-kw">const</span> maybe_bang = tree.firstToken(fn_proto.ast.return_type) - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> is_inferred_error = token_tags[maybe_bang] == .bang;<span class="tok-comment">

    // Note that the capacity here may not be sufficient, as this does not include `anytype` parameters.
    </span><span class="tok-kw">var</span> param_insts: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) = <span class="tok-kw">try</span> .initCapacity(astgen.arena, fn_proto.ast.params.len);<span class="tok-comment">

    // We use this as `is_used_or_discarded` to figure out if parameters / return types are generic.
    </span><span class="tok-kw">var</span> any_param_used = <span class="tok-null">false</span>;

    <span class="tok-kw">var</span> noalias_bits: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> params_scope = scope;
    <span class="tok-kw">const</span> is_var_args = is_var_args: {
        <span class="tok-kw">var</span> param_type_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> it = fn_proto.iterate(tree);
        <span class="tok-kw">while</span> (it.next()) |param| : (param_type_i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> is_comptime = <span class="tok-kw">if</span> (param.comptime_noalias) |token| <span class="tok-kw">switch</span> (token_tags[token]) {
                .keyword_noalias =&gt; is_comptime: {
                    noalias_bits |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>) &lt;&lt; (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u5</span>, param_type_i) <span class="tok-kw">orelse</span>
                        <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;this compiler implementation only supports 'noalias' on the first 32 parameters&quot;</span>, .{}));
                    <span class="tok-kw">break</span> :is_comptime <span class="tok-null">false</span>;
                },
                .keyword_comptime =&gt; <span class="tok-null">true</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
            } <span class="tok-kw">else</span> <span class="tok-null">false</span>;

            <span class="tok-kw">const</span> is_anytype = <span class="tok-kw">if</span> (param.anytype_ellipsis3) |token| blk: {
                <span class="tok-kw">switch</span> (token_tags[token]) {
                    .keyword_anytype =&gt; <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>,
                    .ellipsis3 =&gt; <span class="tok-kw">break</span> :is_var_args <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            } <span class="tok-kw">else</span> <span class="tok-null">false</span>;

            <span class="tok-kw">const</span> param_name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = <span class="tok-kw">if</span> (param.name_token) |name_token| blk: {
                <span class="tok-kw">const</span> name_bytes = tree.tokenSlice(name_token);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, name_bytes))
                    <span class="tok-kw">break</span> :blk .empty;

                <span class="tok-kw">const</span> param_name = <span class="tok-kw">try</span> astgen.identAsString(name_token);
                <span class="tok-kw">try</span> astgen.detectLocalShadowing(params_scope, param_name, name_token, name_bytes, .@&quot;function parameter&quot;);
                <span class="tok-kw">break</span> :blk param_name;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">if</span> (param.anytype_ellipsis3) |tok| {
                    <span class="tok-kw">return</span> astgen.failTok(tok, <span class="tok-str">&quot;missing parameter name&quot;</span>, .{});
                } <span class="tok-kw">else</span> {
                    ambiguous: {
                        <span class="tok-kw">if</span> (tree.nodes.items(.tag)[param.type_expr] != .identifier) <span class="tok-kw">break</span> :ambiguous;
                        <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[param.type_expr];
                        <span class="tok-kw">const</span> identifier_str = tree.tokenSlice(main_token);
                        <span class="tok-kw">if</span> (<a href="std.zig.primitives.html#std.zig.primitives.isPrimitive">isPrimitive</a>(identifier_str)) <span class="tok-kw">break</span> :ambiguous;
                        <span class="tok-kw">return</span> astgen.failNodeNotes(
                            param.type_expr,
                            <span class="tok-str">&quot;missing parameter name or type&quot;</span>,
                            .{},
                            &amp;[_]<span class="tok-type">u32</span>{
                                <span class="tok-kw">try</span> astgen.errNoteNode(
                                    param.type_expr,
                                    <span class="tok-str">&quot;if this is a name, annotate its type '{s}: T'&quot;</span>,
                                    .{identifier_str},
                                ),
                                <span class="tok-kw">try</span> astgen.errNoteNode(
                                    param.type_expr,
                                    <span class="tok-str">&quot;if this is a type, give it a name '&lt;name&gt;: {s}'&quot;</span>,
                                    .{identifier_str},
                                ),
                            },
                        );
                    }
                    <span class="tok-kw">return</span> astgen.failNode(param.type_expr, <span class="tok-str">&quot;missing parameter name&quot;</span>, .{});
                }
            };

            <span class="tok-kw">const</span> param_inst = <span class="tok-kw">if</span> (is_anytype) param: {
                <span class="tok-kw">const</span> name_token = param.name_token <span class="tok-kw">orelse</span> param.anytype_ellipsis3.?;
                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_comptime)
                    .param_anytype_comptime
                <span class="tok-kw">else</span>
                    .param_anytype;
                <span class="tok-kw">break</span> :param <span class="tok-kw">try</span> decl_gz.addStrTok(tag, param_name, name_token);
            } <span class="tok-kw">else</span> param: {
                <span class="tok-kw">const</span> param_type_node = param.type_expr;
                <a href="std.debug.html#std.debug.assert">assert</a>(param_type_node != <span class="tok-number">0</span>);
                any_param_used = <span class="tok-null">false</span>;<span class="tok-comment"> // we will check this later
                </span><span class="tok-kw">var</span> param_gz = decl_gz.makeSubBlock(scope);
                <span class="tok-kw">defer</span> param_gz.unstack();
                <span class="tok-kw">const</span> param_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;param_gz, params_scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_type_ri">coerced_type_ri</a>, param_type_node, .normal);
                <span class="tok-kw">const</span> param_inst_expected: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len + <span class="tok-number">1</span>);
                _ = <span class="tok-kw">try</span> param_gz.addBreakWithSrcNode(.break_inline, param_inst_expected, param_type, param_type_node);
                <span class="tok-kw">const</span> param_type_is_generic = any_param_used;

                <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
                <span class="tok-kw">const</span> name_token = param.name_token <span class="tok-kw">orelse</span> main_tokens[param_type_node];
                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_comptime) .param_comptime <span class="tok-kw">else</span> .param;
                <span class="tok-kw">const</span> param_inst = <span class="tok-kw">try</span> decl_gz.addParam(&amp;param_gz, param_insts.items, param_type_is_generic, tag, name_token, param_name);
                <a href="std.debug.html#std.debug.assert">assert</a>(param_inst_expected == param_inst);
                <span class="tok-kw">break</span> :param param_inst.toRef();
            };

            <span class="tok-kw">if</span> (param_name == .empty) <span class="tok-kw">continue</span>;

            <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> astgen.arena.create(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>);
            sub_scope.* = .{
                .parent = params_scope,
                .gen_zir = decl_gz,
                .name = param_name,
                .inst = param_inst,
                .token_src = param.name_token.?,
                .id_cat = .@&quot;function parameter&quot;,
                .is_used_or_discarded = &amp;any_param_used,
            };
            params_scope = &amp;sub_scope.base;
            <span class="tok-kw">try</span> param_insts.append(astgen.arena, param_inst.toIndex().?);
        }
        <span class="tok-kw">break</span> :is_var_args <span class="tok-null">false</span>;
    };<span class="tok-comment">

    // After creating the function ZIR instruction, it will need to update the break
    // instructions inside the expression blocks for cc and ret_ty to use the function
    // instruction as the body to break from.

    </span><span class="tok-kw">var</span> ret_gz = decl_gz.makeSubBlock(params_scope);
    <span class="tok-kw">defer</span> ret_gz.unstack();
    any_param_used = <span class="tok-null">false</span>;<span class="tok-comment"> // we will check this later
    </span><span class="tok-kw">const</span> ret_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = inst: {<span class="tok-comment">
        // Parameters are in scope for the return type, so we use `params_scope` here.
        // The calling convention will not have parameters in scope, so we'll just use `scope`.
        // See #22263 for a proposal to solve the inconsistency here.
        </span><span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;ret_gz, params_scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_type_ri">coerced_type_ri</a>, fn_proto.ast.return_type, .normal);
        <span class="tok-kw">if</span> (ret_gz.instructionsSlice().len == <span class="tok-number">0</span>) {<span class="tok-comment">
            // In this case we will send a len=0 body which can be encoded more efficiently.
            </span><span class="tok-kw">break</span> :inst inst;
        }
        _ = <span class="tok-kw">try</span> ret_gz.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), inst);
        <span class="tok-kw">break</span> :inst inst;
    };
    <span class="tok-kw">const</span> ret_body_param_refs = <span class="tok-kw">try</span> astgen.fetchRemoveRefEntries(param_insts.items);
    <span class="tok-kw">const</span> ret_ty_is_generic = any_param_used;<span class="tok-comment">

    // We're jumping back in source, so restore the cursor.
    </span>astgen.restoreSourceCursor(saved_cursor);

    <span class="tok-kw">var</span> cc_gz = decl_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> cc_gz.unstack();
    <span class="tok-kw">const</span> cc_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = blk: {
        <span class="tok-kw">if</span> (fn_proto.ast.callconv_expr != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(
                &amp;cc_gz,
                scope,
                .{ .rl = .{ .coerced_ty = <span class="tok-kw">try</span> cc_gz.addBuiltinValue(fn_proto.ast.callconv_expr, .calling_convention) } },
                fn_proto.ast.callconv_expr,
            );
            <span class="tok-kw">if</span> (cc_gz.instructionsSlice().len == <span class="tok-number">0</span>) {<span class="tok-comment">
                // In this case we will send a len=0 body which can be encoded more efficiently.
                </span><span class="tok-kw">break</span> :blk inst;
            }
            _ = <span class="tok-kw">try</span> cc_gz.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), inst);
            <span class="tok-kw">break</span> :blk inst;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (has_inline_keyword) {
            <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> cc_gz.addBuiltinValue(decl_node, .calling_convention_inline);
            _ = <span class="tok-kw">try</span> cc_gz.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), inst);
            <span class="tok-kw">break</span> :blk inst;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">break</span> :blk .none;
        }
    };

    <span class="tok-kw">var</span> body_gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .is_comptime = <span class="tok-null">false</span>,
        .decl_node_index = fn_proto.ast.proto_node,
        .decl_line = decl_gz.decl_line,
        .parent = params_scope,
        .astgen = astgen,
        .instructions = decl_gz.instructions,
        .instructions_top = decl_gz.instructions.items.len,
    };
    <span class="tok-kw">defer</span> body_gz.unstack();<span class="tok-comment">

    // The scope stack looks like this:
    //  body_gz (top)
    //  param2
    //  param1
    //  param0
    //  decl_gz (bottom)

    // Construct the prototype hash.
    // Leave `astgen.src_hasher` unmodified; this will be used for hashing
    // the *whole* function declaration, including its body.
    </span><span class="tok-kw">var</span> proto_hasher = astgen.src_hasher;
    <span class="tok-kw">const</span> proto_node = tree.nodes.items(.data)[decl_node].lhs;
    proto_hasher.update(tree.getNodeSource(proto_node));
    <span class="tok-kw">var</span> proto_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
    proto_hasher.final(&amp;proto_hash);

    <span class="tok-kw">const</span> prev_fn_block = astgen.fn_block;
    <span class="tok-kw">const</span> prev_fn_ret_ty = astgen.fn_ret_ty;
    <span class="tok-kw">defer</span> {
        astgen.fn_block = prev_fn_block;
        astgen.fn_ret_ty = prev_fn_ret_ty;
    }
    astgen.fn_block = &amp;body_gz;
    astgen.fn_ret_ty = <span class="tok-kw">if</span> (is_inferred_error <span class="tok-kw">or</span> ret_ref.toIndex() != <span class="tok-null">null</span>) r: {<span class="tok-comment">
        // We're essentially guaranteed to need the return type at some point,
        // since the return type is likely not `void` or `noreturn` so there
        // will probably be an explicit return requiring RLS. Fetch this
        // return type now so the rest of the function can use it.
        </span><span class="tok-kw">break</span> :r <span class="tok-kw">try</span> body_gz.addNode(.ret_type, decl_node);
    } <span class="tok-kw">else</span> ret_ref;

    <span class="tok-kw">const</span> prev_var_args = astgen.fn_var_args;
    astgen.fn_var_args = is_var_args;
    <span class="tok-kw">defer</span> astgen.fn_var_args = prev_var_args;

    astgen.advanceSourceCursorToNode(body_node);
    <span class="tok-kw">const</span> lbrace_line = astgen.source_line - decl_gz.decl_line;
    <span class="tok-kw">const</span> lbrace_column = astgen.source_column;

    _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;body_gz, &amp;body_gz.base, .{ .rl = .none }, body_node, .allow_branch_hint);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(decl_gz, scope, params_scope);

    <span class="tok-kw">if</span> (!body_gz.endsWithNoReturn()) {<span class="tok-comment">
        // As our last action before the return, &quot;pop&quot; the error trace if needed
        </span>_ = <span class="tok-kw">try</span> body_gz.addRestoreErrRetIndex(.ret, .always, decl_node);<span class="tok-comment">

        // Add implicit return at end of function.
        </span>_ = <span class="tok-kw">try</span> body_gz.addUnTok(.ret_implicit, .void_value, tree.lastToken(body_node));
    }

    <span class="tok-kw">const</span> func_inst = <span class="tok-kw">try</span> decl_gz.addFunc(.{
        .src_node = decl_node,
        .cc_ref = cc_ref,
        .cc_gz = &amp;cc_gz,
        .ret_ref = ret_ref,
        .ret_gz = &amp;ret_gz,
        .ret_param_refs = ret_body_param_refs,
        .ret_ty_is_generic = ret_ty_is_generic,
        .lbrace_line = lbrace_line,
        .lbrace_column = lbrace_column,
        .param_block = decl_inst,
        .param_insts = param_insts.items,
        .body_gz = &amp;body_gz,
        .is_var_args = is_var_args,
        .is_inferred_error = is_inferred_error,
        .is_noinline = is_noinline,
        .noalias_bits = noalias_bits,
        .proto_hash = proto_hash,
    });
    _ = <span class="tok-kw">try</span> decl_gz.addBreakWithSrcNode(.break_inline, decl_inst, func_inst, decl_node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">globalVarDecl</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    wip_members: *<a href="std.zig.AstGen.WipMembers.html">WipMembers</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    var_decl: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> old_hasher = astgen.src_hasher;
    <span class="tok-kw">defer</span> astgen.src_hasher = old_hasher;
    astgen.src_hasher = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>.<a href="std.crypto.blake3.Blake3.html#std.crypto.blake3.Blake3.init">init</a>(.{});
    astgen.src_hasher.update(tree.getNodeSource(node));
    astgen.src_hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;astgen.source_column));

    <span class="tok-kw">const</span> is_mutable = token_tags[var_decl.ast.mut_token] == .keyword_var;
    <span class="tok-kw">const</span> name_token = var_decl.ast.mut_token + <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> is_pub = var_decl.visib_token != <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> is_export = blk: {
        <span class="tok-kw">const</span> maybe_export_token = var_decl.extern_export_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :blk token_tags[maybe_export_token] == .keyword_export;
    };
    <span class="tok-kw">const</span> is_extern = blk: {
        <span class="tok-kw">const</span> maybe_extern_token = var_decl.extern_export_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;
        <span class="tok-kw">break</span> :blk token_tags[maybe_extern_token] == .keyword_extern;
    };
    <span class="tok-kw">const</span> is_threadlocal = <span class="tok-kw">if</span> (var_decl.threadlocal_token) |tok| blk: {
        <span class="tok-kw">if</span> (!is_mutable) {
            <span class="tok-kw">return</span> astgen.failTok(tok, <span class="tok-str">&quot;threadlocal variable cannot be constant&quot;</span>, .{});
        }
        <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>;
    } <span class="tok-kw">else</span> <span class="tok-null">false</span>;
    <span class="tok-kw">const</span> lib_name = <span class="tok-kw">if</span> (var_decl.lib_name) |lib_name_token| blk: {
        <span class="tok-kw">const</span> lib_name_str = <span class="tok-kw">try</span> astgen.strLitAsString(lib_name_token);
        <span class="tok-kw">const</span> lib_name_slice = astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(lib_name_str.index)..][<span class="tok-number">0</span>..lib_name_str.len];
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, lib_name_slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> astgen.failTok(lib_name_token, <span class="tok-str">&quot;library name cannot contain null bytes&quot;</span>, .{});
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lib_name_str.len == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> astgen.failTok(lib_name_token, <span class="tok-str">&quot;library name cannot be empty&quot;</span>, .{});
        }
        <span class="tok-kw">break</span> :blk lib_name_str.index;
    } <span class="tok-kw">else</span> .empty;

    astgen.advanceSourceCursorToNode(node);

    <span class="tok-kw">const</span> decl_column = astgen.source_column;

    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeDeclaration(node);
    wip_members.nextDecl(decl_inst);

    <span class="tok-kw">if</span> (var_decl.ast.init_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (is_extern) {
            <span class="tok-kw">return</span> astgen.failNode(
                var_decl.ast.init_node,
                <span class="tok-str">&quot;extern variables have no initializers&quot;</span>,
                .{},
            );
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">if</span> (!is_extern) {
            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;variables must be initialized&quot;</span>, .{});
        }
    }

    <span class="tok-kw">if</span> (is_extern <span class="tok-kw">and</span> var_decl.ast.type_node == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;unable to infer variable type&quot;</span>, .{});
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(var_decl.comptime_token == <span class="tok-null">null</span>);<span class="tok-comment"> // handled by parser

    </span><span class="tok-kw">var</span> type_gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .parent = scope,
        .decl_node_index = node,
        .decl_line = astgen.source_line,
        .astgen = astgen,
        .is_comptime = <span class="tok-null">true</span>,
        .instructions = gz.instructions,
        .instructions_top = gz.instructions.items.len,
    };
    <span class="tok-kw">defer</span> type_gz.unstack();

    <span class="tok-kw">if</span> (var_decl.ast.type_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;type_gz, &amp;type_gz.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_type_ri">coerced_type_ri</a>, var_decl.ast.type_node);
        _ = <span class="tok-kw">try</span> type_gz.addBreakWithSrcNode(.break_inline, decl_inst, type_inst, node);
    }

    <span class="tok-kw">var</span> align_gz = type_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> align_gz.unstack();

    <span class="tok-kw">if</span> (var_decl.ast.align_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> align_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;align_gz, &amp;align_gz.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_align_ri">coerced_align_ri</a>, var_decl.ast.align_node);
        _ = <span class="tok-kw">try</span> align_gz.addBreakWithSrcNode(.break_inline, decl_inst, align_inst, node);
    }

    <span class="tok-kw">var</span> linksection_gz = type_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> linksection_gz.unstack();

    <span class="tok-kw">if</span> (var_decl.ast.section_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> linksection_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;linksection_gz, &amp;linksection_gz.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_linksection_ri">coerced_linksection_ri</a>, var_decl.ast.section_node);
        _ = <span class="tok-kw">try</span> linksection_gz.addBreakWithSrcNode(.break_inline, decl_inst, linksection_inst, node);
    }

    <span class="tok-kw">var</span> addrspace_gz = type_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> addrspace_gz.unstack();

    <span class="tok-kw">if</span> (var_decl.ast.addrspace_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> addrspace_ty = <span class="tok-kw">try</span> addrspace_gz.addBuiltinValue(var_decl.ast.addrspace_node, .address_space);
        <span class="tok-kw">const</span> addrspace_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;addrspace_gz, &amp;addrspace_gz.base, .{ .rl = .{ .coerced_ty = addrspace_ty } }, var_decl.ast.addrspace_node);
        _ = <span class="tok-kw">try</span> addrspace_gz.addBreakWithSrcNode(.break_inline, decl_inst, addrspace_inst, node);
    }

    <span class="tok-kw">var</span> init_gz = type_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> init_gz.unstack();

    <span class="tok-kw">if</span> (var_decl.ast.init_node != <span class="tok-number">0</span>) {
        init_gz.anon_name_strategy = .parent;
        <span class="tok-kw">const</span> init_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (var_decl.ast.type_node != <span class="tok-number">0</span>) .{
            .rl = .{ .coerced_ty = decl_inst.toRef() },
        } <span class="tok-kw">else</span> .{ .rl = .none };
        <span class="tok-kw">const</span> init_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;init_gz, &amp;init_gz.base, init_ri, var_decl.ast.init_node);
        _ = <span class="tok-kw">try</span> init_gz.addBreakWithSrcNode(.break_inline, decl_inst, init_inst, node);
    }

    <span class="tok-kw">var</span> hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
    astgen.src_hasher.final(&amp;hash);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setDeclaration">setDeclaration</a>(decl_inst, .{
        .src_hash = hash,
        .src_line = type_gz.decl_line,
        .src_column = decl_column,

        .kind = <span class="tok-kw">if</span> (is_mutable) .@&quot;var&quot; <span class="tok-kw">else</span> .@&quot;const&quot;,
        .name = <span class="tok-kw">try</span> astgen.identAsString(name_token),
        .is_pub = is_pub,
        .is_threadlocal = is_threadlocal,
        .linkage = <span class="tok-kw">if</span> (is_extern) .@&quot;extern&quot; <span class="tok-kw">else</span> <span class="tok-kw">if</span> (is_export) .@&quot;export&quot; <span class="tok-kw">else</span> .normal,
        .lib_name = lib_name,

        .type_gz = &amp;type_gz,
        .align_gz = &amp;align_gz,
        .linksection_gz = &amp;linksection_gz,
        .addrspace_gz = &amp;addrspace_gz,
        .value_gz = &amp;init_gz,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">comptimeDecl</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    wip_members: *<a href="std.zig.AstGen.WipMembers.html">WipMembers</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> body_node = node_datas[node].lhs;

    <span class="tok-kw">const</span> old_hasher = astgen.src_hasher;
    <span class="tok-kw">defer</span> astgen.src_hasher = old_hasher;
    astgen.src_hasher = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>.<a href="std.crypto.blake3.Blake3.html#std.crypto.blake3.Blake3.init">init</a>(.{});
    astgen.src_hasher.update(tree.getNodeSource(node));
    astgen.src_hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;astgen.source_column));<span class="tok-comment">

    // Up top so the ZIR instruction index marks the start range of this
    // top-level declaration.
    </span><span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeDeclaration(node);
    wip_members.nextDecl(decl_inst);
    astgen.advanceSourceCursorToNode(node);<span class="tok-comment">

    // This is just needed for the `setDeclaration` call.
    </span><span class="tok-kw">var</span> dummy_gz = gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> dummy_gz.unstack();

    <span class="tok-kw">var</span> comptime_gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .is_comptime = <span class="tok-null">true</span>,
        .decl_node_index = node,
        .decl_line = astgen.source_line,
        .parent = scope,
        .astgen = astgen,
        .instructions = dummy_gz.instructions,
        .instructions_top = dummy_gz.instructions.items.len,
    };
    <span class="tok-kw">defer</span> comptime_gz.unstack();

    <span class="tok-kw">const</span> decl_column = astgen.source_column;

    <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;comptime_gz, &amp;comptime_gz.base, .{ .rl = .none }, body_node, .normal);
    <span class="tok-kw">if</span> (comptime_gz.isEmpty() <span class="tok-kw">or</span> !comptime_gz.refIsNoReturn(block_result)) {
        _ = <span class="tok-kw">try</span> comptime_gz.addBreak(.break_inline, decl_inst, .void_value);
    }

    <span class="tok-kw">var</span> hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
    astgen.src_hasher.final(&amp;hash);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setDeclaration">setDeclaration</a>(decl_inst, .{
        .src_hash = hash,
        .src_line = comptime_gz.decl_line,
        .src_column = decl_column,
        .kind = .@&quot;comptime&quot;,
        .name = .empty,
        .is_pub = <span class="tok-null">false</span>,
        .is_threadlocal = <span class="tok-null">false</span>,
        .linkage = .normal,
        .type_gz = &amp;dummy_gz,
        .align_gz = &amp;dummy_gz,
        .linksection_gz = &amp;dummy_gz,
        .addrspace_gz = &amp;dummy_gz,
        .value_gz = &amp;comptime_gz,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">usingnamespaceDecl</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    wip_members: *<a href="std.zig.AstGen.WipMembers.html">WipMembers</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">const</span> old_hasher = astgen.src_hasher;
    <span class="tok-kw">defer</span> astgen.src_hasher = old_hasher;
    astgen.src_hasher = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>.<a href="std.crypto.blake3.Blake3.html#std.crypto.blake3.Blake3.init">init</a>(.{});
    astgen.src_hasher.update(tree.getNodeSource(node));
    astgen.src_hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;astgen.source_column));

    <span class="tok-kw">const</span> type_expr = node_datas[node].lhs;
    <span class="tok-kw">const</span> is_pub = blk: {
        <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
        <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
        <span class="tok-kw">const</span> main_token = main_tokens[node];
        <span class="tok-kw">break</span> :blk (main_token &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[main_token - <span class="tok-number">1</span>] == .keyword_pub);
    };<span class="tok-comment">
    // Up top so the ZIR instruction index marks the start range of this
    // top-level declaration.
    </span><span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeDeclaration(node);
    wip_members.nextDecl(decl_inst);
    astgen.advanceSourceCursorToNode(node);<span class="tok-comment">

    // This is just needed for the `setDeclaration` call.
    </span><span class="tok-kw">var</span> dummy_gz = gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> dummy_gz.unstack();

    <span class="tok-kw">var</span> usingnamespace_gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .is_comptime = <span class="tok-null">true</span>,
        .decl_node_index = node,
        .decl_line = astgen.source_line,
        .parent = scope,
        .astgen = astgen,
        .instructions = gz.instructions,
        .instructions_top = gz.instructions.items.len,
    };
    <span class="tok-kw">defer</span> usingnamespace_gz.unstack();

    <span class="tok-kw">const</span> decl_column = astgen.source_column;

    <span class="tok-kw">const</span> namespace_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(&amp;usingnamespace_gz, &amp;usingnamespace_gz.base, type_expr);
    _ = <span class="tok-kw">try</span> usingnamespace_gz.addBreak(.break_inline, decl_inst, namespace_inst);

    <span class="tok-kw">var</span> hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
    astgen.src_hasher.final(&amp;hash);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setDeclaration">setDeclaration</a>(decl_inst, .{
        .src_hash = hash,
        .src_line = usingnamespace_gz.decl_line,
        .src_column = decl_column,
        .kind = .@&quot;usingnamespace&quot;,
        .name = .empty,
        .is_pub = is_pub,
        .is_threadlocal = <span class="tok-null">false</span>,
        .linkage = .normal,
        .type_gz = &amp;dummy_gz,
        .align_gz = &amp;dummy_gz,
        .linksection_gz = &amp;dummy_gz,
        .addrspace_gz = &amp;dummy_gz,
        .value_gz = &amp;usingnamespace_gz,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">testDecl</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    wip_members: *<a href="std.zig.AstGen.WipMembers.html">WipMembers</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> body_node = node_datas[node].rhs;

    <span class="tok-kw">const</span> old_hasher = astgen.src_hasher;
    <span class="tok-kw">defer</span> astgen.src_hasher = old_hasher;
    astgen.src_hasher = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>.<a href="std.crypto.blake3.Blake3.html#std.crypto.blake3.Blake3.init">init</a>(.{});
    astgen.src_hasher.update(tree.getNodeSource(node));
    astgen.src_hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;astgen.source_column));<span class="tok-comment">

    // Up top so the ZIR instruction index marks the start range of this
    // top-level declaration.
    </span><span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeDeclaration(node);

    wip_members.nextDecl(decl_inst);
    astgen.advanceSourceCursorToNode(node);<span class="tok-comment">

    // This is just needed for the `setDeclaration` call.
    </span><span class="tok-kw">var</span> dummy_gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> dummy_gz.unstack();

    <span class="tok-kw">var</span> decl_block: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .is_comptime = <span class="tok-null">true</span>,
        .decl_node_index = node,
        .decl_line = astgen.source_line,
        .parent = scope,
        .astgen = astgen,
        .instructions = dummy_gz.instructions,
        .instructions_top = dummy_gz.instructions.items.len,
    };
    <span class="tok-kw">defer</span> decl_block.unstack();

    <span class="tok-kw">const</span> decl_column = astgen.source_column;

    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> test_token = main_tokens[node];

    <span class="tok-kw">const</span> test_name_token = test_token + <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> test_name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = <span class="tok-kw">switch</span> (token_tags[test_name_token]) {
        <span class="tok-kw">else</span> =&gt; .empty,
        .string_literal =&gt; name: {
            <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> astgen.strLitAsString(test_name_token);
            <span class="tok-kw">const</span> slice = astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(name.index)..][<span class="tok-number">0</span>..name.len];
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {
                <span class="tok-kw">return</span> astgen.failTok(test_name_token, <span class="tok-str">&quot;test name cannot contain null bytes&quot;</span>, .{});
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> astgen.failTok(test_name_token, <span class="tok-str">&quot;empty test name must be omitted&quot;</span>, .{});
            }
            <span class="tok-kw">break</span> :name name.index;
        },
        .identifier =&gt; name: {
            <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(test_name_token);

            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_name_raw, <span class="tok-str">&quot;_&quot;</span>)) <span class="tok-kw">return</span> astgen.failTok(test_name_token, <span class="tok-str">&quot;'_' used as an identifier without @\&quot;_\&quot; syntax&quot;</span>, .{});<span class="tok-comment">

            // if not @&quot;&quot; syntax, just use raw token slice
            </span><span class="tok-kw">if</span> (ident_name_raw[<span class="tok-number">0</span>] != <span class="tok-str">'@'</span>) {
                <span class="tok-kw">if</span> (<a href="std.zig.primitives.html#std.zig.primitives.isPrimitive">isPrimitive</a>(ident_name_raw)) <span class="tok-kw">return</span> astgen.failTok(test_name_token, <span class="tok-str">&quot;cannot test a primitive&quot;</span>, .{});
            }<span class="tok-comment">

            // Local variables, including function parameters.
            </span><span class="tok-kw">const</span> name_str_index = <span class="tok-kw">try</span> astgen.identAsString(test_name_token);
            <span class="tok-kw">var</span> s = scope;
            <span class="tok-kw">var</span> found_already: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">null</span>;<span class="tok-comment"> // we have found a decl with the same name already
            </span><span class="tok-kw">var</span> num_namespaces_out: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> capturing_namespace: ?*<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {
                .local_val =&gt; {
                    <span class="tok-kw">const</span> local_val = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?;
                    <span class="tok-kw">if</span> (local_val.name == name_str_index) {
                        local_val.used = test_name_token;
                        <span class="tok-kw">return</span> astgen.failTokNotes(test_name_token, <span class="tok-str">&quot;cannot test a {s}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(local_val.id_cat),
                        }, &amp;[_]<span class="tok-type">u32</span>{
                            <span class="tok-kw">try</span> astgen.errNoteTok(local_val.token_src, <span class="tok-str">&quot;{s} declared here&quot;</span>, .{
                                <span class="tok-builtin">@tagName</span>(local_val.id_cat),
                            }),
                        });
                    }
                    s = local_val.parent;
                },
                .local_ptr =&gt; {
                    <span class="tok-kw">const</span> local_ptr = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?;
                    <span class="tok-kw">if</span> (local_ptr.name == name_str_index) {
                        local_ptr.used = test_name_token;
                        <span class="tok-kw">return</span> astgen.failTokNotes(test_name_token, <span class="tok-str">&quot;cannot test a {s}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(local_ptr.id_cat),
                        }, &amp;[_]<span class="tok-type">u32</span>{
                            <span class="tok-kw">try</span> astgen.errNoteTok(local_ptr.token_src, <span class="tok-str">&quot;{s} declared here&quot;</span>, .{
                                <span class="tok-builtin">@tagName</span>(local_ptr.id_cat),
                            }),
                        });
                    }
                    s = local_ptr.parent;
                },
                .gen_zir =&gt; s = s.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?.parent,
                .defer_normal, .defer_error =&gt; s = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
                .namespace =&gt; {
                    <span class="tok-kw">const</span> ns = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>).?;
                    <span class="tok-kw">if</span> (ns.decls.get(name_str_index)) |i| {
                        <span class="tok-kw">if</span> (found_already) |f| {
                            <span class="tok-kw">return</span> astgen.failTokNotes(test_name_token, <span class="tok-str">&quot;ambiguous reference&quot;</span>, .{}, &amp;.{
                                <span class="tok-kw">try</span> astgen.errNoteNode(f, <span class="tok-str">&quot;declared here&quot;</span>, .{}),
                                <span class="tok-kw">try</span> astgen.errNoteNode(i, <span class="tok-str">&quot;also declared here&quot;</span>, .{}),
                            });
                        }<span class="tok-comment">
                        // We found a match but must continue looking for ambiguous references to decls.
                        </span>found_already = i;
                    }
                    num_namespaces_out += <span class="tok-number">1</span>;
                    capturing_namespace = ns;
                    s = ns.parent;
                },
                .top =&gt; <span class="tok-kw">break</span>,
            };
            <span class="tok-kw">if</span> (found_already == <span class="tok-null">null</span>) {
                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identifierTokenString(test_name_token);
                <span class="tok-kw">return</span> astgen.failTok(test_name_token, <span class="tok-str">&quot;use of undeclared identifier '{s}'&quot;</span>, .{ident_name});
            }

            <span class="tok-kw">break</span> :name <span class="tok-kw">try</span> astgen.identAsString(test_name_token);
        },
    };

    <span class="tok-kw">var</span> fn_block: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .is_comptime = <span class="tok-null">false</span>,
        .decl_node_index = node,
        .decl_line = decl_block.decl_line,
        .parent = &amp;decl_block.base,
        .astgen = astgen,
        .instructions = decl_block.instructions,
        .instructions_top = decl_block.instructions.items.len,
    };
    <span class="tok-kw">defer</span> fn_block.unstack();

    <span class="tok-kw">const</span> prev_within_fn = astgen.within_fn;
    <span class="tok-kw">const</span> prev_fn_block = astgen.fn_block;
    <span class="tok-kw">const</span> prev_fn_ret_ty = astgen.fn_ret_ty;
    astgen.within_fn = <span class="tok-null">true</span>;
    astgen.fn_block = &amp;fn_block;
    astgen.fn_ret_ty = .anyerror_void_error_union_type;
    <span class="tok-kw">defer</span> {
        astgen.within_fn = prev_within_fn;
        astgen.fn_block = prev_fn_block;
        astgen.fn_ret_ty = prev_fn_ret_ty;
    }

    astgen.advanceSourceCursorToNode(body_node);
    <span class="tok-kw">const</span> lbrace_line = astgen.source_line - decl_block.decl_line;
    <span class="tok-kw">const</span> lbrace_column = astgen.source_column;

    <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;fn_block, &amp;fn_block.base, .{ .rl = .none }, body_node, .normal);
    <span class="tok-kw">if</span> (fn_block.isEmpty() <span class="tok-kw">or</span> !fn_block.refIsNoReturn(block_result)) {<span class="tok-comment">

        // As our last action before the return, &quot;pop&quot; the error trace if needed
        </span>_ = <span class="tok-kw">try</span> fn_block.addRestoreErrRetIndex(.ret, .always, node);<span class="tok-comment">

        // Add implicit return at end of function.
        </span>_ = <span class="tok-kw">try</span> fn_block.addUnTok(.ret_implicit, .void_value, tree.lastToken(body_node));
    }

    <span class="tok-kw">const</span> func_inst = <span class="tok-kw">try</span> decl_block.addFunc(.{
        .src_node = node,

        .cc_ref = .none,
        .cc_gz = <span class="tok-null">null</span>,
        .ret_ref = .anyerror_void_error_union_type,
        .ret_gz = <span class="tok-null">null</span>,

        .ret_param_refs = &amp;.{},
        .param_insts = &amp;.{},
        .ret_ty_is_generic = <span class="tok-null">false</span>,

        .lbrace_line = lbrace_line,
        .lbrace_column = lbrace_column,
        .param_block = decl_inst,
        .body_gz = &amp;fn_block,
        .is_var_args = <span class="tok-null">false</span>,
        .is_inferred_error = <span class="tok-null">false</span>,
        .is_noinline = <span class="tok-null">false</span>,
        .noalias_bits = <span class="tok-number">0</span>,<span class="tok-comment">

        // Tests don't have a prototype that needs hashing
        </span>.proto_hash = .{<span class="tok-number">0</span>} ** <span class="tok-number">16</span>,
    });

    _ = <span class="tok-kw">try</span> decl_block.addBreak(.break_inline, decl_inst, func_inst);

    <span class="tok-kw">var</span> hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
    astgen.src_hasher.final(&amp;hash);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setDeclaration">setDeclaration</a>(decl_inst, .{
        .src_hash = hash,
        .src_line = decl_block.decl_line,
        .src_column = decl_column,

        .kind = <span class="tok-kw">switch</span> (token_tags[test_name_token]) {
            .string_literal =&gt; .@&quot;test&quot;,
            .identifier =&gt; .decltest,
            <span class="tok-kw">else</span> =&gt; .unnamed_test,
        },
        .name = test_name,
        .is_pub = <span class="tok-null">false</span>,
        .is_threadlocal = <span class="tok-null">false</span>,
        .linkage = .normal,

        .type_gz = &amp;dummy_gz,
        .align_gz = &amp;dummy_gz,
        .linksection_gz = &amp;dummy_gz,
        .addrspace_gz = &amp;dummy_gz,
        .value_gz = &amp;decl_block,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">structDeclInner</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    container_decl: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a>,
    layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a>,
    backing_int_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;

    is_tuple: {
        <span class="tok-kw">const</span> tuple_field_node = <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {
            <span class="tok-kw">const</span> container_field = tree.fullContainerField(member_node) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            <span class="tok-kw">if</span> (container_field.ast.tuple_like) <span class="tok-kw">break</span> member_node;
        } <span class="tok-kw">else</span> <span class="tok-kw">break</span> :is_tuple;

        <span class="tok-kw">if</span> (node == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> astgen.failNode(tuple_field_node, <span class="tok-str">&quot;file cannot be a tuple&quot;</span>, .{});
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.tupleDecl">tupleDecl</a>(gz, scope, node, container_decl, layout, backing_int_node);
        }
    }

    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.reserveInstructionIndex();

    <span class="tok-kw">if</span> (container_decl.ast.members.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> backing_int_node == <span class="tok-number">0</span>) {
        <span class="tok-kw">try</span> gz.setStruct(decl_inst, .{
            .src_node = node,
            .layout = layout,
            .captures_len = <span class="tok-number">0</span>,
            .fields_len = <span class="tok-number">0</span>,
            .decls_len = <span class="tok-number">0</span>,
            .has_backing_int = <span class="tok-null">false</span>,
            .known_non_opv = <span class="tok-null">false</span>,
            .known_comptime_only = <span class="tok-null">false</span>,
            .any_comptime_fields = <span class="tok-null">false</span>,
            .any_default_inits = <span class="tok-null">false</span>,
            .any_aligned_fields = <span class="tok-null">false</span>,
            .fields_hash = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.hashSrc">hashSrc</a>(<span class="tok-builtin">@tagName</span>(layout)),
        });
        <span class="tok-kw">return</span> decl_inst.toRef();
    }

    <span class="tok-kw">var</span> namespace: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a> = .{
        .parent = scope,
        .node = node,
        .inst = decl_inst,
        .declaring_gz = gz,
        .maybe_generic = astgen.within_fn,
    };
    <span class="tok-kw">defer</span> namespace.deinit(gpa);<span class="tok-comment">

    // The struct_decl instruction introduces a scope in which the decls of the struct
    // are in scope, so that field types, alignments, and default value expressions
    // can refer to decls within the struct itself.
    </span>astgen.advanceSourceCursorToNode(node);
    <span class="tok-kw">var</span> block_scope: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .parent = &amp;namespace.base,
        .decl_node_index = node,
        .decl_line = gz.decl_line,
        .astgen = astgen,
        .is_comptime = <span class="tok-null">true</span>,
        .instructions = gz.instructions,
        .instructions_top = gz.instructions.items.len,
    };
    <span class="tok-kw">defer</span> block_scope.unstack();

    <span class="tok-kw">const</span> scratch_top = astgen.scratch.items.len;
    <span class="tok-kw">defer</span> astgen.scratch.items.len = scratch_top;

    <span class="tok-kw">var</span> backing_int_body_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> backing_int_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = blk: {
        <span class="tok-kw">if</span> (backing_int_node != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (layout != .@&quot;packed&quot;) {
                <span class="tok-kw">return</span> astgen.failNode(backing_int_node, <span class="tok-str">&quot;non-packed struct does not support backing integer type&quot;</span>, .{});
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> backing_int_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(&amp;block_scope, &amp;namespace.base, backing_int_node);
                <span class="tok-kw">if</span> (!block_scope.isEmpty()) {
                    <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {
                        _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, backing_int_ref);
                    }

                    <span class="tok-kw">const</span> body = block_scope.instructionsSlice();
                    <span class="tok-kw">const</span> old_scratch_len = astgen.scratch.items.len;
                    <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, <a href="std.zig.AstGen.html#std.zig.AstGen.countBodyLenAfterFixups">countBodyLenAfterFixups</a>(astgen, body));
                    <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsArrayList">appendBodyWithFixupsArrayList</a>(astgen, &amp;astgen.scratch, body);
                    backing_int_body_len = astgen.scratch.items.len - old_scratch_len;
                    block_scope.instructions.items.len = block_scope.instructions_top;
                }
                <span class="tok-kw">break</span> :blk backing_int_ref;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">break</span> :blk .none;
        }
    };

    <span class="tok-kw">const</span> decl_count = <span class="tok-kw">try</span> astgen.scanContainer(&amp;namespace, container_decl.ast.members, .@&quot;struct&quot;);
    <span class="tok-kw">const</span> field_count: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(container_decl.ast.members.len - decl_count);

    <span class="tok-kw">const</span> bits_per_field = <span class="tok-number">4</span>;
    <span class="tok-kw">const</span> max_field_size = <span class="tok-number">5</span>;
    <span class="tok-kw">var</span> wip_members = <span class="tok-kw">try</span> <a href="std.zig.AstGen.WipMembers.html">WipMembers</a>.<a href="std.zig.AstGen.WipMembers.html#std.zig.AstGen.WipMembers.init">init</a>(gpa, &amp;astgen.scratch, decl_count, field_count, bits_per_field, max_field_size);
    <span class="tok-kw">defer</span> wip_members.deinit();<span class="tok-comment">

    // We will use the scratch buffer, starting here, for the bodies:
    //    bodies: { // for every fields_len
    //        field_type_body_inst: Inst, // for each field_type_body_len
    //        align_body_inst: Inst, // for each align_body_len
    //        init_body_inst: Inst, // for each init_body_len
    //    }
    // Note that the scratch buffer is simultaneously being used by WipMembers, however
    // it will not access any elements beyond this point in the ArrayList. It also
    // accesses via the ArrayList items field so it can handle the scratch buffer being
    // reallocated.
    // No defer needed here because it is handled by `wip_members.deinit()` above.
    </span><span class="tok-kw">const</span> bodies_start = astgen.scratch.items.len;

    <span class="tok-kw">const</span> old_hasher = astgen.src_hasher;
    <span class="tok-kw">defer</span> astgen.src_hasher = old_hasher;
    astgen.src_hasher = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>.<a href="std.crypto.blake3.Blake3.html#std.crypto.blake3.Blake3.init">init</a>(.{});
    astgen.src_hasher.update(<span class="tok-builtin">@tagName</span>(layout));
    <span class="tok-kw">if</span> (backing_int_node != <span class="tok-number">0</span>) {
        astgen.src_hasher.update(tree.getNodeSource(backing_int_node));
    }

    <span class="tok-kw">var</span> known_non_opv = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> known_comptime_only = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> any_comptime_fields = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> any_aligned_fields = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> any_default_inits = <span class="tok-null">false</span>;
    <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {
        <span class="tok-kw">var</span> member = <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.containerMember">containerMember</a>(&amp;block_scope, &amp;namespace.base, &amp;wip_members, member_node)) {
            .decl =&gt; <span class="tok-kw">continue</span>,
            .field =&gt; |field| field,
        };

        astgen.src_hasher.update(tree.getNodeSource(member_node));

        <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> astgen.identAsString(member.ast.main_token);
        member.convertToNonTupleLike(astgen.tree.nodes);
        <a href="std.debug.html#std.debug.assert">assert</a>(!member.ast.tuple_like);
        wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_name));

        <span class="tok-kw">if</span> (member.ast.type_expr == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> astgen.failTok(member.ast.main_token, <span class="tok-str">&quot;struct field missing type&quot;</span>, .{});
        }

        <span class="tok-kw">const</span> field_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(&amp;block_scope, &amp;namespace.base, member.ast.type_expr);
        <span class="tok-kw">const</span> have_type_body = !block_scope.isEmpty();
        <span class="tok-kw">const</span> have_align = member.ast.align_expr != <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> have_value = member.ast.value_expr != <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> is_comptime = member.comptime_token != <span class="tok-null">null</span>;

        <span class="tok-kw">if</span> (is_comptime) {
            <span class="tok-kw">switch</span> (layout) {
                .@&quot;packed&quot;, .@&quot;extern&quot; =&gt; <span class="tok-kw">return</span> astgen.failTok(member.comptime_token.?, <span class="tok-str">&quot;{s} struct fields cannot be marked comptime&quot;</span>, .{<span class="tok-builtin">@tagName</span>(layout)}),
                .auto =&gt; any_comptime_fields = <span class="tok-null">true</span>,
            }
        } <span class="tok-kw">else</span> {
            known_non_opv = known_non_opv <span class="tok-kw">or</span>
                <a href="std.zig.AstGen.html#std.zig.AstGen.nodeImpliesMoreThanOnePossibleValue">nodeImpliesMoreThanOnePossibleValue</a>(tree, member.ast.type_expr);
            known_comptime_only = known_comptime_only <span class="tok-kw">or</span>
                <a href="std.zig.AstGen.html#std.zig.AstGen.nodeImpliesComptimeOnly">nodeImpliesComptimeOnly</a>(tree, member.ast.type_expr);
        }
        wip_members.nextField(bits_per_field, .{ have_align, have_value, is_comptime, have_type_body });

        <span class="tok-kw">if</span> (have_type_body) {
            <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {
                _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, field_type);
            }
            <span class="tok-kw">const</span> body = block_scope.instructionsSlice();
            <span class="tok-kw">const</span> old_scratch_len = astgen.scratch.items.len;
            <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, <a href="std.zig.AstGen.html#std.zig.AstGen.countBodyLenAfterFixups">countBodyLenAfterFixups</a>(astgen, body));
            <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsArrayList">appendBodyWithFixupsArrayList</a>(astgen, &amp;astgen.scratch, body);
            wip_members.appendToField(<span class="tok-builtin">@intCast</span>(astgen.scratch.items.len - old_scratch_len));
            block_scope.instructions.items.len = block_scope.instructions_top;
        } <span class="tok-kw">else</span> {
            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_type));
        }

        <span class="tok-kw">if</span> (have_align) {
            <span class="tok-kw">if</span> (layout == .@&quot;packed&quot;) {
                <span class="tok-kw">return</span> astgen.failNode(member.ast.align_expr, <span class="tok-str">&quot;unable to override alignment of packed struct fields&quot;</span>, .{});
            }
            any_aligned_fields = <span class="tok-null">true</span>;
            <span class="tok-kw">const</span> align_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;block_scope, &amp;namespace.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_align_ri">coerced_align_ri</a>, member.ast.align_expr);
            <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {
                _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, align_ref);
            }
            <span class="tok-kw">const</span> body = block_scope.instructionsSlice();
            <span class="tok-kw">const</span> old_scratch_len = astgen.scratch.items.len;
            <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, <a href="std.zig.AstGen.html#std.zig.AstGen.countBodyLenAfterFixups">countBodyLenAfterFixups</a>(astgen, body));
            <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsArrayList">appendBodyWithFixupsArrayList</a>(astgen, &amp;astgen.scratch, body);
            wip_members.appendToField(<span class="tok-builtin">@intCast</span>(astgen.scratch.items.len - old_scratch_len));
            block_scope.instructions.items.len = block_scope.instructions_top;
        }

        <span class="tok-kw">if</span> (have_value) {
            any_default_inits = <span class="tok-null">true</span>;<span class="tok-comment">

            // The decl_inst is used as here so that we can easily reconstruct a mapping
            // between it and the field type when the fields inits are analyzed.
            </span><span class="tok-kw">const</span> ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = <span class="tok-kw">if</span> (field_type == .none) .none <span class="tok-kw">else</span> .{ .coerced_ty = decl_inst.toRef() } };

            <span class="tok-kw">const</span> default_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;block_scope, &amp;namespace.base, ri, member.ast.value_expr);
            <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {
                _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, default_inst);
            }
            <span class="tok-kw">const</span> body = block_scope.instructionsSlice();
            <span class="tok-kw">const</span> old_scratch_len = astgen.scratch.items.len;
            <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, <a href="std.zig.AstGen.html#std.zig.AstGen.countBodyLenAfterFixups">countBodyLenAfterFixups</a>(astgen, body));
            <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsArrayList">appendBodyWithFixupsArrayList</a>(astgen, &amp;astgen.scratch, body);
            wip_members.appendToField(<span class="tok-builtin">@intCast</span>(astgen.scratch.items.len - old_scratch_len));
            block_scope.instructions.items.len = block_scope.instructions_top;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (member.comptime_token) |comptime_token| {
            <span class="tok-kw">return</span> astgen.failTok(comptime_token, <span class="tok-str">&quot;comptime field without default initialization value&quot;</span>, .{});
        }
    }

    <span class="tok-kw">var</span> fields_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
    astgen.src_hasher.final(&amp;fields_hash);

    <span class="tok-kw">try</span> gz.setStruct(decl_inst, .{
        .src_node = node,
        .layout = layout,
        .captures_len = <span class="tok-builtin">@intCast</span>(namespace.captures.count()),
        .fields_len = field_count,
        .decls_len = decl_count,
        .has_backing_int = backing_int_ref != .none,
        .known_non_opv = known_non_opv,
        .known_comptime_only = known_comptime_only,
        .any_comptime_fields = any_comptime_fields,
        .any_default_inits = any_default_inits,
        .any_aligned_fields = any_aligned_fields,
        .fields_hash = fields_hash,
    });

    wip_members.finishBits(bits_per_field);
    <span class="tok-kw">const</span> decls_slice = wip_members.declsSlice();
    <span class="tok-kw">const</span> fields_slice = wip_members.fieldsSlice();
    <span class="tok-kw">const</span> bodies_slice = astgen.scratch.items[bodies_start..];
    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, backing_int_body_len + <span class="tok-number">2</span> +
        decls_slice.len + namespace.captures.count() * <span class="tok-number">2</span> + fields_slice.len + bodies_slice.len);
    astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.keys()));
    astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.values()));
    <span class="tok-kw">if</span> (backing_int_ref != .none) {
        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(backing_int_body_len));
        <span class="tok-kw">if</span> (backing_int_body_len == <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(backing_int_ref));
        } <span class="tok-kw">else</span> {
            astgen.extra.appendSliceAssumeCapacity(astgen.scratch.items[scratch_top..][<span class="tok-number">0</span>..backing_int_body_len]);
        }
    }
    astgen.extra.appendSliceAssumeCapacity(decls_slice);
    astgen.extra.appendSliceAssumeCapacity(fields_slice);
    astgen.extra.appendSliceAssumeCapacity(bodies_slice);

    block_scope.unstack();
    <span class="tok-kw">return</span> decl_inst.toRef();
}

<span class="tok-kw">fn</span> <span class="tok-fn">tupleDecl</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    container_decl: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a>,
    layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a>,
    backing_int_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;

    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);

    <span class="tok-kw">switch</span> (layout) {
        .auto =&gt; {},
        .@&quot;extern&quot;, .@&quot;packed&quot; =&gt; <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;{s} tuples are not supported&quot;</span>, .{<span class="tok-builtin">@tagName</span>(layout)}),
    }

    <span class="tok-kw">if</span> (backing_int_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNode(backing_int_node, <span class="tok-str">&quot;tuple does not support backing integer type&quot;</span>, .{});
    }<span class="tok-comment">

    // We will use the scratch buffer, starting here, for the field data:
    // 1. fields: { // for every `fields_len` (stored in `extended.small`)
    //        type: Inst.Ref,
    //        init: Inst.Ref, // `.none` for non-`comptime` fields
    //    }
    </span><span class="tok-kw">const</span> fields_start = astgen.scratch.items.len;
    <span class="tok-kw">defer</span> astgen.scratch.items.len = fields_start;

    <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, container_decl.ast.members.len * <span class="tok-number">2</span>);

    <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {
        <span class="tok-kw">const</span> field = tree.fullContainerField(member_node) <span class="tok-kw">orelse</span> {
            <span class="tok-kw">const</span> tuple_member = <span class="tok-kw">for</span> (container_decl.ast.members) |maybe_tuple| <span class="tok-kw">switch</span> (node_tags[maybe_tuple]) {
                .container_field_init,
                .container_field_align,
                .container_field,
                =&gt; <span class="tok-kw">break</span> maybe_tuple,
                <span class="tok-kw">else</span> =&gt; {},
            } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> astgen.failNodeNotes(
                member_node,
                <span class="tok-str">&quot;tuple declarations cannot contain declarations&quot;</span>,
                .{},
                &amp;.{<span class="tok-kw">try</span> astgen.errNoteNode(tuple_member, <span class="tok-str">&quot;tuple field here&quot;</span>, .{})},
            );
        };

        <span class="tok-kw">if</span> (!field.ast.tuple_like) {
            <span class="tok-kw">return</span> astgen.failTok(field.ast.main_token, <span class="tok-str">&quot;tuple field has a name&quot;</span>, .{});
        }

        <span class="tok-kw">if</span> (field.ast.align_expr != <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> astgen.failTok(field.ast.main_token, <span class="tok-str">&quot;tuple field has alignment&quot;</span>, .{});
        }

        <span class="tok-kw">if</span> (field.ast.value_expr != <span class="tok-number">0</span> <span class="tok-kw">and</span> field.comptime_token == <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> astgen.failTok(field.ast.main_token, <span class="tok-str">&quot;non-comptime tuple field has default initialization value&quot;</span>, .{});
        }

        <span class="tok-kw">if</span> (field.ast.value_expr == <span class="tok-number">0</span> <span class="tok-kw">and</span> field.comptime_token != <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> astgen.failTok(field.comptime_token.?, <span class="tok-str">&quot;comptime field without default initialization value&quot;</span>, .{});
        }

        <span class="tok-kw">const</span> field_type_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, field.ast.type_expr);
        astgen.scratch.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(field_type_ref));

        <span class="tok-kw">if</span> (field.ast.value_expr != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> field_init_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = field_type_ref } }, field.ast.value_expr, .tuple_field_default_value);
            astgen.scratch.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(field_init_ref));
        } <span class="tok-kw">else</span> {
            astgen.scratch.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">none</a>));
        }
    }

    <span class="tok-kw">const</span> fields_len = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u16</span>, container_decl.ast.members.len) <span class="tok-kw">orelse</span> {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;this compiler implementation only supports 65535 tuple fields&quot;</span>, .{});
    };

    <span class="tok-kw">const</span> extra_trail = astgen.scratch.items[fields_start..];
    <a href="std.debug.html#std.debug.assert">assert</a>(extra_trail.len == fields_len * <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.TupleDecl.html">TupleDecl</a>).@&quot;struct&quot;.fields.len + extra_trail.len);
    <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.TupleDecl.html">TupleDecl</a>{
        .src_node = gz.nodeIndexToRelative(node),
    });
    astgen.extra.appendSliceAssumeCapacity(extra_trail);

    <span class="tok-kw">return</span> gz.add(.{
        .tag = .extended,
        .data = .{ .extended = .{
            .opcode = .tuple_decl,
            .small = fields_len,
            .operand = payload_index,
        } },
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">unionDeclInner</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    members: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a>,
    arg_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    auto_enum_tok: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.reserveInstructionIndex();

    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;

    <span class="tok-kw">var</span> namespace: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a> = .{
        .parent = scope,
        .node = node,
        .inst = decl_inst,
        .declaring_gz = gz,
        .maybe_generic = astgen.within_fn,
    };
    <span class="tok-kw">defer</span> namespace.deinit(gpa);<span class="tok-comment">

    // The union_decl instruction introduces a scope in which the decls of the union
    // are in scope, so that field types, alignments, and default value expressions
    // can refer to decls within the union itself.
    </span>astgen.advanceSourceCursorToNode(node);
    <span class="tok-kw">var</span> block_scope: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
        .parent = &amp;namespace.base,
        .decl_node_index = node,
        .decl_line = gz.decl_line,
        .astgen = astgen,
        .is_comptime = <span class="tok-null">true</span>,
        .instructions = gz.instructions,
        .instructions_top = gz.instructions.items.len,
    };
    <span class="tok-kw">defer</span> block_scope.unstack();

    <span class="tok-kw">const</span> decl_count = <span class="tok-kw">try</span> astgen.scanContainer(&amp;namespace, members, .@&quot;union&quot;);
    <span class="tok-kw">const</span> field_count: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(members.len - decl_count);

    <span class="tok-kw">if</span> (layout != .auto <span class="tok-kw">and</span> (auto_enum_tok != <span class="tok-null">null</span> <span class="tok-kw">or</span> arg_node != <span class="tok-number">0</span>)) {
        <span class="tok-kw">if</span> (arg_node != <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> astgen.failNode(arg_node, <span class="tok-str">&quot;{s} union does not support enum tag type&quot;</span>, .{<span class="tok-builtin">@tagName</span>(layout)});
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> astgen.failTok(auto_enum_tok.?, <span class="tok-str">&quot;{s} union does not support enum tag type&quot;</span>, .{<span class="tok-builtin">@tagName</span>(layout)});
        }
    }

    <span class="tok-kw">const</span> arg_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">if</span> (arg_node != <span class="tok-number">0</span>)
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(&amp;block_scope, &amp;namespace.base, arg_node)
    <span class="tok-kw">else</span>
        .none;

    <span class="tok-kw">const</span> bits_per_field = <span class="tok-number">4</span>;
    <span class="tok-kw">const</span> max_field_size = <span class="tok-number">4</span>;
    <span class="tok-kw">var</span> any_aligned_fields = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> wip_members = <span class="tok-kw">try</span> <a href="std.zig.AstGen.WipMembers.html">WipMembers</a>.<a href="std.zig.AstGen.WipMembers.html#std.zig.AstGen.WipMembers.init">init</a>(gpa, &amp;astgen.scratch, decl_count, field_count, bits_per_field, max_field_size);
    <span class="tok-kw">defer</span> wip_members.deinit();

    <span class="tok-kw">const</span> old_hasher = astgen.src_hasher;
    <span class="tok-kw">defer</span> astgen.src_hasher = old_hasher;
    astgen.src_hasher = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>.<a href="std.crypto.blake3.Blake3.html#std.crypto.blake3.Blake3.init">init</a>(.{});
    astgen.src_hasher.update(<span class="tok-builtin">@tagName</span>(layout));
    astgen.src_hasher.update(&amp;.{<span class="tok-builtin">@intFromBool</span>(auto_enum_tok != <span class="tok-null">null</span>)});
    <span class="tok-kw">if</span> (arg_node != <span class="tok-number">0</span>) {
        astgen.src_hasher.update(astgen.tree.getNodeSource(arg_node));
    }

    <span class="tok-kw">for</span> (members) |member_node| {
        <span class="tok-kw">var</span> member = <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.containerMember">containerMember</a>(&amp;block_scope, &amp;namespace.base, &amp;wip_members, member_node)) {
            .decl =&gt; <span class="tok-kw">continue</span>,
            .field =&gt; |field| field,
        };
        astgen.src_hasher.update(astgen.tree.getNodeSource(member_node));
        member.convertToNonTupleLike(astgen.tree.nodes);
        <span class="tok-kw">if</span> (member.ast.tuple_like) {
            <span class="tok-kw">return</span> astgen.failTok(member.ast.main_token, <span class="tok-str">&quot;union field missing name&quot;</span>, .{});
        }
        <span class="tok-kw">if</span> (member.comptime_token) |comptime_token| {
            <span class="tok-kw">return</span> astgen.failTok(comptime_token, <span class="tok-str">&quot;union fields cannot be marked comptime&quot;</span>, .{});
        }

        <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> astgen.identAsString(member.ast.main_token);
        wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_name));

        <span class="tok-kw">const</span> have_type = member.ast.type_expr != <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> have_align = member.ast.align_expr != <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> have_value = member.ast.value_expr != <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> unused = <span class="tok-null">false</span>;
        wip_members.nextField(bits_per_field, .{ have_type, have_align, have_value, unused });

        <span class="tok-kw">if</span> (have_type) {
            <span class="tok-kw">const</span> field_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(&amp;block_scope, &amp;namespace.base, member.ast.type_expr);
            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_type));
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (arg_inst == .none <span class="tok-kw">and</span> auto_enum_tok == <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> astgen.failNode(member_node, <span class="tok-str">&quot;union field missing type&quot;</span>, .{});
        }
        <span class="tok-kw">if</span> (have_align) {
            <span class="tok-kw">const</span> align_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;block_scope, &amp;block_scope.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_align_ri">coerced_align_ri</a>, member.ast.align_expr);
            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(align_inst));
            any_aligned_fields = <span class="tok-null">true</span>;
        }
        <span class="tok-kw">if</span> (have_value) {
            <span class="tok-kw">if</span> (arg_inst == .none) {
                <span class="tok-kw">return</span> astgen.failNodeNotes(
                    node,
                    <span class="tok-str">&quot;explicitly valued tagged union missing integer tag type&quot;</span>,
                    .{},
                    &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteNode(
                            member.ast.value_expr,
                            <span class="tok-str">&quot;tag value specified here&quot;</span>,
                            .{},
                        ),
                    },
                );
            }
            <span class="tok-kw">if</span> (auto_enum_tok == <span class="tok-null">null</span>) {
                <span class="tok-kw">return</span> astgen.failNodeNotes(
                    node,
                    <span class="tok-str">&quot;explicitly valued tagged union requires inferred enum tag type&quot;</span>,
                    .{},
                    &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteNode(
                            member.ast.value_expr,
                            <span class="tok-str">&quot;tag value specified here&quot;</span>,
                            .{},
                        ),
                    },
                );
            }
            <span class="tok-kw">const</span> tag_value = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;block_scope, &amp;block_scope.base, .{ .rl = .{ .ty = arg_inst } }, member.ast.value_expr);
            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(tag_value));
        }
    }

    <span class="tok-kw">var</span> fields_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
    astgen.src_hasher.final(&amp;fields_hash);

    <span class="tok-kw">if</span> (!block_scope.isEmpty()) {
        _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, .void_value);
    }

    <span class="tok-kw">const</span> body = block_scope.instructionsSlice();
    <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);

    <span class="tok-kw">try</span> gz.setUnion(decl_inst, .{
        .src_node = node,
        .layout = layout,
        .tag_type = arg_inst,
        .captures_len = <span class="tok-builtin">@intCast</span>(namespace.captures.count()),
        .body_len = body_len,
        .fields_len = field_count,
        .decls_len = decl_count,
        .auto_enum_tag = auto_enum_tok != <span class="tok-null">null</span>,
        .any_aligned_fields = any_aligned_fields,
        .fields_hash = fields_hash,
    });

    wip_members.finishBits(bits_per_field);
    <span class="tok-kw">const</span> decls_slice = wip_members.declsSlice();
    <span class="tok-kw">const</span> fields_slice = wip_members.fieldsSlice();
    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, namespace.captures.count() * <span class="tok-number">2</span> + decls_slice.len + body_len + fields_slice.len);
    astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.keys()));
    astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.values()));
    astgen.extra.appendSliceAssumeCapacity(decls_slice);
    astgen.appendBodyWithFixups(body);
    astgen.extra.appendSliceAssumeCapacity(fields_slice);

    block_scope.unstack();
    <span class="tok-kw">return</span> decl_inst.toRef();
}

<span class="tok-kw">fn</span> <span class="tok-fn">containerDecl</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    container_decl: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> prev_fn_block = astgen.fn_block;
    astgen.fn_block = <span class="tok-null">null</span>;
    <span class="tok-kw">defer</span> astgen.fn_block = prev_fn_block;<span class="tok-comment">

    // We must not create any types until Sema. Here the goal is only to generate
    // ZIR for all the field types, alignments, and default value expressions.

    </span><span class="tok-kw">switch</span> (token_tags[container_decl.ast.main_token]) {
        .keyword_struct =&gt; {
            <span class="tok-kw">const</span> layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a> = <span class="tok-kw">if</span> (container_decl.layout_token) |t| <span class="tok-kw">switch</span> (token_tags[t]) {
                .keyword_packed =&gt; .@&quot;packed&quot;,
                .keyword_extern =&gt; .@&quot;extern&quot;,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            } <span class="tok-kw">else</span> .auto;

            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.structDeclInner">structDeclInner</a>(gz, scope, node, container_decl, layout, container_decl.ast.arg);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .keyword_union =&gt; {
            <span class="tok-kw">const</span> layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a> = <span class="tok-kw">if</span> (container_decl.layout_token) |t| <span class="tok-kw">switch</span> (token_tags[t]) {
                .keyword_packed =&gt; .@&quot;packed&quot;,
                .keyword_extern =&gt; .@&quot;extern&quot;,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            } <span class="tok-kw">else</span> .auto;

            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.unionDeclInner">unionDeclInner</a>(gz, scope, node, container_decl.ast.members, layout, container_decl.ast.arg, container_decl.ast.enum_token);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .keyword_enum =&gt; {
            <span class="tok-kw">if</span> (container_decl.layout_token) |t| {
                <span class="tok-kw">return</span> astgen.failTok(t, <span class="tok-str">&quot;enums do not support 'packed' or 'extern'; instead provide an explicit integer tag type&quot;</span>, .{});
            }<span class="tok-comment">
            // Count total fields as well as how many have explicitly provided tag values.
            </span><span class="tok-kw">const</span> counts = blk: {
                <span class="tok-kw">var</span> values: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">var</span> total_fields: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">var</span> decls: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">var</span> nonexhaustive_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>;
                <span class="tok-kw">var</span> nonfinal_nonexhaustive = <span class="tok-null">false</span>;
                <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {
                    <span class="tok-kw">var</span> member = tree.fullContainerField(member_node) <span class="tok-kw">orelse</span> {
                        decls += <span class="tok-number">1</span>;
                        <span class="tok-kw">continue</span>;
                    };
                    member.convertToNonTupleLike(astgen.tree.nodes);
                    <span class="tok-kw">if</span> (member.ast.tuple_like) {
                        <span class="tok-kw">return</span> astgen.failTok(member.ast.main_token, <span class="tok-str">&quot;enum field missing name&quot;</span>, .{});
                    }
                    <span class="tok-kw">if</span> (member.comptime_token) |comptime_token| {
                        <span class="tok-kw">return</span> astgen.failTok(comptime_token, <span class="tok-str">&quot;enum fields cannot be marked comptime&quot;</span>, .{});
                    }
                    <span class="tok-kw">if</span> (member.ast.type_expr != <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span> astgen.failNodeNotes(
                            member.ast.type_expr,
                            <span class="tok-str">&quot;enum fields do not have types&quot;</span>,
                            .{},
                            &amp;[_]<span class="tok-type">u32</span>{
                                <span class="tok-kw">try</span> astgen.errNoteNode(
                                    node,
                                    <span class="tok-str">&quot;consider 'union(enum)' here to make it a tagged union&quot;</span>,
                                    .{},
                                ),
                            },
                        );
                    }
                    <span class="tok-kw">if</span> (member.ast.align_expr != <span class="tok-number">0</span>) {
                        <span class="tok-kw">return</span> astgen.failNode(member.ast.align_expr, <span class="tok-str">&quot;enum fields cannot be aligned&quot;</span>, .{});
                    }

                    <span class="tok-kw">const</span> name_token = member.ast.main_token;
                    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(name_token), <span class="tok-str">&quot;_&quot;</span>)) {
                        <span class="tok-kw">if</span> (nonexhaustive_node != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> astgen.failNodeNotes(
                                member_node,
                                <span class="tok-str">&quot;redundant non-exhaustive enum mark&quot;</span>,
                                .{},
                                &amp;[_]<span class="tok-type">u32</span>{
                                    <span class="tok-kw">try</span> astgen.errNoteNode(
                                        nonexhaustive_node,
                                        <span class="tok-str">&quot;other mark here&quot;</span>,
                                        .{},
                                    ),
                                },
                            );
                        }
                        nonexhaustive_node = member_node;
                        <span class="tok-kw">if</span> (member.ast.value_expr != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> astgen.failNode(member.ast.value_expr, <span class="tok-str">&quot;'_' is used to mark an enum as non-exhaustive and cannot be assigned a value&quot;</span>, .{});
                        }
                        <span class="tok-kw">continue</span>;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (nonexhaustive_node != <span class="tok-number">0</span>) {
                        nonfinal_nonexhaustive = <span class="tok-null">true</span>;
                    }
                    total_fields += <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (member.ast.value_expr != <span class="tok-number">0</span>) {
                        <span class="tok-kw">if</span> (container_decl.ast.arg == <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> astgen.failNode(member.ast.value_expr, <span class="tok-str">&quot;value assigned to enum tag with inferred tag type&quot;</span>, .{});
                        }
                        values += <span class="tok-number">1</span>;
                    }
                }
                <span class="tok-kw">if</span> (nonfinal_nonexhaustive) {
                    <span class="tok-kw">return</span> astgen.failNode(nonexhaustive_node, <span class="tok-str">&quot;'_' field of non-exhaustive enum must be last&quot;</span>, .{});
                }
                <span class="tok-kw">break</span> :blk .{
                    .total_fields = total_fields,
                    .values = values,
                    .decls = decls,
                    .nonexhaustive_node = nonexhaustive_node,
                };
            };
            <span class="tok-kw">if</span> (counts.nonexhaustive_node != <span class="tok-number">0</span> <span class="tok-kw">and</span> container_decl.ast.arg == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> astgen.failNodeNotes(
                    node,
                    <span class="tok-str">&quot;non-exhaustive enum missing integer tag type&quot;</span>,
                    .{},
                    &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteNode(
                            counts.nonexhaustive_node,
                            <span class="tok-str">&quot;marked non-exhaustive here&quot;</span>,
                            .{},
                        ),
                    },
                );
            }<span class="tok-comment">
            // In this case we must generate ZIR code for the tag values, similar to
            // how structs are handled above.
            </span><span class="tok-kw">const</span> nonexhaustive = counts.nonexhaustive_node != <span class="tok-number">0</span>;

            <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.reserveInstructionIndex();

            <span class="tok-kw">var</span> namespace: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a> = .{
                .parent = scope,
                .node = node,
                .inst = decl_inst,
                .declaring_gz = gz,
                .maybe_generic = astgen.within_fn,
            };
            <span class="tok-kw">defer</span> namespace.deinit(gpa);<span class="tok-comment">

            // The enum_decl instruction introduces a scope in which the decls of the enum
            // are in scope, so that tag values can refer to decls within the enum itself.
            </span>astgen.advanceSourceCursorToNode(node);
            <span class="tok-kw">var</span> block_scope: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
                .parent = &amp;namespace.base,
                .decl_node_index = node,
                .decl_line = gz.decl_line,
                .astgen = astgen,
                .is_comptime = <span class="tok-null">true</span>,
                .instructions = gz.instructions,
                .instructions_top = gz.instructions.items.len,
            };
            <span class="tok-kw">defer</span> block_scope.unstack();

            _ = <span class="tok-kw">try</span> astgen.scanContainer(&amp;namespace, container_decl.ast.members, .@&quot;enum&quot;);
            namespace.base.tag = .namespace;

            <span class="tok-kw">const</span> arg_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">if</span> (container_decl.ast.arg != <span class="tok-number">0</span>)
                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(&amp;block_scope, &amp;namespace.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_type_ri">coerced_type_ri</a>, container_decl.ast.arg, .<span class="tok-type">type</span>)
            <span class="tok-kw">else</span>
                .none;

            <span class="tok-kw">const</span> bits_per_field = <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> max_field_size = <span class="tok-number">2</span>;
            <span class="tok-kw">var</span> wip_members = <span class="tok-kw">try</span> <a href="std.zig.AstGen.WipMembers.html">WipMembers</a>.<a href="std.zig.AstGen.WipMembers.html#std.zig.AstGen.WipMembers.init">init</a>(gpa, &amp;astgen.scratch, <span class="tok-builtin">@intCast</span>(counts.decls), <span class="tok-builtin">@intCast</span>(counts.total_fields), bits_per_field, max_field_size);
            <span class="tok-kw">defer</span> wip_members.deinit();

            <span class="tok-kw">const</span> old_hasher = astgen.src_hasher;
            <span class="tok-kw">defer</span> astgen.src_hasher = old_hasher;
            astgen.src_hasher = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.crypto.blake3.Blake3.html">SrcHasher</a>.<a href="std.crypto.blake3.Blake3.html#std.crypto.blake3.Blake3.init">init</a>(.{});
            <span class="tok-kw">if</span> (container_decl.ast.arg != <span class="tok-number">0</span>) {
                astgen.src_hasher.update(tree.getNodeSource(container_decl.ast.arg));
            }
            astgen.src_hasher.update(&amp;.{<span class="tok-builtin">@intFromBool</span>(nonexhaustive)});

            <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {
                <span class="tok-kw">if</span> (member_node == counts.nonexhaustive_node)
                    <span class="tok-kw">continue</span>;
                astgen.src_hasher.update(tree.getNodeSource(member_node));
                <span class="tok-kw">var</span> member = <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.containerMember">containerMember</a>(&amp;block_scope, &amp;namespace.base, &amp;wip_members, member_node)) {
                    .decl =&gt; <span class="tok-kw">continue</span>,
                    .field =&gt; |field| field,
                };
                member.convertToNonTupleLike(astgen.tree.nodes);
                <a href="std.debug.html#std.debug.assert">assert</a>(member.comptime_token == <span class="tok-null">null</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(member.ast.type_expr == <span class="tok-number">0</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(member.ast.align_expr == <span class="tok-number">0</span>);

                <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> astgen.identAsString(member.ast.main_token);
                wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_name));

                <span class="tok-kw">const</span> have_value = member.ast.value_expr != <span class="tok-number">0</span>;
                wip_members.nextField(bits_per_field, .{have_value});

                <span class="tok-kw">if</span> (have_value) {
                    <span class="tok-kw">if</span> (arg_inst == .none) {
                        <span class="tok-kw">return</span> astgen.failNodeNotes(
                            node,
                            <span class="tok-str">&quot;explicitly valued enum missing integer tag type&quot;</span>,
                            .{},
                            &amp;[_]<span class="tok-type">u32</span>{
                                <span class="tok-kw">try</span> astgen.errNoteNode(
                                    member.ast.value_expr,
                                    <span class="tok-str">&quot;tag value specified here&quot;</span>,
                                    .{},
                                ),
                            },
                        );
                    }
                    <span class="tok-kw">const</span> tag_value_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;block_scope, &amp;namespace.base, .{ .rl = .{ .ty = arg_inst } }, member.ast.value_expr);
                    wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(tag_value_inst));
                }
            }

            <span class="tok-kw">if</span> (!block_scope.isEmpty()) {
                _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, .void_value);
            }

            <span class="tok-kw">var</span> fields_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a> = <span class="tok-null">undefined</span>;
            astgen.src_hasher.final(&amp;fields_hash);

            <span class="tok-kw">const</span> body = block_scope.instructionsSlice();
            <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);

            <span class="tok-kw">try</span> gz.setEnum(decl_inst, .{
                .src_node = node,
                .nonexhaustive = nonexhaustive,
                .tag_type = arg_inst,
                .captures_len = <span class="tok-builtin">@intCast</span>(namespace.captures.count()),
                .body_len = body_len,
                .fields_len = <span class="tok-builtin">@intCast</span>(counts.total_fields),
                .decls_len = <span class="tok-builtin">@intCast</span>(counts.decls),
                .fields_hash = fields_hash,
            });

            wip_members.finishBits(bits_per_field);
            <span class="tok-kw">const</span> decls_slice = wip_members.declsSlice();
            <span class="tok-kw">const</span> fields_slice = wip_members.fieldsSlice();
            <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, namespace.captures.count() * <span class="tok-number">2</span> + decls_slice.len + body_len + fields_slice.len);
            astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.keys()));
            astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.values()));
            astgen.extra.appendSliceAssumeCapacity(decls_slice);
            astgen.appendBodyWithFixups(body);
            astgen.extra.appendSliceAssumeCapacity(fields_slice);

            block_scope.unstack();
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, decl_inst.toRef(), node);
        },
        .keyword_opaque =&gt; {
            <a href="std.debug.html#std.debug.assert">assert</a>(container_decl.ast.arg == <span class="tok-number">0</span>);

            <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.reserveInstructionIndex();

            <span class="tok-kw">var</span> namespace: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a> = .{
                .parent = scope,
                .node = node,
                .inst = decl_inst,
                .declaring_gz = gz,
                .maybe_generic = astgen.within_fn,
            };
            <span class="tok-kw">defer</span> namespace.deinit(gpa);

            astgen.advanceSourceCursorToNode(node);
            <span class="tok-kw">var</span> block_scope: <a href="std.zig.AstGen.GenZir.html">GenZir</a> = .{
                .parent = &amp;namespace.base,
                .decl_node_index = node,
                .decl_line = gz.decl_line,
                .astgen = astgen,
                .is_comptime = <span class="tok-null">true</span>,
                .instructions = gz.instructions,
                .instructions_top = gz.instructions.items.len,
            };
            <span class="tok-kw">defer</span> block_scope.unstack();

            <span class="tok-kw">const</span> decl_count = <span class="tok-kw">try</span> astgen.scanContainer(&amp;namespace, container_decl.ast.members, .@&quot;opaque&quot;);

            <span class="tok-kw">var</span> wip_members = <span class="tok-kw">try</span> <a href="std.zig.AstGen.WipMembers.html">WipMembers</a>.<a href="std.zig.AstGen.WipMembers.html#std.zig.AstGen.WipMembers.init">init</a>(gpa, &amp;astgen.scratch, decl_count, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">defer</span> wip_members.deinit();

            <span class="tok-kw">if</span> (container_decl.layout_token) |layout_token| {
                <span class="tok-kw">return</span> astgen.failTok(layout_token, <span class="tok-str">&quot;opaque types do not support 'packed' or 'extern'&quot;</span>, .{});
            }

            <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {
                <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.containerMember">containerMember</a>(&amp;block_scope, &amp;namespace.base, &amp;wip_members, member_node);
                <span class="tok-kw">if</span> (res == .field) {
                    <span class="tok-kw">return</span> astgen.failNode(member_node, <span class="tok-str">&quot;opaque types cannot have fields&quot;</span>, .{});
                }
            }

            <span class="tok-kw">try</span> gz.setOpaque(decl_inst, .{
                .src_node = node,
                .captures_len = <span class="tok-builtin">@intCast</span>(namespace.captures.count()),
                .decls_len = decl_count,
            });

            wip_members.finishBits(<span class="tok-number">0</span>);
            <span class="tok-kw">const</span> decls_slice = wip_members.declsSlice();
            <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, namespace.captures.count() * <span class="tok-number">2</span> + decls_slice.len);
            astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.keys()));
            astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.values()));
            astgen.extra.appendSliceAssumeCapacity(decls_slice);

            block_scope.unstack();
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, decl_inst.toRef(), node);
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">const</span> ContainerMemberResult = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { decl, field: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> };

<span class="tok-kw">fn</span> <span class="tok-fn">containerMember</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    wip_members: *<a href="std.zig.AstGen.WipMembers.html">WipMembers</a>,
    member_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.AstGen.ContainerMemberResult.html">ContainerMemberResult</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">switch</span> (node_tags[member_node]) {
        .container_field_init,
        .container_field_align,
        .container_field,
        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.ContainerMemberResult.html">ContainerMemberResult</a>{ .field = tree.fullContainerField(member_node).? },

        .fn_proto,
        .fn_proto_multi,
        .fn_proto_one,
        .fn_proto_simple,
        .fn_decl,
        =&gt; {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> full = tree.fullFnProto(&amp;buf, member_node).?;
            <span class="tok-kw">const</span> body = <span class="tok-kw">if</span> (node_tags[member_node] == .fn_decl) node_datas[member_node].rhs <span class="tok-kw">else</span> <span class="tok-number">0</span>;

            <span class="tok-kw">const</span> prev_decl_index = wip_members.decl_index;
            astgen.fnDecl(gz, scope, wip_members, member_node, body, full) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                <span class="tok-kw">error</span>.AnalysisFail =&gt; {
                    wip_members.decl_index = prev_decl_index;
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addFailedDeclaration">addFailedDeclaration</a>(
                        wip_members,
                        gz,
                        .@&quot;const&quot;,
                        <span class="tok-kw">try</span> astgen.identAsString(full.name_token.?),
                        full.ast.proto_node,
                        full.visib_token != <span class="tok-null">null</span>,
                    );
                },
            };
        },

        .global_var_decl,
        .local_var_decl,
        .simple_var_decl,
        .aligned_var_decl,
        =&gt; {
            <span class="tok-kw">const</span> full = tree.fullVarDecl(member_node).?;
            <span class="tok-kw">const</span> prev_decl_index = wip_members.decl_index;
            astgen.globalVarDecl(gz, scope, wip_members, member_node, full) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                <span class="tok-kw">error</span>.AnalysisFail =&gt; {
                    wip_members.decl_index = prev_decl_index;
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addFailedDeclaration">addFailedDeclaration</a>(
                        wip_members,
                        gz,
                        .@&quot;const&quot;,<span class="tok-comment"> // doesn't really matter
                        </span><span class="tok-kw">try</span> astgen.identAsString(full.ast.mut_token + <span class="tok-number">1</span>),
                        member_node,
                        full.visib_token != <span class="tok-null">null</span>,
                    );
                },
            };
        },

        .@&quot;comptime&quot; =&gt; {
            <span class="tok-kw">const</span> prev_decl_index = wip_members.decl_index;
            astgen.comptimeDecl(gz, scope, wip_members, member_node) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                <span class="tok-kw">error</span>.AnalysisFail =&gt; {
                    wip_members.decl_index = prev_decl_index;
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addFailedDeclaration">addFailedDeclaration</a>(
                        wip_members,
                        gz,
                        .@&quot;comptime&quot;,
                        .empty,
                        member_node,
                        <span class="tok-null">false</span>,
                    );
                },
            };
        },
        .@&quot;usingnamespace&quot; =&gt; {
            <span class="tok-kw">const</span> prev_decl_index = wip_members.decl_index;
            astgen.usingnamespaceDecl(gz, scope, wip_members, member_node) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                <span class="tok-kw">error</span>.AnalysisFail =&gt; {
                    wip_members.decl_index = prev_decl_index;
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addFailedDeclaration">addFailedDeclaration</a>(
                        wip_members,
                        gz,
                        .@&quot;usingnamespace&quot;,
                        .empty,
                        member_node,
                        is_pub: {
                            <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
                            <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
                            <span class="tok-kw">const</span> main_token = main_tokens[member_node];
                            <span class="tok-kw">break</span> :is_pub main_token &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[main_token - <span class="tok-number">1</span>] == .keyword_pub;
                        },
                    );
                },
            };
        },
        .test_decl =&gt; {
            <span class="tok-kw">const</span> prev_decl_index = wip_members.decl_index;<span class="tok-comment">
            // We need to have *some* decl here so that the decl count matches what's expected.
            // Since it doesn't strictly matter *what* this is, let's save ourselves the trouble
            // of duplicating the test name logic, and just assume this is an unnamed test.
            </span>astgen.testDecl(gz, scope, wip_members, member_node) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
                <span class="tok-kw">error</span>.AnalysisFail =&gt; {
                    wip_members.decl_index = prev_decl_index;
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addFailedDeclaration">addFailedDeclaration</a>(
                        wip_members,
                        gz,
                        .unnamed_test,
                        .empty,
                        member_node,
                        <span class="tok-null">false</span>,
                    );
                },
            };
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
    <span class="tok-kw">return</span> .decl;
}

<span class="tok-kw">fn</span> <span class="tok-fn">errorSetDecl</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(astgen, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ErrorSetDecl.html">ErrorSetDecl</a>).@&quot;struct&quot;.fields.len);
    <span class="tok-kw">var</span> fields_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    {
        <span class="tok-kw">var</span> idents: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) = .empty;
        <span class="tok-kw">defer</span> idents.deinit(gpa);

        <span class="tok-kw">const</span> error_token = main_tokens[node];
        <span class="tok-kw">var</span> tok_i = error_token + <span class="tok-number">2</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (tok_i += <span class="tok-number">1</span>) {
            <span class="tok-kw">switch</span> (token_tags[tok_i]) {
                .doc_comment, .comma =&gt; {},
                .identifier =&gt; {
                    <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(tok_i);
                    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> idents.getOrPut(gpa, str_index);
                    <span class="tok-kw">if</span> (gop.found_existing) {
                        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(astgen.nullTerminatedString(str_index)));
                        <span class="tok-kw">defer</span> gpa.free(name);
                        <span class="tok-kw">return</span> astgen.failTokNotes(
                            tok_i,
                            <span class="tok-str">&quot;duplicate error set field '{s}'&quot;</span>,
                            .{name},
                            &amp;[_]<span class="tok-type">u32</span>{
                                <span class="tok-kw">try</span> astgen.errNoteTok(
                                    gop.value_ptr.*,
                                    <span class="tok-str">&quot;previous declaration here&quot;</span>,
                                    .{},
                                ),
                            },
                        );
                    }
                    gop.value_ptr.* = tok_i;

                    <span class="tok-kw">try</span> astgen.extra.append(gpa, <span class="tok-builtin">@intFromEnum</span>(str_index));
                    fields_len += <span class="tok-number">1</span>;
                },
                .r_brace =&gt; <span class="tok-kw">break</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            }
        }
    }

    <a href="std.zig.AstGen.html#std.zig.AstGen.setExtra">setExtra</a>(astgen, payload_index, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ErrorSetDecl.html">ErrorSetDecl</a>{
        .fields_len = <span class="tok-builtin">@intCast</span>(fields_len),
    });
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(.error_set_decl, node, payload_index);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">tryExpr</span>(
    parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    operand_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;

    <span class="tok-kw">const</span> fn_block = astgen.fn_block <span class="tok-kw">orelse</span> {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'try' outside function scope&quot;</span>, .{});
    };

    <span class="tok-kw">if</span> (parent_gz.any_defer_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;'try' not allowed inside defer expression&quot;</span>, .{}, &amp;.{
            <span class="tok-kw">try</span> astgen.errNoteNode(
                parent_gz.any_defer_node,
                <span class="tok-str">&quot;defer expression here&quot;</span>,
                .{},
            ),
        });
    }<span class="tok-comment">

    // Ensure debug line/column information is emitted for this try expression.
    // Then we will save the line/column so that we can emit another one that goes
    // &quot;backwards&quot; because we want to evaluate the operand, but then put the debug
    // info back at the try keyword for error return tracing.
    </span><span class="tok-kw">if</span> (!parent_gz.is_comptime) {
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(parent_gz, node);
    }
    <span class="tok-kw">const</span> try_lc: <a href="std.zig.AstGen.LineColumn.html">LineColumn</a> = .{ astgen.source_line - parent_gz.decl_line, astgen.source_column };

    <span class="tok-kw">const</span> operand_rl: ResultInfo.Loc, <span class="tok-kw">const</span> block_tag: Zir.Inst.Tag = <span class="tok-kw">switch</span> (ri.rl) {
        .ref, .ref_coerced_ty =&gt; .{ .ref, .try_ptr },
        <span class="tok-kw">else</span> =&gt; .{ .none, .@&quot;try&quot; },
    };
    <span class="tok-kw">const</span> operand_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = operand_rl, .ctx = .error_handling_expr };
    <span class="tok-kw">const</span> operand = operand: {<span class="tok-comment">
        // As a special case, we need to detect this form:
        // `try .foo(...)`
        // This is a decl literal form, even though we don't propagate a result type through `try`.
        </span><span class="tok-kw">var</span> buf: [<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (astgen.tree.fullCall(&amp;buf, operand_node)) |full_call| {
            <span class="tok-kw">const</span> res_ty: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">try</span> ri.rl.resultType(parent_gz, operand_node) <span class="tok-kw">orelse</span> .none;
            <span class="tok-kw">break</span> :operand <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.callExpr">callExpr</a>(parent_gz, scope, operand_ri, res_ty, operand_node, full_call);
        }<span class="tok-comment">

        // This could be a pointer or value depending on the `ri` parameter.
        </span><span class="tok-kw">break</span> :operand <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(parent_gz, scope, operand_ri, operand_node, node);
    };

    <span class="tok-kw">const</span> try_inst = <span class="tok-kw">try</span> parent_gz.makeBlockInst(block_tag, node);
    <span class="tok-kw">try</span> parent_gz.instructions.append(astgen.gpa, try_inst);

    <span class="tok-kw">var</span> else_scope = parent_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> else_scope.unstack();

    <span class="tok-kw">const</span> err_tag = <span class="tok-kw">switch</span> (ri.rl) {
        .ref, .ref_coerced_ty =&gt; <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>.<a href="#">err_union_code_ptr</a>,
        <span class="tok-kw">else</span> =&gt; <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>.<a href="#">err_union_code</a>,
    };
    <span class="tok-kw">const</span> err_code = <span class="tok-kw">try</span> else_scope.addUnNode(err_tag, operand, node);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(&amp;else_scope, &amp;fn_block.base, scope, .{ .both = err_code });
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(&amp;else_scope, try_lc);
    _ = <span class="tok-kw">try</span> else_scope.addUnNode(.ret_node, err_code, node);

    <span class="tok-kw">try</span> else_scope.setTryBody(try_inst, operand);
    <span class="tok-kw">const</span> result = try_inst.toRef();
    <span class="tok-kw">switch</span> (ri.rl) {
        .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> result,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(parent_gz, ri, result, node),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">orelseCatchExpr</span>(
    parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    lhs: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    cond_op: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
    unwrap_op: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
    unwrap_code_op: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
    rhs: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    payload_token: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;

    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);
    <span class="tok-kw">const</span> block_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{
        .rl = <span class="tok-kw">switch</span> (ri.rl) {
            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },
            .inferred_ptr =&gt; .none,
            <span class="tok-kw">else</span> =&gt; ri.rl,
        },
        .ctx = ri.ctx,
    };<span class="tok-comment">
    // We need to call `rvalue` to write through to the pointer only if we had a
    // result pointer and aren't forwarding it.
    </span><span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>).@&quot;union&quot;.tag_type.?;
    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);

    <span class="tok-kw">const</span> do_err_trace = astgen.fn_block != <span class="tok-null">null</span> <span class="tok-kw">and</span> (cond_op == .is_non_err <span class="tok-kw">or</span> cond_op == .is_non_err_ptr);

    <span class="tok-kw">var</span> block_scope = parent_gz.makeSubBlock(scope);
    block_scope.setBreakResultInfo(block_ri);
    <span class="tok-kw">defer</span> block_scope.unstack();

    <span class="tok-kw">const</span> operand_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">switch</span> (block_scope.break_result_info.rl) {
        .ref, .ref_coerced_ty =&gt; .{ .rl = .ref, .ctx = <span class="tok-kw">if</span> (do_err_trace) .error_handling_expr <span class="tok-kw">else</span> .none },
        <span class="tok-kw">else</span> =&gt; .{ .rl = .none, .ctx = <span class="tok-kw">if</span> (do_err_trace) .error_handling_expr <span class="tok-kw">else</span> .none },
    };<span class="tok-comment">
    // This could be a pointer or value depending on the `operand_ri` parameter.
    // We cannot use `block_scope.break_result_info` because that has the bare
    // type, whereas this expression has the optional type. Later we make
    // up for this fact by calling rvalue on the else branch.
    </span><span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(&amp;block_scope, &amp;block_scope.base, operand_ri, lhs, rhs);
    <span class="tok-kw">const</span> cond = <span class="tok-kw">try</span> block_scope.addUnNode(cond_op, operand, node);
    <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> block_scope.addCondBr(.condbr, node);

    <span class="tok-kw">const</span> block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(.block, node);
    <span class="tok-kw">try</span> block_scope.setBlockBody(block);<span class="tok-comment">
    // block_scope unstacked now, can add new instructions to parent_gz
    </span><span class="tok-kw">try</span> parent_gz.instructions.append(astgen.gpa, block);

    <span class="tok-kw">var</span> then_scope = block_scope.makeSubBlock(scope);
    <span class="tok-kw">defer</span> then_scope.unstack();<span class="tok-comment">

    // This could be a pointer or value depending on `unwrap_op`.
    </span><span class="tok-kw">const</span> unwrapped_payload = <span class="tok-kw">try</span> then_scope.addUnNode(unwrap_op, operand, node);
    <span class="tok-kw">const</span> then_result = <span class="tok-kw">switch</span> (ri.rl) {
        .ref, .ref_coerced_ty =&gt; unwrapped_payload,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(&amp;then_scope, block_scope.break_result_info, unwrapped_payload, node),
    };
    _ = <span class="tok-kw">try</span> then_scope.addBreakWithSrcNode(.@&quot;break&quot;, block, then_result, node);

    <span class="tok-kw">var</span> else_scope = block_scope.makeSubBlock(scope);
    <span class="tok-kw">defer</span> else_scope.unstack();<span class="tok-comment">

    // We know that the operand (almost certainly) modified the error return trace,
    // so signal to Sema that it should save the new index for restoring later.
    </span><span class="tok-kw">if</span> (do_err_trace <span class="tok-kw">and</span> <a href="std.zig.AstGen.html#std.zig.AstGen.nodeMayAppendToErrorTrace">nodeMayAppendToErrorTrace</a>(tree, lhs))
        _ = <span class="tok-kw">try</span> else_scope.addSaveErrRetIndex(.always);

    <span class="tok-kw">var</span> err_val_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> else_sub_scope = blk: {
        <span class="tok-kw">const</span> payload = payload_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk &amp;else_scope.base;
        <span class="tok-kw">const</span> err_str = tree.tokenSlice(payload);
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, err_str, <span class="tok-str">&quot;_&quot;</span>)) {
            <span class="tok-kw">try</span> astgen.appendErrorTok(payload, <span class="tok-str">&quot;discard of error capture; omit it instead&quot;</span>, .{});
            <span class="tok-kw">break</span> :blk &amp;else_scope.base;
        }
        <span class="tok-kw">const</span> err_name = <span class="tok-kw">try</span> astgen.identAsString(payload);

        <span class="tok-kw">try</span> astgen.detectLocalShadowing(scope, err_name, payload, err_str, .capture);

        err_val_scope = .{
            .parent = &amp;else_scope.base,
            .gen_zir = &amp;else_scope,
            .name = err_name,
            .inst = <span class="tok-kw">try</span> else_scope.addUnNode(unwrap_code_op, operand, node),
            .token_src = payload,
            .id_cat = .capture,
        };
        <span class="tok-kw">break</span> :blk &amp;err_val_scope.base;
    };

    <span class="tok-kw">const</span> else_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;else_scope, else_sub_scope, block_scope.break_result_info, rhs, .allow_branch_hint);
    <span class="tok-kw">if</span> (!else_scope.endsWithNoReturn()) {<span class="tok-comment">
        // As our last action before the break, &quot;pop&quot; the error trace if needed
        </span><span class="tok-kw">if</span> (do_err_trace)
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.restoreErrRetIndex">restoreErrRetIndex</a>(&amp;else_scope, .{ .block = block }, block_scope.break_result_info, rhs, else_result);

        _ = <span class="tok-kw">try</span> else_scope.addBreakWithSrcNode(.@&quot;break&quot;, block, else_result, rhs);
    }
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;else_scope.base, else_sub_scope);

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setCondBrPayload">setCondBrPayload</a>(condbr, cond, &amp;then_scope, &amp;else_scope);

    <span class="tok-kw">if</span> (need_result_rvalue) {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(parent_gz, ri, block.toRef(), node);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> block.toRef();
    }
}

<span class="tok-comment">/// Return whether the identifier names of two tokens are equal. Resolves @&quot;&quot;</span>
<span class="tok-comment">/// tokens without allocating.</span>
<span class="tok-comment">/// OK in theory it could do it without allocating. This implementation</span>
<span class="tok-comment">/// allocates when the @&quot;&quot; form is used.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">tokenIdentEql</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, token1: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, token2: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) !<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> ident_name_1 = <span class="tok-kw">try</span> astgen.identifierTokenString(token1);
    <span class="tok-kw">const</span> ident_name_2 = <span class="tok-kw">try</span> astgen.identifierTokenString(token2);
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_name_1, ident_name_2);
}

<span class="tok-kw">fn</span> <span class="tok-fn">fieldAccess</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">switch</span> (ri.rl) {
        .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addFieldAccess">addFieldAccess</a>(.field_ptr, gz, scope, .{ .rl = .ref }, node),
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">const</span> access = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addFieldAccess">addFieldAccess</a>(.field_val, gz, scope, .{ .rl = .none }, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, access, node);
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">addFieldAccess</span>(
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    lhs_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">const</span> object_node = node_datas[node].lhs;
    <span class="tok-kw">const</span> dot_token = main_tokens[node];
    <span class="tok-kw">const</span> field_ident = dot_token + <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(field_ident);
    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, lhs_ri, object_node);

    <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);

    <span class="tok-kw">return</span> gz.addPlNode(tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Field.html">Field</a>{
        .lhs = lhs,
        .field_name_start = str_index,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">arrayAccess</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> tree = gz.astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">switch</span> (ri.rl) {
        .ref, .ref_coerced_ty =&gt; {
            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, node_datas[node].lhs);

            <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);

            <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[node].rhs);
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);

            <span class="tok-kw">return</span> gz.addPlNode(.elem_ptr_node, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{ .lhs = lhs, .rhs = rhs });
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node_datas[node].lhs);

            <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);

            <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[node].rhs);
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);

            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addPlNode(.elem_val_node, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{ .lhs = lhs, .rhs = rhs }), node);
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">simpleBinOp</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    op_inst_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">if</span> (op_inst_tag == .cmp_neq <span class="tok-kw">or</span> op_inst_tag == .cmp_eq) {
        <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
        <span class="tok-kw">const</span> str = <span class="tok-kw">if</span> (op_inst_tag == .cmp_eq) <span class="tok-str">&quot;==&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;!=&quot;</span>;
        <span class="tok-kw">if</span> (node_tags[node_datas[node].lhs] == .string_literal <span class="tok-kw">or</span>
            node_tags[node_datas[node].rhs] == .string_literal)
            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;cannot compare strings with {s}&quot;</span>, .{str});
    }

    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(gz, scope, .{ .rl = .none }, node_datas[node].lhs, node);
    <span class="tok-kw">const</span> cursor = <span class="tok-kw">switch</span> (op_inst_tag) {
        .add, .sub, .mul, .div, .mod_rem =&gt; <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,
    };
    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(gz, scope, .{ .rl = .none }, node_datas[node].rhs, node);

    <span class="tok-kw">switch</span> (op_inst_tag) {
        .add, .sub, .mul, .div, .mod_rem =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(op_inst_tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{ .lhs = lhs, .rhs = rhs });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">simpleStrTok</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    ident_token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    op_inst_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(ident_token);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addStrTok(op_inst_tag, str_index, ident_token);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">boolBinOp</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    zir_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_bool_ri">coerced_bool_ri</a>, node_datas[node].lhs);
    <span class="tok-kw">const</span> bool_br = (<span class="tok-kw">try</span> gz.addPlNodePayloadIndex(zir_tag, node, <span class="tok-null">undefined</span>)).toIndex().?;

    <span class="tok-kw">var</span> rhs_scope = gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> rhs_scope.unstack();
    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;rhs_scope, &amp;rhs_scope.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_bool_ri">coerced_bool_ri</a>, node_datas[node].rhs, .allow_branch_hint);
    <span class="tok-kw">if</span> (!gz.refIsNoReturn(rhs)) {
        _ = <span class="tok-kw">try</span> rhs_scope.addBreakWithSrcNode(.break_inline, bool_br, rhs, node_datas[node].rhs);
    }
    <span class="tok-kw">try</span> rhs_scope.setBoolBrBody(bool_br, lhs);

    <span class="tok-kw">const</span> block_ref = bool_br.toRef();
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, block_ref, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ifExpr</span>(
    parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    if_full: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> do_err_trace = astgen.fn_block != <span class="tok-null">null</span> <span class="tok-kw">and</span> if_full.error_token != <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);
    <span class="tok-kw">const</span> block_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{
        .rl = <span class="tok-kw">switch</span> (ri.rl) {
            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },
            .inferred_ptr =&gt; .none,
            <span class="tok-kw">else</span> =&gt; ri.rl,
        },
        .ctx = ri.ctx,
    };<span class="tok-comment">
    // We need to call `rvalue` to write through to the pointer only if we had a
    // result pointer and aren't forwarding it.
    </span><span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>).@&quot;union&quot;.tag_type.?;
    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);

    <span class="tok-kw">var</span> block_scope = parent_gz.makeSubBlock(scope);
    block_scope.setBreakResultInfo(block_ri);
    <span class="tok-kw">defer</span> block_scope.unstack();

    <span class="tok-kw">const</span> payload_is_ref = <span class="tok-kw">if</span> (if_full.payload_token) |payload_token|
        token_tags[payload_token] == .asterisk
    <span class="tok-kw">else</span>
        <span class="tok-null">false</span>;

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(parent_gz, if_full.ast.cond_expr);
    <span class="tok-kw">const</span> cond: <span class="tok-kw">struct</span> {
        inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        bool_bit: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    } = c: {
        <span class="tok-kw">if</span> (if_full.error_token) |_| {
            <span class="tok-kw">const</span> cond_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none, .ctx = .error_handling_expr };
            <span class="tok-kw">const</span> err_union = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;block_scope, &amp;block_scope.base, cond_ri, if_full.ast.cond_expr);
            <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref) .is_non_err_ptr <span class="tok-kw">else</span> .is_non_err;
            <span class="tok-kw">break</span> :c .{
                .inst = err_union,
                .bool_bit = <span class="tok-kw">try</span> block_scope.addUnNode(tag, err_union, if_full.ast.cond_expr),
            };
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (if_full.payload_token) |_| {
            <span class="tok-kw">const</span> cond_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none };
            <span class="tok-kw">const</span> optional = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;block_scope, &amp;block_scope.base, cond_ri, if_full.ast.cond_expr);
            <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref) .is_non_null_ptr <span class="tok-kw">else</span> .is_non_null;
            <span class="tok-kw">break</span> :c .{
                .inst = optional,
                .bool_bit = <span class="tok-kw">try</span> block_scope.addUnNode(tag, optional, if_full.ast.cond_expr),
            };
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> cond = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(&amp;block_scope, &amp;block_scope.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_bool_ri">coerced_bool_ri</a>, if_full.ast.cond_expr);
            <span class="tok-kw">break</span> :c .{
                .inst = cond,
                .bool_bit = cond,
            };
        }
    };

    <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> block_scope.addCondBr(.condbr, node);

    <span class="tok-kw">const</span> block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(.block, node);
    <span class="tok-kw">try</span> block_scope.setBlockBody(block);<span class="tok-comment">
    // block_scope unstacked now, can add new instructions to parent_gz
    </span><span class="tok-kw">try</span> parent_gz.instructions.append(astgen.gpa, block);

    <span class="tok-kw">var</span> then_scope = parent_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> then_scope.unstack();

    <span class="tok-kw">var</span> payload_val_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> then_node = if_full.ast.then_expr;
    <span class="tok-kw">const</span> then_sub_scope = s: {
        <span class="tok-kw">if</span> (if_full.error_token != <span class="tok-null">null</span>) {
            <span class="tok-kw">if</span> (if_full.payload_token) |payload_token| {
                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref)
                    .err_union_payload_unsafe_ptr
                <span class="tok-kw">else</span>
                    .err_union_payload_unsafe;
                <span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> then_scope.addUnNode(tag, cond.inst, then_node);
                <span class="tok-kw">const</span> token_name_index = payload_token + <span class="tok-builtin">@intFromBool</span>(payload_is_ref);
                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(token_name_index);
                <span class="tok-kw">const</span> token_name_str = tree.tokenSlice(token_name_index);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, token_name_str)) {
                    <span class="tok-kw">if</span> (payload_is_ref) <span class="tok-kw">return</span> astgen.failTok(payload_token, <span class="tok-str">&quot;pointer modifier invalid on discard&quot;</span>, .{});
                    <span class="tok-kw">break</span> :s &amp;then_scope.base;
                }
                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;then_scope.base, ident_name, token_name_index, token_name_str, .capture);
                payload_val_scope = .{
                    .parent = &amp;then_scope.base,
                    .gen_zir = &amp;then_scope,
                    .name = ident_name,
                    .inst = payload_inst,
                    .token_src = token_name_index,
                    .id_cat = .capture,
                };
                <span class="tok-kw">try</span> then_scope.addDbgVar(.dbg_var_val, ident_name, payload_inst);
                <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;
            } <span class="tok-kw">else</span> {
                _ = <span class="tok-kw">try</span> then_scope.addUnNode(.ensure_err_union_payload_void, cond.inst, node);
                <span class="tok-kw">break</span> :s &amp;then_scope.base;
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (if_full.payload_token) |payload_token| {
            <span class="tok-kw">const</span> ident_token = <span class="tok-kw">if</span> (payload_is_ref) payload_token + <span class="tok-number">1</span> <span class="tok-kw">else</span> payload_token;
            <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref)
                .optional_payload_unsafe_ptr
            <span class="tok-kw">else</span>
                .optional_payload_unsafe;
            <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(ident_token);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, ident_bytes)) {
                <span class="tok-kw">if</span> (payload_is_ref) <span class="tok-kw">return</span> astgen.failTok(payload_token, <span class="tok-str">&quot;pointer modifier invalid on discard&quot;</span>, .{});
                <span class="tok-kw">break</span> :s &amp;then_scope.base;
            }
            <span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> then_scope.addUnNode(tag, cond.inst, then_node);
            <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(ident_token);
            <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;then_scope.base, ident_name, ident_token, ident_bytes, .capture);
            payload_val_scope = .{
                .parent = &amp;then_scope.base,
                .gen_zir = &amp;then_scope,
                .name = ident_name,
                .inst = payload_inst,
                .token_src = ident_token,
                .id_cat = .capture,
            };
            <span class="tok-kw">try</span> then_scope.addDbgVar(.dbg_var_val, ident_name, payload_inst);
            <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">break</span> :s &amp;then_scope.base;
        }
    };

    <span class="tok-kw">const</span> then_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;then_scope, then_sub_scope, block_scope.break_result_info, then_node, .allow_branch_hint);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;then_scope.base, then_sub_scope);
    <span class="tok-kw">if</span> (!then_scope.endsWithNoReturn()) {
        _ = <span class="tok-kw">try</span> then_scope.addBreakWithSrcNode(.@&quot;break&quot;, block, then_result, then_node);
    }

    <span class="tok-kw">var</span> else_scope = parent_gz.makeSubBlock(scope);
    <span class="tok-kw">defer</span> else_scope.unstack();<span class="tok-comment">

    // We know that the operand (almost certainly) modified the error return trace,
    // so signal to Sema that it should save the new index for restoring later.
    </span><span class="tok-kw">if</span> (do_err_trace <span class="tok-kw">and</span> <a href="std.zig.AstGen.html#std.zig.AstGen.nodeMayAppendToErrorTrace">nodeMayAppendToErrorTrace</a>(tree, if_full.ast.cond_expr))
        _ = <span class="tok-kw">try</span> else_scope.addSaveErrRetIndex(.always);

    <span class="tok-kw">const</span> else_node = if_full.ast.else_expr;
    <span class="tok-kw">if</span> (else_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> sub_scope = s: {
            <span class="tok-kw">if</span> (if_full.error_token) |error_token| {
                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref)
                    .err_union_code_ptr
                <span class="tok-kw">else</span>
                    .err_union_code;
                <span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> else_scope.addUnNode(tag, cond.inst, if_full.ast.cond_expr);
                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(error_token);
                <span class="tok-kw">const</span> error_token_str = tree.tokenSlice(error_token);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, error_token_str))
                    <span class="tok-kw">break</span> :s &amp;else_scope.base;
                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;else_scope.base, ident_name, error_token, error_token_str, .capture);
                payload_val_scope = .{
                    .parent = &amp;else_scope.base,
                    .gen_zir = &amp;else_scope,
                    .name = ident_name,
                    .inst = payload_inst,
                    .token_src = error_token,
                    .id_cat = .capture,
                };
                <span class="tok-kw">try</span> else_scope.addDbgVar(.dbg_var_val, ident_name, payload_inst);
                <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">break</span> :s &amp;else_scope.base;
            }
        };
        <span class="tok-kw">const</span> else_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;else_scope, sub_scope, block_scope.break_result_info, else_node, .allow_branch_hint);
        <span class="tok-kw">if</span> (!else_scope.endsWithNoReturn()) {<span class="tok-comment">
            // As our last action before the break, &quot;pop&quot; the error trace if needed
            </span><span class="tok-kw">if</span> (do_err_trace)
                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.restoreErrRetIndex">restoreErrRetIndex</a>(&amp;else_scope, .{ .block = block }, block_scope.break_result_info, else_node, else_result);
            _ = <span class="tok-kw">try</span> else_scope.addBreakWithSrcNode(.@&quot;break&quot;, block, else_result, else_node);
        }
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;else_scope.base, sub_scope);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(&amp;else_scope, ri, .void_value, node);
        _ = <span class="tok-kw">try</span> else_scope.addBreak(.@&quot;break&quot;, block, result);
    }

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setCondBrPayload">setCondBrPayload</a>(condbr, cond.bool_bit, &amp;then_scope, &amp;else_scope);

    <span class="tok-kw">if</span> (need_result_rvalue) {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(parent_gz, ri, block.toRef(), node);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> block.toRef();
    }
}

<span class="tok-comment">/// Supports `else_scope` stacked on `then_scope`. Unstacks `else_scope` then `then_scope`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">setCondBrPayload</span>(
    condbr: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
    cond: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    then_scope: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    else_scope: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">defer</span> then_scope.unstack();
    <span class="tok-kw">defer</span> else_scope.unstack();
    <span class="tok-kw">const</span> astgen = then_scope.astgen;
    <span class="tok-kw">const</span> then_body = then_scope.instructionsSliceUpto(else_scope);
    <span class="tok-kw">const</span> else_body = else_scope.instructionsSlice();
    <span class="tok-kw">const</span> then_body_len = astgen.countBodyLenAfterFixups(then_body);
    <span class="tok-kw">const</span> else_body_len = astgen.countBodyLenAfterFixups(else_body);
    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
        astgen.gpa,
        <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CondBr.html">CondBr</a>).@&quot;struct&quot;.fields.len + then_body_len + else_body_len,
    );

    <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
    zir_datas[<span class="tok-builtin">@intFromEnum</span>(condbr)].pl_node.payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CondBr.html">CondBr</a>{
        .condition = cond,
        .then_body_len = then_body_len,
        .else_body_len = else_body_len,
    });
    astgen.appendBodyWithFixups(then_body);
    astgen.appendBodyWithFixups(else_body);
}

<span class="tok-kw">fn</span> <span class="tok-fn">whileExpr</span>(
    parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    while_full: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a>,
    is_statement: <span class="tok-type">bool</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);

    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);
    <span class="tok-kw">const</span> block_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{
        .rl = <span class="tok-kw">switch</span> (ri.rl) {
            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },
            .inferred_ptr =&gt; .none,
            <span class="tok-kw">else</span> =&gt; ri.rl,
        },
        .ctx = ri.ctx,
    };<span class="tok-comment">
    // We need to call `rvalue` to write through to the pointer only if we had a
    // result pointer and aren't forwarding it.
    </span><span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>).@&quot;union&quot;.tag_type.?;
    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);

    <span class="tok-kw">if</span> (while_full.label_token) |label_token| {
        <span class="tok-kw">try</span> astgen.checkLabelRedefinition(scope, label_token);
    }

    <span class="tok-kw">const</span> is_inline = while_full.inline_token != <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (parent_gz.is_comptime <span class="tok-kw">and</span> is_inline) {
        <span class="tok-kw">try</span> astgen.appendErrorTok(while_full.inline_token.?, <span class="tok-str">&quot;redundant inline keyword in comptime scope&quot;</span>, .{});
    }
    <span class="tok-kw">const</span> loop_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .block_inline <span class="tok-kw">else</span> .loop;
    <span class="tok-kw">const</span> loop_block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(loop_tag, node);
    <span class="tok-kw">try</span> parent_gz.instructions.append(astgen.gpa, loop_block);

    <span class="tok-kw">var</span> loop_scope = parent_gz.makeSubBlock(scope);
    loop_scope.is_inline = is_inline;
    loop_scope.setBreakResultInfo(block_ri);
    <span class="tok-kw">defer</span> loop_scope.unstack();

    <span class="tok-kw">var</span> cond_scope = parent_gz.makeSubBlock(&amp;loop_scope.base);
    <span class="tok-kw">defer</span> cond_scope.unstack();

    <span class="tok-kw">const</span> payload_is_ref = <span class="tok-kw">if</span> (while_full.payload_token) |payload_token|
        token_tags[payload_token] == .asterisk
    <span class="tok-kw">else</span>
        <span class="tok-null">false</span>;

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(parent_gz, while_full.ast.cond_expr);
    <span class="tok-kw">const</span> cond: <span class="tok-kw">struct</span> {
        inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        bool_bit: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    } = c: {
        <span class="tok-kw">if</span> (while_full.error_token) |_| {
            <span class="tok-kw">const</span> cond_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none };
            <span class="tok-kw">const</span> err_union = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;cond_scope, &amp;cond_scope.base, cond_ri, while_full.ast.cond_expr, .normal);
            <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref) .is_non_err_ptr <span class="tok-kw">else</span> .is_non_err;
            <span class="tok-kw">break</span> :c .{
                .inst = err_union,
                .bool_bit = <span class="tok-kw">try</span> cond_scope.addUnNode(tag, err_union, while_full.ast.cond_expr),
            };
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (while_full.payload_token) |_| {
            <span class="tok-kw">const</span> cond_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none };
            <span class="tok-kw">const</span> optional = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;cond_scope, &amp;cond_scope.base, cond_ri, while_full.ast.cond_expr, .normal);
            <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref) .is_non_null_ptr <span class="tok-kw">else</span> .is_non_null;
            <span class="tok-kw">break</span> :c .{
                .inst = optional,
                .bool_bit = <span class="tok-kw">try</span> cond_scope.addUnNode(tag, optional, while_full.ast.cond_expr),
            };
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> cond = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;cond_scope, &amp;cond_scope.base, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_bool_ri">coerced_bool_ri</a>, while_full.ast.cond_expr, .normal);
            <span class="tok-kw">break</span> :c .{
                .inst = cond,
                .bool_bit = cond,
            };
        }
    };

    <span class="tok-kw">const</span> condbr_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .condbr_inline <span class="tok-kw">else</span> .condbr;
    <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> cond_scope.addCondBr(condbr_tag, node);
    <span class="tok-kw">const</span> block_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .block_inline <span class="tok-kw">else</span> .block;
    <span class="tok-kw">const</span> cond_block = <span class="tok-kw">try</span> loop_scope.makeBlockInst(block_tag, node);
    <span class="tok-kw">try</span> cond_scope.setBlockBody(cond_block);<span class="tok-comment">
    // cond_scope unstacked now, can add new instructions to loop_scope
    </span><span class="tok-kw">try</span> loop_scope.instructions.append(astgen.gpa, cond_block);<span class="tok-comment">

    // make scope now but don't stack on parent_gz until loop_scope
    // gets unstacked after cont_expr is emitted and added below
    </span><span class="tok-kw">var</span> then_scope = parent_gz.makeSubBlock(&amp;cond_scope.base);
    then_scope.instructions_top = <a href="std.zig.AstGen.GenZir.html">GenZir</a>.<a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>;
    <span class="tok-kw">defer</span> then_scope.unstack();

    <span class="tok-kw">var</span> dbg_var_name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = .empty;
    <span class="tok-kw">var</span> dbg_var_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> opt_payload_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.OptionalIndex.html">OptionalIndex</a> = .none;
    <span class="tok-kw">var</span> payload_val_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> then_sub_scope = s: {
        <span class="tok-kw">if</span> (while_full.error_token != <span class="tok-null">null</span>) {
            <span class="tok-kw">if</span> (while_full.payload_token) |payload_token| {
                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref)
                    .err_union_payload_unsafe_ptr
                <span class="tok-kw">else</span>
                    .err_union_payload_unsafe;<span class="tok-comment">
                // will add this instruction to then_scope.instructions below
                </span><span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> then_scope.makeUnNode(tag, cond.inst, while_full.ast.cond_expr);
                opt_payload_inst = payload_inst.toOptional();
                <span class="tok-kw">const</span> ident_token = payload_token + <span class="tok-builtin">@intFromBool</span>(payload_is_ref);
                <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(ident_token);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, ident_bytes)) {
                    <span class="tok-kw">if</span> (payload_is_ref) <span class="tok-kw">return</span> astgen.failTok(payload_token, <span class="tok-str">&quot;pointer modifier invalid on discard&quot;</span>, .{});
                    <span class="tok-kw">break</span> :s &amp;then_scope.base;
                }
                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(ident_token);
                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;then_scope.base, ident_name, ident_token, ident_bytes, .capture);
                payload_val_scope = .{
                    .parent = &amp;then_scope.base,
                    .gen_zir = &amp;then_scope,
                    .name = ident_name,
                    .inst = payload_inst.toRef(),
                    .token_src = ident_token,
                    .id_cat = .capture,
                };
                dbg_var_name = ident_name;
                dbg_var_inst = payload_inst.toRef();
                <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;
            } <span class="tok-kw">else</span> {
                _ = <span class="tok-kw">try</span> then_scope.addUnNode(.ensure_err_union_payload_void, cond.inst, node);
                <span class="tok-kw">break</span> :s &amp;then_scope.base;
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (while_full.payload_token) |payload_token| {
            <span class="tok-kw">const</span> ident_token = <span class="tok-kw">if</span> (payload_is_ref) payload_token + <span class="tok-number">1</span> <span class="tok-kw">else</span> payload_token;
            <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref)
                .optional_payload_unsafe_ptr
            <span class="tok-kw">else</span>
                .optional_payload_unsafe;<span class="tok-comment">
            // will add this instruction to then_scope.instructions below
            </span><span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> then_scope.makeUnNode(tag, cond.inst, while_full.ast.cond_expr);
            opt_payload_inst = payload_inst.toOptional();
            <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(ident_token);
            <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(ident_token);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, ident_bytes)) {
                <span class="tok-kw">if</span> (payload_is_ref) <span class="tok-kw">return</span> astgen.failTok(payload_token, <span class="tok-str">&quot;pointer modifier invalid on discard&quot;</span>, .{});
                <span class="tok-kw">break</span> :s &amp;then_scope.base;
            }
            <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;then_scope.base, ident_name, ident_token, ident_bytes, .capture);
            payload_val_scope = .{
                .parent = &amp;then_scope.base,
                .gen_zir = &amp;then_scope,
                .name = ident_name,
                .inst = payload_inst.toRef(),
                .token_src = ident_token,
                .id_cat = .capture,
            };
            dbg_var_name = ident_name;
            dbg_var_inst = payload_inst.toRef();
            <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">break</span> :s &amp;then_scope.base;
        }
    };

    <span class="tok-kw">var</span> continue_scope = parent_gz.makeSubBlock(then_sub_scope);
    continue_scope.instructions_top = <a href="std.zig.AstGen.GenZir.html">GenZir</a>.<a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>;
    <span class="tok-kw">defer</span> continue_scope.unstack();
    <span class="tok-kw">const</span> continue_block = <span class="tok-kw">try</span> then_scope.makeBlockInst(block_tag, node);

    <span class="tok-kw">const</span> repeat_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .repeat_inline <span class="tok-kw">else</span> .repeat;
    _ = <span class="tok-kw">try</span> loop_scope.addNode(repeat_tag, node);

    <span class="tok-kw">try</span> loop_scope.setBlockBody(loop_block);
    loop_scope.break_block = loop_block.toOptional();
    loop_scope.continue_block = continue_block.toOptional();
    <span class="tok-kw">if</span> (while_full.label_token) |label_token| {
        loop_scope.label = .{
            .token = label_token,
            .block_inst = loop_block,
        };
    }<span class="tok-comment">

    // done adding instructions to loop_scope, can now stack then_scope
    </span>then_scope.instructions_top = then_scope.instructions.items.len;

    <span class="tok-kw">const</span> then_node = while_full.ast.then_expr;
    <span class="tok-kw">if</span> (opt_payload_inst.unwrap()) |payload_inst| {
        <span class="tok-kw">try</span> then_scope.instructions.append(astgen.gpa, payload_inst);
    }
    <span class="tok-kw">if</span> (dbg_var_name != .empty) <span class="tok-kw">try</span> then_scope.addDbgVar(.dbg_var_val, dbg_var_name, dbg_var_inst);
    <span class="tok-kw">try</span> then_scope.instructions.append(astgen.gpa, continue_block);<span class="tok-comment">
    // This code could be improved to avoid emitting the continue expr when there
    // are no jumps to it. This happens when the last statement of a while body is noreturn
    // and there are no `continue` statements.
    // Tracking issue: https://github.com/ziglang/zig/issues/9185
    </span><span class="tok-kw">if</span> (while_full.ast.cont_expr != <span class="tok-number">0</span>) {
        _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.unusedResultExpr">unusedResultExpr</a>(&amp;then_scope, then_sub_scope, while_full.ast.cont_expr);
    }

    continue_scope.instructions_top = continue_scope.instructions.items.len;
    {
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(&amp;continue_scope, then_node);
        <span class="tok-kw">const</span> unused_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;continue_scope, &amp;continue_scope.base, .{ .rl = .none }, then_node, .allow_branch_hint);
        _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addEnsureResult">addEnsureResult</a>(&amp;continue_scope, unused_result, then_node);
    }
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;then_scope.base, then_sub_scope);
    <span class="tok-kw">const</span> break_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .break_inline <span class="tok-kw">else</span> .@&quot;break&quot;;
    <span class="tok-kw">if</span> (!continue_scope.endsWithNoReturn()) {
        astgen.advanceSourceCursor(token_starts[tree.lastToken(then_node)]);
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(parent_gz, .{ astgen.source_line - parent_gz.decl_line, astgen.source_column });
        _ = <span class="tok-kw">try</span> parent_gz.add(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .dbg_empty_stmt,
                .small = <span class="tok-null">undefined</span>,
                .operand = <span class="tok-null">undefined</span>,
            } },
        });
        _ = <span class="tok-kw">try</span> continue_scope.addBreak(break_tag, continue_block, .void_value);
    }
    <span class="tok-kw">try</span> continue_scope.setBlockBody(continue_block);
    _ = <span class="tok-kw">try</span> then_scope.addBreak(break_tag, cond_block, .void_value);

    <span class="tok-kw">var</span> else_scope = parent_gz.makeSubBlock(&amp;cond_scope.base);
    <span class="tok-kw">defer</span> else_scope.unstack();

    <span class="tok-kw">const</span> else_node = while_full.ast.else_expr;
    <span class="tok-kw">if</span> (else_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> sub_scope = s: {
            <span class="tok-kw">if</span> (while_full.error_token) |error_token| {
                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref)
                    .err_union_code_ptr
                <span class="tok-kw">else</span>
                    .err_union_code;
                <span class="tok-kw">const</span> else_payload_inst = <span class="tok-kw">try</span> else_scope.addUnNode(tag, cond.inst, while_full.ast.cond_expr);
                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(error_token);
                <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(error_token);
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_bytes, <span class="tok-str">&quot;_&quot;</span>))
                    <span class="tok-kw">break</span> :s &amp;else_scope.base;
                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;else_scope.base, ident_name, error_token, ident_bytes, .capture);
                payload_val_scope = .{
                    .parent = &amp;else_scope.base,
                    .gen_zir = &amp;else_scope,
                    .name = ident_name,
                    .inst = else_payload_inst,
                    .token_src = error_token,
                    .id_cat = .capture,
                };
                <span class="tok-kw">try</span> else_scope.addDbgVar(.dbg_var_val, ident_name, else_payload_inst);
                <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">break</span> :s &amp;else_scope.base;
            }
        };<span class="tok-comment">
        // Remove the continue block and break block so that `continue` and `break`
        // control flow apply to outer loops; not this one.
        </span>loop_scope.continue_block = .none;
        loop_scope.break_block = .none;
        <span class="tok-kw">const</span> else_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;else_scope, sub_scope, loop_scope.break_result_info, else_node, .allow_branch_hint);
        <span class="tok-kw">if</span> (is_statement) {
            _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addEnsureResult">addEnsureResult</a>(&amp;else_scope, else_result, else_node);
        }

        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;else_scope.base, sub_scope);
        <span class="tok-kw">if</span> (!else_scope.endsWithNoReturn()) {
            _ = <span class="tok-kw">try</span> else_scope.addBreakWithSrcNode(break_tag, loop_block, else_result, else_node);
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(&amp;else_scope, ri, .void_value, node);
        _ = <span class="tok-kw">try</span> else_scope.addBreak(break_tag, loop_block, result);
    }

    <span class="tok-kw">if</span> (loop_scope.label) |some| {
        <span class="tok-kw">if</span> (!some.used) {
            <span class="tok-kw">try</span> astgen.appendErrorTok(some.token, <span class="tok-str">&quot;unused while loop label&quot;</span>, .{});
        }
    }

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setCondBrPayload">setCondBrPayload</a>(condbr, cond.bool_bit, &amp;then_scope, &amp;else_scope);

    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (need_result_rvalue)
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(parent_gz, ri, loop_block.toRef(), node)
    <span class="tok-kw">else</span>
        loop_block.toRef();

    <span class="tok-kw">if</span> (is_statement) {
        _ = <span class="tok-kw">try</span> parent_gz.addUnNode(.ensure_result_used, result, node);
    }

    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">forExpr</span>(
    parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    for_full: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a>,
    is_statement: <span class="tok-type">bool</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;

    <span class="tok-kw">if</span> (for_full.label_token) |label_token| {
        <span class="tok-kw">try</span> astgen.checkLabelRedefinition(scope, label_token);
    }

    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);
    <span class="tok-kw">const</span> block_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{
        .rl = <span class="tok-kw">switch</span> (ri.rl) {
            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },
            .inferred_ptr =&gt; .none,
            <span class="tok-kw">else</span> =&gt; ri.rl,
        },
        .ctx = ri.ctx,
    };<span class="tok-comment">
    // We need to call `rvalue` to write through to the pointer only if we had a
    // result pointer and aren't forwarding it.
    </span><span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>).@&quot;union&quot;.tag_type.?;
    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);

    <span class="tok-kw">const</span> is_inline = for_full.inline_token != <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (parent_gz.is_comptime <span class="tok-kw">and</span> is_inline) {
        <span class="tok-kw">try</span> astgen.appendErrorTok(for_full.inline_token.?, <span class="tok-str">&quot;redundant inline keyword in comptime scope&quot;</span>, .{});
    }
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_data = tree.nodes.items(.data);
    <span class="tok-kw">const</span> gpa = astgen.gpa;<span class="tok-comment">

    // For counters, this is the start value; for indexables, this is the base
    // pointer that can be used with elem_ptr and similar instructions.
    // Special value `none` means that this is a counter and its start value is
    // zero, indicating that the main index counter can be used directly.
    </span><span class="tok-kw">const</span> indexables = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>, for_full.ast.inputs.len);
    <span class="tok-kw">defer</span> gpa.free(indexables);<span class="tok-comment">
    // elements of this array can be `none`, indicating no length check.
    </span><span class="tok-kw">const</span> lens = <span class="tok-kw">try</span> gpa.alloc([<span class="tok-number">2</span>]<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>, for_full.ast.inputs.len);
    <span class="tok-kw">defer</span> gpa.free(lens);<span class="tok-comment">

    // We will use a single zero-based counter no matter how many indexables there are.
    </span><span class="tok-kw">const</span> index_ptr = blk: {
        <span class="tok-kw">const</span> alloc_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .alloc_comptime_mut <span class="tok-kw">else</span> .alloc;
        <span class="tok-kw">const</span> index_ptr = <span class="tok-kw">try</span> parent_gz.addUnNode(alloc_tag, .usize_type, node);<span class="tok-comment">
        // initialize to zero
        </span>_ = <span class="tok-kw">try</span> parent_gz.addPlNode(.store_node, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
            .lhs = index_ptr,
            .rhs = .zero_usize,
        });
        <span class="tok-kw">break</span> :blk index_ptr;
    };

    <span class="tok-kw">var</span> any_len_checks = <span class="tok-null">false</span>;

    {
        <span class="tok-kw">var</span> capture_token = for_full.payload_token;
        <span class="tok-kw">for</span> (for_full.ast.inputs, indexables, lens) |input, *indexable_ref, *len_refs| {
            <span class="tok-kw">const</span> capture_is_ref = token_tags[capture_token] == .asterisk;
            <span class="tok-kw">const</span> ident_tok = capture_token + <span class="tok-builtin">@intFromBool</span>(capture_is_ref);
            <span class="tok-kw">const</span> is_discard = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(ident_tok), <span class="tok-str">&quot;_&quot;</span>);

            <span class="tok-kw">if</span> (is_discard <span class="tok-kw">and</span> capture_is_ref) {
                <span class="tok-kw">return</span> astgen.failTok(capture_token, <span class="tok-str">&quot;pointer modifier invalid on discard&quot;</span>, .{});
            }<span class="tok-comment">
            // Skip over the comma, and on to the next capture (or the ending pipe character).
            </span>capture_token = ident_tok + <span class="tok-number">2</span>;

            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(parent_gz, input);
            <span class="tok-kw">if</span> (node_tags[input] == .for_range) {
                <span class="tok-kw">if</span> (capture_is_ref) {
                    <span class="tok-kw">return</span> astgen.failTok(ident_tok, <span class="tok-str">&quot;cannot capture reference to range&quot;</span>, .{});
                }
                <span class="tok-kw">const</span> start_node = node_data[input].lhs;
                <span class="tok-kw">const</span> start_val = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(parent_gz, scope, .{ .rl = .{ .ty = .usize_type } }, start_node);

                <span class="tok-kw">const</span> end_node = node_data[input].rhs;
                <span class="tok-kw">const</span> end_val = <span class="tok-kw">if</span> (end_node != <span class="tok-number">0</span>)
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(parent_gz, scope, .{ .rl = .{ .ty = .usize_type } }, node_data[input].rhs)
                <span class="tok-kw">else</span>
                    .none;

                <span class="tok-kw">if</span> (end_val == .none <span class="tok-kw">and</span> is_discard) {
                    <span class="tok-kw">try</span> astgen.appendErrorTok(ident_tok, <span class="tok-str">&quot;discard of unbounded counter&quot;</span>, .{});
                }

                <span class="tok-kw">if</span> (end_val == .none) {
                    len_refs.* = .{ .none, .none };
                } <span class="tok-kw">else</span> {
                    any_len_checks = <span class="tok-null">true</span>;
                    len_refs.* = .{ start_val, end_val };
                }

                <span class="tok-kw">const</span> start_is_zero = <a href="std.zig.AstGen.html#std.zig.AstGen.nodeIsTriviallyZero">nodeIsTriviallyZero</a>(tree, start_node);
                indexable_ref.* = <span class="tok-kw">if</span> (start_is_zero) .none <span class="tok-kw">else</span> start_val;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> indexable = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(parent_gz, scope, .{ .rl = .none }, input);

                any_len_checks = <span class="tok-null">true</span>;
                indexable_ref.* = indexable;
                len_refs.* = .{ indexable, .none };
            }
        }
    }

    <span class="tok-kw">if</span> (!any_len_checks) {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;unbounded for loop&quot;</span>, .{});
    }<span class="tok-comment">

    // We use a dedicated ZIR instruction to assert the lengths to assist with
    // nicer error reporting as well as fewer ZIR bytes emitted.
    </span><span class="tok-kw">const</span> len: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = len: {
        <span class="tok-kw">const</span> all_lens = <span class="tok-builtin">@as</span>([*]<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>, <span class="tok-builtin">@ptrCast</span>(lens))[<span class="tok-number">0</span> .. lens.len * <span class="tok-number">2</span>];
        <span class="tok-kw">const</span> lens_len: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(all_lens.len);
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.MultiOp.html">MultiOp</a>).@&quot;struct&quot;.fields.len + lens_len);
        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> parent_gz.addPlNode(.for_len, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.MultiOp.html">MultiOp</a>{
            .operands_len = lens_len,
        });
        <a href="std.zig.AstGen.html#std.zig.AstGen.appendRefsAssumeCapacity">appendRefsAssumeCapacity</a>(astgen, all_lens);
        <span class="tok-kw">break</span> :len len;
    };

    <span class="tok-kw">const</span> loop_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .block_inline <span class="tok-kw">else</span> .loop;
    <span class="tok-kw">const</span> loop_block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(loop_tag, node);
    <span class="tok-kw">try</span> parent_gz.instructions.append(gpa, loop_block);

    <span class="tok-kw">var</span> loop_scope = parent_gz.makeSubBlock(scope);
    loop_scope.is_inline = is_inline;
    loop_scope.setBreakResultInfo(block_ri);
    <span class="tok-kw">defer</span> loop_scope.unstack();<span class="tok-comment">

    // We need to finish loop_scope later once we have the deferred refs from then_scope. However, the
    // load must be removed from instructions in the meantime or it appears to be part of parent_gz.
    </span><span class="tok-kw">const</span> index = <span class="tok-kw">try</span> loop_scope.addUnNode(.load, index_ptr, node);
    _ = loop_scope.instructions.pop();

    <span class="tok-kw">var</span> cond_scope = parent_gz.makeSubBlock(&amp;loop_scope.base);
    <span class="tok-kw">defer</span> cond_scope.unstack();<span class="tok-comment">

    // Check the condition.
    </span><span class="tok-kw">const</span> cond = <span class="tok-kw">try</span> cond_scope.addPlNode(.cmp_lt, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = index,
        .rhs = len,
    });

    <span class="tok-kw">const</span> condbr_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .condbr_inline <span class="tok-kw">else</span> .condbr;
    <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> cond_scope.addCondBr(condbr_tag, node);
    <span class="tok-kw">const</span> block_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .block_inline <span class="tok-kw">else</span> .block;
    <span class="tok-kw">const</span> cond_block = <span class="tok-kw">try</span> loop_scope.makeBlockInst(block_tag, node);
    <span class="tok-kw">try</span> cond_scope.setBlockBody(cond_block);

    loop_scope.break_block = loop_block.toOptional();
    loop_scope.continue_block = cond_block.toOptional();
    <span class="tok-kw">if</span> (for_full.label_token) |label_token| {
        loop_scope.label = .{
            .token = label_token,
            .block_inst = loop_block,
        };
    }

    <span class="tok-kw">const</span> then_node = for_full.ast.then_expr;
    <span class="tok-kw">var</span> then_scope = parent_gz.makeSubBlock(&amp;cond_scope.base);
    <span class="tok-kw">defer</span> then_scope.unstack();

    <span class="tok-kw">const</span> capture_scopes = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>, for_full.ast.inputs.len);
    <span class="tok-kw">defer</span> gpa.free(capture_scopes);

    <span class="tok-kw">const</span> then_sub_scope = blk: {
        <span class="tok-kw">var</span> capture_token = for_full.payload_token;
        <span class="tok-kw">var</span> capture_sub_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a> = &amp;then_scope.base;
        <span class="tok-kw">for</span> (for_full.ast.inputs, indexables, capture_scopes) |input, indexable_ref, *capture_scope| {
            <span class="tok-kw">const</span> capture_is_ref = token_tags[capture_token] == .asterisk;
            <span class="tok-kw">const</span> ident_tok = capture_token + <span class="tok-builtin">@intFromBool</span>(capture_is_ref);
            <span class="tok-kw">const</span> capture_name = tree.tokenSlice(ident_tok);<span class="tok-comment">
            // Skip over the comma, and on to the next capture (or the ending pipe character).
            </span>capture_token = ident_tok + <span class="tok-number">2</span>;

            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, capture_name, <span class="tok-str">&quot;_&quot;</span>)) <span class="tok-kw">continue</span>;

            <span class="tok-kw">const</span> name_str_index = <span class="tok-kw">try</span> astgen.identAsString(ident_tok);
            <span class="tok-kw">try</span> astgen.detectLocalShadowing(capture_sub_scope, name_str_index, ident_tok, capture_name, .capture);

            <span class="tok-kw">const</span> capture_inst = inst: {
                <span class="tok-kw">const</span> is_counter = node_tags[input] == .for_range;

                <span class="tok-kw">if</span> (indexable_ref == .none) {<span class="tok-comment">
                    // Special case: the main index can be used directly.
                    </span><a href="std.debug.html#std.debug.assert">assert</a>(is_counter);
                    <a href="std.debug.html#std.debug.assert">assert</a>(!capture_is_ref);
                    <span class="tok-kw">break</span> :inst index;
                }<span class="tok-comment">

                // For counters, we add the index variable to the start value; for
                // indexables, we use it as an element index. This is so similar
                // that they can share the same code paths, branching only on the
                // ZIR tag.
                </span><span class="tok-kw">const</span> switch_cond = (<span class="tok-builtin">@as</span>(<span class="tok-type">u2</span>, <span class="tok-builtin">@intFromBool</span>(capture_is_ref)) &lt;&lt; <span class="tok-number">1</span>) | <span class="tok-builtin">@intFromBool</span>(is_counter);
                <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (switch_cond) {
                    <span class="tok-number">0b00</span> =&gt; .elem_val,
                    <span class="tok-number">0b01</span> =&gt; .add,
                    <span class="tok-number">0b10</span> =&gt; .elem_ptr,
                    <span class="tok-number">0b11</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // compile error emitted already
                </span>};
                <span class="tok-kw">break</span> :inst <span class="tok-kw">try</span> then_scope.addPlNode(tag, input, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                    .lhs = indexable_ref,
                    .rhs = index,
                });
            };

            capture_scope.* = .{
                .parent = capture_sub_scope,
                .gen_zir = &amp;then_scope,
                .name = name_str_index,
                .inst = capture_inst,
                .token_src = ident_tok,
                .id_cat = .capture,
            };

            <span class="tok-kw">try</span> then_scope.addDbgVar(.dbg_var_val, name_str_index, capture_inst);
            capture_sub_scope = &amp;capture_scope.base;
        }

        <span class="tok-kw">break</span> :blk capture_sub_scope;
    };

    <span class="tok-kw">const</span> then_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;then_scope, then_sub_scope, .{ .rl = .none }, then_node, .allow_branch_hint);
    _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addEnsureResult">addEnsureResult</a>(&amp;then_scope, then_result, then_node);

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;then_scope.base, then_sub_scope);

    astgen.advanceSourceCursor(token_starts[tree.lastToken(then_node)]);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(parent_gz, .{ astgen.source_line - parent_gz.decl_line, astgen.source_column });
    _ = <span class="tok-kw">try</span> parent_gz.add(.{
        .tag = .extended,
        .data = .{ .extended = .{
            .opcode = .dbg_empty_stmt,
            .small = <span class="tok-null">undefined</span>,
            .operand = <span class="tok-null">undefined</span>,
        } },
    });

    <span class="tok-kw">const</span> break_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .break_inline <span class="tok-kw">else</span> .@&quot;break&quot;;
    _ = <span class="tok-kw">try</span> then_scope.addBreak(break_tag, cond_block, .void_value);

    <span class="tok-kw">var</span> else_scope = parent_gz.makeSubBlock(&amp;cond_scope.base);
    <span class="tok-kw">defer</span> else_scope.unstack();

    <span class="tok-kw">const</span> else_node = for_full.ast.else_expr;
    <span class="tok-kw">if</span> (else_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> sub_scope = &amp;else_scope.base;<span class="tok-comment">
        // Remove the continue block and break block so that `continue` and `break`
        // control flow apply to outer loops; not this one.
        </span>loop_scope.continue_block = .none;
        loop_scope.break_block = .none;
        <span class="tok-kw">const</span> else_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;else_scope, sub_scope, loop_scope.break_result_info, else_node, .allow_branch_hint);
        <span class="tok-kw">if</span> (is_statement) {
            _ = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addEnsureResult">addEnsureResult</a>(&amp;else_scope, else_result, else_node);
        }
        <span class="tok-kw">if</span> (!else_scope.endsWithNoReturn()) {
            _ = <span class="tok-kw">try</span> else_scope.addBreakWithSrcNode(break_tag, loop_block, else_result, else_node);
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(&amp;else_scope, ri, .void_value, node);
        _ = <span class="tok-kw">try</span> else_scope.addBreak(break_tag, loop_block, result);
    }

    <span class="tok-kw">if</span> (loop_scope.label) |some| {
        <span class="tok-kw">if</span> (!some.used) {
            <span class="tok-kw">try</span> astgen.appendErrorTok(some.token, <span class="tok-str">&quot;unused for loop label&quot;</span>, .{});
        }
    }

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setCondBrPayload">setCondBrPayload</a>(condbr, cond, &amp;then_scope, &amp;else_scope);<span class="tok-comment">

    // then_block and else_block unstacked now, can resurrect loop_scope to finally finish it
    </span>{
        loop_scope.instructions_top = loop_scope.instructions.items.len;
        <span class="tok-kw">try</span> loop_scope.instructions.appendSlice(gpa, &amp;.{ index.toIndex().?, cond_block });<span class="tok-comment">

        // Increment the index variable.
        </span><span class="tok-kw">const</span> index_plus_one = <span class="tok-kw">try</span> loop_scope.addPlNode(.add_unsafe, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
            .lhs = index,
            .rhs = .one_usize,
        });
        _ = <span class="tok-kw">try</span> loop_scope.addPlNode(.store_node, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
            .lhs = index_ptr,
            .rhs = index_plus_one,
        });

        <span class="tok-kw">const</span> repeat_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (is_inline) .repeat_inline <span class="tok-kw">else</span> .repeat;
        _ = <span class="tok-kw">try</span> loop_scope.addNode(repeat_tag, node);

        <span class="tok-kw">try</span> loop_scope.setBlockBody(loop_block);
    }

    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (need_result_rvalue)
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(parent_gz, ri, loop_block.toRef(), node)
    <span class="tok-kw">else</span>
        loop_block.toRef();

    <span class="tok-kw">if</span> (is_statement) {
        _ = <span class="tok-kw">try</span> parent_gz.addUnNode(.ensure_result_used, result, node);
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">switchExprErrUnion</span>(
    parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    catch_or_if_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    node_ty: <span class="tok-kw">enum</span> { @&quot;catch&quot;, @&quot;if&quot; },
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> if_full = <span class="tok-kw">switch</span> (node_ty) {
        .@&quot;catch&quot; =&gt; <span class="tok-null">undefined</span>,
        .@&quot;if&quot; =&gt; tree.fullIf(catch_or_if_node).?,
    };

    <span class="tok-kw">const</span> switch_node, <span class="tok-kw">const</span> operand_node, <span class="tok-kw">const</span> error_payload = <span class="tok-kw">switch</span> (node_ty) {
        .@&quot;catch&quot; =&gt; .{
            node_datas[catch_or_if_node].rhs,
            node_datas[catch_or_if_node].lhs,
            main_tokens[catch_or_if_node] + <span class="tok-number">2</span>,
        },
        .@&quot;if&quot; =&gt; .{
            if_full.ast.else_expr,
            if_full.ast.cond_expr,
            if_full.error_token.?,
        },
    };
    <a href="std.debug.html#std.debug.assert">assert</a>(node_tags[switch_node] == .@&quot;switch&quot; <span class="tok-kw">or</span> node_tags[switch_node] == .switch_comma);

    <span class="tok-kw">const</span> do_err_trace = astgen.fn_block != <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> extra = tree.extraData(node_datas[switch_node].rhs, <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">const</span> case_nodes = tree.extra_data[extra.start..extra.end];

    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(catch_or_if_node);
    <span class="tok-kw">const</span> block_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{
        .rl = <span class="tok-kw">switch</span> (ri.rl) {
            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, catch_or_if_node)).? },
            .inferred_ptr =&gt; .none,
            <span class="tok-kw">else</span> =&gt; ri.rl,
        },
        .ctx = ri.ctx,
    };

    <span class="tok-kw">const</span> payload_is_ref = <span class="tok-kw">switch</span> (node_ty) {
        .@&quot;if&quot; =&gt; if_full.payload_token != <span class="tok-null">null</span> <span class="tok-kw">and</span> token_tags[if_full.payload_token.?] == .asterisk,
        .@&quot;catch&quot; =&gt; ri.rl == .ref <span class="tok-kw">or</span> ri.rl == .ref_coerced_ty,
    };<span class="tok-comment">

    // We need to call `rvalue` to write through to the pointer only if we had a
    // result pointer and aren't forwarding it.
    </span><span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>).@&quot;union&quot;.tag_type.?;
    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);
    <span class="tok-kw">var</span> scalar_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> multi_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> inline_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> has_else = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> else_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> else_src: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">for</span> (case_nodes) |case_node| {
        <span class="tok-kw">const</span> case = tree.fullSwitchCase(case_node).?;

        <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> case_src = case.ast.arrow_token - <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (else_src) |src| {
                <span class="tok-kw">return</span> astgen.failTokNotes(
                    case_src,
                    <span class="tok-str">&quot;multiple else prongs in switch expression&quot;</span>,
                    .{},
                    &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            src,
                            <span class="tok-str">&quot;previous else prong here&quot;</span>,
                            .{},
                        ),
                    },
                );
            }
            has_else = <span class="tok-null">true</span>;
            else_node = case_node;
            else_src = case_src;
            <span class="tok-kw">continue</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span>
            node_tags[case.ast.values[<span class="tok-number">0</span>]] == .identifier <span class="tok-kw">and</span>
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[case.ast.values[<span class="tok-number">0</span>]]), <span class="tok-str">&quot;_&quot;</span>))
        {
            <span class="tok-kw">const</span> case_src = case.ast.arrow_token - <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> astgen.failTokNotes(
                case_src,
                <span class="tok-str">&quot;'_' prong is not allowed when switching on errors&quot;</span>,
                .{},
                &amp;[_]<span class="tok-type">u32</span>{
                    <span class="tok-kw">try</span> astgen.errNoteTok(
                        case_src,
                        <span class="tok-str">&quot;consider using 'else'&quot;</span>,
                        .{},
                    ),
                },
            );
        }

        <span class="tok-kw">for</span> (case.ast.values) |val| {
            <span class="tok-kw">if</span> (node_tags[val] == .string_literal)
                <span class="tok-kw">return</span> astgen.failNode(val, <span class="tok-str">&quot;cannot switch on strings&quot;</span>, .{});
        }

        <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> node_tags[case.ast.values[<span class="tok-number">0</span>]] != .switch_range) {
            scalar_cases_len += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            multi_cases_len += <span class="tok-number">1</span>;
        }
        <span class="tok-kw">if</span> (case.inline_token != <span class="tok-null">null</span>) {
            inline_cases_len += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">const</span> operand_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{
        .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none,
        .ctx = .error_handling_expr,
    };

    astgen.advanceSourceCursorToNode(operand_node);
    <span class="tok-kw">const</span> operand_lc: <a href="std.zig.AstGen.LineColumn.html">LineColumn</a> = .{ astgen.source_line - parent_gz.decl_line, astgen.source_column };

    <span class="tok-kw">const</span> raw_operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(parent_gz, scope, operand_ri, operand_node, switch_node);
    <span class="tok-kw">const</span> item_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .none };<span class="tok-comment">

    // This contains the data that goes into the `extra` array for the SwitchBlockErrUnion, except
    // the first cases_nodes.len slots are a table that indexes payloads later in the array,
    // with the non-error and else case indices coming first, then scalar_cases_len indexes, then
    // multi_cases_len indexes
    </span><span class="tok-kw">const</span> payloads = &amp;astgen.scratch;
    <span class="tok-kw">const</span> scratch_top = astgen.scratch.items.len;
    <span class="tok-kw">const</span> case_table_start = scratch_top;
    <span class="tok-kw">const</span> scalar_case_table = case_table_start + <span class="tok-number">1</span> + <span class="tok-builtin">@intFromBool</span>(has_else);
    <span class="tok-kw">const</span> multi_case_table = scalar_case_table + scalar_cases_len;
    <span class="tok-kw">const</span> case_table_end = multi_case_table + multi_cases_len;

    <span class="tok-kw">try</span> astgen.scratch.resize(gpa, case_table_end);
    <span class="tok-kw">defer</span> astgen.scratch.items.len = scratch_top;

    <span class="tok-kw">var</span> block_scope = parent_gz.makeSubBlock(scope);<span class="tok-comment">
    // block_scope not used for collecting instructions
    </span>block_scope.instructions_top = <a href="std.zig.AstGen.GenZir.html">GenZir</a>.<a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>;
    block_scope.setBreakResultInfo(block_ri);<span class="tok-comment">

    // Sema expects a dbg_stmt immediately before switch_block_err_union
    </span><span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmtForceCurrentIndex">emitDbgStmtForceCurrentIndex</a>(parent_gz, operand_lc);<span class="tok-comment">
    // This gets added to the parent block later, after the item expressions.
    </span><span class="tok-kw">const</span> switch_block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(.switch_block_err_union, switch_node);<span class="tok-comment">

    // We re-use this same scope for all cases, including the special prong, if any.
    </span><span class="tok-kw">var</span> case_scope = parent_gz.makeSubBlock(&amp;block_scope.base);
    case_scope.instructions_top = <a href="std.zig.AstGen.GenZir.html">GenZir</a>.<a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>;

    {
        <span class="tok-kw">const</span> body_len_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(payloads.items.len);
        payloads.items[case_table_start] = body_len_index;
        <span class="tok-kw">try</span> payloads.resize(gpa, body_len_index + <span class="tok-number">1</span>);<span class="tok-comment"> // body_len

        </span>case_scope.instructions_top = parent_gz.instructions.items.len;
        <span class="tok-kw">defer</span> case_scope.unstack();

        <span class="tok-kw">const</span> unwrap_payload_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (payload_is_ref)
            .err_union_payload_unsafe_ptr
        <span class="tok-kw">else</span>
            .err_union_payload_unsafe;

        <span class="tok-kw">const</span> unwrapped_payload = <span class="tok-kw">try</span> case_scope.addUnNode(
            unwrap_payload_tag,
            raw_operand,
            catch_or_if_node,
        );

        <span class="tok-kw">switch</span> (node_ty) {
            .@&quot;catch&quot; =&gt; {
                <span class="tok-kw">const</span> case_result = <span class="tok-kw">switch</span> (ri.rl) {
                    .ref, .ref_coerced_ty =&gt; unwrapped_payload,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(
                        &amp;case_scope,
                        block_scope.break_result_info,
                        unwrapped_payload,
                        catch_or_if_node,
                    ),
                };
                _ = <span class="tok-kw">try</span> case_scope.addBreakWithSrcNode(
                    .@&quot;break&quot;,
                    switch_block,
                    case_result,
                    catch_or_if_node,
                );
            },
            .@&quot;if&quot; =&gt; {
                <span class="tok-kw">var</span> payload_val_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;

                <span class="tok-kw">const</span> then_node = if_full.ast.then_expr;
                <span class="tok-kw">const</span> then_sub_scope = s: {
                    <a href="std.debug.html#std.debug.assert">assert</a>(if_full.error_token != <span class="tok-null">null</span>);
                    <span class="tok-kw">if</span> (if_full.payload_token) |payload_token| {
                        <span class="tok-kw">const</span> token_name_index = payload_token + <span class="tok-builtin">@intFromBool</span>(payload_is_ref);
                        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(token_name_index);
                        <span class="tok-kw">const</span> token_name_str = tree.tokenSlice(token_name_index);
                        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, token_name_str))
                            <span class="tok-kw">break</span> :s &amp;case_scope.base;
                        <span class="tok-kw">try</span> astgen.detectLocalShadowing(
                            &amp;case_scope.base,
                            ident_name,
                            token_name_index,
                            token_name_str,
                            .capture,
                        );
                        payload_val_scope = .{
                            .parent = &amp;case_scope.base,
                            .gen_zir = &amp;case_scope,
                            .name = ident_name,
                            .inst = unwrapped_payload,
                            .token_src = token_name_index,
                            .id_cat = .capture,
                        };
                        <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, ident_name, unwrapped_payload);
                        <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;
                    } <span class="tok-kw">else</span> {
                        _ = <span class="tok-kw">try</span> case_scope.addUnNode(
                            .ensure_err_union_payload_void,
                            raw_operand,
                            catch_or_if_node,
                        );
                        <span class="tok-kw">break</span> :s &amp;case_scope.base;
                    }
                };
                <span class="tok-kw">const</span> then_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(
                    &amp;case_scope,
                    then_sub_scope,
                    block_scope.break_result_info,
                    then_node,
                );
                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;case_scope.base, then_sub_scope);
                <span class="tok-kw">if</span> (!case_scope.endsWithNoReturn()) {
                    _ = <span class="tok-kw">try</span> case_scope.addBreakWithSrcNode(
                        .@&quot;break&quot;,
                        switch_block,
                        then_result,
                        then_node,
                    );
                }
            },
        }

        <span class="tok-kw">const</span> case_slice = case_scope.instructionsSlice();
        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixupsExtraRefs(case_slice, &amp;.{switch_block});
        <span class="tok-kw">try</span> payloads.ensureUnusedCapacity(gpa, body_len);
        <span class="tok-kw">const</span> capture: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.html">ProngInfo</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.Capture.html">Capture</a> = <span class="tok-kw">switch</span> (node_ty) {
            .@&quot;catch&quot; =&gt; .none,
            .@&quot;if&quot; =&gt; <span class="tok-kw">if</span> (if_full.payload_token == <span class="tok-null">null</span>)
                .none
            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (payload_is_ref)
                .by_ref
            <span class="tok-kw">else</span>
                .by_val,
        };
        payloads.items[body_len_index] = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.html">ProngInfo</a>{
            .body_len = <span class="tok-builtin">@intCast</span>(body_len),
            .capture = capture,
            .is_inline = <span class="tok-null">false</span>,
            .has_tag_capture = <span class="tok-null">false</span>,
        });
        <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsExtraRefsArrayList">appendBodyWithFixupsExtraRefsArrayList</a>(astgen, payloads, case_slice, &amp;.{switch_block});
    }

    <span class="tok-kw">const</span> err_name = blk: {
        <span class="tok-kw">const</span> err_str = tree.tokenSlice(error_payload);
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, err_str, <span class="tok-str">&quot;_&quot;</span>)) {<span class="tok-comment">
            // This is fatal because we already know we're switching on the captured error.
            </span><span class="tok-kw">return</span> astgen.failTok(error_payload, <span class="tok-str">&quot;discard of error capture; omit it instead&quot;</span>, .{});
        }
        <span class="tok-kw">const</span> err_name = <span class="tok-kw">try</span> astgen.identAsString(error_payload);
        <span class="tok-kw">try</span> astgen.detectLocalShadowing(scope, err_name, error_payload, err_str, .capture);

        <span class="tok-kw">break</span> :blk err_name;
    };<span class="tok-comment">

    // allocate a shared dummy instruction for the error capture
    </span><span class="tok-kw">const</span> err_inst = err_inst: {
        <span class="tok-kw">const</span> inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        <span class="tok-kw">try</span> astgen.instructions.append(astgen.gpa, .{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .value_placeholder,
                .small = <span class="tok-null">undefined</span>,
                .operand = <span class="tok-null">undefined</span>,
            } },
        });
        <span class="tok-kw">break</span> :err_inst inst;
    };<span class="tok-comment">

    // In this pass we generate all the item and prong expressions for error cases.
    </span><span class="tok-kw">var</span> multi_case_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> scalar_case_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> any_uses_err_capture = <span class="tok-null">false</span>;
    <span class="tok-kw">for</span> (case_nodes) |case_node| {
        <span class="tok-kw">const</span> case = tree.fullSwitchCase(case_node).?;

        <span class="tok-kw">const</span> is_multi_case = case.ast.values.len &gt; <span class="tok-number">1</span> <span class="tok-kw">or</span>
            (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> node_tags[case.ast.values[<span class="tok-number">0</span>]] == .switch_range);

        <span class="tok-kw">var</span> dbg_var_name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = .empty;
        <span class="tok-kw">var</span> dbg_var_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> err_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> capture_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">const</span> sub_scope = blk: {
            err_scope = .{
                .parent = &amp;case_scope.base,
                .gen_zir = &amp;case_scope,
                .name = err_name,
                .inst = err_inst.toRef(),
                .token_src = error_payload,
                .id_cat = .capture,
            };

            <span class="tok-kw">const</span> capture_token = case.payload_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk &amp;err_scope.base;
            <span class="tok-kw">if</span> (token_tags[capture_token] != .identifier) {
                <span class="tok-kw">return</span> astgen.failTok(capture_token + <span class="tok-number">1</span>, <span class="tok-str">&quot;error set cannot be captured by reference&quot;</span>, .{});
            }

            <span class="tok-kw">const</span> capture_slice = tree.tokenSlice(capture_token);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, capture_slice, <span class="tok-str">&quot;_&quot;</span>)) {
                <span class="tok-kw">try</span> astgen.appendErrorTok(capture_token, <span class="tok-str">&quot;discard of error capture; omit it instead&quot;</span>, .{});
            }
            <span class="tok-kw">const</span> tag_name = <span class="tok-kw">try</span> astgen.identAsString(capture_token);
            <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;case_scope.base, tag_name, capture_token, capture_slice, .capture);

            capture_scope = .{
                .parent = &amp;case_scope.base,
                .gen_zir = &amp;case_scope,
                .name = tag_name,
                .inst = switch_block.toRef(),
                .token_src = capture_token,
                .id_cat = .capture,
            };
            dbg_var_name = tag_name;
            dbg_var_inst = switch_block.toRef();

            err_scope.parent = &amp;capture_scope.base;

            <span class="tok-kw">break</span> :blk &amp;err_scope.base;
        };

        <span class="tok-kw">const</span> header_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(payloads.items.len);
        <span class="tok-kw">const</span> body_len_index = <span class="tok-kw">if</span> (is_multi_case) blk: {
            payloads.items[multi_case_table + multi_case_index] = header_index;
            multi_case_index += <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">3</span>);<span class="tok-comment"> // items_len, ranges_len, body_len

            // items
            </span><span class="tok-kw">var</span> items_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (case.ast.values) |item_node| {
                <span class="tok-kw">if</span> (node_tags[item_node] == .switch_range) <span class="tok-kw">continue</span>;
                items_len += <span class="tok-number">1</span>;

                <span class="tok-kw">const</span> item_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(parent_gz, scope, item_ri, item_node, .switch_item);
                <span class="tok-kw">try</span> payloads.append(gpa, <span class="tok-builtin">@intFromEnum</span>(item_inst));
            }<span class="tok-comment">

            // ranges
            </span><span class="tok-kw">var</span> ranges_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (case.ast.values) |range| {
                <span class="tok-kw">if</span> (node_tags[range] != .switch_range) <span class="tok-kw">continue</span>;
                ranges_len += <span class="tok-number">1</span>;

                <span class="tok-kw">const</span> first = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(parent_gz, scope, item_ri, node_datas[range].lhs, .switch_item);
                <span class="tok-kw">const</span> last = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(parent_gz, scope, item_ri, node_datas[range].rhs, .switch_item);
                <span class="tok-kw">try</span> payloads.appendSlice(gpa, &amp;[_]<span class="tok-type">u32</span>{
                    <span class="tok-builtin">@intFromEnum</span>(first), <span class="tok-builtin">@intFromEnum</span>(last),
                });
            }

            payloads.items[header_index] = items_len;
            payloads.items[header_index + <span class="tok-number">1</span>] = ranges_len;
            <span class="tok-kw">break</span> :blk header_index + <span class="tok-number">2</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case_node == else_node) blk: {
            payloads.items[case_table_start + <span class="tok-number">1</span>] = header_index;
            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">1</span>);<span class="tok-comment"> // body_len
            </span><span class="tok-kw">break</span> :blk header_index;
        } <span class="tok-kw">else</span> blk: {
            payloads.items[scalar_case_table + scalar_case_index] = header_index;
            scalar_case_index += <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">2</span>);<span class="tok-comment"> // item, body_len
            </span><span class="tok-kw">const</span> item_node = case.ast.values[<span class="tok-number">0</span>];
            <span class="tok-kw">const</span> item_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(parent_gz, scope, item_ri, item_node, .switch_item);
            payloads.items[header_index] = <span class="tok-builtin">@intFromEnum</span>(item_inst);
            <span class="tok-kw">break</span> :blk header_index + <span class="tok-number">1</span>;
        };

        {<span class="tok-comment">
            // temporarily stack case_scope on parent_gz
            </span>case_scope.instructions_top = parent_gz.instructions.items.len;
            <span class="tok-kw">defer</span> case_scope.unstack();

            <span class="tok-kw">if</span> (do_err_trace <span class="tok-kw">and</span> <a href="std.zig.AstGen.html#std.zig.AstGen.nodeMayAppendToErrorTrace">nodeMayAppendToErrorTrace</a>(tree, operand_node))
                _ = <span class="tok-kw">try</span> case_scope.addSaveErrRetIndex(.always);

            <span class="tok-kw">if</span> (dbg_var_name != .empty) {
                <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, dbg_var_name, dbg_var_inst);
            }

            <span class="tok-kw">const</span> target_expr_node = case.ast.target_expr;
            <span class="tok-kw">const</span> case_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;case_scope, sub_scope, block_scope.break_result_info, target_expr_node, .allow_branch_hint);<span class="tok-comment">
            // check capture_scope, not err_scope to avoid false positive unused error capture
            </span><span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;case_scope.base, err_scope.parent);
            <span class="tok-kw">const</span> uses_err = err_scope.used != <span class="tok-number">0</span> <span class="tok-kw">or</span> err_scope.discarded != <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (uses_err) {
                <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, err_name, err_inst.toRef());
                any_uses_err_capture = <span class="tok-null">true</span>;
            }

            <span class="tok-kw">if</span> (!parent_gz.refIsNoReturn(case_result)) {
                <span class="tok-kw">if</span> (do_err_trace)
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.restoreErrRetIndex">restoreErrRetIndex</a>(
                        &amp;case_scope,
                        .{ .block = switch_block },
                        block_scope.break_result_info,
                        target_expr_node,
                        case_result,
                    );

                _ = <span class="tok-kw">try</span> case_scope.addBreakWithSrcNode(.@&quot;break&quot;, switch_block, case_result, target_expr_node);
            }

            <span class="tok-kw">const</span> case_slice = case_scope.instructionsSlice();
            <span class="tok-kw">const</span> extra_insts: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-kw">if</span> (uses_err) &amp;.{ switch_block, err_inst } <span class="tok-kw">else</span> &amp;.{switch_block};
            <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixupsExtraRefs(case_slice, extra_insts);
            <span class="tok-kw">try</span> payloads.ensureUnusedCapacity(gpa, body_len);
            payloads.items[body_len_index] = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.html">ProngInfo</a>{
                .body_len = <span class="tok-builtin">@intCast</span>(body_len),
                .capture = <span class="tok-kw">if</span> (case.payload_token != <span class="tok-null">null</span>) .by_val <span class="tok-kw">else</span> .none,
                .is_inline = case.inline_token != <span class="tok-null">null</span>,
                .has_tag_capture = <span class="tok-null">false</span>,
            });
            <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsExtraRefsArrayList">appendBodyWithFixupsExtraRefsArrayList</a>(astgen, payloads, case_slice, extra_insts);
        }
    }<span class="tok-comment">
    // Now that the item expressions are generated we can add this.
    </span><span class="tok-kw">try</span> parent_gz.instructions.append(gpa, switch_block);

    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlockErrUnion.html">SwitchBlockErrUnion</a>).@&quot;struct&quot;.fields.len +
        <span class="tok-builtin">@intFromBool</span>(multi_cases_len != <span class="tok-number">0</span>) +
        payloads.items.len - case_table_end +
        (case_table_end - case_table_start) * <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.As.html">As</a>).@&quot;struct&quot;.fields.len);

    <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlockErrUnion.html">SwitchBlockErrUnion</a>{
        .operand = raw_operand,
        .bits = <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlockErrUnion.html">SwitchBlockErrUnion</a>.<a href="std.zig.Zir.Inst.SwitchBlockErrUnion.Bits.html">Bits</a>{
            .has_multi_cases = multi_cases_len != <span class="tok-number">0</span>,
            .has_else = has_else,
            .scalar_cases_len = <span class="tok-builtin">@intCast</span>(scalar_cases_len),
            .any_uses_err_capture = any_uses_err_capture,
            .payload_is_ref = payload_is_ref,
        },
        .main_src_node_offset = parent_gz.nodeIndexToRelative(catch_or_if_node),
    });

    <span class="tok-kw">if</span> (multi_cases_len != <span class="tok-number">0</span>) {
        astgen.extra.appendAssumeCapacity(multi_cases_len);
    }

    <span class="tok-kw">if</span> (any_uses_err_capture) {
        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(err_inst));
    }

    <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
    zir_datas[<span class="tok-builtin">@intFromEnum</span>(switch_block)].pl_node.payload_index = payload_index;

    <span class="tok-kw">for</span> (payloads.items[case_table_start..case_table_end], <span class="tok-number">0</span>..) |start_index, i| {
        <span class="tok-kw">var</span> body_len_index = start_index;
        <span class="tok-kw">var</span> end_index = start_index;
        <span class="tok-kw">const</span> table_index = case_table_start + i;
        <span class="tok-kw">if</span> (table_index &lt; scalar_case_table) {
            end_index += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (table_index &lt; multi_case_table) {
            body_len_index += <span class="tok-number">1</span>;
            end_index += <span class="tok-number">2</span>;
        } <span class="tok-kw">else</span> {
            body_len_index += <span class="tok-number">2</span>;
            <span class="tok-kw">const</span> items_len = payloads.items[start_index];
            <span class="tok-kw">const</span> ranges_len = payloads.items[start_index + <span class="tok-number">1</span>];
            end_index += <span class="tok-number">3</span> + items_len + <span class="tok-number">2</span> * ranges_len;
        }
        <span class="tok-kw">const</span> prong_info: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.html">ProngInfo</a> = <span class="tok-builtin">@bitCast</span>(payloads.items[body_len_index]);
        end_index += prong_info.body_len;
        astgen.extra.appendSliceAssumeCapacity(payloads.items[start_index..end_index]);
    }

    <span class="tok-kw">if</span> (need_result_rvalue) {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(parent_gz, ri, switch_block.toRef(), switch_node);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> switch_block.toRef();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">switchExpr</span>(
    parent_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    switch_full: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = parent_gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> operand_node = switch_full.ast.condition;
    <span class="tok-kw">const</span> case_nodes = switch_full.ast.cases;

    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);
    <span class="tok-kw">const</span> block_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{
        .rl = <span class="tok-kw">switch</span> (ri.rl) {
            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },
            .inferred_ptr =&gt; .none,
            <span class="tok-kw">else</span> =&gt; ri.rl,
        },
        .ctx = ri.ctx,
    };<span class="tok-comment">
    // We need to call `rvalue` to write through to the pointer only if we had a
    // result pointer and aren't forwarding it.
    </span><span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>).@&quot;union&quot;.tag_type.?;
    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);

    <span class="tok-kw">if</span> (switch_full.label_token) |label_token| {
        <span class="tok-kw">try</span> astgen.checkLabelRedefinition(scope, label_token);
    }<span class="tok-comment">

    // We perform two passes over the AST. This first pass is to collect information
    // for the following variables, make note of the special prong AST node index,
    // and bail out with a compile error if there are multiple special prongs present.
    </span><span class="tok-kw">var</span> any_payload_is_ref = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> any_has_tag_capture = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> any_non_inline_capture = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> scalar_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> multi_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> inline_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> special_prong: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.SpecialProng.html">SpecialProng</a> = .none;
    <span class="tok-kw">var</span> special_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> else_src: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> underscore_src: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">for</span> (case_nodes) |case_node| {
        <span class="tok-kw">const</span> case = tree.fullSwitchCase(case_node).?;
        <span class="tok-kw">if</span> (case.payload_token) |payload_token| {
            <span class="tok-kw">const</span> ident = <span class="tok-kw">if</span> (token_tags[payload_token] == .asterisk) blk: {
                any_payload_is_ref = <span class="tok-null">true</span>;
                <span class="tok-kw">break</span> :blk payload_token + <span class="tok-number">1</span>;
            } <span class="tok-kw">else</span> payload_token;
            <span class="tok-kw">if</span> (token_tags[ident + <span class="tok-number">1</span>] == .comma) {
                any_has_tag_capture = <span class="tok-null">true</span>;
            }<span class="tok-comment">

            // If the first capture is ignored, then there is no runtime-known
            // capture, as the tag capture must be for an inline prong.
            // This check isn't perfect, because for things like enums, the
            // first prong *is* comptime-known for inline prongs! But such
            // knowledge requires semantic analysis.
            </span><span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(ident), <span class="tok-str">&quot;_&quot;</span>)) {
                any_non_inline_capture = <span class="tok-null">true</span>;
            }
        }<span class="tok-comment">
        // Check for else/`_` prong.
        </span><span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> case_src = case.ast.arrow_token - <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (else_src) |src| {
                <span class="tok-kw">return</span> astgen.failTokNotes(
                    case_src,
                    <span class="tok-str">&quot;multiple else prongs in switch expression&quot;</span>,
                    .{},
                    &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            src,
                            <span class="tok-str">&quot;previous else prong here&quot;</span>,
                            .{},
                        ),
                    },
                );
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (underscore_src) |some_underscore| {
                <span class="tok-kw">return</span> astgen.failNodeNotes(
                    node,
                    <span class="tok-str">&quot;else and '_' prong in switch expression&quot;</span>,
                    .{},
                    &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            case_src,
                            <span class="tok-str">&quot;else prong here&quot;</span>,
                            .{},
                        ),
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            some_underscore,
                            <span class="tok-str">&quot;'_' prong here&quot;</span>,
                            .{},
                        ),
                    },
                );
            }
            special_node = case_node;
            special_prong = .@&quot;else&quot;;
            else_src = case_src;
            <span class="tok-kw">continue</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span>
            node_tags[case.ast.values[<span class="tok-number">0</span>]] == .identifier <span class="tok-kw">and</span>
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[case.ast.values[<span class="tok-number">0</span>]]), <span class="tok-str">&quot;_&quot;</span>))
        {
            <span class="tok-kw">const</span> case_src = case.ast.arrow_token - <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (underscore_src) |src| {
                <span class="tok-kw">return</span> astgen.failTokNotes(
                    case_src,
                    <span class="tok-str">&quot;multiple '_' prongs in switch expression&quot;</span>,
                    .{},
                    &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            src,
                            <span class="tok-str">&quot;previous '_' prong here&quot;</span>,
                            .{},
                        ),
                    },
                );
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (else_src) |some_else| {
                <span class="tok-kw">return</span> astgen.failNodeNotes(
                    node,
                    <span class="tok-str">&quot;else and '_' prong in switch expression&quot;</span>,
                    .{},
                    &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            some_else,
                            <span class="tok-str">&quot;else prong here&quot;</span>,
                            .{},
                        ),
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            case_src,
                            <span class="tok-str">&quot;'_' prong here&quot;</span>,
                            .{},
                        ),
                    },
                );
            }
            <span class="tok-kw">if</span> (case.inline_token != <span class="tok-null">null</span>) {
                <span class="tok-kw">return</span> astgen.failTok(case_src, <span class="tok-str">&quot;cannot inline '_' prong&quot;</span>, .{});
            }
            special_node = case_node;
            special_prong = .under;
            underscore_src = case_src;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">for</span> (case.ast.values) |val| {
            <span class="tok-kw">if</span> (node_tags[val] == .string_literal)
                <span class="tok-kw">return</span> astgen.failNode(val, <span class="tok-str">&quot;cannot switch on strings&quot;</span>, .{});
        }

        <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> node_tags[case.ast.values[<span class="tok-number">0</span>]] != .switch_range) {
            scalar_cases_len += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            multi_cases_len += <span class="tok-number">1</span>;
        }
        <span class="tok-kw">if</span> (case.inline_token != <span class="tok-null">null</span>) {
            inline_cases_len += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">const</span> operand_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = <span class="tok-kw">if</span> (any_payload_is_ref) .ref <span class="tok-kw">else</span> .none };

    astgen.advanceSourceCursorToNode(operand_node);
    <span class="tok-kw">const</span> operand_lc: <a href="std.zig.AstGen.LineColumn.html">LineColumn</a> = .{ astgen.source_line - parent_gz.decl_line, astgen.source_column };

    <span class="tok-kw">const</span> raw_operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(parent_gz, scope, operand_ri, operand_node);
    <span class="tok-kw">const</span> item_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{ .rl = .none };<span class="tok-comment">

    // If this switch is labeled, it may have `continue`s targeting it, and thus we need the operand type
    // to provide a result type.
    </span><span class="tok-kw">const</span> raw_operand_ty_ref = <span class="tok-kw">if</span> (switch_full.label_token != <span class="tok-null">null</span>) t: {
        <span class="tok-kw">break</span> :t <span class="tok-kw">try</span> parent_gz.addUnNode(.typeof, raw_operand, operand_node);
    } <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;<span class="tok-comment">

    // This contains the data that goes into the `extra` array for the SwitchBlock/SwitchBlockMulti,
    // except the first cases_nodes.len slots are a table that indexes payloads later in the array, with
    // the special case index coming first, then scalar_case_len indexes, then multi_cases_len indexes
    </span><span class="tok-kw">const</span> payloads = &amp;astgen.scratch;
    <span class="tok-kw">const</span> scratch_top = astgen.scratch.items.len;
    <span class="tok-kw">const</span> case_table_start = scratch_top;
    <span class="tok-kw">const</span> scalar_case_table = case_table_start + <span class="tok-builtin">@intFromBool</span>(special_prong != .none);
    <span class="tok-kw">const</span> multi_case_table = scalar_case_table + scalar_cases_len;
    <span class="tok-kw">const</span> case_table_end = multi_case_table + multi_cases_len;
    <span class="tok-kw">try</span> astgen.scratch.resize(gpa, case_table_end);
    <span class="tok-kw">defer</span> astgen.scratch.items.len = scratch_top;

    <span class="tok-kw">var</span> block_scope = parent_gz.makeSubBlock(scope);<span class="tok-comment">
    // block_scope not used for collecting instructions
    </span>block_scope.instructions_top = <a href="std.zig.AstGen.GenZir.html">GenZir</a>.<a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>;
    block_scope.setBreakResultInfo(block_ri);<span class="tok-comment">

    // Sema expects a dbg_stmt immediately before switch_block(_ref)
    </span><span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmtForceCurrentIndex">emitDbgStmtForceCurrentIndex</a>(parent_gz, operand_lc);<span class="tok-comment">
    // This gets added to the parent block later, after the item expressions.
    </span><span class="tok-kw">const</span> switch_tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">if</span> (any_payload_is_ref) .switch_block_ref <span class="tok-kw">else</span> .switch_block;
    <span class="tok-kw">const</span> switch_block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(switch_tag, node);

    <span class="tok-kw">if</span> (switch_full.label_token) |label_token| {
        block_scope.continue_block = switch_block.toOptional();
        block_scope.continue_result_info = .{
            .rl = <span class="tok-kw">if</span> (any_payload_is_ref)
                .{ .ref_coerced_ty = raw_operand_ty_ref }
            <span class="tok-kw">else</span>
                .{ .coerced_ty = raw_operand_ty_ref },
        };

        block_scope.label = .{
            .token = label_token,
            .block_inst = switch_block,
        };<span class="tok-comment">
        // `break` can target this via `label.block_inst`
        // `break_result_info` already set by `setBreakResultInfo`
    </span>}<span class="tok-comment">

    // We re-use this same scope for all cases, including the special prong, if any.
    </span><span class="tok-kw">var</span> case_scope = parent_gz.makeSubBlock(&amp;block_scope.base);
    case_scope.instructions_top = <a href="std.zig.AstGen.GenZir.html">GenZir</a>.<a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>;<span class="tok-comment">

    // If any prong has an inline tag capture, allocate a shared dummy instruction for it
    </span><span class="tok-kw">const</span> tag_inst = <span class="tok-kw">if</span> (any_has_tag_capture) tag_inst: {
        <span class="tok-kw">const</span> inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        <span class="tok-kw">try</span> astgen.instructions.append(astgen.gpa, .{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .value_placeholder,
                .small = <span class="tok-null">undefined</span>,
                .operand = <span class="tok-null">undefined</span>,
            } },
        });
        <span class="tok-kw">break</span> :tag_inst inst;
    } <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;<span class="tok-comment">

    // In this pass we generate all the item and prong expressions.
    </span><span class="tok-kw">var</span> multi_case_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> scalar_case_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (case_nodes) |case_node| {
        <span class="tok-kw">const</span> case = tree.fullSwitchCase(case_node).?;

        <span class="tok-kw">const</span> is_multi_case = case.ast.values.len &gt; <span class="tok-number">1</span> <span class="tok-kw">or</span>
            (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> node_tags[case.ast.values[<span class="tok-number">0</span>]] == .switch_range);

        <span class="tok-kw">var</span> dbg_var_name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = .empty;
        <span class="tok-kw">var</span> dbg_var_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> dbg_var_tag_name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = .empty;
        <span class="tok-kw">var</span> dbg_var_tag_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> has_tag_capture = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> capture_val_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> tag_scope: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">var</span> capture: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.html">ProngInfo</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.Capture.html">Capture</a> = .none;

        <span class="tok-kw">const</span> sub_scope = blk: {
            <span class="tok-kw">const</span> payload_token = case.payload_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk &amp;case_scope.base;
            <span class="tok-kw">const</span> ident = <span class="tok-kw">if</span> (token_tags[payload_token] == .asterisk)
                payload_token + <span class="tok-number">1</span>
            <span class="tok-kw">else</span>
                payload_token;

            <span class="tok-kw">const</span> is_ptr = ident != payload_token;
            capture = <span class="tok-kw">if</span> (is_ptr) .by_ref <span class="tok-kw">else</span> .by_val;

            <span class="tok-kw">const</span> ident_slice = tree.tokenSlice(ident);
            <span class="tok-kw">var</span> payload_sub_scope: *<a href="std.zig.AstGen.Scope.html">Scope</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_slice, <span class="tok-str">&quot;_&quot;</span>)) {
                <span class="tok-kw">if</span> (is_ptr) {
                    <span class="tok-kw">return</span> astgen.failTok(payload_token, <span class="tok-str">&quot;pointer modifier invalid on discard&quot;</span>, .{});
                }
                payload_sub_scope = &amp;case_scope.base;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> capture_name = <span class="tok-kw">try</span> astgen.identAsString(ident);
                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;case_scope.base, capture_name, ident, ident_slice, .capture);
                capture_val_scope = .{
                    .parent = &amp;case_scope.base,
                    .gen_zir = &amp;case_scope,
                    .name = capture_name,
                    .inst = switch_block.toRef(),
                    .token_src = ident,
                    .id_cat = .capture,
                };
                dbg_var_name = capture_name;
                dbg_var_inst = switch_block.toRef();
                payload_sub_scope = &amp;capture_val_scope.base;
            }

            <span class="tok-kw">const</span> tag_token = <span class="tok-kw">if</span> (token_tags[ident + <span class="tok-number">1</span>] == .comma)
                ident + <span class="tok-number">2</span>
            <span class="tok-kw">else</span>
                <span class="tok-kw">break</span> :blk payload_sub_scope;
            <span class="tok-kw">const</span> tag_slice = tree.tokenSlice(tag_token);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, tag_slice, <span class="tok-str">&quot;_&quot;</span>)) {
                <span class="tok-kw">try</span> astgen.appendErrorTok(tag_token, <span class="tok-str">&quot;discard of tag capture; omit it instead&quot;</span>, .{});
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case.inline_token == <span class="tok-null">null</span>) {
                <span class="tok-kw">return</span> astgen.failTok(tag_token, <span class="tok-str">&quot;tag capture on non-inline prong&quot;</span>, .{});
            }
            <span class="tok-kw">const</span> tag_name = <span class="tok-kw">try</span> astgen.identAsString(tag_token);
            <span class="tok-kw">try</span> astgen.detectLocalShadowing(payload_sub_scope, tag_name, tag_token, tag_slice, .@&quot;switch tag capture&quot;);

            <a href="std.debug.html#std.debug.assert">assert</a>(any_has_tag_capture);
            has_tag_capture = <span class="tok-null">true</span>;

            tag_scope = .{
                .parent = payload_sub_scope,
                .gen_zir = &amp;case_scope,
                .name = tag_name,
                .inst = tag_inst.toRef(),
                .token_src = tag_token,
                .id_cat = .@&quot;switch tag capture&quot;,
            };
            dbg_var_tag_name = tag_name;
            dbg_var_tag_inst = tag_inst.toRef();
            <span class="tok-kw">break</span> :blk &amp;tag_scope.base;
        };

        <span class="tok-kw">const</span> header_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(payloads.items.len);
        <span class="tok-kw">const</span> body_len_index = <span class="tok-kw">if</span> (is_multi_case) blk: {
            payloads.items[multi_case_table + multi_case_index] = header_index;
            multi_case_index += <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">3</span>);<span class="tok-comment"> // items_len, ranges_len, body_len

            // items
            </span><span class="tok-kw">var</span> items_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (case.ast.values) |item_node| {
                <span class="tok-kw">if</span> (node_tags[item_node] == .switch_range) <span class="tok-kw">continue</span>;
                items_len += <span class="tok-number">1</span>;

                <span class="tok-kw">const</span> item_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(parent_gz, scope, item_ri, item_node, .switch_item);
                <span class="tok-kw">try</span> payloads.append(gpa, <span class="tok-builtin">@intFromEnum</span>(item_inst));
            }<span class="tok-comment">

            // ranges
            </span><span class="tok-kw">var</span> ranges_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (case.ast.values) |range| {
                <span class="tok-kw">if</span> (node_tags[range] != .switch_range) <span class="tok-kw">continue</span>;
                ranges_len += <span class="tok-number">1</span>;

                <span class="tok-kw">const</span> first = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(parent_gz, scope, item_ri, node_datas[range].lhs, .switch_item);
                <span class="tok-kw">const</span> last = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(parent_gz, scope, item_ri, node_datas[range].rhs, .switch_item);
                <span class="tok-kw">try</span> payloads.appendSlice(gpa, &amp;[_]<span class="tok-type">u32</span>{
                    <span class="tok-builtin">@intFromEnum</span>(first), <span class="tok-builtin">@intFromEnum</span>(last),
                });
            }

            payloads.items[header_index] = items_len;
            payloads.items[header_index + <span class="tok-number">1</span>] = ranges_len;
            <span class="tok-kw">break</span> :blk header_index + <span class="tok-number">2</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case_node == special_node) blk: {
            payloads.items[case_table_start] = header_index;
            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">1</span>);<span class="tok-comment"> // body_len
            </span><span class="tok-kw">break</span> :blk header_index;
        } <span class="tok-kw">else</span> blk: {
            payloads.items[scalar_case_table + scalar_case_index] = header_index;
            scalar_case_index += <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">2</span>);<span class="tok-comment"> // item, body_len
            </span><span class="tok-kw">const</span> item_node = case.ast.values[<span class="tok-number">0</span>];
            <span class="tok-kw">const</span> item_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(parent_gz, scope, item_ri, item_node, .switch_item);
            payloads.items[header_index] = <span class="tok-builtin">@intFromEnum</span>(item_inst);
            <span class="tok-kw">break</span> :blk header_index + <span class="tok-number">1</span>;
        };

        {<span class="tok-comment">
            // temporarily stack case_scope on parent_gz
            </span>case_scope.instructions_top = parent_gz.instructions.items.len;
            <span class="tok-kw">defer</span> case_scope.unstack();

            <span class="tok-kw">if</span> (dbg_var_name != .empty) {
                <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, dbg_var_name, dbg_var_inst);
            }
            <span class="tok-kw">if</span> (dbg_var_tag_name != .empty) {
                <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, dbg_var_tag_name, dbg_var_tag_inst);
            }
            <span class="tok-kw">const</span> target_expr_node = case.ast.target_expr;
            <span class="tok-kw">const</span> case_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;case_scope, sub_scope, block_scope.break_result_info, target_expr_node, .allow_branch_hint);
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.checkUsed">checkUsed</a>(parent_gz, &amp;case_scope.base, sub_scope);
            <span class="tok-kw">if</span> (!parent_gz.refIsNoReturn(case_result)) {
                _ = <span class="tok-kw">try</span> case_scope.addBreakWithSrcNode(.@&quot;break&quot;, switch_block, case_result, target_expr_node);
            }

            <span class="tok-kw">const</span> case_slice = case_scope.instructionsSlice();
            <span class="tok-kw">const</span> extra_insts: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-kw">if</span> (has_tag_capture) &amp;.{ switch_block, tag_inst } <span class="tok-kw">else</span> &amp;.{switch_block};
            <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixupsExtraRefs(case_slice, extra_insts);
            <span class="tok-kw">try</span> payloads.ensureUnusedCapacity(gpa, body_len);
            payloads.items[body_len_index] = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.html">ProngInfo</a>{
                .body_len = <span class="tok-builtin">@intCast</span>(body_len),
                .capture = capture,
                .is_inline = case.inline_token != <span class="tok-null">null</span>,
                .has_tag_capture = has_tag_capture,
            });
            <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsExtraRefsArrayList">appendBodyWithFixupsExtraRefsArrayList</a>(astgen, payloads, case_slice, extra_insts);
        }
    }

    <span class="tok-kw">if</span> (switch_full.label_token) |label_token| <span class="tok-kw">if</span> (!block_scope.label.?.used) {
        <span class="tok-kw">try</span> astgen.appendErrorTok(label_token, <span class="tok-str">&quot;unused switch label&quot;</span>, .{});
    };<span class="tok-comment">

    // Now that the item expressions are generated we can add this.
    </span><span class="tok-kw">try</span> parent_gz.instructions.append(gpa, switch_block);

    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>).@&quot;struct&quot;.fields.len +
        <span class="tok-builtin">@intFromBool</span>(multi_cases_len != <span class="tok-number">0</span>) +
        <span class="tok-builtin">@intFromBool</span>(any_has_tag_capture) +
        payloads.items.len - case_table_end +
        (case_table_end - case_table_start) * <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.As.html">As</a>).@&quot;struct&quot;.fields.len);

    <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>{
        .operand = raw_operand,
        .bits = <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.Bits.html">Bits</a>{
            .has_multi_cases = multi_cases_len != <span class="tok-number">0</span>,
            .has_else = special_prong == .@&quot;else&quot;,
            .has_under = special_prong == .under,
            .any_has_tag_capture = any_has_tag_capture,
            .any_non_inline_capture = any_non_inline_capture,
            .has_continue = switch_full.label_token != <span class="tok-null">null</span> <span class="tok-kw">and</span> block_scope.label.?.used_for_continue,
            .scalar_cases_len = <span class="tok-builtin">@intCast</span>(scalar_cases_len),
        },
    });

    <span class="tok-kw">if</span> (multi_cases_len != <span class="tok-number">0</span>) {
        astgen.extra.appendAssumeCapacity(multi_cases_len);
    }

    <span class="tok-kw">if</span> (any_has_tag_capture) {
        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(tag_inst));
    }

    <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
    zir_datas[<span class="tok-builtin">@intFromEnum</span>(switch_block)].pl_node.payload_index = payload_index;

    <span class="tok-kw">for</span> (payloads.items[case_table_start..case_table_end], <span class="tok-number">0</span>..) |start_index, i| {
        <span class="tok-kw">var</span> body_len_index = start_index;
        <span class="tok-kw">var</span> end_index = start_index;
        <span class="tok-kw">const</span> table_index = case_table_start + i;
        <span class="tok-kw">if</span> (table_index &lt; scalar_case_table) {
            end_index += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (table_index &lt; multi_case_table) {
            body_len_index += <span class="tok-number">1</span>;
            end_index += <span class="tok-number">2</span>;
        } <span class="tok-kw">else</span> {
            body_len_index += <span class="tok-number">2</span>;
            <span class="tok-kw">const</span> items_len = payloads.items[start_index];
            <span class="tok-kw">const</span> ranges_len = payloads.items[start_index + <span class="tok-number">1</span>];
            end_index += <span class="tok-number">3</span> + items_len + <span class="tok-number">2</span> * ranges_len;
        }
        <span class="tok-kw">const</span> prong_info: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.SwitchBlock.html">SwitchBlock</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.html">ProngInfo</a> = <span class="tok-builtin">@bitCast</span>(payloads.items[body_len_index]);
        end_index += prong_info.body_len;
        astgen.extra.appendSliceAssumeCapacity(payloads.items[start_index..end_index]);
    }

    <span class="tok-kw">if</span> (need_result_rvalue) {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(parent_gz, ri, switch_block.toRef(), node);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> switch_block.toRef();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">ret</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);

    <span class="tok-kw">if</span> (astgen.fn_block == <span class="tok-null">null</span>) {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'return' outside function scope&quot;</span>, .{});
    }

    <span class="tok-kw">if</span> (gz.any_defer_node != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot return from defer expression&quot;</span>, .{}, &amp;.{
            <span class="tok-kw">try</span> astgen.errNoteNode(
                gz.any_defer_node,
                <span class="tok-str">&quot;defer expression here&quot;</span>,
                .{},
            ),
        });
    }<span class="tok-comment">

    // Ensure debug line/column information is emitted for this return expression.
    // Then we will save the line/column so that we can emit another one that goes
    // &quot;backwards&quot; because we want to evaluate the operand, but then put the debug
    // info back at the return keyword for error return tracing.
    </span><span class="tok-kw">if</span> (!gz.is_comptime) {
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, node);
    }
    <span class="tok-kw">const</span> ret_lc: <a href="std.zig.AstGen.LineColumn.html">LineColumn</a> = .{ astgen.source_line - gz.decl_line, astgen.source_column };

    <span class="tok-kw">const</span> defer_outer = &amp;astgen.fn_block.?.base;

    <span class="tok-kw">const</span> operand_node = node_datas[node].lhs;
    <span class="tok-kw">if</span> (operand_node == <span class="tok-number">0</span>) {<span class="tok-comment">
        // Returning a void value; skip error defers.
        </span><span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(gz, defer_outer, scope, .normal_only);<span class="tok-comment">

        // As our last action before the return, &quot;pop&quot; the error trace if needed
        </span>_ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.ret, .always, node);

        _ = <span class="tok-kw">try</span> gz.addUnNode(.ret_node, .void_value, node);
        <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
    }

    <span class="tok-kw">if</span> (node_tags[operand_node] == .error_value) {<span class="tok-comment">
        // Hot path for `return error.Foo`. This bypasses result location logic as well as logic
        // for detecting whether to add something to the function's inferred error set.
        </span><span class="tok-kw">const</span> ident_token = node_datas[operand_node].rhs;
        <span class="tok-kw">const</span> err_name_str_index = <span class="tok-kw">try</span> astgen.identAsString(ident_token);
        <span class="tok-kw">const</span> defer_counts = <a href="std.zig.AstGen.html#std.zig.AstGen.countDefers">countDefers</a>(defer_outer, scope);
        <span class="tok-kw">if</span> (!defer_counts.need_err_code) {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(gz, defer_outer, scope, .both_sans_err);
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, ret_lc);
            _ = <span class="tok-kw">try</span> gz.addStrTok(.ret_err_value, err_name_str_index, ident_token);
            <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
        }
        <span class="tok-kw">const</span> err_code = <span class="tok-kw">try</span> gz.addStrTok(.ret_err_value_code, err_name_str_index, ident_token);
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(gz, defer_outer, scope, .{ .both = err_code });
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, ret_lc);
        _ = <span class="tok-kw">try</span> gz.addUnNode(.ret_node, err_code, node);
        <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
    }

    <span class="tok-kw">const</span> ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-kw">if</span> (astgen.nodes_need_rl.contains(node)) .{
        .rl = .{ .ptr = .{ .inst = <span class="tok-kw">try</span> gz.addNode(.ret_ptr, node) } },
        .ctx = .@&quot;return&quot;,
    } <span class="tok-kw">else</span> .{
        .rl = .{ .coerced_ty = astgen.fn_ret_ty },
        .ctx = .@&quot;return&quot;,
    };
    <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;
    gz.anon_name_strategy = .func;
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(gz, scope, ri, operand_node, node);
    gz.anon_name_strategy = prev_anon_name_strategy;

    <span class="tok-kw">switch</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.nodeMayEvalToError">nodeMayEvalToError</a>(tree, operand_node)) {
        .never =&gt; {<span class="tok-comment">
            // Returning a value that cannot be an error; skip error defers.
            </span><span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(gz, defer_outer, scope, .normal_only);<span class="tok-comment">

            // As our last action before the return, &quot;pop&quot; the error trace if needed
            </span>_ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.ret, .always, node);

            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, ret_lc);
            <span class="tok-kw">try</span> gz.addRet(ri, operand, node);
            <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
        },
        .always =&gt; {<span class="tok-comment">
            // Value is always an error. Emit both error defers and regular defers.
            </span><span class="tok-kw">const</span> err_code = <span class="tok-kw">if</span> (ri.rl == .ptr) <span class="tok-kw">try</span> gz.addUnNode(.load, ri.rl.ptr.inst, node) <span class="tok-kw">else</span> operand;
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(gz, defer_outer, scope, .{ .both = err_code });
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, ret_lc);
            <span class="tok-kw">try</span> gz.addRet(ri, operand, node);
            <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
        },
        .maybe =&gt; {
            <span class="tok-kw">const</span> defer_counts = <a href="std.zig.AstGen.html#std.zig.AstGen.countDefers">countDefers</a>(defer_outer, scope);
            <span class="tok-kw">if</span> (!defer_counts.have_err) {<span class="tok-comment">
                // Only regular defers; no branch needed.
                </span><span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(gz, defer_outer, scope, .normal_only);
                <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, ret_lc);<span class="tok-comment">

                // As our last action before the return, &quot;pop&quot; the error trace if needed
                </span><span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (ri.rl == .ptr) <span class="tok-kw">try</span> gz.addUnNode(.load, ri.rl.ptr.inst, node) <span class="tok-kw">else</span> operand;
                _ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.ret, .{ .if_non_error = result }, node);

                <span class="tok-kw">try</span> gz.addRet(ri, operand, node);
                <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
            }<span class="tok-comment">

            // Emit conditional branch for generating errdefers.
            </span><span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (ri.rl == .ptr) <span class="tok-kw">try</span> gz.addUnNode(.load, ri.rl.ptr.inst, node) <span class="tok-kw">else</span> operand;
            <span class="tok-kw">const</span> is_non_err = <span class="tok-kw">try</span> gz.addUnNode(.ret_is_non_err, result, node);
            <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> gz.addCondBr(.condbr, node);

            <span class="tok-kw">var</span> then_scope = gz.makeSubBlock(scope);
            <span class="tok-kw">defer</span> then_scope.unstack();

            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(&amp;then_scope, defer_outer, scope, .normal_only);<span class="tok-comment">

            // As our last action before the return, &quot;pop&quot; the error trace if needed
            </span>_ = <span class="tok-kw">try</span> then_scope.addRestoreErrRetIndex(.ret, .always, node);

            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(&amp;then_scope, ret_lc);
            <span class="tok-kw">try</span> then_scope.addRet(ri, operand, node);

            <span class="tok-kw">var</span> else_scope = gz.makeSubBlock(scope);
            <span class="tok-kw">defer</span> else_scope.unstack();

            <span class="tok-kw">const</span> which_ones: <a href="std.zig.AstGen.DefersToEmit.html">DefersToEmit</a> = <span class="tok-kw">if</span> (!defer_counts.need_err_code) .both_sans_err <span class="tok-kw">else</span> .{
                .both = <span class="tok-kw">try</span> else_scope.addUnNode(.err_union_code, result, node),
            };
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.genDefers">genDefers</a>(&amp;else_scope, defer_outer, scope, which_ones);
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(&amp;else_scope, ret_lc);
            <span class="tok-kw">try</span> else_scope.addRet(ri, operand, node);

            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setCondBrPayload">setCondBrPayload</a>(condbr, is_non_err, &amp;then_scope, &amp;else_scope);

            <span class="tok-kw">return</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">unreachable_value</a>;
        },
    }
}

<span class="tok-comment">/// Parses the string `buf` as a base 10 integer of type `u16`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Unlike std.fmt.parseInt, does not allow the '_' character in `buf`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">parseBitCount</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a>!<span class="tok-type">u16</span> {
    <span class="tok-kw">if</span> (buf.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;

    <span class="tok-kw">var</span> x: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (buf) |c| {
        <span class="tok-kw">const</span> digit = <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; c - <span class="tok-str">'0'</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter,
        };

        <span class="tok-kw">if</span> (x != <span class="tok-number">0</span>) x = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">u16</span>, x, <span class="tok-number">10</span>);
        x = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">u16</span>, x, digit);
    }

    <span class="tok-kw">return</span> x;
}

<span class="tok-kw">const</span> ComptimeBlockInfo = <span class="tok-kw">struct</span> {
    src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    reason: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.SimpleComptimeReason.html">SimpleComptimeReason</a>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">identifier</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    ident: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    force_comptime: ?<a href="std.zig.AstGen.ComptimeBlockInfo.html">ComptimeBlockInfo</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);

    <span class="tok-kw">const</span> ident_token = main_tokens[ident];
    <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(ident_token);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ident_name_raw, <span class="tok-str">&quot;_&quot;</span>)) {
        <span class="tok-kw">return</span> astgen.failNode(ident, <span class="tok-str">&quot;'_' used as an identifier without @\&quot;_\&quot; syntax&quot;</span>, .{});
    }<span class="tok-comment">

    // if not @&quot;&quot; syntax, just use raw token slice
    </span><span class="tok-kw">if</span> (ident_name_raw[<span class="tok-number">0</span>] != <span class="tok-str">'@'</span>) {
        <span class="tok-kw">if</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.primitive_instrs">primitive_instrs</a>.<a href="#">get</a>(ident_name_raw)) |zir_const_ref| {
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, zir_const_ref, ident);
        }

        <span class="tok-kw">if</span> (ident_name_raw.len &gt;= <span class="tok-number">2</span>) integer: {<span class="tok-comment">
            // Keep in sync with logic in `comptimeExpr2`.
            </span><span class="tok-kw">const</span> first_c = ident_name_raw[<span class="tok-number">0</span>];
            <span class="tok-kw">if</span> (first_c == <span class="tok-str">'i'</span> <span class="tok-kw">or</span> first_c == <span class="tok-str">'u'</span>) {
                <span class="tok-kw">const</span> signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a> = <span class="tok-kw">switch</span> (first_c == <span class="tok-str">'i'</span>) {
                    <span class="tok-null">true</span> =&gt; .signed,
                    <span class="tok-null">false</span> =&gt; .unsigned,
                };
                <span class="tok-kw">if</span> (ident_name_raw.len &gt;= <span class="tok-number">3</span> <span class="tok-kw">and</span> ident_name_raw[<span class="tok-number">1</span>] == <span class="tok-str">'0'</span>) {
                    <span class="tok-kw">return</span> astgen.failNode(
                        ident,
                        <span class="tok-str">&quot;primitive integer type '{s}' has leading zero&quot;</span>,
                        .{ident_name_raw},
                    );
                }
                <span class="tok-kw">const</span> bit_count = <a href="std.zig.AstGen.html#std.zig.AstGen.parseBitCount">parseBitCount</a>(ident_name_raw[<span class="tok-number">1</span>..]) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> astgen.failNode(
                        ident,
                        <span class="tok-str">&quot;primitive integer type '{s}' exceeds maximum bit width of 65535&quot;</span>,
                        .{ident_name_raw},
                    ),
                    <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">break</span> :integer,
                };
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.add(.{
                    .tag = .int_type,
                    .data = .{ .int_type = .{
                        .src_node = gz.nodeIndexToRelative(ident),
                        .signedness = signedness,
                        .bit_count = bit_count,
                    } },
                });
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, ident);
            }
        }
    }<span class="tok-comment">

    // Local variables, including function parameters, and container-level declarations.

    </span><span class="tok-kw">if</span> (force_comptime) |fc| {<span class="tok-comment">
        // Mirrors the logic at the end of `comptimeExpr2`.
        </span><span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_comptime, fc.src_node);

        <span class="tok-kw">var</span> comptime_gz = gz.makeSubBlock(scope);
        comptime_gz.is_comptime = <span class="tok-null">true</span>;
        <span class="tok-kw">defer</span> comptime_gz.unstack();

        <span class="tok-kw">const</span> sub_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = .{
            .ctx = ri.ctx,
            .rl = .none,<span class="tok-comment"> // no point providing a result type, it won't change anything
        </span>};
        <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.localVarRef">localVarRef</a>(&amp;comptime_gz, scope, sub_ri, ident, ident_token);
        <a href="std.debug.html#std.debug.assert">assert</a>(!comptime_gz.endsWithNoReturn());
        _ = <span class="tok-kw">try</span> comptime_gz.addBreak(.break_inline, block_inst, block_result);

        <span class="tok-kw">try</span> comptime_gz.setBlockComptimeBody(block_inst, fc.reason);
        <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, block_inst);

        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, block_inst.toRef(), fc.src_node);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.localVarRef">localVarRef</a>(gz, scope, ri, ident, ident_token);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">localVarRef</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    ident: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ident_token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> name_str_index = <span class="tok-kw">try</span> astgen.identAsString(ident_token);
    <span class="tok-kw">var</span> s = scope;
    <span class="tok-kw">var</span> found_already: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-null">null</span>;<span class="tok-comment"> // we have found a decl with the same name already
    </span><span class="tok-kw">var</span> found_needs_tunnel: <span class="tok-type">bool</span> = <span class="tok-null">undefined</span>;<span class="tok-comment"> // defined when `found_already != null`
    </span><span class="tok-kw">var</span> found_namespaces_out: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;<span class="tok-comment"> // defined when `found_already != null`

    // The number of namespaces above `gz` we currently are
    </span><span class="tok-kw">var</span> num_namespaces_out: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;<span class="tok-comment">
    // defined by `num_namespaces_out != 0`
    </span><span class="tok-kw">var</span> capturing_namespace: *<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {
        .local_val =&gt; {
            <span class="tok-kw">const</span> local_val = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?;

            <span class="tok-kw">if</span> (local_val.name == name_str_index) {<span class="tok-comment">
                // Locals cannot shadow anything, so we do not need to look for ambiguous
                // references in this case.
                </span><span class="tok-kw">if</span> (ri.rl == .discard <span class="tok-kw">and</span> ri.ctx == .assignment) {
                    local_val.discarded = ident_token;
                } <span class="tok-kw">else</span> {
                    local_val.used = ident_token;
                }

                <span class="tok-kw">if</span> (local_val.is_used_or_discarded) |ptr| ptr.* = <span class="tok-null">true</span>;

                <span class="tok-kw">const</span> value_inst = <span class="tok-kw">if</span> (num_namespaces_out != <span class="tok-number">0</span>) <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.tunnelThroughClosure">tunnelThroughClosure</a>(
                    gz,
                    ident,
                    num_namespaces_out,
                    .{ .ref = local_val.inst },
                    .{ .token = local_val.token_src },
                    name_str_index,
                ) <span class="tok-kw">else</span> local_val.inst;

                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalueNoCoercePreRef">rvalueNoCoercePreRef</a>(gz, ri, value_inst, ident);
            }
            s = local_val.parent;
        },
        .local_ptr =&gt; {
            <span class="tok-kw">const</span> local_ptr = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?;
            <span class="tok-kw">if</span> (local_ptr.name == name_str_index) {
                <span class="tok-kw">if</span> (ri.rl == .discard <span class="tok-kw">and</span> ri.ctx == .assignment) {
                    local_ptr.discarded = ident_token;
                } <span class="tok-kw">else</span> {
                    local_ptr.used = ident_token;
                }<span class="tok-comment">

                // Can't close over a runtime variable
                </span><span class="tok-kw">if</span> (num_namespaces_out != <span class="tok-number">0</span> <span class="tok-kw">and</span> !local_ptr.maybe_comptime <span class="tok-kw">and</span> !gz.is_typeof) {
                    <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identifierTokenString(ident_token);
                    <span class="tok-kw">return</span> astgen.failNodeNotes(ident, <span class="tok-str">&quot;mutable '{s}' not accessible from here&quot;</span>, .{ident_name}, &amp;.{
                        <span class="tok-kw">try</span> astgen.errNoteTok(local_ptr.token_src, <span class="tok-str">&quot;declared mutable here&quot;</span>, .{}),
                        <span class="tok-kw">try</span> astgen.errNoteNode(capturing_namespace.node, <span class="tok-str">&quot;crosses namespace boundary here&quot;</span>, .{}),
                    });
                }

                <span class="tok-kw">switch</span> (ri.rl) {
                    .ref, .ref_coerced_ty =&gt; {
                        <span class="tok-kw">const</span> ptr_inst = <span class="tok-kw">if</span> (num_namespaces_out != <span class="tok-number">0</span>) <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.tunnelThroughClosure">tunnelThroughClosure</a>(
                            gz,
                            ident,
                            num_namespaces_out,
                            .{ .ref = local_ptr.ptr },
                            .{ .token = local_ptr.token_src },
                            name_str_index,
                        ) <span class="tok-kw">else</span> local_ptr.ptr;
                        local_ptr.used_as_lvalue = <span class="tok-null">true</span>;
                        <span class="tok-kw">return</span> ptr_inst;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">const</span> val_inst = <span class="tok-kw">if</span> (num_namespaces_out != <span class="tok-number">0</span>) <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.tunnelThroughClosure">tunnelThroughClosure</a>(
                            gz,
                            ident,
                            num_namespaces_out,
                            .{ .ref_load = local_ptr.ptr },
                            .{ .token = local_ptr.token_src },
                            name_str_index,
                        ) <span class="tok-kw">else</span> <span class="tok-kw">try</span> gz.addUnNode(.load, local_ptr.ptr, ident);
                        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalueNoCoercePreRef">rvalueNoCoercePreRef</a>(gz, ri, val_inst, ident);
                    },
                }
            }
            s = local_ptr.parent;
        },
        .gen_zir =&gt; s = s.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?.parent,
        .defer_normal, .defer_error =&gt; s = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
        .namespace =&gt; {
            <span class="tok-kw">const</span> ns = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>).?;
            <span class="tok-kw">if</span> (ns.decls.get(name_str_index)) |i| {
                <span class="tok-kw">if</span> (found_already) |f| {
                    <span class="tok-kw">return</span> astgen.failNodeNotes(ident, <span class="tok-str">&quot;ambiguous reference&quot;</span>, .{}, &amp;.{
                        <span class="tok-kw">try</span> astgen.errNoteNode(f, <span class="tok-str">&quot;declared here&quot;</span>, .{}),
                        <span class="tok-kw">try</span> astgen.errNoteNode(i, <span class="tok-str">&quot;also declared here&quot;</span>, .{}),
                    });
                }<span class="tok-comment">
                // We found a match but must continue looking for ambiguous references to decls.
                </span>found_already = i;
                found_needs_tunnel = ns.maybe_generic;
                found_namespaces_out = num_namespaces_out;
            }
            num_namespaces_out += <span class="tok-number">1</span>;
            capturing_namespace = ns;
            s = ns.parent;
        },
        .top =&gt; <span class="tok-kw">break</span>,
    };
    <span class="tok-kw">if</span> (found_already == <span class="tok-null">null</span>) {
        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identifierTokenString(ident_token);
        <span class="tok-kw">return</span> astgen.failNode(ident, <span class="tok-str">&quot;use of undeclared identifier '{s}'&quot;</span>, .{ident_name});
    }<span class="tok-comment">

    // Decl references happen by name rather than ZIR index so that when unrelated
    // decls are modified, ZIR code containing references to them can be unmodified.

    </span><span class="tok-kw">if</span> (found_namespaces_out &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> found_needs_tunnel) {
        <span class="tok-kw">switch</span> (ri.rl) {
            .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.tunnelThroughClosure">tunnelThroughClosure</a>(
                gz,
                ident,
                found_namespaces_out,
                .{ .decl_ref = name_str_index },
                .{ .node = found_already.? },
                name_str_index,
            ),
            <span class="tok-kw">else</span> =&gt; {
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.tunnelThroughClosure">tunnelThroughClosure</a>(
                    gz,
                    ident,
                    found_namespaces_out,
                    .{ .decl_val = name_str_index },
                    .{ .node = found_already.? },
                    name_str_index,
                );
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalueNoCoercePreRef">rvalueNoCoercePreRef</a>(gz, ri, result, ident);
            },
        }
    }

    <span class="tok-kw">switch</span> (ri.rl) {
        .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> gz.addStrTok(.decl_ref, name_str_index, ident_token),
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addStrTok(.decl_val, name_str_index, ident_token);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalueNoCoercePreRef">rvalueNoCoercePreRef</a>(gz, ri, result, ident);
        },
    }
}

<span class="tok-comment">/// Access a ZIR instruction through closure. May tunnel through arbitrarily</span>
<span class="tok-comment">/// many namespaces, adding closure captures as required.</span>
<span class="tok-comment">/// Returns the index of the `closure_get` instruction added to `gz`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">tunnelThroughClosure</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    <span class="tok-comment">/// The node which references the value to be captured.</span>
    inner_ref_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-comment">/// The number of namespaces being tunnelled through. At least 1.</span>
    num_tunnels: <span class="tok-type">u32</span>,
    <span class="tok-comment">/// The value being captured.</span>
    value: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        ref_load: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        decl_val: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
        decl_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    },
    <span class="tok-comment">/// The location of the value's declaration.</span>
    decl_src: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    },
    name_str_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">switch</span> (value) {
        .ref =&gt; |v| <span class="tok-kw">if</span> (v.toIndex() == <span class="tok-null">null</span>) <span class="tok-kw">return</span> v,<span class="tok-comment"> // trivial value; do not need tunnel
        </span>.ref_load =&gt; |v| <a href="std.debug.html#std.debug.assert">assert</a>(v.toIndex() != <span class="tok-null">null</span>),<span class="tok-comment"> // there are no constant pointer refs
        </span>.decl_val, .decl_ref =&gt; {},
    }

    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;<span class="tok-comment">

    // Otherwise we need a tunnel. First, figure out the path of namespaces we
    // are tunneling through. This is usually only going to be one or two, so
    // use an SFBA to optimize for the common case.
    </span><span class="tok-kw">var</span> sfba = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>, astgen.arena);
    <span class="tok-kw">var</span> intermediate_tunnels = <span class="tok-kw">try</span> sfba.get().alloc(*<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>, num_tunnels - <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> root_ns = ns: {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = num_tunnels - <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> scope: *<a href="std.zig.AstGen.Scope.html">Scope</a> = gz.parent;
        <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>)) |mid_ns| {
                i -= <span class="tok-number">1</span>;
                intermediate_tunnels[i] = mid_ns;
            }
            scope = scope.parent().?;
        }
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">if</span> (scope.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>)) |ns| <span class="tok-kw">break</span> :ns ns;
            scope = scope.parent().?;
        }
    };<span class="tok-comment">

    // Now that we know the scopes we're tunneling through, begin adding
    // captures as required, starting with the outermost namespace.
    </span><span class="tok-kw">const</span> root_capture: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Capture.html">Capture</a> = .wrap(<span class="tok-kw">switch</span> (value) {
        .ref =&gt; |v| .{ .instruction = v.toIndex().? },
        .ref_load =&gt; |v| .{ .instruction_load = v.toIndex().? },
        .decl_val =&gt; |str| .{ .decl_val = str },
        .decl_ref =&gt; |str| .{ .decl_ref = str },
    });

    <span class="tok-kw">const</span> root_gop = <span class="tok-kw">try</span> root_ns.captures.getOrPut(gpa, root_capture);
    root_gop.value_ptr.* = name_str_index;
    <span class="tok-kw">var</span> cur_capture_index = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u16</span>, root_gop.index) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> astgen.failNodeNotes(
        root_ns.node,
        <span class="tok-str">&quot;this compiler implementation only supports up to 65536 captures per namespace&quot;</span>,
        .{},
        &amp;.{
            <span class="tok-kw">switch</span> (decl_src) {
                .token =&gt; |t| <span class="tok-kw">try</span> astgen.errNoteTok(t, <span class="tok-str">&quot;captured value here&quot;</span>, .{}),
                .node =&gt; |n| <span class="tok-kw">try</span> astgen.errNoteNode(n, <span class="tok-str">&quot;captured value here&quot;</span>, .{}),
            },
            <span class="tok-kw">try</span> astgen.errNoteNode(inner_ref_node, <span class="tok-str">&quot;value used here&quot;</span>, .{}),
        },
    );

    <span class="tok-kw">for</span> (intermediate_tunnels) |tunnel_ns| {
        <span class="tok-kw">const</span> tunnel_gop = <span class="tok-kw">try</span> tunnel_ns.captures.getOrPut(gpa, .wrap(.{ .nested = cur_capture_index }));
        tunnel_gop.value_ptr.* = name_str_index;
        cur_capture_index = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u16</span>, tunnel_gop.index) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> astgen.failNodeNotes(
            tunnel_ns.node,
            <span class="tok-str">&quot;this compiler implementation only supports up to 65536 captures per namespace&quot;</span>,
            .{},
            &amp;.{
                <span class="tok-kw">switch</span> (decl_src) {
                    .token =&gt; |t| <span class="tok-kw">try</span> astgen.errNoteTok(t, <span class="tok-str">&quot;captured value here&quot;</span>, .{}),
                    .node =&gt; |n| <span class="tok-kw">try</span> astgen.errNoteNode(n, <span class="tok-str">&quot;captured value here&quot;</span>, .{}),
                },
                <span class="tok-kw">try</span> astgen.errNoteNode(inner_ref_node, <span class="tok-str">&quot;value used here&quot;</span>, .{}),
            },
        );
    }<span class="tok-comment">

    // Incorporate the capture index into the source hash, so that changes in
    // the order of captures cause suitable re-analysis.
    </span>astgen.src_hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;cur_capture_index));<span class="tok-comment">

    // Add an instruction to get the value from the closure.
    </span><span class="tok-kw">return</span> gz.addExtendedNodeSmall(.closure_get, inner_ref_node, cur_capture_index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">stringLiteral</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> str_lit_token = main_tokens[node];
    <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> astgen.strLitAsString(str_lit_token);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.add(.{
        .tag = .str,
        .data = .{ .str = .{
            .start = str.index,
            .len = str.len,
        } },
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">multilineStringLiteral</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> astgen.strLitNodeAsString(node);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.add(.{
        .tag = .str,
        .data = .{ .str = .{
            .start = str.index,
            .len = str.len,
        } },
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">charLiteral</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> main_token = main_tokens[node];
    <span class="tok-kw">const</span> slice = tree.tokenSlice(main_token);

    <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.string_literal.html#std.zig.string_literal.parseCharLiteral">parseCharLiteral</a>(slice)) {
        .success =&gt; |codepoint| {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addInt(codepoint);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .failure =&gt; |err| <span class="tok-kw">return</span> astgen.failWithStrLitError(err, main_token, slice, <span class="tok-number">0</span>),
    }
}

<span class="tok-kw">const</span> Sign = <span class="tok-kw">enum</span> { negative, positive };

<span class="tok-kw">fn</span> <span class="tok-fn">numberLiteral</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, source_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, sign: <a href="std.zig.AstGen.Sign.html">Sign</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> num_token = main_tokens[node];
    <span class="tok-kw">const</span> bytes = tree.tokenSlice(num_token);

    <span class="tok-kw">const</span> result: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.number_literal.html#std.zig.number_literal.parseNumberLiteral">parseNumberLiteral</a>(bytes)) {
        .int =&gt; |num| <span class="tok-kw">switch</span> (num) {
            <span class="tok-number">0</span> =&gt; <span class="tok-kw">if</span> (sign == .positive) .zero <span class="tok-kw">else</span> <span class="tok-kw">return</span> astgen.failTokNotes(
                num_token,
                <span class="tok-str">&quot;integer literal '-0' is ambiguous&quot;</span>,
                .{},
                &amp;.{
                    <span class="tok-kw">try</span> astgen.errNoteTok(num_token, <span class="tok-str">&quot;use '0' for an integer zero&quot;</span>, .{}),
                    <span class="tok-kw">try</span> astgen.errNoteTok(num_token, <span class="tok-str">&quot;use '-0.0' for a floating-point signed zero&quot;</span>, .{}),
                },
            ),
            <span class="tok-number">1</span> =&gt; {<span class="tok-comment">
                // Handle the negation here!
                </span><span class="tok-kw">const</span> result: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> = <span class="tok-kw">switch</span> (sign) {
                    .positive =&gt; .one,
                    .negative =&gt; .negative_one,
                };
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, source_node);
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> gz.addInt(num),
        },
        .big_int =&gt; |base| big: {
            <span class="tok-kw">const</span> gpa = astgen.gpa;
            <span class="tok-kw">var</span> big_int = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(gpa);
            <span class="tok-kw">defer</span> big_int.deinit();
            <span class="tok-kw">const</span> prefix_offset: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (base == .decimal) <span class="tok-number">0</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>;
            big_int.setString(<span class="tok-builtin">@intFromEnum</span>(base), bytes[prefix_offset..]) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // caught in `parseNumberLiteral`
                </span><span class="tok-kw">error</span>.InvalidBase =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // we only pass 16, 8, 2, see above
                </span><span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            };

            <span class="tok-kw">const</span> limbs = big_int.limbs[<span class="tok-number">0</span>..big_int.len()];
            <a href="std.debug.html#std.debug.assert">assert</a>(big_int.isPositive());
            <span class="tok-kw">break</span> :big <span class="tok-kw">try</span> gz.addIntBig(limbs);
        },
        .float =&gt; {
            <span class="tok-kw">const</span> unsigned_float_number = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.parse_float.html#std.fmt.parse_float.parseFloat">parseFloat</a>(<span class="tok-type">f128</span>, bytes) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // validated by tokenizer
            </span>};
            <span class="tok-kw">const</span> float_number = <span class="tok-kw">switch</span> (sign) {
                .negative =&gt; -unsigned_float_number,
                .positive =&gt; unsigned_float_number,
            };<span class="tok-comment">
            // If the value fits into a f64 without losing any precision, store it that way.
            </span><span class="tok-builtin">@setFloatMode</span>(.strict);
            <span class="tok-kw">const</span> smaller_float: <span class="tok-type">f64</span> = <span class="tok-builtin">@floatCast</span>(float_number);
            <span class="tok-kw">const</span> bigger_again: <span class="tok-type">f128</span> = smaller_float;
            <span class="tok-kw">if</span> (bigger_again == float_number) {
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addFloat(smaller_float);
                <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, source_node);
            }<span class="tok-comment">
            // We need to use 128 bits. Break the float into 4 u32 values so we can
            // put it into the `extra` array.
            </span><span class="tok-kw">const</span> int_bits: <span class="tok-type">u128</span> = <span class="tok-builtin">@bitCast</span>(float_number);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.float128, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Float128.html">Float128</a>{
                .piece0 = <span class="tok-builtin">@truncate</span>(int_bits),
                .piece1 = <span class="tok-builtin">@truncate</span>(int_bits &gt;&gt; <span class="tok-number">32</span>),
                .piece2 = <span class="tok-builtin">@truncate</span>(int_bits &gt;&gt; <span class="tok-number">64</span>),
                .piece3 = <span class="tok-builtin">@truncate</span>(int_bits &gt;&gt; <span class="tok-number">96</span>),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, source_node);
        },
        .failure =&gt; |err| <span class="tok-kw">return</span> astgen.failWithNumberError(err, num_token, bytes),
    };

    <span class="tok-kw">if</span> (sign == .positive) {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, source_node);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> negated = <span class="tok-kw">try</span> gz.addUnNode(.negate, result, source_node);
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, negated, source_node);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">failWithNumberError</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, err: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.number_literal.html">number_literal</a>.<a href="std.zig.number_literal.Error.html">Error</a>, token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a> {
    <span class="tok-kw">const</span> is_float = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, bytes, <span class="tok-str">'.'</span>) != <span class="tok-null">null</span>;
    <span class="tok-kw">switch</span> (err) {
        .leading_zero =&gt; <span class="tok-kw">if</span> (is_float) {
            <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;number '{s}' has leading zero&quot;</span>, .{bytes});
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> astgen.failTokNotes(token, <span class="tok-str">&quot;number '{s}' has leading zero&quot;</span>, .{bytes}, &amp;.{
                <span class="tok-kw">try</span> astgen.errNoteTok(token, <span class="tok-str">&quot;use '0o' prefix for octal literals&quot;</span>, .{}),
            });
        },
        .digit_after_base =&gt; <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;expected a digit after base prefix&quot;</span>, .{}),
        .upper_case_base =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;base prefix must be lowercase&quot;</span>, .{}),
        .invalid_float_base =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;invalid base for float literal&quot;</span>, .{}),
        .repeated_underscore =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;repeated digit separator&quot;</span>, .{}),
        .invalid_underscore_after_special =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;expected digit before digit separator&quot;</span>, .{}),
        .invalid_digit =&gt; |info| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(info.i), <span class="tok-str">&quot;invalid digit '{c}' for {s} base&quot;</span>, .{ bytes[info.i], <span class="tok-builtin">@tagName</span>(info.base) }),
        .invalid_digit_exponent =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;invalid digit '{c}' in exponent&quot;</span>, .{bytes[i]}),
        .duplicate_exponent =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;duplicate exponent&quot;</span>, .{}),
        .exponent_after_underscore =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;expected digit before exponent&quot;</span>, .{}),
        .special_after_underscore =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;expected digit before '{c}'&quot;</span>, .{bytes[i]}),
        .trailing_special =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;expected digit after '{c}'&quot;</span>, .{bytes[i - <span class="tok-number">1</span>]}),
        .trailing_underscore =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;trailing digit separator&quot;</span>, .{}),
        .duplicate_period =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Validated by tokenizer
        </span>.invalid_character =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Validated by tokenizer
        </span>.invalid_exponent_sign =&gt; |i| {
            <a href="std.debug.html#std.debug.assert">assert</a>(bytes.len &gt;= <span class="tok-number">2</span> <span class="tok-kw">and</span> bytes[<span class="tok-number">0</span>] == <span class="tok-str">'0'</span> <span class="tok-kw">and</span> bytes[<span class="tok-number">1</span>] == <span class="tok-str">'x'</span>);<span class="tok-comment"> // Validated by tokenizer
            </span><span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;sign '{c}' cannot follow digit '{c}' in hex base&quot;</span>, .{ bytes[i], bytes[i - <span class="tok-number">1</span>] });
        },
        .period_after_exponent =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;unexpected period after exponent&quot;</span>, .{}),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">asmExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    full: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">const</span> TagAndTmpl = <span class="tok-kw">struct</span> { tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>, tmpl: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> };
    <span class="tok-kw">const</span> tag_and_tmpl: TagAndTmpl = <span class="tok-kw">switch</span> (node_tags[full.ast.template]) {
        .string_literal =&gt; .{
            .tag = .@&quot;asm&quot;,
            .tmpl = (<span class="tok-kw">try</span> astgen.strLitAsString(main_tokens[full.ast.template])).index,
        },
        .multiline_string_literal =&gt; .{
            .tag = .@&quot;asm&quot;,
            .tmpl = (<span class="tok-kw">try</span> astgen.strLitNodeAsString(full.ast.template)).index,
        },
        <span class="tok-kw">else</span> =&gt; .{
            .tag = .asm_expr,
            .tmpl = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(<span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .none }, full.ast.template, .inline_assembly_code))),
        },
    };<span class="tok-comment">

    // See https://github.com/ziglang/zig/issues/215 and related issues discussing
    // possible inline assembly improvements. Until then here is status quo AstGen
    // for assembly syntax. It's used by std lib crypto aesni.zig.
    </span><span class="tok-kw">const</span> is_container_asm = astgen.fn_block == <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (is_container_asm) {
        <span class="tok-kw">if</span> (full.volatile_token) |t|
            <span class="tok-kw">return</span> astgen.failTok(t, <span class="tok-str">&quot;volatile is meaningless on global assembly&quot;</span>, .{});
        <span class="tok-kw">if</span> (full.outputs.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> full.inputs.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> full.first_clobber != <span class="tok-null">null</span>)
            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;global assembly cannot have inputs, outputs, or clobbers&quot;</span>, .{});
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">if</span> (full.outputs.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> full.volatile_token == <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;assembly expression with no output must be marked volatile&quot;</span>, .{});
        }
    }
    <span class="tok-kw">if</span> (full.outputs.len &gt; <span class="tok-number">32</span>) {
        <span class="tok-kw">return</span> astgen.failNode(full.outputs[<span class="tok-number">32</span>], <span class="tok-str">&quot;too many asm outputs&quot;</span>, .{});
    }
    <span class="tok-kw">var</span> outputs_buffer: [<span class="tok-number">32</span>]<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Asm.html">Asm</a>.<a href="std.zig.Zir.Inst.Asm.Output.html">Output</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> outputs = outputs_buffer[<span class="tok-number">0</span>..full.outputs.len];

    <span class="tok-kw">var</span> output_type_bits: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (full.outputs, <span class="tok-number">0</span>..) |output_node, i| {
        <span class="tok-kw">const</span> symbolic_name = main_tokens[output_node];
        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> astgen.identAsString(symbolic_name);
        <span class="tok-kw">const</span> constraint_token = symbolic_name + <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> constraint = (<span class="tok-kw">try</span> astgen.strLitAsString(constraint_token)).index;
        <span class="tok-kw">const</span> has_arrow = token_tags[symbolic_name + <span class="tok-number">4</span>] == .arrow;
        <span class="tok-kw">if</span> (has_arrow) {
            <span class="tok-kw">if</span> (output_type_bits != <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> astgen.failNode(output_node, <span class="tok-str">&quot;inline assembly allows up to one output value&quot;</span>, .{});
            }
            output_type_bits |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@intCast</span>(i);
            <span class="tok-kw">const</span> out_type_node = node_datas[output_node].lhs;
            <span class="tok-kw">const</span> out_type_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, out_type_node);
            outputs[i] = .{
                .name = name,
                .constraint = constraint,
                .operand = out_type_inst,
            };
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> ident_token = symbolic_name + <span class="tok-number">4</span>;<span class="tok-comment">
            // TODO have a look at #215 and related issues and decide how to
            // handle outputs. Do we want this to be identifiers?
            // Or maybe we want to force this to be expressions with a pointer type.
            </span>outputs[i] = .{
                .name = name,
                .constraint = constraint,
                .operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.localVarRef">localVarRef</a>(gz, scope, .{ .rl = .ref }, node, ident_token),
            };
        }
    }

    <span class="tok-kw">if</span> (full.inputs.len &gt; <span class="tok-number">32</span>) {
        <span class="tok-kw">return</span> astgen.failNode(full.inputs[<span class="tok-number">32</span>], <span class="tok-str">&quot;too many asm inputs&quot;</span>, .{});
    }
    <span class="tok-kw">var</span> inputs_buffer: [<span class="tok-number">32</span>]<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Asm.html">Asm</a>.<a href="std.zig.Zir.Inst.Asm.Input.html">Input</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> inputs = inputs_buffer[<span class="tok-number">0</span>..full.inputs.len];

    <span class="tok-kw">for</span> (full.inputs, <span class="tok-number">0</span>..) |input_node, i| {
        <span class="tok-kw">const</span> symbolic_name = main_tokens[input_node];
        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> astgen.identAsString(symbolic_name);
        <span class="tok-kw">const</span> constraint_token = symbolic_name + <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> constraint = (<span class="tok-kw">try</span> astgen.strLitAsString(constraint_token)).index;
        <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node_datas[input_node].lhs);
        inputs[i] = .{
            .name = name,
            .constraint = constraint,
            .operand = operand,
        };
    }

    <span class="tok-kw">var</span> clobbers_buffer: [<span class="tok-number">32</span>]<span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> clobber_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (full.first_clobber) |first_clobber| clobbers: {<span class="tok-comment">
        // asm (&quot;foo&quot; ::: &quot;a&quot;, &quot;b&quot;)
        // asm (&quot;foo&quot; ::: &quot;a&quot;, &quot;b&quot;,)
        </span><span class="tok-kw">var</span> tok_i = first_clobber;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (tok_i += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (clobber_i &gt;= clobbers_buffer.len) {
                <span class="tok-kw">return</span> astgen.failTok(tok_i, <span class="tok-str">&quot;too many asm clobbers&quot;</span>, .{});
            }
            clobbers_buffer[clobber_i] = <span class="tok-builtin">@intFromEnum</span>((<span class="tok-kw">try</span> astgen.strLitAsString(tok_i)).index);
            clobber_i += <span class="tok-number">1</span>;
            tok_i += <span class="tok-number">1</span>;
            <span class="tok-kw">switch</span> (token_tags[tok_i]) {
                .r_paren =&gt; <span class="tok-kw">break</span> :clobbers,
                .comma =&gt; {
                    <span class="tok-kw">if</span> (token_tags[tok_i + <span class="tok-number">1</span>] == .r_paren) {
                        <span class="tok-kw">break</span> :clobbers;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">continue</span>;
                    }
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            }
        }
    }

    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addAsm(.{
        .tag = tag_and_tmpl.tag,
        .node = node,
        .asm_source = tag_and_tmpl.tmpl,
        .is_volatile = full.volatile_token != <span class="tok-null">null</span>,
        .output_type_bits = output_type_bits,
        .outputs = outputs,
        .inputs = inputs,
        .clobbers = clobbers_buffer[<span class="tok-number">0</span>..clobber_i],
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">as</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    lhs: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    rhs: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> dest_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, lhs);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(gz, scope, .{ .rl = .{ .ty = dest_type } }, rhs, node);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">unionInit</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    params: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> union_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]);
    <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">1</span>], .union_field_name);
    <span class="tok-kw">const</span> field_type = <span class="tok-kw">try</span> gz.addPlNode(.field_type_ref, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldTypeRef.html">FieldTypeRef</a>{
        .container_type = union_type,
        .field_name = field_name,
    });
    <span class="tok-kw">const</span> init = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(gz, scope, .{ .rl = .{ .ty = field_type } }, params[<span class="tok-number">2</span>], node);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.union_init, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnionInit.html">UnionInit</a>{
        .union_type = union_type,
        .init = init,
        .field_name = field_name,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bitCast</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    operand_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> dest_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, <span class="tok-str">&quot;@bitCast&quot;</span>);
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(gz, scope, .{ .rl = .none }, operand_node, node);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.bitcast, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = dest_type,
        .rhs = operand,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-comment">/// Handle one or more nested pointer cast builtins:</span>
<span class="tok-comment">/// * @ptrCast</span>
<span class="tok-comment">/// * @alignCast</span>
<span class="tok-comment">/// * @addrSpaceCast</span>
<span class="tok-comment">/// * @constCast</span>
<span class="tok-comment">/// * @volatileCast</span>
<span class="tok-comment">/// Any sequence of such builtins is treated as a single operation. This allowed</span>
<span class="tok-comment">/// for sequences like `@ptrCast(@alignCast(ptr))` to work correctly despite the</span>
<span class="tok-comment">/// intermediate result type being unknown.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">ptrCast</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    root_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);

    <span class="tok-kw">const</span> FlagsInt = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FullPtrCastFlags.html">FullPtrCastFlags</a>).@&quot;struct&quot;.backing_integer.?;
    <span class="tok-kw">var</span> flags: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FullPtrCastFlags.html">FullPtrCastFlags</a> = .{};<span class="tok-comment">

    // Note that all pointer cast builtins have one parameter, so we only need
    // to handle `builtin_call_two`.
    </span><span class="tok-kw">var</span> node = root_node;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (node_tags[node]) {
            .builtin_call_two, .builtin_call_two_comma =&gt; {},
            .grouped_expression =&gt; {<span class="tok-comment">
                // Handle the chaining even with redundant parentheses
                </span>node = node_datas[node].lhs;
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
        }

        <span class="tok-kw">if</span> (node_datas[node].lhs == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;<span class="tok-comment"> // 0 args

        </span><span class="tok-kw">const</span> builtin_token = main_tokens[node];
        <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);
        <span class="tok-kw">const</span> info = <a href="std.zig.BuiltinFn.html">BuiltinFn</a>.<a href="std.zig.BuiltinFn.html#std.zig.BuiltinFn.list">list</a>.<a href="#">get</a>(builtin_name) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span>;
        <span class="tok-kw">if</span> (node_datas[node].rhs == <span class="tok-number">0</span>) {<span class="tok-comment">
            // 1 arg
            </span><span class="tok-kw">if</span> (info.param_count != <span class="tok-number">1</span>) <span class="tok-kw">break</span>;

            <span class="tok-kw">switch</span> (info.tag) {
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
                <span class="tok-kw">inline</span> .ptr_cast,
                .align_cast,
                .addrspace_cast,
                .const_cast,
                .volatile_cast,
                =&gt; |tag| {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(flags, <span class="tok-builtin">@tagName</span>(tag))) {
                        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;redundant {s}&quot;</span>, .{builtin_name});
                    }
                    <span class="tok-builtin">@field</span>(flags, <span class="tok-builtin">@tagName</span>(tag)) = <span class="tok-null">true</span>;
                },
            }

            node = node_datas[node].lhs;
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // 2 args
            </span><span class="tok-kw">if</span> (info.param_count != <span class="tok-number">2</span>) <span class="tok-kw">break</span>;

            <span class="tok-kw">switch</span> (info.tag) {
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
                .field_parent_ptr =&gt; {
                    <span class="tok-kw">if</span> (flags.ptr_cast) <span class="tok-kw">break</span>;

                    <span class="tok-kw">const</span> flags_int: FlagsInt = <span class="tok-builtin">@bitCast</span>(flags);
                    <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, root_node);
                    <span class="tok-kw">const</span> parent_ptr_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, root_node, <span class="tok-str">&quot;@alignCast&quot;</span>);
                    <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, node_datas[node].lhs, .field_name);
                    <span class="tok-kw">const</span> field_ptr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node_datas[node].rhs);
                    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
                    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayloadSmall(.field_parent_ptr, flags_int, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldParentPtr.html">FieldParentPtr</a>{
                        .src_node = gz.nodeIndexToRelative(node),
                        .parent_ptr_type = parent_ptr_type,
                        .field_name = field_name,
                        .field_ptr = field_ptr,
                    });
                    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, root_node);
                },
            }
        }
    }

    <span class="tok-kw">const</span> flags_int: FlagsInt = <span class="tok-builtin">@bitCast</span>(flags);
    <a href="std.debug.html#std.debug.assert">assert</a>(flags_int != <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> ptr_only: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FullPtrCastFlags.html">FullPtrCastFlags</a> = .{ .ptr_cast = <span class="tok-null">true</span> };
    <span class="tok-kw">if</span> (flags_int == <span class="tok-builtin">@as</span>(FlagsInt, <span class="tok-builtin">@bitCast</span>(ptr_only))) {<span class="tok-comment">
        // Special case: simpler representation
        </span><span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeCast">typeCast</a>(gz, scope, ri, root_node, node, .ptr_cast, <span class="tok-str">&quot;@ptrCast&quot;</span>);
    }

    <span class="tok-kw">const</span> no_result_ty_flags: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FullPtrCastFlags.html">FullPtrCastFlags</a> = .{
        .const_cast = <span class="tok-null">true</span>,
        .volatile_cast = <span class="tok-null">true</span>,
    };
    <span class="tok-kw">if</span> ((flags_int &amp; ~<span class="tok-builtin">@as</span>(FlagsInt, <span class="tok-builtin">@bitCast</span>(no_result_ty_flags))) == <span class="tok-number">0</span>) {<span class="tok-comment">
        // Result type not needed
        </span><span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, root_node);
        <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node);
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayloadSmall(.ptr_cast_no_dest, flags_int, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
            .node = gz.nodeIndexToRelative(root_node),
            .operand = operand,
        });
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, root_node);
    }<span class="tok-comment">

    // Full cast including result type

    </span><span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, root_node);
    <span class="tok-kw">const</span> result_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, root_node, flags.needResultTypeBuiltinName());
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node);
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayloadSmall(.ptr_cast_full, flags_int, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BinNode.html">BinNode</a>{
        .node = gz.nodeIndexToRelative(root_node),
        .lhs = result_type,
        .rhs = operand,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, root_node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    args: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">if</span> (args.len &lt; <span class="tok-number">1</span>) {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;expected at least 1 argument, found 0&quot;</span>, .{});
    }
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">if</span> (args.len == <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> typeof_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.typeof_builtin, node);

        <span class="tok-kw">var</span> typeof_scope = gz.makeSubBlock(scope);
        typeof_scope.is_comptime = <span class="tok-null">false</span>;
        typeof_scope.is_typeof = <span class="tok-null">true</span>;
        typeof_scope.c_import = <span class="tok-null">false</span>;
        <span class="tok-kw">defer</span> typeof_scope.unstack();

        <span class="tok-kw">const</span> ty_expr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(&amp;typeof_scope, &amp;typeof_scope.base, .{ .rl = .none }, args[<span class="tok-number">0</span>], node);
        <span class="tok-kw">if</span> (!gz.refIsNoReturn(ty_expr)) {
            _ = <span class="tok-kw">try</span> typeof_scope.addBreak(.break_inline, typeof_inst, ty_expr);
        }
        <span class="tok-kw">try</span> typeof_scope.setBlockBody(typeof_inst);<span class="tok-comment">

        // typeof_scope unstacked now, can add new instructions to gz
        </span><span class="tok-kw">try</span> gz.instructions.append(gpa, typeof_inst);
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, typeof_inst.toRef(), node);
    }
    <span class="tok-kw">const</span> payload_size: <span class="tok-type">u32</span> = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.TypeOfPeer.html">TypeOfPeer</a>).len;
    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(astgen, payload_size + args.len);
    <span class="tok-kw">const</span> args_index = payload_index + payload_size;

    <span class="tok-kw">const</span> typeof_inst = <span class="tok-kw">try</span> gz.addExtendedMultiOpPayloadIndex(.typeof_peer, payload_index, args.len);

    <span class="tok-kw">var</span> typeof_scope = gz.makeSubBlock(scope);
    typeof_scope.is_comptime = <span class="tok-null">false</span>;

    <span class="tok-kw">for</span> (args, <span class="tok-number">0</span>..) |arg, i| {
        <span class="tok-kw">const</span> param_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reachableExpr">reachableExpr</a>(&amp;typeof_scope, &amp;typeof_scope.base, .{ .rl = .none }, arg, node);
        astgen.extra.items[args_index + i] = <span class="tok-builtin">@intFromEnum</span>(param_ref);
    }
    _ = <span class="tok-kw">try</span> typeof_scope.addBreak(.break_inline, typeof_inst.toIndex().?, .void_value);

    <span class="tok-kw">const</span> body = typeof_scope.instructionsSlice();
    <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);
    astgen.setExtra(payload_index, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.TypeOfPeer.html">TypeOfPeer</a>{
        .body_len = <span class="tok-builtin">@intCast</span>(body_len),
        .body_index = <span class="tok-builtin">@intCast</span>(astgen.extra.items.len),
        .src_node = gz.nodeIndexToRelative(node),
    });
    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, body_len);
    astgen.appendBodyWithFixups(body);
    typeof_scope.unstack();

    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, typeof_inst, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">minMax</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    args: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-kw">comptime</span> op: <span class="tok-kw">enum</span> { min, max },
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">if</span> (args.len &lt; <span class="tok-number">2</span>) {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;expected at least 2 arguments, found {}&quot;</span>, .{args.len});
    }
    <span class="tok-kw">if</span> (args.len == <span class="tok-number">2</span>) {
        <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (op) {
            .min =&gt; .min,
            .max =&gt; .max,
        };
        <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, args[<span class="tok-number">0</span>]);
        <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, args[<span class="tok-number">1</span>]);
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
            .lhs = a,
            .rhs = b,
        });
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
    }
    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.NodeMultiOp.html">NodeMultiOp</a>{
        .src_node = gz.nodeIndexToRelative(node),
    });
    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(gz.astgen, args.len);
    <span class="tok-kw">for</span> (args) |arg| {
        <span class="tok-kw">const</span> arg_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, arg);
        astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(arg_ref);
        extra_index += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">const</span> tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a> = <span class="tok-kw">switch</span> (op) {
        .min =&gt; .min_multi,
        .max =&gt; .max_multi,
    };
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedMultiOpPayloadIndex(tag, payload_index, args.len);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">builtinCall</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    params: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    allow_branch_hint: <span class="tok-type">bool</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);

    <span class="tok-kw">const</span> builtin_token = main_tokens[node];
    <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);<span class="tok-comment">

    // We handle the different builtins manually because they have different semantics depending
    // on the function. For example, `@as` and others participate in result location semantics,
    // and `@cImport` creates a special scope that collects a .c source code text buffer.
    // Also, some builtins have a variable number of parameters.

    </span><span class="tok-kw">const</span> info = <a href="std.zig.BuiltinFn.html">BuiltinFn</a>.<a href="std.zig.BuiltinFn.html#std.zig.BuiltinFn.list">list</a>.<a href="#">get</a>(builtin_name) <span class="tok-kw">orelse</span> {
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;invalid builtin function: '{s}'&quot;</span>, .{
            builtin_name,
        });
    };
    <span class="tok-kw">if</span> (info.param_count) |expected| {
        <span class="tok-kw">if</span> (expected != params.len) {
            <span class="tok-kw">const</span> s = <span class="tok-kw">if</span> (expected == <span class="tok-number">1</span>) <span class="tok-str">&quot;&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;s&quot;</span>;
            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;expected {d} argument{s}, found {d}&quot;</span>, .{
                expected, s, params.len,
            });
        }
    }<span class="tok-comment">

    // Check function scope-only builtins

    </span><span class="tok-kw">if</span> (astgen.fn_block == <span class="tok-null">null</span> <span class="tok-kw">and</span> info.illegal_outside_function)
        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'{s}' outside function scope&quot;</span>, .{builtin_name});

    <span class="tok-kw">switch</span> (info.tag) {
        .branch_hint =&gt; {
            <span class="tok-kw">if</span> (!allow_branch_hint) {
                <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'@branchHint' must appear as the first statement in a function or conditional branch&quot;</span>, .{});
            }
            <span class="tok-kw">const</span> hint_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .branch_hint);
            <span class="tok-kw">const</span> hint_val = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = hint_ty } }, params[<span class="tok-number">0</span>], .operand_branchHint);
            _ = <span class="tok-kw">try</span> gz.addExtendedPayload(.branch_hint, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = hint_val,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .import =&gt; {
            <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
            <span class="tok-kw">const</span> operand_node = params[<span class="tok-number">0</span>];

            <span class="tok-kw">if</span> (node_tags[operand_node] != .string_literal) {<span class="tok-comment">
                // Spec reference: https://github.com/ziglang/zig/issues/2206
                </span><span class="tok-kw">return</span> astgen.failNode(operand_node, <span class="tok-str">&quot;@import operand must be a string literal&quot;</span>, .{});
            }
            <span class="tok-kw">const</span> str_lit_token = main_tokens[operand_node];
            <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> astgen.strLitAsString(str_lit_token);
            <span class="tok-kw">const</span> str_slice = astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(str.index)..][<span class="tok-number">0</span>..str.len];
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, str_slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {
                <span class="tok-kw">return</span> astgen.failTok(str_lit_token, <span class="tok-str">&quot;import path cannot contain null bytes&quot;</span>, .{});
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (str.len == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> astgen.failTok(str_lit_token, <span class="tok-str">&quot;import path cannot be empty&quot;</span>, .{});
            }
            <span class="tok-kw">const</span> res_ty = <span class="tok-kw">try</span> ri.rl.resultType(gz, node) <span class="tok-kw">orelse</span> .none;
            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(gz.astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Import.html">Import</a>{
                .res_ty = res_ty,
                .path = str.index,
            });
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.add(.{
                .tag = .import,
                .data = .{ .pl_tok = .{
                    .src_tok = gz.tokenIndexToRelative(str_lit_token),
                    .payload_index = payload_index,
                } },
            });
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.imports.getOrPut(astgen.gpa, str.index);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.value_ptr.* = str_lit_token;
            }
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .compile_log =&gt; {
            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(gz.astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.NodeMultiOp.html">NodeMultiOp</a>{
                .src_node = gz.nodeIndexToRelative(node),
            });
            <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.reserveExtra">reserveExtra</a>(gz.astgen, params.len);
            <span class="tok-kw">for</span> (params) |param| {
                <span class="tok-kw">const</span> param_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, param);
                astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(param_ref);
                extra_index += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedMultiOpPayloadIndex(.compile_log, payload_index, params.len);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .field =&gt; {
            <span class="tok-kw">if</span> (ri.rl == .ref <span class="tok-kw">or</span> ri.rl == .ref_coerced_ty) {
                <span class="tok-kw">return</span> gz.addPlNode(.field_ptr_named, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldNamed.html">FieldNamed</a>{
                    .lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, params[<span class="tok-number">0</span>]),
                    .field_name = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">1</span>], .field_name),
                });
            }
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.field_val_named, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldNamed.html">FieldNamed</a>{
                .lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),
                .field_name = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">1</span>], .field_name),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .FieldType =&gt; {
            <span class="tok-kw">const</span> ty_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> name_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">1</span>], .field_name);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.field_type_ref, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldTypeRef.html">FieldTypeRef</a>{
                .container_type = ty_inst,
                .field_name = name_inst,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },<span class="tok-comment">

        // zig fmt: off
        </span>.as         =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.as">as</a>(       gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>]),
        .bit_cast   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.bitCast">bitCast</a>(  gz, scope, ri, node, params[<span class="tok-number">0</span>]),
        .TypeOf     =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeOf">typeOf</a>(   gz, scope, ri, node, params),
        .union_init =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.unionInit">unionInit</a>(gz, scope, ri, node, params),
        .c_import   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.cImport">cImport</a>(  gz, scope,     node, params[<span class="tok-number">0</span>]),
        .min        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.minMax">minMax</a>(   gz, scope, ri, node, params, .min),
        .max        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.minMax">minMax</a>(   gz, scope, ri, node, params, .max),<span class="tok-comment">
        // zig fmt: on

        </span>.@&quot;export&quot; =&gt; {
            <span class="tok-kw">const</span> exported = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> export_options_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .export_options);
            <span class="tok-kw">const</span> options = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = export_options_ty } }, params[<span class="tok-number">1</span>], .export_options);
            _ = <span class="tok-kw">try</span> gz.addPlNode(.@&quot;export&quot;, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Export.html">Export</a>{
                .exported = exported,
                .options = options,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .@&quot;extern&quot; =&gt; {
            <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> extern_options_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .extern_options);
            <span class="tok-kw">const</span> options = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = extern_options_ty } }, params[<span class="tok-number">1</span>], .extern_options);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.builtin_extern, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BinNode.html">BinNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .lhs = type_inst,
                .rhs = options,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .set_float_mode =&gt; {
            <span class="tok-kw">const</span> float_mode_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .float_mode);
            <span class="tok-kw">const</span> order = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = float_mode_ty } }, params[<span class="tok-number">0</span>]);
            _ = <span class="tok-kw">try</span> gz.addExtendedPayload(.set_float_mode, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = order,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },

        .src =&gt; {<span class="tok-comment">
            // Incorporate the source location into the source hash, so that
            // changes in the source location of `@src()` result in re-analysis.
            </span>astgen.src_hasher.update(
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;astgen.source_line) ++
                    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;astgen.source_column),
            );

            <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
            <span class="tok-kw">const</span> node_start = token_starts[tree.firstToken(node)];
            astgen.advanceSourceCursor(node_start);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.builtin_src, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Src.html">Src</a>{
                .node = gz.nodeIndexToRelative(node),
                .line = astgen.source_line,
                .column = astgen.source_column,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },<span class="tok-comment">

        // zig fmt: off
        </span>.This                    =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.this,                    node), node),
        .return_address          =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.ret_addr,                node), node),
        .error_return_trace      =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.error_return_trace,      node), node),
        .frame                   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.frame,                   node), node),
        .frame_address           =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.frame_address,           node), node),
        .breakpoint              =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.breakpoint,              node), node),
        .disable_instrumentation =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.disable_instrumentation, node), node),
        .disable_intrinsics      =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.disable_intrinsics,      node), node),

        .type_info   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOpType">simpleUnOpType</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .type_info),
        .size_of     =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOpType">simpleUnOpType</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .size_of),
        .bit_size_of =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOpType">simpleUnOpType</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .bit_size_of),
        .align_of    =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOpType">simpleUnOpType</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .align_of),

        .int_from_ptr          =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .int_from_ptr),
        .compile_error         =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } },   params[<span class="tok-number">0</span>], .compile_error),
        .set_eval_branch_quota =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .u32_type } },              params[<span class="tok-number">0</span>], .set_eval_branch_quota),
        .int_from_enum         =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .int_from_enum),
        .int_from_bool         =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .int_from_bool),
        .embed_file            =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } },   params[<span class="tok-number">0</span>], .embed_file),
        .error_name            =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .anyerror_type } },         params[<span class="tok-number">0</span>], .error_name),
        .set_runtime_safety    =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, <a href="std.zig.AstGen.html#std.zig.AstGen.coerced_bool_ri">coerced_bool_ri</a>,                                      params[<span class="tok-number">0</span>], .set_runtime_safety),
        .sqrt                  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .sqrt),
        .sin                   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .sin),
        .cos                   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .cos),
        .tan                   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .tan),
        .exp                   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .exp),
        .exp2                  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .exp2),
        .log                   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .log),
        .log2                  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .log2),
        .log10                 =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .log10),
        .abs                   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .abs),
        .floor                 =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .floor),
        .ceil                  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .ceil),
        .trunc                 =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .trunc),
        .round                 =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .round),
        .tag_name              =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .tag_name),
        .type_name             =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .type_name),
        .Frame                 =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .frame_type),
        .frame_size            =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .frame_size),

        .int_from_float =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeCast">typeCast</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .int_from_float, builtin_name),
        .float_from_int =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeCast">typeCast</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .float_from_int, builtin_name),
        .ptr_from_int   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeCast">typeCast</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .ptr_from_int, builtin_name),
        .enum_from_int  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeCast">typeCast</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .enum_from_int, builtin_name),
        .float_cast     =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeCast">typeCast</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .float_cast, builtin_name),
        .int_cast       =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeCast">typeCast</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .int_cast, builtin_name),
        .truncate       =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeCast">typeCast</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .truncate, builtin_name),<span class="tok-comment">
        // zig fmt: on

        </span>.in_comptime =&gt; <span class="tok-kw">if</span> (gz.is_comptime) {
            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;redundant '@inComptime' in comptime scope&quot;</span>, .{});
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.in_comptime, node), node);
        },

        .Type =&gt; {
            <span class="tok-kw">const</span> type_info_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .type_info);
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = type_info_ty } }, params[<span class="tok-number">0</span>]);

            <span class="tok-kw">const</span> gpa = gz.astgen.gpa;

            <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
            <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> gz.astgen.addExtra(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Reify.html">Reify</a>{
                .node = node,<span class="tok-comment"> // Absolute node index -- see the definition of `Reify`.
                </span>.operand = operand,
                .src_line = astgen.source_line,
            });
            <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
            gz.astgen.instructions.appendAssumeCapacity(.{
                .tag = .extended,
                .data = .{ .extended = .{
                    .opcode = .reify,
                    .small = <span class="tok-builtin">@intFromEnum</span>(gz.anon_name_strategy),
                    .operand = payload_index,
                } },
            });
            gz.instructions.appendAssumeCapacity(new_index);
            <span class="tok-kw">const</span> result = new_index.toRef();
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .panic =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleUnOp">simpleUnOp</a>(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">0</span>], .panic);
        },
        .trap =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, node);
            _ = <span class="tok-kw">try</span> gz.addNode(.trap, node);
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .unreachable_value, node);
        },
        .int_from_error =&gt; {
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.int_from_error, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = operand,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .error_from_int =&gt; {
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.error_from_int, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = operand,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .error_cast =&gt; {
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgNode">emitDbgNode</a>(gz, node);

            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.error_cast, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BinNode.html">BinNode</a>{
                .lhs = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, builtin_name),
                .rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),
                .node = gz.nodeIndexToRelative(node),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .ptr_cast,
        .align_cast,
        .addrspace_cast,
        .const_cast,
        .volatile_cast,
        =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.ptrCast">ptrCast</a>(gz, scope, ri, node),<span class="tok-comment">

        // zig fmt: off
        </span>.has_decl  =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.hasDeclOrField">hasDeclOrField</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .has_decl),
        .has_field =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.hasDeclOrField">hasDeclOrField</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .has_field),

        .clz         =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.bitBuiltin">bitBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .clz),
        .ctz         =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.bitBuiltin">bitBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .ctz),
        .pop_count   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.bitBuiltin">bitBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .pop_count),
        .byte_swap   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.bitBuiltin">bitBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .byte_swap),
        .bit_reverse =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.bitBuiltin">bitBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .bit_reverse),

        .div_exact =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.divBuiltin">divBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .div_exact),
        .div_floor =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.divBuiltin">divBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .div_floor),
        .div_trunc =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.divBuiltin">divBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .div_trunc),
        .mod       =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.divBuiltin">divBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .mod),
        .rem       =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.divBuiltin">divBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .rem),

        .shl_exact =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.shiftOp">shiftOp</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .shl_exact),
        .shr_exact =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.shiftOp">shiftOp</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .shr_exact),

        .bit_offset_of =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.offsetOf">offsetOf</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .bit_offset_of),
        .offset_of     =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.offsetOf">offsetOf</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .offset_of),

        .c_undef   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleCBuiltin">simpleCBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .c_undef),
        .c_include =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.simpleCBuiltin">simpleCBuiltin</a>(gz, scope, ri, node, params[<span class="tok-number">0</span>], .c_include),

        .cmpxchg_strong =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.cmpxchg">cmpxchg</a>(gz, scope, ri, node, params, <span class="tok-number">1</span>),
        .cmpxchg_weak   =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.cmpxchg">cmpxchg</a>(gz, scope, ri, node, params, <span class="tok-number">0</span>),<span class="tok-comment">
        // zig fmt: on

        </span>.wasm_memory_size =&gt; {
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>], .wasm_memory_index);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.wasm_memory_size, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = operand,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .wasm_memory_grow =&gt; {
            <span class="tok-kw">const</span> index_arg = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>], .wasm_memory_index);
            <span class="tok-kw">const</span> delta_arg = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, params[<span class="tok-number">1</span>]);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.wasm_memory_grow, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BinNode.html">BinNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .lhs = index_arg,
                .rhs = delta_arg,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .c_define =&gt; {
            <span class="tok-kw">if</span> (!gz.c_import) <span class="tok-kw">return</span> gz.astgen.failNode(node, <span class="tok-str">&quot;C define valid only inside C import block&quot;</span>, .{});
            <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">0</span>], .operand_cDefine_macro_name);
            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>], .operand_cDefine_macro_value);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.c_define, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BinNode.html">BinNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .lhs = name,
                .rhs = value,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },

        .splat =&gt; {
            <span class="tok-kw">const</span> result_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, builtin_name);
            <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> gz.addUnNode(.vec_arr_elem_type, result_type, node);
            <span class="tok-kw">const</span> scalar = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = elem_type } }, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.splat, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                .lhs = result_type,
                .rhs = scalar,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .reduce =&gt; {
            <span class="tok-kw">const</span> reduce_op_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .reduce_op);
            <span class="tok-kw">const</span> op = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = reduce_op_ty } }, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> scalar = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.reduce, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                .lhs = op,
                .rhs = scalar,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },

        .add_with_overflow =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.overflowArithmetic">overflowArithmetic</a>(gz, scope, ri, node, params, .add_with_overflow),
        .sub_with_overflow =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.overflowArithmetic">overflowArithmetic</a>(gz, scope, ri, node, params, .sub_with_overflow),
        .mul_with_overflow =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.overflowArithmetic">overflowArithmetic</a>(gz, scope, ri, node, params, .mul_with_overflow),
        .shl_with_overflow =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.overflowArithmetic">overflowArithmetic</a>(gz, scope, ri, node, params, .shl_with_overflow),

        .atomic_load =&gt; {
            <span class="tok-kw">const</span> atomic_order_type = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .atomic_order);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.atomic_load, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.AtomicLoad.html">AtomicLoad</a>{<span class="tok-comment">
                // zig fmt: off
                </span>.elem_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope,                                                  params[<span class="tok-number">0</span>]),
                .ptr       = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>    (gz, scope, .{ .rl = .none },                                params[<span class="tok-number">1</span>]),
                .ordering  = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>    (gz, scope, .{ .rl = .{ .coerced_ty = atomic_order_type } }, params[<span class="tok-number">2</span>]),<span class="tok-comment">
                // zig fmt: on
            </span>});
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .atomic_rmw =&gt; {
            <span class="tok-kw">const</span> atomic_order_type = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .atomic_order);
            <span class="tok-kw">const</span> atomic_rmw_op_type = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .atomic_rmw_op);
            <span class="tok-kw">const</span> int_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.atomic_rmw, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.AtomicRmw.html">AtomicRmw</a>{<span class="tok-comment">
                // zig fmt: off
                </span>.ptr       = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none },                                 params[<span class="tok-number">1</span>]),
                .operation = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = atomic_rmw_op_type } }, params[<span class="tok-number">2</span>]),
                .operand   = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = int_type } },                   params[<span class="tok-number">3</span>]),
                .ordering  = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = atomic_order_type } },  params[<span class="tok-number">4</span>]),<span class="tok-comment">
                // zig fmt: on
            </span>});
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .atomic_store =&gt; {
            <span class="tok-kw">const</span> atomic_order_type = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .atomic_order);
            <span class="tok-kw">const</span> int_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]);
            _ = <span class="tok-kw">try</span> gz.addPlNode(.atomic_store, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.AtomicStore.html">AtomicStore</a>{<span class="tok-comment">
                // zig fmt: off
                </span>.ptr      = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none },                                params[<span class="tok-number">1</span>]),
                .operand  = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = int_type } },                  params[<span class="tok-number">2</span>]),
                .ordering = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = atomic_order_type } }, params[<span class="tok-number">3</span>]),<span class="tok-comment">
                // zig fmt: on
            </span>});
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .mul_add =&gt; {
            <span class="tok-kw">const</span> float_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> mulend1 = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = float_type } }, params[<span class="tok-number">1</span>]);
            <span class="tok-kw">const</span> mulend2 = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = float_type } }, params[<span class="tok-number">2</span>]);
            <span class="tok-kw">const</span> addend = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = float_type } }, params[<span class="tok-number">3</span>]);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.mul_add, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.MulAdd.html">MulAdd</a>{
                .mulend1 = mulend1,
                .mulend2 = mulend2,
                .addend = addend,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .call =&gt; {
            <span class="tok-kw">const</span> call_modifier_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .call_modifier);
            <span class="tok-kw">const</span> modifier = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = call_modifier_ty } }, params[<span class="tok-number">0</span>], .call_modifier);
            <span class="tok-kw">const</span> callee = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]);
            <span class="tok-kw">const</span> args = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.builtin_call, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BuiltinCall.html">BuiltinCall</a>{
                .modifier = modifier,
                .callee = callee,
                .args = args,
                .flags = .{
                    .is_nosuspend = gz.nosuspend_node != <span class="tok-number">0</span>,
                    .ensure_result_used = <span class="tok-null">false</span>,
                },
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .field_parent_ptr =&gt; {
            <span class="tok-kw">const</span> parent_ptr_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, builtin_name);
            <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">0</span>], .field_name);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayloadSmall(.field_parent_ptr, <span class="tok-number">0</span>, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldParentPtr.html">FieldParentPtr</a>{
                .src_node = gz.nodeIndexToRelative(node),
                .parent_ptr_type = parent_ptr_type,
                .field_name = field_name,
                .field_ptr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .memcpy =&gt; {
            _ = <span class="tok-kw">try</span> gz.addPlNode(.memcpy, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                .lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),
                .rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .memset =&gt; {
            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> lhs_ty = <span class="tok-kw">try</span> gz.addUnNode(.typeof, lhs, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> elem_ty = <span class="tok-kw">try</span> gz.addUnNode(.indexable_ptr_elem_type, lhs_ty, params[<span class="tok-number">0</span>]);
            _ = <span class="tok-kw">try</span> gz.addPlNode(.memset, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                .lhs = lhs,
                .rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = elem_ty } }, params[<span class="tok-number">1</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .shuffle =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.shuffle, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Shuffle.html">Shuffle</a>{
                .elem_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]),
                .a = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),
                .b = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]),
                .mask = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">3</span>], .operand_shuffle_mask),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .select =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.select, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Select.html">Select</a>{
                .node = gz.nodeIndexToRelative(node),
                .elem_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]),
                .pred = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),
                .a = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]),
                .b = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">3</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .async_call =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.builtin_async_call, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.AsyncCall.html">AsyncCall</a>{
                .node = gz.nodeIndexToRelative(node),
                .frame_buffer = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),
                .result_ptr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),
                .fn_ptr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]),
                .args = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">3</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .Vector =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.vector_type, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                .lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>], .<span class="tok-type">type</span>),
                .rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">1</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .prefetch =&gt; {
            <span class="tok-kw">const</span> prefetch_options_ty = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .prefetch_options);
            <span class="tok-kw">const</span> ptr = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);
            <span class="tok-kw">const</span> options = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = prefetch_options_ty } }, params[<span class="tok-number">1</span>], .prefetch_options);
            _ = <span class="tok-kw">try</span> gz.addExtendedPayload(.prefetch, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BinNode.html">BinNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .lhs = ptr,
                .rhs = options,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
        },
        .c_va_arg =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.c_va_arg, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BinNode.html">BinNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),
                .rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">1</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .c_va_copy =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.c_va_copy, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .c_va_end =&gt; {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.c_va_end, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .c_va_start =&gt; {
            <span class="tok-kw">if</span> (!astgen.fn_var_args) {
                <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'@cVaStart' in a non-variadic function&quot;</span>, .{});
            }
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.c_va_start, node), node);
        },

        .work_item_id =&gt; {
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>], .work_group_dim_index);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.work_item_id, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = operand,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .work_group_size =&gt; {
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>], .work_group_dim_index);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.work_group_size, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = operand,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
        .work_group_id =&gt; {
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>], .work_group_dim_index);
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.work_group_id, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
                .node = gz.nodeIndexToRelative(node),
                .operand = operand,
            });
            <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
        },
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">hasDeclOrField</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    lhs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    rhs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> container_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, lhs_node);
    <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(
        gz,
        scope,
        .{ .rl = .{ .coerced_ty = .slice_const_u8_type } },
        rhs_node,
        <span class="tok-kw">if</span> (tag == .has_decl) .decl_name <span class="tok-kw">else</span> .field_name,
    );
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = container_type,
        .rhs = name,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeCast</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    operand_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
    builtin_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
    <span class="tok-kw">const</span> result_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, builtin_name);
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, operand_node);

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = result_type,
        .rhs = operand,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">simpleUnOpType</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    operand_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, operand_node);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(tag, operand, node);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">simpleUnOp</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    operand_ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    operand_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
    <span class="tok-kw">const</span> operand = <span class="tok-kw">if</span> (tag == .compile_error)
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, operand_ri, operand_node, .compile_error_string)
    <span class="tok-kw">else</span>
        <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, operand_ri, operand_node);
    <span class="tok-kw">switch</span> (tag) {
        .tag_name, .error_name, .int_from_ptr =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor),
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(tag, operand, node);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">negation</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);<span class="tok-comment">

    // Check for float literal as the sub-expression because we want to preserve
    // its negativity rather than having it go through comptime subtraction.
    </span><span class="tok-kw">const</span> operand_node = node_datas[node].lhs;
    <span class="tok-kw">if</span> (node_tags[operand_node] == .number_literal) {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.numberLiteral">numberLiteral</a>(gz, ri, operand_node, node, .negative);
    }

    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, operand_node);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.negate, operand, node);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">cmpxchg</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    params: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    small: <span class="tok-type">u16</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> int_type = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, params[<span class="tok-number">0</span>]);
    <span class="tok-kw">const</span> atomic_order_type = <span class="tok-kw">try</span> gz.addBuiltinValue(node, .atomic_order);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayloadSmall(.cmpxchg, small, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Cmpxchg.html">Cmpxchg</a>{<span class="tok-comment">
        // zig fmt: off
        </span>.node           = gz.nodeIndexToRelative(node),
        .ptr            = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none },                                params[<span class="tok-number">1</span>]),
        .expected_value = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = int_type } },                  params[<span class="tok-number">2</span>]),
        .new_value      = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = int_type } },          params[<span class="tok-number">3</span>]),
        .success_order  = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = atomic_order_type } }, params[<span class="tok-number">4</span>]),
        .failure_order  = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .coerced_ty = atomic_order_type } }, params[<span class="tok-number">5</span>]),<span class="tok-comment">
        // zig fmt: on
    </span>});
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bitBuiltin</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    operand_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, operand_node);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(tag, operand, node);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">divBuiltin</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    lhs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    rhs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, lhs_node);
    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, rhs_node);

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{ .lhs = lhs, .rhs = rhs });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">simpleCBuiltin</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    operand_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">if</span> (tag == .c_undef) <span class="tok-str">&quot;C undef&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;C include&quot;</span>;
    <span class="tok-kw">if</span> (!gz.c_import) <span class="tok-kw">return</span> gz.astgen.failNode(node, <span class="tok-str">&quot;{s} valid only inside C import block&quot;</span>, .{name});
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(
        gz,
        scope,
        .{ .rl = .{ .coerced_ty = .slice_const_u8_type } },
        operand_node,
        <span class="tok-kw">if</span> (tag == .c_undef) .operand_cUndef_macro_name <span class="tok-kw">else</span> .operand_cInclude_file_name,
    );
    _ = <span class="tok-kw">try</span> gz.addExtendedPayload(tag, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnNode.html">UnNode</a>{
        .node = gz.nodeIndexToRelative(node),
        .operand = operand,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, .void_value, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">offsetOf</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    lhs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    rhs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.typeExpr">typeExpr</a>(gz, scope, lhs_node);
    <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.comptimeExpr">comptimeExpr</a>(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, rhs_node, .field_name);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = type_inst,
        .rhs = field_name,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">shiftOp</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    lhs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    rhs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, lhs_node);

    <span class="tok-kw">const</span> cursor = <span class="tok-kw">switch</span> (gz.astgen.tree.nodes.items(.tag)[node]) {
        .shl, .shr =&gt; <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,
    };

    <span class="tok-kw">const</span> log2_int_type = <span class="tok-kw">try</span> gz.addUnNode(.typeof_log2_int_type, lhs, lhs_node);
    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .{ .ty = log2_int_type }, .ctx = .shift_op }, rhs_node);

    <span class="tok-kw">switch</span> (gz.astgen.tree.nodes.items(.tag)[node]) {
        .shl, .shr =&gt; <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,
    }

    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
        .lhs = lhs,
        .rhs = rhs,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">cImport</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    body_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;

    <span class="tok-kw">if</span> (gz.c_import) <span class="tok-kw">return</span> gz.astgen.failNode(node, <span class="tok-str">&quot;cannot nest @cImport&quot;</span>, .{});

    <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(scope);
    block_scope.is_comptime = <span class="tok-null">true</span>;
    block_scope.c_import = <span class="tok-null">true</span>;
    <span class="tok-kw">defer</span> block_scope.unstack();

    <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.c_import, node);
    <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;block_scope, &amp;block_scope.base, .{ .rl = .none }, body_node, .normal);
    _ = <span class="tok-kw">try</span> gz.addUnNode(.ensure_result_used, block_result, node);
    <span class="tok-kw">if</span> (!gz.refIsNoReturn(block_result)) {
        _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, block_inst, .void_value);
    }
    <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);<span class="tok-comment">
    // block_scope unstacked now, can add new instructions to gz
    </span><span class="tok-kw">try</span> gz.instructions.append(gpa, block_inst);

    <span class="tok-kw">return</span> block_inst.toRef();
}

<span class="tok-kw">fn</span> <span class="tok-fn">overflowArithmetic</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    params: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);
    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(tag, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BinNode.html">BinNode</a>{
        .node = gz.nodeIndexToRelative(node),
        .lhs = lhs,
        .rhs = rhs,
    });
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, result, node);
}

<span class="tok-kw">fn</span> <span class="tok-fn">callExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    <span class="tok-comment">/// If this is not `.none` and this call is a decl literal form (`.foo(...)`), then this</span>
    <span class="tok-comment">/// type is used as the decl literal result type instead of the result type from `ri.rl`.</span>
    override_decl_literal_type: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    call: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;

    <span class="tok-kw">const</span> callee = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.calleeExpr">calleeExpr</a>(gz, scope, ri.rl, override_decl_literal_type, call.ast.fn_expr);
    <span class="tok-kw">const</span> modifier: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.CallModifier.html">CallModifier</a> = blk: {
        <span class="tok-kw">if</span> (call.async_token != <span class="tok-null">null</span>) {
            <span class="tok-kw">break</span> :blk .async_kw;
        }
        <span class="tok-kw">if</span> (gz.nosuspend_node != <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span> :blk .no_async;
        }
        <span class="tok-kw">break</span> :blk .auto;
    };

    {
        astgen.advanceSourceCursor(astgen.tree.tokens.items(.start)[call.ast.lparen]);
        <span class="tok-kw">const</span> line = astgen.source_line - gz.decl_line;
        <span class="tok-kw">const</span> column = astgen.source_column;<span class="tok-comment">
        // Sema expects a dbg_stmt immediately before call,
        </span><span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmtForceCurrentIndex">emitDbgStmtForceCurrentIndex</a>(gz, .{ line, column });
    }

    <span class="tok-kw">switch</span> (callee) {
        .direct =&gt; |obj| <a href="std.debug.html#std.debug.assert">assert</a>(obj != .none),
        .field =&gt; |field| <a href="std.debug.html#std.debug.assert">assert</a>(field.obj_ptr != .none),
    }
    <a href="std.debug.html#std.debug.assert">assert</a>(node != <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> call_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
    <span class="tok-kw">const</span> call_inst = call_index.toRef();
    <span class="tok-kw">try</span> gz.astgen.instructions.append(astgen.gpa, <span class="tok-null">undefined</span>);
    <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, call_index);

    <span class="tok-kw">const</span> scratch_top = astgen.scratch.items.len;
    <span class="tok-kw">defer</span> astgen.scratch.items.len = scratch_top;

    <span class="tok-kw">var</span> scratch_index = scratch_top;
    <span class="tok-kw">try</span> astgen.scratch.resize(astgen.gpa, scratch_top + call.ast.params.len);

    <span class="tok-kw">for</span> (call.ast.params) |param_node| {
        <span class="tok-kw">var</span> arg_block = gz.makeSubBlock(scope);
        <span class="tok-kw">defer</span> arg_block.unstack();<span class="tok-comment">

        // `call_inst` is reused to provide the param type.
        </span><span class="tok-kw">const</span> arg_ref = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.fullBodyExpr">fullBodyExpr</a>(&amp;arg_block, &amp;arg_block.base, .{ .rl = .{ .coerced_ty = call_inst }, .ctx = .fn_arg }, param_node, .normal);
        _ = <span class="tok-kw">try</span> arg_block.addBreakWithSrcNode(.break_inline, call_index, arg_ref, param_node);

        <span class="tok-kw">const</span> body = arg_block.instructionsSlice();
        <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(astgen.gpa, <a href="std.zig.AstGen.html#std.zig.AstGen.countBodyLenAfterFixups">countBodyLenAfterFixups</a>(astgen, body));
        <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsArrayList">appendBodyWithFixupsArrayList</a>(astgen, &amp;astgen.scratch, body);

        astgen.scratch.items[scratch_index] = <span class="tok-builtin">@intCast</span>(astgen.scratch.items.len - scratch_top);
        scratch_index += <span class="tok-number">1</span>;
    }<span class="tok-comment">

    // If our result location is a try/catch/error-union-if/return, a function argument,
    // or an initializer for a `const` variable, the error trace propagates.
    // Otherwise, it should always be popped (handled in Sema).
    </span><span class="tok-kw">const</span> propagate_error_trace = <span class="tok-kw">switch</span> (ri.ctx) {
        .error_handling_expr, .@&quot;return&quot;, .fn_arg, .const_init =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };

    <span class="tok-kw">switch</span> (callee) {
        .direct =&gt; |callee_obj| {
            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Call.html">Call</a>{
                .callee = callee_obj,
                .flags = .{
                    .pop_error_return_trace = !propagate_error_trace,
                    .packed_modifier = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(modifier)),
                    .args_len = <span class="tok-builtin">@intCast</span>(call.ast.params.len),
                },
            });
            <span class="tok-kw">if</span> (call.ast.params.len != <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> astgen.extra.appendSlice(astgen.gpa, astgen.scratch.items[scratch_top..]);
            }
            gz.astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(call_index), .{
                .tag = .call,
                .data = .{ .pl_node = .{
                    .src_node = gz.nodeIndexToRelative(node),
                    .payload_index = payload_index,
                } },
            });
        },
        .field =&gt; |callee_field| {
            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.addExtra">addExtra</a>(astgen, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.FieldCall.html">FieldCall</a>{
                .obj_ptr = callee_field.obj_ptr,
                .field_name_start = callee_field.field_name_start,
                .flags = .{
                    .pop_error_return_trace = !propagate_error_trace,
                    .packed_modifier = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(modifier)),
                    .args_len = <span class="tok-builtin">@intCast</span>(call.ast.params.len),
                },
            });
            <span class="tok-kw">if</span> (call.ast.params.len != <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> astgen.extra.appendSlice(astgen.gpa, astgen.scratch.items[scratch_top..]);
            }
            gz.astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(call_index), .{
                .tag = .field_call,
                .data = .{ .pl_node = .{
                    .src_node = gz.nodeIndexToRelative(node),
                    .payload_index = payload_index,
                } },
            });
        },
    }
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalue">rvalue</a>(gz, ri, call_inst, node);<span class="tok-comment"> // TODO function call with result location
</span>}

<span class="tok-kw">const</span> Callee = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    field: <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// A *pointer* to the object the field is fetched on, so that we can</span>
        <span class="tok-comment">/// promote the lvalue to an address if the first parameter requires it.</span>
        obj_ptr: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Offset into `string_bytes`.</span>
        field_name_start: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    },
    direct: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
};

<span class="tok-comment">/// calleeExpr generates the function part of a call expression (f in f(x)), but</span>
<span class="tok-comment">/// *not* the callee argument to the @call() builtin. Its purpose is to</span>
<span class="tok-comment">/// distinguish between standard calls and method call syntax `a.b()`. Thus, if</span>
<span class="tok-comment">/// the lhs is a field access, we return using the `field` union field;</span>
<span class="tok-comment">/// otherwise, we use the `direct` union field.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">calleeExpr</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    call_rl: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>.<a href="std.zig.AstGen.ResultInfo.Loc.html">Loc</a>,
    <span class="tok-comment">/// If this is not `.none` and this call is a decl literal form (`.foo(...)`), then this</span>
    <span class="tok-comment">/// type is used as the decl literal result type instead of the result type from `call_rl`.</span>
    override_decl_literal_type: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.AstGen.Callee.html">Callee</a> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">const</span> tree = astgen.tree;

    <span class="tok-kw">const</span> tag = tree.nodes.items(.tag)[node];
    <span class="tok-kw">switch</span> (tag) {
        .field_access =&gt; {
            <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
            <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
            <span class="tok-kw">const</span> object_node = node_datas[node].lhs;
            <span class="tok-kw">const</span> dot_token = main_tokens[node];
            <span class="tok-kw">const</span> field_ident = dot_token + <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(field_ident);<span class="tok-comment">
            // Capture the object by reference so we can promote it to an
            // address in Sema if needed.
            </span><span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .ref }, object_node);

            <span class="tok-kw">const</span> cursor = <a href="std.zig.AstGen.html#std.zig.AstGen.maybeAdvanceSourceCursorToMainToken">maybeAdvanceSourceCursorToMainToken</a>(gz, node);
            <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.emitDbgStmt">emitDbgStmt</a>(gz, cursor);

            <span class="tok-kw">return</span> .{ .field = .{
                .obj_ptr = lhs,
                .field_name_start = str_index,
            } };
        },
        .enum_literal =&gt; {
            <span class="tok-kw">const</span> res_ty = res_ty: {
                <span class="tok-kw">if</span> (override_decl_literal_type != .none) <span class="tok-kw">break</span> :res_ty override_decl_literal_type;
                <span class="tok-kw">break</span> :res_ty <span class="tok-kw">try</span> call_rl.resultType(gz, node) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                    // No result type; lower to a literal call of an enum literal.
                    </span><span class="tok-kw">return</span> .{ .direct = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node) };
                };
            };<span class="tok-comment">
            // Decl literal call syntax, e.g.
            // `const foo: T = .init();`
            // Look up `init` in `T`, but don't try and coerce it.
            </span><span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(tree.nodes.items(.main_token)[node]);
            <span class="tok-kw">const</span> callee = <span class="tok-kw">try</span> gz.addPlNode(.decl_literal_no_coerce, node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Field.html">Field</a>{
                .lhs = res_ty,
                .field_name_start = str_index,
            });
            <span class="tok-kw">return</span> .{ .direct = callee };
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> .{ .direct = <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.expr">expr</a>(gz, scope, .{ .rl = .none }, node) },
    }
}

<span class="tok-kw">const</span> primitive_instrs = <a href="std.html">std</a>.<a href="std.static_string_map.html#std.static_string_map.StaticStringMap">StaticStringMap</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>).initComptime(.{
    .{ <span class="tok-str">&quot;anyerror&quot;</span>, .anyerror_type },
    .{ <span class="tok-str">&quot;anyframe&quot;</span>, .anyframe_type },
    .{ <span class="tok-str">&quot;anyopaque&quot;</span>, .anyopaque_type },
    .{ <span class="tok-str">&quot;bool&quot;</span>, .bool_type },
    .{ <span class="tok-str">&quot;c_int&quot;</span>, .c_int_type },
    .{ <span class="tok-str">&quot;c_long&quot;</span>, .c_long_type },
    .{ <span class="tok-str">&quot;c_longdouble&quot;</span>, .c_longdouble_type },
    .{ <span class="tok-str">&quot;c_longlong&quot;</span>, .c_longlong_type },
    .{ <span class="tok-str">&quot;c_char&quot;</span>, .c_char_type },
    .{ <span class="tok-str">&quot;c_short&quot;</span>, .c_short_type },
    .{ <span class="tok-str">&quot;c_uint&quot;</span>, .c_uint_type },
    .{ <span class="tok-str">&quot;c_ulong&quot;</span>, .c_ulong_type },
    .{ <span class="tok-str">&quot;c_ulonglong&quot;</span>, .c_ulonglong_type },
    .{ <span class="tok-str">&quot;c_ushort&quot;</span>, .c_ushort_type },
    .{ <span class="tok-str">&quot;comptime_float&quot;</span>, .comptime_float_type },
    .{ <span class="tok-str">&quot;comptime_int&quot;</span>, .comptime_int_type },
    .{ <span class="tok-str">&quot;f128&quot;</span>, .f128_type },
    .{ <span class="tok-str">&quot;f16&quot;</span>, .f16_type },
    .{ <span class="tok-str">&quot;f32&quot;</span>, .f32_type },
    .{ <span class="tok-str">&quot;f64&quot;</span>, .f64_type },
    .{ <span class="tok-str">&quot;f80&quot;</span>, .f80_type },
    .{ <span class="tok-str">&quot;false&quot;</span>, .bool_false },
    .{ <span class="tok-str">&quot;i16&quot;</span>, .i16_type },
    .{ <span class="tok-str">&quot;i32&quot;</span>, .i32_type },
    .{ <span class="tok-str">&quot;i64&quot;</span>, .i64_type },
    .{ <span class="tok-str">&quot;i128&quot;</span>, .i128_type },
    .{ <span class="tok-str">&quot;i8&quot;</span>, .i8_type },
    .{ <span class="tok-str">&quot;isize&quot;</span>, .isize_type },
    .{ <span class="tok-str">&quot;noreturn&quot;</span>, .noreturn_type },
    .{ <span class="tok-str">&quot;null&quot;</span>, .null_value },
    .{ <span class="tok-str">&quot;true&quot;</span>, .bool_true },
    .{ <span class="tok-str">&quot;type&quot;</span>, .type_type },
    .{ <span class="tok-str">&quot;u16&quot;</span>, .u16_type },
    .{ <span class="tok-str">&quot;u29&quot;</span>, .u29_type },
    .{ <span class="tok-str">&quot;u32&quot;</span>, .u32_type },
    .{ <span class="tok-str">&quot;u64&quot;</span>, .u64_type },
    .{ <span class="tok-str">&quot;u128&quot;</span>, .u128_type },
    .{ <span class="tok-str">&quot;u1&quot;</span>, .u1_type },
    .{ <span class="tok-str">&quot;u8&quot;</span>, .u8_type },
    .{ <span class="tok-str">&quot;undefined&quot;</span>, .undef },
    .{ <span class="tok-str">&quot;usize&quot;</span>, .usize_type },
    .{ <span class="tok-str">&quot;void&quot;</span>, .void_type },
});

<span class="tok-kw">comptime</span> {<span class="tok-comment">
    // These checks ensure that std.zig.primitives stays in sync with the primitive-&gt;Zir map.
    </span><span class="tok-kw">const</span> primitives = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.primitives.html">primitives</a>;
    <span class="tok-kw">for</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.primitive_instrs">primitive_instrs</a>.<a href="#">keys</a>(), <a href="std.zig.AstGen.html#std.zig.AstGen.primitive_instrs">primitive_instrs</a>.<a href="#">values</a>()) |key, value| {
        <span class="tok-kw">if</span> (!primitives.isPrimitive(key)) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.zig.isPrimitive() is not aware of Zir instr '&quot;</span> ++ <span class="tok-builtin">@tagName</span>(value) ++ <span class="tok-str">&quot;'&quot;</span>);
        }
    }
    <span class="tok-kw">for</span> (primitives.names.keys()) |key| {
        <span class="tok-kw">if</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.primitive_instrs">primitive_instrs</a>.<a href="#">get</a>(key) == <span class="tok-null">null</span>) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.zig.primitives entry '&quot;</span> ++ key ++ <span class="tok-str">&quot;' does not have a corresponding Zir instr&quot;</span>);
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">nodeIsTriviallyZero</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);

    <span class="tok-kw">switch</span> (node_tags[node]) {
        .number_literal =&gt; {
            <span class="tok-kw">const</span> ident = main_tokens[node];
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.number_literal.html#std.zig.number_literal.parseNumberLiteral">parseNumberLiteral</a>(tree.tokenSlice(ident))) {
                .int =&gt; |number| <span class="tok-kw">switch</span> (number) {
                    <span class="tok-number">0</span> =&gt; <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
            };
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">nodeMayAppendToErrorTrace</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, start_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">var</span> node = start_node;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (node_tags[node]) {<span class="tok-comment">
            // These don't have the opportunity to call any runtime functions.
            </span>.error_value,
            .identifier,
            .@&quot;comptime&quot;,
            =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,<span class="tok-comment">

            // Forward the question to the LHS sub-expression.
            </span>.grouped_expression,
            .@&quot;try&quot;,
            .@&quot;nosuspend&quot;,
            .unwrap_optional,
            =&gt; node = node_datas[node].lhs,<span class="tok-comment">

            // Anything that does not eval to an error is guaranteed to pop any
            // additions to the error trace, so it effectively does not append.
            </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.nodeMayEvalToError">nodeMayEvalToError</a>(tree, start_node) != .never,
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">nodeMayEvalToError</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, start_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.BuiltinFn.html">BuiltinFn</a>.<a href="std.zig.BuiltinFn.EvalToError.html">EvalToError</a> {
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">var</span> node = start_node;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (node_tags[node]) {
            .root,
            .@&quot;usingnamespace&quot;,
            .test_decl,
            .switch_case,
            .switch_case_inline,
            .switch_case_one,
            .switch_case_inline_one,
            .container_field_init,
            .container_field_align,
            .container_field,
            .asm_output,
            .asm_input,
            =&gt; <span class="tok-kw">unreachable</span>,

            .error_value =&gt; <span class="tok-kw">return</span> .always,

            .@&quot;asm&quot;,
            .asm_simple,
            .identifier,
            .field_access,
            .deref,
            .array_access,
            .while_simple,
            .while_cont,
            .for_simple,
            .if_simple,
            .@&quot;while&quot;,
            .@&quot;if&quot;,
            .@&quot;for&quot;,
            .@&quot;switch&quot;,
            .switch_comma,
            .call_one,
            .call_one_comma,
            .async_call_one,
            .async_call_one_comma,
            .call,
            .call_comma,
            .async_call,
            .async_call_comma,
            =&gt; <span class="tok-kw">return</span> .maybe,

            .@&quot;return&quot;,
            .@&quot;break&quot;,
            .@&quot;continue&quot;,
            .bit_not,
            .bool_not,
            .global_var_decl,
            .local_var_decl,
            .simple_var_decl,
            .aligned_var_decl,
            .@&quot;defer&quot;,
            .@&quot;errdefer&quot;,
            .address_of,
            .optional_type,
            .negation,
            .negation_wrap,
            .@&quot;resume&quot;,
            .array_type,
            .array_type_sentinel,
            .ptr_type_aligned,
            .ptr_type_sentinel,
            .ptr_type,
            .ptr_type_bit_range,
            .@&quot;suspend&quot;,
            .fn_proto_simple,
            .fn_proto_multi,
            .fn_proto_one,
            .fn_proto,
            .fn_decl,
            .anyframe_type,
            .anyframe_literal,
            .number_literal,
            .enum_literal,
            .string_literal,
            .multiline_string_literal,
            .char_literal,
            .unreachable_literal,
            .error_set_decl,
            .container_decl,
            .container_decl_trailing,
            .container_decl_two,
            .container_decl_two_trailing,
            .container_decl_arg,
            .container_decl_arg_trailing,
            .tagged_union,
            .tagged_union_trailing,
            .tagged_union_two,
            .tagged_union_two_trailing,
            .tagged_union_enum_tag,
            .tagged_union_enum_tag_trailing,
            .add,
            .add_wrap,
            .add_sat,
            .array_cat,
            .array_mult,
            .assign,
            .assign_destructure,
            .assign_bit_and,
            .assign_bit_or,
            .assign_shl,
            .assign_shl_sat,
            .assign_shr,
            .assign_bit_xor,
            .assign_div,
            .assign_sub,
            .assign_sub_wrap,
            .assign_sub_sat,
            .assign_mod,
            .assign_add,
            .assign_add_wrap,
            .assign_add_sat,
            .assign_mul,
            .assign_mul_wrap,
            .assign_mul_sat,
            .bang_equal,
            .bit_and,
            .bit_or,
            .shl,
            .shl_sat,
            .shr,
            .bit_xor,
            .bool_and,
            .bool_or,
            .div,
            .equal_equal,
            .error_union,
            .greater_or_equal,
            .greater_than,
            .less_or_equal,
            .less_than,
            .merge_error_sets,
            .mod,
            .mul,
            .mul_wrap,
            .mul_sat,
            .switch_range,
            .for_range,
            .sub,
            .sub_wrap,
            .sub_sat,
            .slice,
            .slice_open,
            .slice_sentinel,
            .array_init_one,
            .array_init_one_comma,
            .array_init_dot_two,
            .array_init_dot_two_comma,
            .array_init_dot,
            .array_init_dot_comma,
            .array_init,
            .array_init_comma,
            .struct_init_one,
            .struct_init_one_comma,
            .struct_init_dot_two,
            .struct_init_dot_two_comma,
            .struct_init_dot,
            .struct_init_dot_comma,
            .struct_init,
            .struct_init_comma,
            =&gt; <span class="tok-kw">return</span> .never,<span class="tok-comment">

            // Forward the question to the LHS sub-expression.
            </span>.grouped_expression,
            .@&quot;try&quot;,
            .@&quot;await&quot;,
            .@&quot;comptime&quot;,
            .@&quot;nosuspend&quot;,
            .unwrap_optional,
            =&gt; node = node_datas[node].lhs,<span class="tok-comment">

            // LHS sub-expression may still be an error under the outer optional or error union
            </span>.@&quot;catch&quot;,
            .@&quot;orelse&quot;,
            =&gt; <span class="tok-kw">return</span> .maybe,

            .block_two,
            .block_two_semicolon,
            .block,
            .block_semicolon,
            =&gt; {
                <span class="tok-kw">const</span> lbrace = main_tokens[node];
                <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon) {<span class="tok-comment">
                    // Labeled blocks may need a memory location to forward
                    // to their break statements.
                    </span><span class="tok-kw">return</span> .maybe;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> .never;
                }
            },

            .builtin_call,
            .builtin_call_comma,
            .builtin_call_two,
            .builtin_call_two_comma,
            =&gt; {
                <span class="tok-kw">const</span> builtin_token = main_tokens[node];
                <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);<span class="tok-comment">
                // If the builtin is an invalid name, we don't cause an error here; instead
                // let it pass, and the error will be &quot;invalid builtin function&quot; later.
                </span><span class="tok-kw">const</span> builtin_info = <a href="std.zig.BuiltinFn.html">BuiltinFn</a>.<a href="std.zig.BuiltinFn.html#std.zig.BuiltinFn.list">list</a>.<a href="#">get</a>(builtin_name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .maybe;
                <span class="tok-kw">return</span> builtin_info.eval_to_error;
            },
        }
    }
}

<span class="tok-comment">/// Returns `true` if it is known the type expression has more than one possible value;</span>
<span class="tok-comment">/// `false` otherwise.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">nodeImpliesMoreThanOnePossibleValue</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, start_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">var</span> node = start_node;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (node_tags[node]) {
            .root,
            .@&quot;usingnamespace&quot;,
            .test_decl,
            .switch_case,
            .switch_case_inline,
            .switch_case_one,
            .switch_case_inline_one,
            .container_field_init,
            .container_field_align,
            .container_field,
            .asm_output,
            .asm_input,
            .global_var_decl,
            .local_var_decl,
            .simple_var_decl,
            .aligned_var_decl,
            =&gt; <span class="tok-kw">unreachable</span>,

            .@&quot;return&quot;,
            .@&quot;break&quot;,
            .@&quot;continue&quot;,
            .bit_not,
            .bool_not,
            .@&quot;defer&quot;,
            .@&quot;errdefer&quot;,
            .address_of,
            .negation,
            .negation_wrap,
            .@&quot;resume&quot;,
            .array_type,
            .@&quot;suspend&quot;,
            .fn_decl,
            .anyframe_literal,
            .number_literal,
            .enum_literal,
            .string_literal,
            .multiline_string_literal,
            .char_literal,
            .unreachable_literal,
            .error_set_decl,
            .container_decl,
            .container_decl_trailing,
            .container_decl_two,
            .container_decl_two_trailing,
            .container_decl_arg,
            .container_decl_arg_trailing,
            .tagged_union,
            .tagged_union_trailing,
            .tagged_union_two,
            .tagged_union_two_trailing,
            .tagged_union_enum_tag,
            .tagged_union_enum_tag_trailing,
            .@&quot;asm&quot;,
            .asm_simple,
            .add,
            .add_wrap,
            .add_sat,
            .array_cat,
            .array_mult,
            .assign,
            .assign_destructure,
            .assign_bit_and,
            .assign_bit_or,
            .assign_shl,
            .assign_shl_sat,
            .assign_shr,
            .assign_bit_xor,
            .assign_div,
            .assign_sub,
            .assign_sub_wrap,
            .assign_sub_sat,
            .assign_mod,
            .assign_add,
            .assign_add_wrap,
            .assign_add_sat,
            .assign_mul,
            .assign_mul_wrap,
            .assign_mul_sat,
            .bang_equal,
            .bit_and,
            .bit_or,
            .shl,
            .shl_sat,
            .shr,
            .bit_xor,
            .bool_and,
            .bool_or,
            .div,
            .equal_equal,
            .error_union,
            .greater_or_equal,
            .greater_than,
            .less_or_equal,
            .less_than,
            .merge_error_sets,
            .mod,
            .mul,
            .mul_wrap,
            .mul_sat,
            .switch_range,
            .for_range,
            .field_access,
            .sub,
            .sub_wrap,
            .sub_sat,
            .slice,
            .slice_open,
            .slice_sentinel,
            .deref,
            .array_access,
            .error_value,
            .while_simple,
            .while_cont,
            .for_simple,
            .if_simple,
            .@&quot;catch&quot;,
            .@&quot;orelse&quot;,
            .array_init_one,
            .array_init_one_comma,
            .array_init_dot_two,
            .array_init_dot_two_comma,
            .array_init_dot,
            .array_init_dot_comma,
            .array_init,
            .array_init_comma,
            .struct_init_one,
            .struct_init_one_comma,
            .struct_init_dot_two,
            .struct_init_dot_two_comma,
            .struct_init_dot,
            .struct_init_dot_comma,
            .struct_init,
            .struct_init_comma,
            .@&quot;while&quot;,
            .@&quot;if&quot;,
            .@&quot;for&quot;,
            .@&quot;switch&quot;,
            .switch_comma,
            .call_one,
            .call_one_comma,
            .async_call_one,
            .async_call_one_comma,
            .call,
            .call_comma,
            .async_call,
            .async_call_comma,
            .block_two,
            .block_two_semicolon,
            .block,
            .block_semicolon,
            .builtin_call,
            .builtin_call_comma,
            .builtin_call_two,
            .builtin_call_two_comma,<span class="tok-comment">
            // these are function bodies, not pointers
            </span>.fn_proto_simple,
            .fn_proto_multi,
            .fn_proto_one,
            .fn_proto,
            =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,<span class="tok-comment">

            // Forward the question to the LHS sub-expression.
            </span>.grouped_expression,
            .@&quot;try&quot;,
            .@&quot;await&quot;,
            .@&quot;comptime&quot;,
            .@&quot;nosuspend&quot;,
            .unwrap_optional,
            =&gt; node = node_datas[node].lhs,

            .ptr_type_aligned,
            .ptr_type_sentinel,
            .ptr_type,
            .ptr_type_bit_range,
            .optional_type,
            .anyframe_type,
            .array_type_sentinel,
            =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,

            .identifier =&gt; {
                <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
                <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(main_tokens[node]);
                <span class="tok-kw">if</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.primitive_instrs">primitive_instrs</a>.<a href="#">get</a>(ident_bytes)) |primitive| <span class="tok-kw">switch</span> (primitive) {
                    .anyerror_type,
                    .anyframe_type,
                    .anyopaque_type,
                    .bool_type,
                    .c_int_type,
                    .c_long_type,
                    .c_longdouble_type,
                    .c_longlong_type,
                    .c_char_type,
                    .c_short_type,
                    .c_uint_type,
                    .c_ulong_type,
                    .c_ulonglong_type,
                    .c_ushort_type,
                    .comptime_float_type,
                    .comptime_int_type,
                    .f16_type,
                    .f32_type,
                    .f64_type,
                    .f80_type,
                    .f128_type,
                    .i16_type,
                    .i32_type,
                    .i64_type,
                    .i128_type,
                    .i8_type,
                    .isize_type,
                    .type_type,
                    .u16_type,
                    .u29_type,
                    .u32_type,
                    .u64_type,
                    .u128_type,
                    .u1_type,
                    .u8_type,
                    .usize_type,
                    =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,

                    .void_type,
                    .bool_false,
                    .bool_true,
                    .null_value,
                    .undef,
                    .noreturn_type,
                    =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // that's all the values from `primitives`.
                </span>} <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            },
        }
    }
}

<span class="tok-comment">/// Returns `true` if it is known the expression is a type that cannot be used at runtime;</span>
<span class="tok-comment">/// `false` otherwise.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">nodeImpliesComptimeOnly</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, start_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">var</span> node = start_node;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (node_tags[node]) {
            .root,
            .@&quot;usingnamespace&quot;,
            .test_decl,
            .switch_case,
            .switch_case_inline,
            .switch_case_one,
            .switch_case_inline_one,
            .container_field_init,
            .container_field_align,
            .container_field,
            .asm_output,
            .asm_input,
            .global_var_decl,
            .local_var_decl,
            .simple_var_decl,
            .aligned_var_decl,
            =&gt; <span class="tok-kw">unreachable</span>,

            .@&quot;return&quot;,
            .@&quot;break&quot;,
            .@&quot;continue&quot;,
            .bit_not,
            .bool_not,
            .@&quot;defer&quot;,
            .@&quot;errdefer&quot;,
            .address_of,
            .negation,
            .negation_wrap,
            .@&quot;resume&quot;,
            .array_type,
            .@&quot;suspend&quot;,
            .fn_decl,
            .anyframe_literal,
            .number_literal,
            .enum_literal,
            .string_literal,
            .multiline_string_literal,
            .char_literal,
            .unreachable_literal,
            .error_set_decl,
            .container_decl,
            .container_decl_trailing,
            .container_decl_two,
            .container_decl_two_trailing,
            .container_decl_arg,
            .container_decl_arg_trailing,
            .tagged_union,
            .tagged_union_trailing,
            .tagged_union_two,
            .tagged_union_two_trailing,
            .tagged_union_enum_tag,
            .tagged_union_enum_tag_trailing,
            .@&quot;asm&quot;,
            .asm_simple,
            .add,
            .add_wrap,
            .add_sat,
            .array_cat,
            .array_mult,
            .assign,
            .assign_destructure,
            .assign_bit_and,
            .assign_bit_or,
            .assign_shl,
            .assign_shl_sat,
            .assign_shr,
            .assign_bit_xor,
            .assign_div,
            .assign_sub,
            .assign_sub_wrap,
            .assign_sub_sat,
            .assign_mod,
            .assign_add,
            .assign_add_wrap,
            .assign_add_sat,
            .assign_mul,
            .assign_mul_wrap,
            .assign_mul_sat,
            .bang_equal,
            .bit_and,
            .bit_or,
            .shl,
            .shl_sat,
            .shr,
            .bit_xor,
            .bool_and,
            .bool_or,
            .div,
            .equal_equal,
            .error_union,
            .greater_or_equal,
            .greater_than,
            .less_or_equal,
            .less_than,
            .merge_error_sets,
            .mod,
            .mul,
            .mul_wrap,
            .mul_sat,
            .switch_range,
            .for_range,
            .field_access,
            .sub,
            .sub_wrap,
            .sub_sat,
            .slice,
            .slice_open,
            .slice_sentinel,
            .deref,
            .array_access,
            .error_value,
            .while_simple,
            .while_cont,
            .for_simple,
            .if_simple,
            .@&quot;catch&quot;,
            .@&quot;orelse&quot;,
            .array_init_one,
            .array_init_one_comma,
            .array_init_dot_two,
            .array_init_dot_two_comma,
            .array_init_dot,
            .array_init_dot_comma,
            .array_init,
            .array_init_comma,
            .struct_init_one,
            .struct_init_one_comma,
            .struct_init_dot_two,
            .struct_init_dot_two_comma,
            .struct_init_dot,
            .struct_init_dot_comma,
            .struct_init,
            .struct_init_comma,
            .@&quot;while&quot;,
            .@&quot;if&quot;,
            .@&quot;for&quot;,
            .@&quot;switch&quot;,
            .switch_comma,
            .call_one,
            .call_one_comma,
            .async_call_one,
            .async_call_one_comma,
            .call,
            .call_comma,
            .async_call,
            .async_call_comma,
            .block_two,
            .block_two_semicolon,
            .block,
            .block_semicolon,
            .builtin_call,
            .builtin_call_comma,
            .builtin_call_two,
            .builtin_call_two_comma,
            .ptr_type_aligned,
            .ptr_type_sentinel,
            .ptr_type,
            .ptr_type_bit_range,
            .optional_type,
            .anyframe_type,
            .array_type_sentinel,
            =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,<span class="tok-comment">

            // these are function bodies, not pointers
            </span>.fn_proto_simple,
            .fn_proto_multi,
            .fn_proto_one,
            .fn_proto,
            =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,<span class="tok-comment">

            // Forward the question to the LHS sub-expression.
            </span>.grouped_expression,
            .@&quot;try&quot;,
            .@&quot;await&quot;,
            .@&quot;comptime&quot;,
            .@&quot;nosuspend&quot;,
            .unwrap_optional,
            =&gt; node = node_datas[node].lhs,

            .identifier =&gt; {
                <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
                <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(main_tokens[node]);
                <span class="tok-kw">if</span> (<a href="std.zig.AstGen.html#std.zig.AstGen.primitive_instrs">primitive_instrs</a>.<a href="#">get</a>(ident_bytes)) |primitive| <span class="tok-kw">switch</span> (primitive) {
                    .anyerror_type,
                    .anyframe_type,
                    .anyopaque_type,
                    .bool_type,
                    .c_int_type,
                    .c_long_type,
                    .c_longdouble_type,
                    .c_longlong_type,
                    .c_char_type,
                    .c_short_type,
                    .c_uint_type,
                    .c_ulong_type,
                    .c_ulonglong_type,
                    .c_ushort_type,
                    .f16_type,
                    .f32_type,
                    .f64_type,
                    .f80_type,
                    .f128_type,
                    .i16_type,
                    .i32_type,
                    .i64_type,
                    .i128_type,
                    .i8_type,
                    .isize_type,
                    .u16_type,
                    .u29_type,
                    .u32_type,
                    .u64_type,
                    .u128_type,
                    .u1_type,
                    .u8_type,
                    .usize_type,
                    .void_type,
                    .bool_false,
                    .bool_true,
                    .null_value,
                    .undef,
                    .noreturn_type,
                    =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,

                    .comptime_float_type,
                    .comptime_int_type,
                    .type_type,
                    =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // that's all the values from `primitives`.
                </span>} <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            },
        }
    }
}

<span class="tok-comment">/// Returns `true` if the node uses `gz.anon_name_strategy`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">nodeUsesAnonNameStrategy</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">switch</span> (node_tags[node]) {
        .container_decl,
        .container_decl_trailing,
        .container_decl_two,
        .container_decl_two_trailing,
        .container_decl_arg,
        .container_decl_arg_trailing,
        .tagged_union,
        .tagged_union_trailing,
        .tagged_union_two,
        .tagged_union_two_trailing,
        .tagged_union_enum_tag,
        .tagged_union_enum_tag_trailing,
        =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
        .builtin_call_two, .builtin_call_two_comma, .builtin_call, .builtin_call_comma =&gt; {
            <span class="tok-kw">const</span> builtin_token = tree.nodes.items(.main_token)[node];
            <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, builtin_name, <span class="tok-str">&quot;@Type&quot;</span>);
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    }
}

<span class="tok-comment">/// Applies `rl` semantics to `result`. Expressions which do not do their own handling of</span>
<span class="tok-comment">/// result locations must call this function on their result.</span>
<span class="tok-comment">/// As an example, if `ri.rl` is `.ptr`, it will write the result to the pointer.</span>
<span class="tok-comment">/// If `ri.rl` is `.ty`, it will coerce the result to the type.</span>
<span class="tok-comment">/// Assumes nothing stacked on `gz`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">rvalue</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    raw_result: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalueInner">rvalueInner</a>(gz, ri, raw_result, src_node, <span class="tok-null">true</span>);
}

<span class="tok-comment">/// Like `rvalue`, but refuses to perform coercions before taking references for</span>
<span class="tok-comment">/// the `ref_coerced_ty` result type. This is used for local variables which do</span>
<span class="tok-comment">/// not have `alloc`s, because we want variables to have consistent addresses,</span>
<span class="tok-comment">/// i.e. we want them to act like lvalues.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">rvalueNoCoercePreRef</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    raw_result: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.rvalueInner">rvalueInner</a>(gz, ri, raw_result, src_node, <span class="tok-null">false</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">rvalueInner</span>(
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>,
    raw_result: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    allow_coerce_pre_ref: <span class="tok-type">bool</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
    <span class="tok-kw">const</span> result = r: {
        <span class="tok-kw">if</span> (raw_result.toIndex()) |result_index| {
            <span class="tok-kw">const</span> zir_tags = gz.astgen.instructions.items(.tag);
            <span class="tok-kw">const</span> data = gz.astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(result_index)];
            <span class="tok-kw">if</span> (zir_tags[<span class="tok-builtin">@intFromEnum</span>(result_index)].isAlwaysVoid(data)) {
                <span class="tok-kw">break</span> :r <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">void_value</a>;
            }
        }
        <span class="tok-kw">break</span> :r raw_result;
    };
    <span class="tok-kw">if</span> (gz.endsWithNoReturn()) <span class="tok-kw">return</span> result;
    <span class="tok-kw">switch</span> (ri.rl) {
        .none, .coerced_ty =&gt; <span class="tok-kw">return</span> result,
        .discard =&gt; {<span class="tok-comment">
            // Emit a compile error for discarding error values.
            </span>_ = <span class="tok-kw">try</span> gz.addUnNode(.ensure_result_non_error, result, src_node);
            <span class="tok-kw">return</span> .void_value;
        },
        .ref, .ref_coerced_ty =&gt; {
            <span class="tok-kw">const</span> coerced_result = <span class="tok-kw">if</span> (allow_coerce_pre_ref <span class="tok-kw">and</span> ri.rl == .ref_coerced_ty) res: {
                <span class="tok-kw">const</span> ptr_ty = ri.rl.ref_coerced_ty;
                <span class="tok-kw">break</span> :res <span class="tok-kw">try</span> gz.addPlNode(.coerce_ptr_elem_ty, src_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                    .lhs = ptr_ty,
                    .rhs = result,
                });
            } <span class="tok-kw">else</span> result;<span class="tok-comment">
            // We need a pointer but we have a value.
            // Unfortunately it's not quite as simple as directly emitting a ref
            // instruction here because we need subsequent address-of operator on
            // const locals to return the same address.
            </span><span class="tok-kw">const</span> astgen = gz.astgen;
            <span class="tok-kw">const</span> tree = astgen.tree;
            <span class="tok-kw">const</span> src_token = tree.firstToken(src_node);
            <span class="tok-kw">const</span> result_index = coerced_result.toIndex() <span class="tok-kw">orelse</span>
                <span class="tok-kw">return</span> gz.addUnTok(.ref, coerced_result, src_token);
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.ref_table.getOrPut(astgen.gpa, result_index);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.value_ptr.* = <span class="tok-kw">try</span> gz.makeUnTok(.ref, coerced_result, src_token);
            }
            <span class="tok-kw">return</span> gop.value_ptr.*.toRef();
        },
        .ty =&gt; |ty_inst| {<span class="tok-comment">
            // Quickly eliminate some common, unnecessary type coercion.
            </span><span class="tok-kw">const</span> as_ty = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">type_type</a>)) &lt;&lt; <span class="tok-number">32</span>;
            <span class="tok-kw">const</span> as_bool = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">bool_type</a>)) &lt;&lt; <span class="tok-number">32</span>;
            <span class="tok-kw">const</span> as_void = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">void_type</a>)) &lt;&lt; <span class="tok-number">32</span>;
            <span class="tok-kw">const</span> as_comptime_int = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">comptime_int_type</a>)) &lt;&lt; <span class="tok-number">32</span>;
            <span class="tok-kw">const</span> as_usize = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">usize_type</a>)) &lt;&lt; <span class="tok-number">32</span>;
            <span class="tok-kw">const</span> as_u8 = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">u8_type</a>)) &lt;&lt; <span class="tok-number">32</span>;
            <span class="tok-kw">switch</span> ((<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(ty_inst)) &lt;&lt; <span class="tok-number">32</span>) | <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(result))) {
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">u1_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">u8_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">i8_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">u16_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">u29_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">i16_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">u32_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">i32_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">u64_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">i64_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">u128_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">i128_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">usize_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">isize_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_char_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_short_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_ushort_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_int_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_uint_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_long_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_ulong_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_longlong_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_ulonglong_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">c_longdouble_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">f16_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">f32_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">f64_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">f80_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">f128_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">anyopaque_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">bool_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">void_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">type_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">anyerror_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">comptime_int_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">comptime_float_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">noreturn_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">anyframe_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">null_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">undefined_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">enum_literal_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">manyptr_u8_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">manyptr_const_u8_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">manyptr_const_u8_sentinel_0_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">single_const_pointer_to_comptime_int_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">slice_const_u8_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">slice_const_u8_sentinel_0_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">anyerror_void_error_union_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">generic_poison_type</a>),
                as_ty | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">empty_tuple_type</a>),
                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero</a>),
                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one</a>),
                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">negative_one</a>),
                as_usize | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero_usize</a>),
                as_usize | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one_usize</a>),
                as_u8 | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero_u8</a>),
                as_u8 | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one_u8</a>),
                as_u8 | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">four_u8</a>),
                as_bool | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">bool_true</a>),
                as_bool | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">bool_false</a>),
                as_void | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">void_value</a>),
                =&gt; <span class="tok-kw">return</span> result,<span class="tok-comment"> // type of result is already correct

                </span>as_usize | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero</a>) =&gt; <span class="tok-kw">return</span> .zero_usize,
                as_u8 | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero</a>) =&gt; <span class="tok-kw">return</span> .zero_u8,
                as_usize | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one</a>) =&gt; <span class="tok-kw">return</span> .one_usize,
                as_u8 | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one</a>) =&gt; <span class="tok-kw">return</span> .one_u8,
                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero_usize</a>) =&gt; <span class="tok-kw">return</span> .zero,
                as_u8 | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero_usize</a>) =&gt; <span class="tok-kw">return</span> .zero_u8,
                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one_usize</a>) =&gt; <span class="tok-kw">return</span> .one,
                as_u8 | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one_usize</a>) =&gt; <span class="tok-kw">return</span> .one_u8,
                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero_u8</a>) =&gt; <span class="tok-kw">return</span> .zero,
                as_usize | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">zero_u8</a>) =&gt; <span class="tok-kw">return</span> .zero_usize,
                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one_u8</a>) =&gt; <span class="tok-kw">return</span> .one,
                as_usize | <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>.<a href="#">one_u8</a>) =&gt; <span class="tok-kw">return</span> .one_usize,<span class="tok-comment">

                // Need an explicit type coercion instruction.
                </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> gz.addPlNode(ri.zirTag(), src_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.As.html">As</a>{
                    .dest_type = ty_inst,
                    .operand = result,
                }),
            }
        },
        .ptr =&gt; |ptr_res| {
            _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, ptr_res.src_node <span class="tok-kw">orelse</span> src_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                .lhs = ptr_res.inst,
                .rhs = result,
            });
            <span class="tok-kw">return</span> .void_value;
        },
        .inferred_ptr =&gt; |alloc| {
            _ = <span class="tok-kw">try</span> gz.addPlNode(.store_to_inferred_ptr, src_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                .lhs = alloc,
                .rhs = result,
            });
            <span class="tok-kw">return</span> .void_value;
        },
        .destructure =&gt; |destructure| {
            <span class="tok-kw">const</span> components = destructure.components;
            _ = <span class="tok-kw">try</span> gz.addPlNode(.validate_destructure, src_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.ValidateDestructure.html">ValidateDestructure</a>{
                .operand = result,
                .destructure_node = gz.nodeIndexToRelative(destructure.src_node),
                .expect_len = <span class="tok-builtin">@intCast</span>(components.len),
            });
            <span class="tok-kw">for</span> (components, <span class="tok-number">0</span>..) |component, i| {
                <span class="tok-kw">if</span> (component == .discard) <span class="tok-kw">continue</span>;
                <span class="tok-kw">const</span> elem_val = <span class="tok-kw">try</span> gz.add(.{
                    .tag = .elem_val_imm,
                    .data = .{ .elem_val_imm = .{
                        .operand = result,
                        .idx = <span class="tok-builtin">@intCast</span>(i),
                    } },
                });
                <span class="tok-kw">switch</span> (component) {
                    .typed_ptr =&gt; |ptr_res| {
                        _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, ptr_res.src_node <span class="tok-kw">orelse</span> src_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                            .lhs = ptr_res.inst,
                            .rhs = elem_val,
                        });
                    },
                    .inferred_ptr =&gt; |ptr_inst| {
                        _ = <span class="tok-kw">try</span> gz.addPlNode(.store_to_inferred_ptr, src_node, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Bin.html">Bin</a>{
                            .lhs = ptr_inst,
                            .rhs = elem_val,
                        });
                    },
                    .discard =&gt; <span class="tok-kw">unreachable</span>,
                }
            }
            <span class="tok-kw">return</span> .void_value;
        },
    }
}

<span class="tok-comment">/// Given an identifier token, obtain the string for it.</span>
<span class="tok-comment">/// If the token uses @&quot;&quot; syntax, parses as a string, reports errors if applicable,</span>
<span class="tok-comment">/// and allocates the result within `astgen.arena`.</span>
<span class="tok-comment">/// Otherwise, returns a reference to the source code bytes directly.</span>
<span class="tok-comment">/// See also `appendIdentStr` and `parseStrLit`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">identifierTokenString</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <a href="std.debug.html#std.debug.assert">assert</a>(token_tags[token] == .identifier);
    <span class="tok-kw">const</span> ident_name = tree.tokenSlice(token);
    <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;@&quot;</span>)) {
        <span class="tok-kw">return</span> ident_name;
    }
    <span class="tok-kw">var</span> buf: <a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty;
    <span class="tok-kw">defer</span> buf.deinit(astgen.gpa);
    <span class="tok-kw">try</span> astgen.parseStrLit(token, &amp;buf, ident_name, <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, buf.items, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {
        <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;identifier cannot contain null bytes&quot;</span>, .{});
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buf.items.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;identifier cannot be empty&quot;</span>, .{});
    }
    <span class="tok-kw">const</span> duped = <span class="tok-kw">try</span> astgen.arena.dupe(<span class="tok-type">u8</span>, buf.items);
    <span class="tok-kw">return</span> duped;
}

<span class="tok-comment">/// Given an identifier token, obtain the string for it (possibly parsing as a string</span>
<span class="tok-comment">/// literal if it is @&quot;&quot; syntax), and append the string to `buf`.</span>
<span class="tok-comment">/// See also `identifierTokenString` and `parseStrLit`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">appendIdentStr</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    buf: *<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <a href="std.debug.html#std.debug.assert">assert</a>(token_tags[token] == .identifier);
    <span class="tok-kw">const</span> ident_name = tree.tokenSlice(token);
    <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;@&quot;</span>)) {
        <span class="tok-kw">return</span> buf.appendSlice(astgen.gpa, ident_name);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> start = buf.items.len;
        <span class="tok-kw">try</span> astgen.parseStrLit(token, buf, ident_name, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> slice = buf.items[start..];
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;identifier cannot contain null bytes&quot;</span>, .{});
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;identifier cannot be empty&quot;</span>, .{});
        }
    }
}

<span class="tok-comment">/// Appends the result to `buf`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">parseStrLit</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    buf: *<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
    bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    offset: <span class="tok-type">u32</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> raw_string = bytes[offset..];
    <span class="tok-kw">var</span> buf_managed = buf.toManaged(astgen.gpa);
    <span class="tok-kw">const</span> result = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.string_literal.html">string_literal</a>.<a href="std.zig.string_literal.html#std.zig.string_literal.parseWrite">parseWrite</a>(buf_managed.writer(), raw_string);
    buf.* = buf_managed.moveToUnmanaged();
    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> result) {
        .success =&gt; <span class="tok-kw">return</span>,
        .failure =&gt; |err| <span class="tok-kw">return</span> astgen.failWithStrLitError(err, token, bytes, offset),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">failWithStrLitError</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    err: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.string_literal.html">string_literal</a>.<a href="std.zig.string_literal.Error.html">Error</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    offset: <span class="tok-type">u32</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a> {
    <span class="tok-kw">const</span> raw_string = bytes[offset..];
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.failOff">failOff</a>(
        astgen,
        token,
        <span class="tok-builtin">@intCast</span>(offset + err.offset()),
        <span class="tok-str">&quot;{}&quot;</span>,
        .{err.fmt(raw_string)},
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">failNode</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a> {
    <span class="tok-kw">return</span> astgen.failNodeNotes(node, format, args, &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{});
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendErrorNode</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> astgen.appendErrorNodeNotes(node, format, args, &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{});
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendErrorNodeNotes</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;
    <span class="tok-kw">const</span> msg: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = <span class="tok-builtin">@enumFromInt</span>(string_bytes.items.len);
    <span class="tok-kw">try</span> string_bytes.writer(astgen.gpa).print(format ++ <span class="tok-str">&quot;\x00&quot;</span>, args);
    <span class="tok-kw">const</span> notes_index: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (notes.len != <span class="tok-number">0</span>) blk: {
        <span class="tok-kw">const</span> notes_start = astgen.extra.items.len;
        <span class="tok-kw">try</span> astgen.extra.ensureTotalCapacity(astgen.gpa, notes_start + <span class="tok-number">1</span> + notes.len);
        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(notes.len));
        astgen.extra.appendSliceAssumeCapacity(notes);
        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@intCast</span>(notes_start);
    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">try</span> astgen.compile_errors.append(astgen.gpa, .{
        .msg = msg,
        .node = node,
        .token = <span class="tok-number">0</span>,
        .byte_offset = <span class="tok-number">0</span>,
        .notes = notes_index,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">failNodeNotes</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.appendErrorNodeNotes">appendErrorNodeNotes</a>(astgen, node, format, args, notes);
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;
}

<span class="tok-kw">fn</span> <span class="tok-fn">failTok</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a> {
    <span class="tok-kw">return</span> astgen.failTokNotes(token, format, args, &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{});
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendErrorTok</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> astgen.appendErrorTokNotesOff(token, <span class="tok-number">0</span>, format, args, &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{});
}

<span class="tok-kw">fn</span> <span class="tok-fn">failTokNotes</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.appendErrorTokNotesOff">appendErrorTokNotesOff</a>(astgen, token, <span class="tok-number">0</span>, format, args, notes);
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendErrorTokNotes</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.appendErrorTokNotesOff">appendErrorTokNotesOff</a>(astgen, token, <span class="tok-number">0</span>, format, args, notes);
}

<span class="tok-comment">/// Same as `fail`, except given a token plus an offset from its starting byte</span>
<span class="tok-comment">/// offset.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">failOff</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    byte_offset: <span class="tok-type">u32</span>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <a href="std.zig.AstGen.html#std.zig.AstGen.InnerError">InnerError</a> {
    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.appendErrorTokNotesOff">appendErrorTokNotesOff</a>(astgen, token, byte_offset, format, args, &amp;.{});
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendErrorTokNotesOff</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    byte_offset: <span class="tok-type">u32</span>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;
    <span class="tok-kw">const</span> msg: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = <span class="tok-builtin">@enumFromInt</span>(string_bytes.items.len);
    <span class="tok-kw">try</span> string_bytes.writer(gpa).print(format ++ <span class="tok-str">&quot;\x00&quot;</span>, args);
    <span class="tok-kw">const</span> notes_index: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (notes.len != <span class="tok-number">0</span>) blk: {
        <span class="tok-kw">const</span> notes_start = astgen.extra.items.len;
        <span class="tok-kw">try</span> astgen.extra.ensureTotalCapacity(gpa, notes_start + <span class="tok-number">1</span> + notes.len);
        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(notes.len));
        astgen.extra.appendSliceAssumeCapacity(notes);
        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@intCast</span>(notes_start);
    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">try</span> astgen.compile_errors.append(gpa, .{
        .msg = msg,
        .node = <span class="tok-number">0</span>,
        .token = token,
        .byte_offset = byte_offset,
        .notes = notes_index,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">errNoteTok</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.errNoteTokOff">errNoteTokOff</a>(astgen, token, <span class="tok-number">0</span>, format, args);
}

<span class="tok-kw">fn</span> <span class="tok-fn">errNoteTokOff</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    byte_offset: <span class="tok-type">u32</span>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">u32</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;
    <span class="tok-kw">const</span> msg: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = <span class="tok-builtin">@enumFromInt</span>(string_bytes.items.len);
    <span class="tok-kw">try</span> string_bytes.writer(astgen.gpa).print(format ++ <span class="tok-str">&quot;\x00&quot;</span>, args);
    <span class="tok-kw">return</span> astgen.addExtra(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CompileErrors.html">CompileErrors</a>.<a href="std.zig.Zir.Inst.CompileErrors.Item.html">Item</a>{
        .msg = msg,
        .node = <span class="tok-number">0</span>,
        .token = token,
        .byte_offset = byte_offset,
        .notes = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">errNoteNode</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">u32</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;
    <span class="tok-kw">const</span> msg: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = <span class="tok-builtin">@enumFromInt</span>(string_bytes.items.len);
    <span class="tok-kw">try</span> string_bytes.writer(astgen.gpa).print(format ++ <span class="tok-str">&quot;\x00&quot;</span>, args);
    <span class="tok-kw">return</span> astgen.addExtra(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.CompileErrors.html">CompileErrors</a>.<a href="std.zig.Zir.Inst.CompileErrors.Item.html">Item</a>{
        .msg = msg,
        .node = node,
        .token = <span class="tok-number">0</span>,
        .byte_offset = <span class="tok-number">0</span>,
        .notes = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">identAsString</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, ident_token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> {
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;
    <span class="tok-kw">const</span> str_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(string_bytes.items.len);
    <span class="tok-kw">try</span> astgen.appendIdentStr(ident_token, string_bytes);
    <span class="tok-kw">const</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = string_bytes.items[str_index..];
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.string_table.getOrPutContextAdapted(gpa, key, <a href="std.hash_map.StringIndexAdapter.html">StringIndexAdapter</a>{
        .bytes = string_bytes,
    }, <a href="std.hash_map.StringIndexContext.html">StringIndexContext</a>{
        .bytes = string_bytes,
    });
    <span class="tok-kw">if</span> (gop.found_existing) {
        string_bytes.shrinkRetainingCapacity(str_index);
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.key_ptr.*);
    } <span class="tok-kw">else</span> {
        gop.key_ptr.* = str_index;
        <span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(str_index);
    }
}

<span class="tok-kw">const</span> IndexSlice = <span class="tok-kw">struct</span> { index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, len: <span class="tok-type">u32</span> };

<span class="tok-kw">fn</span> <span class="tok-fn">strLitAsString</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, str_lit_token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) !<a href="std.zig.AstGen.IndexSlice.html">IndexSlice</a> {
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;
    <span class="tok-kw">const</span> str_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(string_bytes.items.len);
    <span class="tok-kw">const</span> token_bytes = astgen.tree.tokenSlice(str_lit_token);
    <span class="tok-kw">try</span> astgen.parseStrLit(str_lit_token, string_bytes, token_bytes, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = string_bytes.items[str_index..];
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, key, <span class="tok-number">0</span>)) |_| <span class="tok-kw">return</span> .{
        .index = <span class="tok-builtin">@enumFromInt</span>(str_index),
        .len = <span class="tok-builtin">@intCast</span>(key.len),
    };
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.string_table.getOrPutContextAdapted(gpa, key, <a href="std.hash_map.StringIndexAdapter.html">StringIndexAdapter</a>{
        .bytes = string_bytes,
    }, <a href="std.hash_map.StringIndexContext.html">StringIndexContext</a>{
        .bytes = string_bytes,
    });
    <span class="tok-kw">if</span> (gop.found_existing) {
        string_bytes.shrinkRetainingCapacity(str_index);
        <span class="tok-kw">return</span> .{
            .index = <span class="tok-builtin">@enumFromInt</span>(gop.key_ptr.*),
            .len = <span class="tok-builtin">@intCast</span>(key.len),
        };
    } <span class="tok-kw">else</span> {
        gop.key_ptr.* = str_index;<span class="tok-comment">
        // Still need a null byte because we are using the same table
        // to lookup null terminated strings, so if we get a match, it has to
        // be null terminated for that to work.
        </span><span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> .{
            .index = <span class="tok-builtin">@enumFromInt</span>(str_index),
            .len = <span class="tok-builtin">@intCast</span>(key.len),
        };
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">strLitNodeAsString</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !<a href="std.zig.AstGen.IndexSlice.html">IndexSlice</a> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);

    <span class="tok-kw">const</span> start = node_datas[node].lhs;
    <span class="tok-kw">const</span> end = node_datas[node].rhs;

    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;
    <span class="tok-kw">const</span> str_index = string_bytes.items.len;<span class="tok-comment">

    // First line: do not append a newline.
    </span><span class="tok-kw">var</span> tok_i = start;
    {
        <span class="tok-kw">const</span> slice = tree.tokenSlice(tok_i);
        <span class="tok-kw">const</span> line_bytes = slice[<span class="tok-number">2</span>..];
        <span class="tok-kw">try</span> string_bytes.appendSlice(gpa, line_bytes);
        tok_i += <span class="tok-number">1</span>;
    }<span class="tok-comment">
    // Following lines: each line prepends a newline.
    </span><span class="tok-kw">while</span> (tok_i &lt;= end) : (tok_i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> slice = tree.tokenSlice(tok_i);
        <span class="tok-kw">const</span> line_bytes = slice[<span class="tok-number">2</span>..];
        <span class="tok-kw">try</span> string_bytes.ensureUnusedCapacity(gpa, line_bytes.len + <span class="tok-number">1</span>);
        string_bytes.appendAssumeCapacity(<span class="tok-str">'\n'</span>);
        string_bytes.appendSliceAssumeCapacity(line_bytes);
    }
    <span class="tok-kw">const</span> len = string_bytes.items.len - str_index;
    <span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.IndexSlice.html">IndexSlice</a>{
        .index = <span class="tok-builtin">@enumFromInt</span>(str_index),
        .len = <span class="tok-builtin">@intCast</span>(len),
    };
}

<span class="tok-kw">const</span> Scope = <span class="tok-kw">struct</span> {
    tag: <a href="std.zig.AstGen.Scope.Tag.html">Tag</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">cast</span>(base: *<a href="std.zig.AstGen.Scope.html">Scope</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) ?*T {
        <span class="tok-kw">if</span> (T == <a href="std.zig.AstGen.Scope.Defer.html">Defer</a>) {
            <span class="tok-kw">switch</span> (base.tag) {
                .defer_normal, .defer_error =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;base&quot;</span>, base)),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
            }
        }
        <span class="tok-kw">if</span> (T == <a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>) {
            <span class="tok-kw">switch</span> (base.tag) {
                .namespace =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;base&quot;</span>, base)),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
            }
        }
        <span class="tok-kw">if</span> (base.tag != T.base_tag)
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;

        <span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;base&quot;</span>, base));
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parent</span>(base: *<a href="std.zig.AstGen.Scope.html">Scope</a>) ?*<a href="std.zig.AstGen.Scope.html">Scope</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (base.tag) {
            .gen_zir =&gt; base.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?.parent,
            .local_val =&gt; base.cast(<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?.parent,
            .local_ptr =&gt; base.cast(<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?.parent,
            .defer_normal, .defer_error =&gt; base.cast(<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
            .namespace =&gt; base.cast(<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>).?.parent,
            .top =&gt; <span class="tok-null">null</span>,
        };
    }

    <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span> {
        gen_zir,
        local_val,
        local_ptr,
        defer_normal,
        defer_error,
        namespace,
        top,
    };

    <span class="tok-comment">/// The category of identifier. These tag names are user-visible in compile errors.</span>
    <span class="tok-kw">const</span> IdCat = <span class="tok-kw">enum</span> {
        @&quot;function parameter&quot;,
        @&quot;local constant&quot;,
        @&quot;local variable&quot;,
        @&quot;switch tag capture&quot;,
        capture,
    };

    <span class="tok-comment">/// This is always a `const` local and importantly the `inst` is a value type, not a pointer.</span>
    <span class="tok-comment">/// This structure lives as long as the AST generation of the Block</span>
    <span class="tok-comment">/// node that contains the variable.</span>
    <span class="tok-kw">const</span> LocalVal = <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> base_tag: <a href="std.zig.AstGen.Scope.Tag.html">Tag</a> = .local_val;
        base: <a href="std.zig.AstGen.Scope.html">Scope</a> = <a href="std.zig.AstGen.Scope.html">Scope</a>{ .tag = <a href="std.zig.AstGen.Scope.LocalVal.html#std.zig.AstGen.Scope.LocalVal.base_tag">base_tag</a> },
        <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span>
        parent: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
        gen_zir: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Source location of the corresponding variable declaration.</span>
        token_src: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Track the first identifier where it is referenced.</span>
        <span class="tok-comment">/// 0 means never referenced.</span>
        used: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>,
        <span class="tok-comment">/// Track the identifier where it is discarded, like this `_ = foo;`.</span>
        <span class="tok-comment">/// 0 means never discarded.</span>
        discarded: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>,
        is_used_or_discarded: ?*<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
        <span class="tok-comment">/// String table index.</span>
        name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
        id_cat: <a href="std.zig.AstGen.Scope.IdCat.html">IdCat</a>,
    };

    <span class="tok-comment">/// This could be a `const` or `var` local. It has a pointer instead of a value.</span>
    <span class="tok-comment">/// This structure lives as long as the AST generation of the Block</span>
    <span class="tok-comment">/// node that contains the variable.</span>
    <span class="tok-kw">const</span> LocalPtr = <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> base_tag: <a href="std.zig.AstGen.Scope.Tag.html">Tag</a> = .local_ptr;
        base: <a href="std.zig.AstGen.Scope.html">Scope</a> = <a href="std.zig.AstGen.Scope.html">Scope</a>{ .tag = <a href="std.zig.AstGen.Scope.LocalPtr.html#std.zig.AstGen.Scope.LocalPtr.base_tag">base_tag</a> },
        <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span>
        parent: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
        gen_zir: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        ptr: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Source location of the corresponding variable declaration.</span>
        token_src: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Track the first identifier where it is referenced.</span>
        <span class="tok-comment">/// 0 means never referenced.</span>
        used: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>,
        <span class="tok-comment">/// Track the identifier where it is discarded, like this `_ = foo;`.</span>
        <span class="tok-comment">/// 0 means never discarded.</span>
        discarded: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>,
        <span class="tok-comment">/// Whether this value is used as an lvalue after initialization.</span>
        <span class="tok-comment">/// If not, we know it can be `const`, so will emit a compile error if it is `var`.</span>
        used_as_lvalue: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        <span class="tok-comment">/// String table index.</span>
        name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
        id_cat: <a href="std.zig.AstGen.Scope.IdCat.html">IdCat</a>,
        <span class="tok-comment">/// true means we find out during Sema whether the value is comptime.</span>
        <span class="tok-comment">/// false means it is already known at AstGen the value is runtime-known.</span>
        maybe_comptime: <span class="tok-type">bool</span>,
    };

    <span class="tok-kw">const</span> Defer = <span class="tok-kw">struct</span> {
        base: <a href="std.zig.AstGen.Scope.html">Scope</a>,
        <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span>
        parent: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
        index: <span class="tok-type">u32</span>,
        len: <span class="tok-type">u32</span>,
        remapped_err_code: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.OptionalIndex.html">OptionalIndex</a> = .none,
    };

    <span class="tok-comment">/// Represents a global scope that has any number of declarations in it.</span>
    <span class="tok-comment">/// Each declaration has this as the parent scope.</span>
    <span class="tok-kw">const</span> Namespace = <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> base_tag: <a href="std.zig.AstGen.Scope.Tag.html">Tag</a> = .namespace;
        base: <a href="std.zig.AstGen.Scope.html">Scope</a> = <a href="std.zig.AstGen.Scope.html">Scope</a>{ .tag = <a href="std.zig.AstGen.Scope.Namespace.html#std.zig.AstGen.Scope.Namespace.base_tag">base_tag</a> },

        <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span>
        parent: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
        <span class="tok-comment">/// Maps string table index to the source location of declaration,</span>
        <span class="tok-comment">/// for the purposes of reporting name shadowing compile errors.</span>
        decls: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) = .empty,
        node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        maybe_generic: <span class="tok-type">bool</span>,

        <span class="tok-comment">/// The astgen scope containing this namespace.</span>
        <span class="tok-comment">/// Only valid during astgen.</span>
        declaring_gz: ?*<a href="std.zig.AstGen.GenZir.html">GenZir</a>,

        <span class="tok-comment">/// Set of captures used by this namespace.</span>
        captures: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Capture.html">Capture</a>, <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>) = .empty,

        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.decls.deinit(gpa);
            self.captures.deinit(gpa);
            self.* = <span class="tok-null">undefined</span>;
        }
    };

    <span class="tok-kw">const</span> Top = <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> base_tag: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Tag.html">Tag</a> = .top;
        base: <a href="std.zig.AstGen.Scope.html">Scope</a> = <a href="std.zig.AstGen.Scope.html">Scope</a>{ .tag = <a href="std.zig.AstGen.Scope.Top.html#std.zig.AstGen.Scope.Top.base_tag">base_tag</a> },
    };
};

<span class="tok-comment">/// This is a temporary structure; references to it are valid only</span>
<span class="tok-comment">/// while constructing a `Zir`.</span>
<span class="tok-kw">const</span> GenZir = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> base_tag: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Tag.html">Tag</a> = .gen_zir;
    base: <a href="std.zig.AstGen.Scope.html">Scope</a> = <a href="std.zig.AstGen.Scope.html">Scope</a>{ .tag = <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.base_tag">base_tag</a> },
    <span class="tok-comment">/// Whether we're already in a scope known to be comptime. This is set</span>
    <span class="tok-comment">/// whenever we know Sema will analyze the current block with `is_comptime`,</span>
    <span class="tok-comment">/// for instance when we're within a `struct_decl` or a `block_comptime`.</span>
    is_comptime: <span class="tok-type">bool</span>,
    <span class="tok-comment">/// Whether we're in an expression within a `@TypeOf` operand. In this case, closure of runtime</span>
    <span class="tok-comment">/// variables is permitted where it is usually not.</span>
    is_typeof: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    <span class="tok-comment">/// This is set to true for a `GenZir` of a `block_inline`, indicating that</span>
    <span class="tok-comment">/// exits from this block should use `break_inline` rather than `break`.</span>
    is_inline: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    c_import: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    <span class="tok-comment">/// How decls created in this scope should be named.</span>
    anon_name_strategy: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.NameStrategy.html">NameStrategy</a> = .anon,
    <span class="tok-comment">/// The containing decl AST node.</span>
    decl_node_index: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    <span class="tok-comment">/// The containing decl line index, absolute.</span>
    decl_line: <span class="tok-type">u32</span>,
    <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span>
    parent: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    <span class="tok-comment">/// All `GenZir` scopes for the same ZIR share this.</span>
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    <span class="tok-comment">/// Keeps track of the list of instructions in this scope. Possibly shared.</span>
    <span class="tok-comment">/// Indexes to instructions in `astgen`.</span>
    instructions: *<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>),
    <span class="tok-comment">/// A sub-block may share its instructions ArrayList with containing GenZir,</span>
    <span class="tok-comment">/// if use is strictly nested. This saves prior size of list for unstacking.</span>
    instructions_top: <span class="tok-type">usize</span>,
    label: ?<a href="std.zig.AstGen.GenZir.Label.html">Label</a> = <span class="tok-null">null</span>,
    break_block: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.OptionalIndex.html">OptionalIndex</a> = .none,
    continue_block: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.OptionalIndex.html">OptionalIndex</a> = .none,
    <span class="tok-comment">/// Only valid when setBreakResultInfo is called.</span>
    break_result_info: <a href="std.zig.AstGen.html">AstGen</a>.<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-null">undefined</span>,
    continue_result_info: <a href="std.zig.AstGen.html">AstGen</a>.<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a> = <span class="tok-null">undefined</span>,

    suspend_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>,
    nosuspend_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>,
    <span class="tok-comment">/// Set if this GenZir is a defer.</span>
    cur_defer_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>,<span class="tok-comment">
    // Set if this GenZir is a defer or it is inside a defer.
    </span>any_defer_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = <span class="tok-number">0</span>,

    <span class="tok-kw">const</span> unstacked_top = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
    <span class="tok-comment">/// Call unstack before adding any new instructions to containing GenZir.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">unstack</span>(self: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.instructions_top != <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>) {
            self.instructions.items.len = self.instructions_top;
            self.instructions_top = <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>;
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">isEmpty</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.AstGen.GenZir.html">GenZir</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> (self.instructions_top == <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>) <span class="tok-kw">or</span>
            (self.instructions.items.len == self.instructions_top);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">instructionsSlice</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.AstGen.GenZir.html">GenZir</a>) []<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.instructions_top == <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>)
            &amp;[<span class="tok-number">0</span>]<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>{}
        <span class="tok-kw">else</span>
            self.instructions.items[self.instructions_top..];
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">instructionsSliceUpto</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.AstGen.GenZir.html">GenZir</a>, stacked_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>) []<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.instructions_top == <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>)
            &amp;[<span class="tok-number">0</span>]<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>{}
        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (self.instructions == stacked_gz.instructions <span class="tok-kw">and</span> stacked_gz.instructions_top != <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.unstacked_top">unstacked_top</a>)
            self.instructions.items[self.instructions_top..stacked_gz.instructions_top]
        <span class="tok-kw">else</span>
            self.instructions.items[self.instructions_top..];
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">instructionsSliceUptoOpt</span>(gz: *<span class="tok-kw">const</span> <a href="std.zig.AstGen.GenZir.html">GenZir</a>, maybe_stacked_gz: ?*<a href="std.zig.AstGen.GenZir.html">GenZir</a>) []<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">if</span> (maybe_stacked_gz) |stacked_gz| {
            <span class="tok-kw">return</span> gz.instructionsSliceUpto(stacked_gz);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> gz.instructionsSlice();
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">makeSubBlock</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>) <a href="std.zig.AstGen.GenZir.html">GenZir</a> {
        <span class="tok-kw">return</span> .{
            .is_comptime = gz.is_comptime,
            .is_typeof = gz.is_typeof,
            .c_import = gz.c_import,
            .decl_node_index = gz.decl_node_index,
            .decl_line = gz.decl_line,
            .parent = scope,
            .astgen = gz.astgen,
            .suspend_node = gz.suspend_node,
            .nosuspend_node = gz.nosuspend_node,
            .any_defer_node = gz.any_defer_node,
            .instructions = gz.instructions,
            .instructions_top = gz.instructions.items.len,
        };
    }

    <span class="tok-kw">const</span> Label = <span class="tok-kw">struct</span> {
        token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        block_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        used: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        used_for_continue: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    };

    <span class="tok-comment">/// Assumes nothing stacked on `gz`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">endsWithNoReturn</span>(gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (gz.isEmpty()) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">const</span> tags = gz.astgen.instructions.items(.tag);
        <span class="tok-kw">const</span> last_inst = gz.instructions.items[gz.instructions.items.len - <span class="tok-number">1</span>];
        <span class="tok-kw">return</span> tags[<span class="tok-builtin">@intFromEnum</span>(last_inst)].isNoReturn();
    }

    <span class="tok-comment">/// TODO all uses of this should be replaced with uses of `endsWithNoReturn`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">refIsNoReturn</span>(gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (inst_ref == .unreachable_value) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (inst_ref.toIndex()) |inst_index| {
            <span class="tok-kw">return</span> gz.astgen.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(inst_index)].isNoReturn();
        }
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">nodeIndexToRelative</span>(gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a>, node_index: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <span class="tok-type">i32</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@bitCast</span>(node_index)) - <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@bitCast</span>(gz.decl_node_index));
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">tokenIndexToRelative</span>(gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a>, token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <span class="tok-type">u32</span> {
        <span class="tok-kw">return</span> token - gz.srcToken();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">srcToken</span>(gz: <a href="std.zig.AstGen.GenZir.html">GenZir</a>) <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> {
        <span class="tok-kw">return</span> gz.astgen.tree.firstToken(gz.decl_node_index);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">setBreakResultInfo</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, parent_ri: <a href="std.zig.AstGen.html">AstGen</a>.<a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Depending on whether the result location is a pointer or value, different
        // ZIR needs to be generated. In the former case we rely on storing to the
        // pointer to communicate the result, and use breakvoid; in the latter case
        // the block break instructions will have the result values.
        </span><span class="tok-kw">switch</span> (parent_ri.rl) {
            .coerced_ty =&gt; |ty_inst| {<span class="tok-comment">
                // Type coercion needs to happen before breaks.
                </span>gz.break_result_info = .{ .rl = .{ .ty = ty_inst }, .ctx = parent_ri.ctx };
            },
            .discard =&gt; {<span class="tok-comment">
                // We don't forward the result context here. This prevents
                // &quot;unnecessary discard&quot; errors from being caused by expressions
                // far from the actual discard, such as a `break` from a
                // discarded block.
                </span>gz.break_result_info = .{ .rl = .discard };
            },
            <span class="tok-kw">else</span> =&gt; {
                gz.break_result_info = parent_ri;
            },
        }
    }

    <span class="tok-comment">/// Assumes nothing stacked on `gz`. Unstacks `gz`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">setBoolBrBody</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, bool_br: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, bool_br_lhs: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;
        <span class="tok-kw">const</span> body = gz.instructionsSlice();
        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
            gpa,
            <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BoolBr.html">BoolBr</a>).@&quot;struct&quot;.fields.len + body_len,
        );
        <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
        zir_datas[<span class="tok-builtin">@intFromEnum</span>(bool_br)].pl_node.payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BoolBr.html">BoolBr</a>{
            .lhs = bool_br_lhs,
            .body_len = body_len,
        });
        astgen.appendBodyWithFixups(body);
        gz.unstack();
    }

    <span class="tok-comment">/// Assumes nothing stacked on `gz`. Unstacks `gz`.</span>
    <span class="tok-comment">/// Asserts `inst` is not a `block_comptime`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">setBlockBody</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;
        <span class="tok-kw">const</span> body = gz.instructionsSlice();
        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);

        <span class="tok-kw">const</span> zir_tags = astgen.instructions.items(.tag);
        <a href="std.debug.html#std.debug.assert">assert</a>(zir_tags[<span class="tok-builtin">@intFromEnum</span>(inst)] != .block_comptime);<span class="tok-comment"> // use `setComptimeBlockBody` instead

        </span><span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
            gpa,
            <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Block.html">Block</a>).@&quot;struct&quot;.fields.len + body_len,
        );
        <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
        zir_datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index = astgen.addExtraAssumeCapacity(
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Block.html">Block</a>{ .body_len = body_len },
        );
        astgen.appendBodyWithFixups(body);
        gz.unstack();
    }

    <span class="tok-comment">/// Assumes nothing stacked on `gz`. Unstacks `gz`.</span>
    <span class="tok-comment">/// Asserts `inst` is a `block_comptime`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">setBlockComptimeBody</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, comptime_reason: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.SimpleComptimeReason.html">SimpleComptimeReason</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;
        <span class="tok-kw">const</span> body = gz.instructionsSlice();
        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);

        <span class="tok-kw">const</span> zir_tags = astgen.instructions.items(.tag);
        <a href="std.debug.html#std.debug.assert">assert</a>(zir_tags[<span class="tok-builtin">@intFromEnum</span>(inst)] == .block_comptime);<span class="tok-comment"> // use `setBlockBody` instead

        </span><span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
            gpa,
            <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BlockComptime.html">BlockComptime</a>).@&quot;struct&quot;.fields.len + body_len,
        );
        <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
        zir_datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index = astgen.addExtraAssumeCapacity(
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BlockComptime.html">BlockComptime</a>{
                .reason = comptime_reason,
                .body_len = body_len,
            },
        );
        astgen.appendBodyWithFixups(body);
        gz.unstack();
    }

    <span class="tok-comment">/// Assumes nothing stacked on `gz`. Unstacks `gz`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">setTryBody</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;
        <span class="tok-kw">const</span> body = gz.instructionsSlice();
        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
            gpa,
            <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Try.html">Try</a>).@&quot;struct&quot;.fields.len + body_len,
        );
        <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
        zir_datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index = astgen.addExtraAssumeCapacity(
            <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Try.html">Try</a>{
                .operand = operand,
                .body_len = body_len,
            },
        );
        astgen.appendBodyWithFixups(body);
        gz.unstack();
    }

    <span class="tok-comment">/// Must be called with the following stack set up:</span>
    <span class="tok-comment">///  * gz (bottom)</span>
    <span class="tok-comment">///  * ret_gz</span>
    <span class="tok-comment">///  * cc_gz</span>
    <span class="tok-comment">///  * body_gz (top)</span>
    <span class="tok-comment">/// Unstacks all of those except for `gz`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">addFunc</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        args: <span class="tok-kw">struct</span> {
            src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            lbrace_line: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
            lbrace_column: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
            param_block: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,

            ret_gz: ?*<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
            body_gz: ?*<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
            cc_gz: ?*<a href="std.zig.AstGen.GenZir.html">GenZir</a>,

            ret_param_refs: []<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
            param_insts: []<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,<span class="tok-comment"> // refs to params in `body_gz` should still be in `astgen.ref_table`
            </span>ret_ty_is_generic: <span class="tok-type">bool</span>,

            cc_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            ret_ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,

            noalias_bits: <span class="tok-type">u32</span>,
            is_var_args: <span class="tok-type">bool</span>,
            is_inferred_error: <span class="tok-type">bool</span>,
            is_noinline: <span class="tok-type">bool</span>,

            <span class="tok-comment">/// Ignored if `body_gz == null`.</span>
            proto_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a>,
        },
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(args.src_node != <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;
        <span class="tok-kw">const</span> ret_ref = <span class="tok-kw">if</span> (args.ret_ref == .void_type) .none <span class="tok-kw">else</span> args.ret_ref;
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);

        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> body, <span class="tok-kw">const</span> cc_body, <span class="tok-kw">const</span> ret_body = bodies: {
            <span class="tok-kw">var</span> stacked_gz: ?*GenZir = <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> body: []<span class="tok-kw">const</span> Zir.Inst.Index = <span class="tok-kw">if</span> (args.body_gz) |body_gz| body: {
                <span class="tok-kw">const</span> body = body_gz.instructionsSliceUptoOpt(stacked_gz);
                stacked_gz = body_gz;
                <span class="tok-kw">break</span> :body body;
            } <span class="tok-kw">else</span> &amp;.{};
            <span class="tok-kw">const</span> cc_body: []<span class="tok-kw">const</span> Zir.Inst.Index = <span class="tok-kw">if</span> (args.cc_gz) |cc_gz| body: {
                <span class="tok-kw">const</span> cc_body = cc_gz.instructionsSliceUptoOpt(stacked_gz);
                stacked_gz = cc_gz;
                <span class="tok-kw">break</span> :body cc_body;
            } <span class="tok-kw">else</span> &amp;.{};
            <span class="tok-kw">const</span> ret_body: []<span class="tok-kw">const</span> Zir.Inst.Index = <span class="tok-kw">if</span> (args.ret_gz) |ret_gz| body: {
                <span class="tok-kw">const</span> ret_body = ret_gz.instructionsSliceUptoOpt(stacked_gz);
                stacked_gz = ret_gz;
                <span class="tok-kw">break</span> :body ret_body;
            } <span class="tok-kw">else</span> &amp;.{};
            <span class="tok-kw">break</span> :bodies .{ body, cc_body, ret_body };
        };

        <span class="tok-kw">var</span> src_locs_and_hash_buffer: [<span class="tok-number">7</span>]<span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> src_locs_and_hash: []<span class="tok-kw">const</span> <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (args.body_gz != <span class="tok-null">null</span>) src_locs_and_hash: {
            <span class="tok-kw">const</span> tree = astgen.tree;
            <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
            <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);
            <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
            <span class="tok-kw">const</span> fn_decl = args.src_node;
            <a href="std.debug.html#std.debug.assert">assert</a>(node_tags[fn_decl] == .fn_decl <span class="tok-kw">or</span> node_tags[fn_decl] == .test_decl);
            <span class="tok-kw">const</span> block = node_datas[fn_decl].rhs;
            <span class="tok-kw">const</span> rbrace_start = token_starts[tree.lastToken(block)];
            astgen.advanceSourceCursor(rbrace_start);
            <span class="tok-kw">const</span> rbrace_line: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(astgen.source_line - gz.decl_line);
            <span class="tok-kw">const</span> rbrace_column: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(astgen.source_column);

            <span class="tok-kw">const</span> columns = args.lbrace_column | (rbrace_column &lt;&lt; <span class="tok-number">16</span>);

            <span class="tok-kw">const</span> proto_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(args.proto_hash);

            src_locs_and_hash_buffer = .{
                args.lbrace_line,
                rbrace_line,
                columns,
                proto_hash_arr[<span class="tok-number">0</span>],
                proto_hash_arr[<span class="tok-number">1</span>],
                proto_hash_arr[<span class="tok-number">2</span>],
                proto_hash_arr[<span class="tok-number">3</span>],
            };
            <span class="tok-kw">break</span> :src_locs_and_hash &amp;src_locs_and_hash_buffer;
        } <span class="tok-kw">else</span> &amp;.{};

        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixupsExtraRefs(body, args.param_insts);

        <span class="tok-kw">const</span> tag: Zir.Inst.Tag, <span class="tok-kw">const</span> payload_index: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (args.cc_ref != .none <span class="tok-kw">or</span>
            args.is_var_args <span class="tok-kw">or</span> args.noalias_bits != <span class="tok-number">0</span> <span class="tok-kw">or</span> args.is_noinline)
        inst_info: {
            <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
                gpa,
                <span class="tok-builtin">@typeInfo</span>(Zir.Inst.FuncFancy).@&quot;struct&quot;.fields.len +
                    fancyFnExprExtraLen(astgen, &amp;.{}, cc_body, args.cc_ref) +
                    fancyFnExprExtraLen(astgen, args.ret_param_refs, ret_body, ret_ref) +
                    body_len + src_locs_and_hash.len +
                    <span class="tok-builtin">@intFromBool</span>(args.noalias_bits != <span class="tok-number">0</span>),
            );
            <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.FuncFancy{
                .param_block = args.param_block,
                .body_len = body_len,
                .bits = .{
                    .is_var_args = args.is_var_args,
                    .is_inferred_error = args.is_inferred_error,
                    .is_noinline = args.is_noinline,
                    .has_any_noalias = args.noalias_bits != <span class="tok-number">0</span>,

                    .has_cc_ref = args.cc_ref != .none,
                    .has_ret_ty_ref = ret_ref != .none,

                    .has_cc_body = cc_body.len != <span class="tok-number">0</span>,
                    .has_ret_ty_body = ret_body.len != <span class="tok-number">0</span>,

                    .ret_ty_is_generic = args.ret_ty_is_generic,
                },
            });

            <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
            <span class="tok-kw">if</span> (cc_body.len != <span class="tok-number">0</span>) {
                astgen.extra.appendAssumeCapacity(astgen.countBodyLenAfterFixups(cc_body));
                astgen.appendBodyWithFixups(cc_body);
                <span class="tok-kw">const</span> break_extra = zir_datas[<span class="tok-builtin">@intFromEnum</span>(cc_body[cc_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;
                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =
                    <span class="tok-builtin">@intFromEnum</span>(new_index);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (args.cc_ref != .none) {
                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.cc_ref));
            }
            <span class="tok-kw">if</span> (ret_body.len != <span class="tok-number">0</span>) {
                astgen.extra.appendAssumeCapacity(
                    astgen.countBodyLenAfterFixups(args.ret_param_refs) +
                        astgen.countBodyLenAfterFixups(ret_body),
                );
                astgen.appendBodyWithFixups(args.ret_param_refs);
                astgen.appendBodyWithFixups(ret_body);
                <span class="tok-kw">const</span> break_extra = zir_datas[<span class="tok-builtin">@intFromEnum</span>(ret_body[ret_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;
                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =
                    <span class="tok-builtin">@intFromEnum</span>(new_index);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (ret_ref != .none) {
                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(ret_ref));
            }

            <span class="tok-kw">if</span> (args.noalias_bits != <span class="tok-number">0</span>) {
                astgen.extra.appendAssumeCapacity(args.noalias_bits);
            }

            astgen.appendBodyWithFixupsExtraRefsArrayList(&amp;astgen.extra, body, args.param_insts);
            astgen.extra.appendSliceAssumeCapacity(src_locs_and_hash);

            <span class="tok-kw">break</span> :inst_info .{ .func_fancy, payload_index };
        } <span class="tok-kw">else</span> inst_info: {
            <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
                gpa,
                <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Func).@&quot;struct&quot;.fields.len + <span class="tok-number">1</span> +
                    fancyFnExprExtraLen(astgen, args.ret_param_refs, ret_body, ret_ref) +
                    body_len + src_locs_and_hash.len,
            );

            <span class="tok-kw">const</span> ret_body_len = <span class="tok-kw">if</span> (ret_body.len != <span class="tok-number">0</span>)
                countBodyLenAfterFixups(astgen, args.ret_param_refs) + countBodyLenAfterFixups(astgen, ret_body)
            <span class="tok-kw">else</span>
                <span class="tok-builtin">@intFromBool</span>(ret_ref != .none);

            <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.Func{
                .param_block = args.param_block,
                .ret_ty = .{
                    .body_len = <span class="tok-builtin">@intCast</span>(ret_body_len),
                    .is_generic = args.ret_ty_is_generic,
                },
                .body_len = body_len,
            });
            <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);
            <span class="tok-kw">if</span> (ret_body.len != <span class="tok-number">0</span>) {
                astgen.appendBodyWithFixups(args.ret_param_refs);
                astgen.appendBodyWithFixups(ret_body);

                <span class="tok-kw">const</span> break_extra = zir_datas[<span class="tok-builtin">@intFromEnum</span>(ret_body[ret_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;
                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =
                    <span class="tok-builtin">@intFromEnum</span>(new_index);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (ret_ref != .none) {
                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(ret_ref));
            }
            astgen.appendBodyWithFixupsExtraRefsArrayList(&amp;astgen.extra, body, args.param_insts);
            astgen.extra.appendSliceAssumeCapacity(src_locs_and_hash);

            <span class="tok-kw">break</span> :inst_info .{
                <span class="tok-kw">if</span> (args.is_inferred_error) .func_inferred <span class="tok-kw">else</span> .func,
                payload_index,
            };
        };<span class="tok-comment">

        // Order is important when unstacking.
        </span><span class="tok-kw">if</span> (args.body_gz) |body_gz| body_gz.unstack();
        <span class="tok-kw">if</span> (args.cc_gz) |cc_gz| cc_gz.unstack();
        <span class="tok-kw">if</span> (args.ret_gz) |ret_gz| ret_gz.unstack();

        astgen.instructions.appendAssumeCapacity(.{
            .tag = tag,
            .data = .{ .pl_node = .{
                .src_node = gz.nodeIndexToRelative(args.src_node),
                .payload_index = payload_index,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fancyFnExprExtraLen</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, param_refs_body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, main_body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, ref: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>) <span class="tok-type">u32</span> {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.countBodyLenAfterFixups">countBodyLenAfterFixups</a>(astgen, param_refs_body) +
            <a href="std.zig.AstGen.html#std.zig.AstGen.countBodyLenAfterFixups">countBodyLenAfterFixups</a>(astgen, main_body) +<span class="tok-comment">
            // If there is a body, we need an element for its length; otherwise, if there is a ref, we need to include that.
            </span><span class="tok-builtin">@intFromBool</span>(main_body.len &gt; <span class="tok-number">0</span> <span class="tok-kw">or</span> ref != .none);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addInt</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, integer: <span class="tok-type">u64</span>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> gz.add(.{
            .tag = .int,
            .data = .{ .int = integer },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addIntBig</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, limbs: []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;
        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.string_bytes.ensureUnusedCapacity(gpa, <span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>) * limbs.len);

        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        astgen.instructions.appendAssumeCapacity(.{
            .tag = .int_big,
            .data = .{ .str = .{
                .start = <span class="tok-builtin">@enumFromInt</span>(astgen.string_bytes.items.len),
                .len = <span class="tok-builtin">@intCast</span>(limbs.len),
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        astgen.string_bytes.appendSliceAssumeCapacity(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(limbs));
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addFloat</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, number: <span class="tok-type">f64</span>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> gz.add(.{
            .tag = .float,
            .data = .{ .float = number },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addUnNode</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(operand != .none);
        <span class="tok-kw">return</span> gz.add(.{
            .tag = tag,
            .data = .{ .un_node = .{
                .operand = operand,
                .src_node = gz.nodeIndexToRelative(src_node),
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">makeUnNode</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(operand != .none);
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        <span class="tok-kw">try</span> gz.astgen.instructions.append(gz.astgen.gpa, .{
            .tag = tag,
            .data = .{ .un_node = .{
                .operand = operand,
                .src_node = gz.nodeIndexToRelative(src_node),
            } },
        });
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addPlNode</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        extra: <span class="tok-kw">anytype</span>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> gz.astgen.addExtra(extra);
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        gz.astgen.instructions.appendAssumeCapacity(.{
            .tag = tag,
            .data = .{ .pl_node = .{
                .src_node = gz.nodeIndexToRelative(src_node),
                .payload_index = payload_index,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addPlNodePayloadIndex</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        payload_index: <span class="tok-type">u32</span>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> gz.add(.{
            .tag = tag,
            .data = .{ .pl_node = .{
                .src_node = gz.nodeIndexToRelative(src_node),
                .payload_index = payload_index,
            } },
        });
    }

    <span class="tok-comment">/// Supports `param_gz` stacked on `gz`. Assumes nothing stacked on `param_gz`. Unstacks `param_gz`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">addParam</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        param_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        <span class="tok-comment">/// Previous parameters, which might be referenced in `param_gz` (the new parameter type).</span>
        <span class="tok-comment">/// `ref`s of these instructions will be put into this param's type body, and removed from `AstGen.ref_table`.</span>
        prev_param_insts: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        ty_is_generic: <span class="tok-type">bool</span>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        <span class="tok-comment">/// Absolute token index. This function does the conversion to Decl offset.</span>
        abs_tok_index: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">const</span> param_body = param_gz.instructionsSlice();
        <span class="tok-kw">const</span> body_len = gz.astgen.countBodyLenAfterFixupsExtraRefs(param_body, prev_param_insts);
        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> gz.astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Param.html">Param</a>).@&quot;struct&quot;.fields.len + body_len);

        <span class="tok-kw">const</span> payload_index = gz.astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Param.html">Param</a>{
            .name = name,
            .<span class="tok-type">type</span> = .{
                .body_len = <span class="tok-builtin">@intCast</span>(body_len),
                .is_generic = ty_is_generic,
            },
        });
        gz.astgen.appendBodyWithFixupsExtraRefsArrayList(&amp;gz.astgen.extra, param_body, prev_param_insts);
        param_gz.unstack();

        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        gz.astgen.instructions.appendAssumeCapacity(.{
            .tag = tag,
            .data = .{ .pl_tok = .{
                .src_tok = gz.tokenIndexToRelative(abs_tok_index),
                .payload_index = payload_index,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addBuiltinValue</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, val: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.BuiltinValue.html">BuiltinValue</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.addExtendedNodeSmall">addExtendedNodeSmall</a>(gz, .builtin_value, src_node, <span class="tok-builtin">@intFromEnum</span>(val));
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedPayload</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, opcode: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>, extra: <span class="tok-kw">anytype</span>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> <a href="std.zig.AstGen.GenZir.html#std.zig.AstGen.GenZir.addExtendedPayloadSmall">addExtendedPayloadSmall</a>(gz, opcode, <span class="tok-null">undefined</span>, extra);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedPayloadSmall</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        opcode: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
        small: <span class="tok-type">u16</span>,
        extra: <span class="tok-kw">anytype</span>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;

        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> gz.astgen.addExtra(extra);
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        gz.astgen.instructions.appendAssumeCapacity(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = opcode,
                .small = small,
                .operand = payload_index,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedMultiOp</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        opcode: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
        node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        operands: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;

        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
            gpa,
            <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.NodeMultiOp.html">NodeMultiOp</a>).@&quot;struct&quot;.fields.len + operands.len,
        );

        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.NodeMultiOp.html">NodeMultiOp</a>{
            .src_node = gz.nodeIndexToRelative(node),
        });
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        astgen.instructions.appendAssumeCapacity(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = opcode,
                .small = <span class="tok-builtin">@intCast</span>(operands.len),
                .operand = payload_index,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        astgen.appendRefsAssumeCapacity(operands);
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedMultiOpPayloadIndex</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        opcode: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
        payload_index: <span class="tok-type">u32</span>,
        trailing_len: <span class="tok-type">usize</span>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;

        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        astgen.instructions.appendAssumeCapacity(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = opcode,
                .small = <span class="tok-builtin">@intCast</span>(trailing_len),
                .operand = payload_index,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedNodeSmall</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        opcode: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        small: <span class="tok-type">u16</span>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;

        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        astgen.instructions.appendAssumeCapacity(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = opcode,
                .small = small,
                .operand = <span class="tok-builtin">@bitCast</span>(gz.nodeIndexToRelative(src_node)),
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addUnTok</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Absolute token index. This function does the conversion to Decl offset.</span>
        abs_tok_index: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(operand != .none);
        <span class="tok-kw">return</span> gz.add(.{
            .tag = tag,
            .data = .{ .un_tok = .{
                .operand = operand,
                .src_tok = gz.tokenIndexToRelative(abs_tok_index),
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">makeUnTok</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Absolute token index. This function does the conversion to Decl offset.</span>
        abs_tok_index: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        <a href="std.debug.html#std.debug.assert">assert</a>(operand != .none);
        <span class="tok-kw">try</span> astgen.instructions.append(astgen.gpa, .{
            .tag = tag,
            .data = .{ .un_tok = .{
                .operand = operand,
                .src_tok = gz.tokenIndexToRelative(abs_tok_index),
            } },
        });
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addStrTok</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        str_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
        <span class="tok-comment">/// Absolute token index. This function does the conversion to Decl offset.</span>
        abs_tok_index: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> gz.add(.{
            .tag = tag,
            .data = .{ .str_tok = .{
                .start = str_index,
                .src_tok = gz.tokenIndexToRelative(abs_tok_index),
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addSaveErrRetIndex</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        cond: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            always: <span class="tok-type">void</span>,
            if_of_error_type: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        },
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">return</span> gz.addAsIndex(.{
            .tag = .save_err_ret_index,
            .data = .{ .save_err_ret_index = .{
                .operand = <span class="tok-kw">switch</span> (cond) {
                    .if_of_error_type =&gt; |x| x,
                    <span class="tok-kw">else</span> =&gt; .none,
                },
            } },
        });
    }

    <span class="tok-kw">const</span> BranchTarget = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        <a href="std.zig.AstGen.html#std.zig.AstGen.ret">ret</a>,
        block: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">addRestoreErrRetIndex</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        bt: <a href="std.zig.AstGen.GenZir.BranchTarget.html">BranchTarget</a>,
        cond: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            always: <span class="tok-type">void</span>,
            if_non_error: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        },
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">switch</span> (cond) {
            .always =&gt; <span class="tok-kw">return</span> gz.addAsIndex(.{
                .tag = .restore_err_ret_index_unconditional,
                .data = .{ .un_node = .{
                    .operand = <span class="tok-kw">switch</span> (bt) {
                        .ret =&gt; .none,
                        .block =&gt; |b| b.toRef(),
                    },
                    .src_node = gz.nodeIndexToRelative(src_node),
                } },
            }),
            .if_non_error =&gt; |operand| <span class="tok-kw">switch</span> (bt) {
                .ret =&gt; <span class="tok-kw">return</span> gz.addAsIndex(.{
                    .tag = .restore_err_ret_index_fn_entry,
                    .data = .{ .un_node = .{
                        .operand = operand,
                        .src_node = gz.nodeIndexToRelative(src_node),
                    } },
                }),
                .block =&gt; |block| <span class="tok-kw">return</span> (<span class="tok-kw">try</span> gz.addExtendedPayload(
                    .restore_err_ret_index,
                    <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.RestoreErrRetIndex.html">RestoreErrRetIndex</a>{
                        .src_node = gz.nodeIndexToRelative(src_node),
                        .block = block.toRef(),
                        .operand = operand,
                    },
                )).toIndex().?,
            },
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addBreak</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        block_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> new_index = <span class="tok-kw">try</span> gz.makeBreak(tag, block_inst, operand);
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">makeBreak</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        block_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">return</span> gz.makeBreakCommon(tag, block_inst, operand, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addBreakWithSrcNode</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        block_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        operand_src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> new_index = <span class="tok-kw">try</span> gz.makeBreakWithSrcNode(tag, block_inst, operand, operand_src_node);
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">makeBreakWithSrcNode</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        block_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        operand_src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">return</span> gz.makeBreakCommon(tag, block_inst, operand, operand_src_node);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">makeBreakCommon</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        block_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        operand_src_node: ?<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> gz.astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Break.html">Break</a>).@&quot;struct&quot;.fields.len);

        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        gz.astgen.instructions.appendAssumeCapacity(.{
            .tag = tag,
            .data = .{ .@&quot;break&quot; = .{
                .operand = operand,
                .payload_index = gz.astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Break.html">Break</a>{
                    .operand_src_node = <span class="tok-kw">if</span> (operand_src_node) |src_node|
                        gz.nodeIndexToRelative(src_node)
                    <span class="tok-kw">else</span>
                        <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Break.html">Break</a>.<a href="std.zig.Zir.Inst.Break.html#std.zig.Zir.Inst.Break.no_src_node">no_src_node</a>,
                    .block_inst = block_inst,
                }),
            } },
        });
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addBin</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        lhs: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        rhs: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(lhs != .none);
        <a href="std.debug.html#std.debug.assert">assert</a>(rhs != .none);
        <span class="tok-kw">return</span> gz.add(.{
            .tag = tag,
            .data = .{ .bin = .{
                .lhs = lhs,
                .rhs = rhs,
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addDefer</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, index: <span class="tok-type">u32</span>, len: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
        _ = <span class="tok-kw">try</span> gz.add(.{
            .tag = .@&quot;defer&quot;,
            .data = .{ .@&quot;defer&quot; = .{
                .index = index,
                .len = len,
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addDecl</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        decl_index: <span class="tok-type">u32</span>,
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> gz.add(.{
            .tag = tag,
            .data = .{ .pl_node = .{
                .src_node = gz.nodeIndexToRelative(src_node),
                .payload_index = decl_index,
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addNode</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> gz.add(.{
            .tag = tag,
            .data = .{ .node = gz.nodeIndexToRelative(src_node) },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addInstNode</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
        inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> gz.add(.{
            .tag = tag,
            .data = .{ .inst_node = .{
                .inst = inst,
                .src_node = gz.nodeIndexToRelative(src_node),
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addNodeExtended</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        opcode: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> gz.add(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = opcode,
                .small = <span class="tok-null">undefined</span>,
                .operand = <span class="tok-builtin">@bitCast</span>(gz.nodeIndexToRelative(src_node)),
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addAllocExtended</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        args: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
            node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            type_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            align_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            is_const: <span class="tok-type">bool</span>,
            is_comptime: <span class="tok-type">bool</span>,
        },
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;

        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(
            gpa,
            <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.AllocExtended.html">AllocExtended</a>).@&quot;struct&quot;.fields.len +
                <span class="tok-builtin">@intFromBool</span>(args.type_inst != .none) +
                <span class="tok-builtin">@intFromBool</span>(args.align_inst != .none),
        );
        <span class="tok-kw">const</span> payload_index = gz.astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.AllocExtended.html">AllocExtended</a>{
            .src_node = gz.nodeIndexToRelative(args.node),
        });
        <span class="tok-kw">if</span> (args.type_inst != .none) {
            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.type_inst));
        }
        <span class="tok-kw">if</span> (args.align_inst != .none) {
            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.align_inst));
        }

        <span class="tok-kw">const</span> has_type: <span class="tok-type">u4</span> = <span class="tok-builtin">@intFromBool</span>(args.type_inst != .none);
        <span class="tok-kw">const</span> has_align: <span class="tok-type">u4</span> = <span class="tok-builtin">@intFromBool</span>(args.align_inst != .none);
        <span class="tok-kw">const</span> is_const: <span class="tok-type">u4</span> = <span class="tok-builtin">@intFromBool</span>(args.is_const);
        <span class="tok-kw">const</span> is_comptime: <span class="tok-type">u4</span> = <span class="tok-builtin">@intFromBool</span>(args.is_comptime);
        <span class="tok-kw">const</span> small: <span class="tok-type">u16</span> = has_type | (has_align &lt;&lt; <span class="tok-number">1</span>) | (is_const &lt;&lt; <span class="tok-number">2</span>) | (is_comptime &lt;&lt; <span class="tok-number">3</span>);

        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        astgen.instructions.appendAssumeCapacity(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .alloc,
                .small = small,
                .operand = payload_index,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addAsm</span>(
        gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        args: <span class="tok-kw">struct</span> {
            tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
            <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span>
            node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            asm_source: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            output_type_bits: <span class="tok-type">u32</span>,
            is_volatile: <span class="tok-type">bool</span>,
            outputs: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Asm.html">Asm</a>.<a href="std.zig.Zir.Inst.Asm.Output.html">Output</a>,
            inputs: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Asm.html">Asm</a>.<a href="std.zig.Zir.Inst.Asm.Input.html">Input</a>,
            clobbers: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
        },
    ) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;

        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Asm.html">Asm</a>).@&quot;struct&quot;.fields.len +
            args.outputs.len * <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Asm.html">Asm</a>.<a href="std.zig.Zir.Inst.Asm.Output.html">Output</a>).@&quot;struct&quot;.fields.len +
            args.inputs.len * <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Asm.html">Asm</a>.<a href="std.zig.Zir.Inst.Asm.Input.html">Input</a>).@&quot;struct&quot;.fields.len +
            args.clobbers.len);

        <span class="tok-kw">const</span> payload_index = gz.astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Asm.html">Asm</a>{
            .src_node = gz.nodeIndexToRelative(args.node),
            .asm_source = args.asm_source,
            .output_type_bits = args.output_type_bits,
        });
        <span class="tok-kw">for</span> (args.outputs) |output| {
            _ = gz.astgen.addExtraAssumeCapacity(output);
        }
        <span class="tok-kw">for</span> (args.inputs) |input| {
            _ = gz.astgen.addExtraAssumeCapacity(input);
        }
        gz.astgen.extra.appendSliceAssumeCapacity(args.clobbers);<span class="tok-comment">

        //  * 0b00000000_000XXXXX - `outputs_len`.
        //  * 0b000000XX_XXX00000 - `inputs_len`.
        //  * 0b0XXXXX00_00000000 - `clobbers_len`.
        //  * 0bX0000000_00000000 - is volatile
        </span><span class="tok-kw">const</span> small: <span class="tok-type">u16</span> = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(args.outputs.len)) |
            <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(args.inputs.len &lt;&lt; <span class="tok-number">5</span>)) |
            <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(args.clobbers.len &lt;&lt; <span class="tok-number">10</span>)) |
            (<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromBool</span>(args.is_volatile)) &lt;&lt; <span class="tok-number">15</span>);

        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);
        astgen.instructions.appendAssumeCapacity(.{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = args.tag,
                .small = small,
                .operand = payload_index,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index.toRef();
    }

    <span class="tok-comment">/// Note that this returns a `Zir.Inst.Index` not a ref.</span>
    <span class="tok-comment">/// Does *not* append the block instruction to the scope.</span>
    <span class="tok-comment">/// Leaves the `payload_index` field undefined.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">makeBlockInst</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">try</span> gz.astgen.instructions.append(gpa, .{
            .tag = tag,
            .data = .{ .pl_node = .{
                .src_node = gz.nodeIndexToRelative(node),
                .payload_index = <span class="tok-null">undefined</span>,
            } },
        });
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-comment">/// Note that this returns a `Zir.Inst.Index` not a ref.</span>
    <span class="tok-comment">/// Does *not* append the block instruction to the scope.</span>
    <span class="tok-comment">/// Leaves the `payload_index` field undefined. Use `setDeclaration` to finalize.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">makeDeclaration</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        <span class="tok-kw">try</span> gz.astgen.instructions.append(gz.astgen.gpa, .{
            .tag = .declaration,
            .data = .{ .declaration = .{
                .src_node = node,
                .payload_index = <span class="tok-null">undefined</span>,
            } },
        });
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-comment">/// Note that this returns a `Zir.Inst.Index` not a ref.</span>
    <span class="tok-comment">/// Leaves the `payload_index` field undefined.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">addCondBr</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        <span class="tok-kw">try</span> gz.astgen.instructions.append(gpa, .{
            .tag = tag,
            .data = .{ .pl_node = .{
                .src_node = gz.nodeIndexToRelative(node),
                .payload_index = <span class="tok-null">undefined</span>,
            } },
        });
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">setStruct</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, args: <span class="tok-kw">struct</span> {
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        captures_len: <span class="tok-type">u32</span>,
        fields_len: <span class="tok-type">u32</span>,
        decls_len: <span class="tok-type">u32</span>,
        has_backing_int: <span class="tok-type">bool</span>,
        layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a>,
        known_non_opv: <span class="tok-type">bool</span>,
        known_comptime_only: <span class="tok-type">bool</span>,
        any_comptime_fields: <span class="tok-type">bool</span>,
        any_default_inits: <span class="tok-type">bool</span>,
        any_aligned_fields: <span class="tok-type">bool</span>,
        fields_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a>,
    }) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;<span class="tok-comment">

        // Node 0 is valid for the root `struct_decl` of a file!
        </span><a href="std.debug.html#std.debug.assert">assert</a>(args.src_node != <span class="tok-number">0</span> <span class="tok-kw">or</span> gz.parent.tag == .top);

        <span class="tok-kw">const</span> fields_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(args.fields_hash);

        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructDecl.html">StructDecl</a>).@&quot;struct&quot;.fields.len + <span class="tok-number">3</span>);
        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructDecl.html">StructDecl</a>{
            .fields_hash_0 = fields_hash_arr[<span class="tok-number">0</span>],
            .fields_hash_1 = fields_hash_arr[<span class="tok-number">1</span>],
            .fields_hash_2 = fields_hash_arr[<span class="tok-number">2</span>],
            .fields_hash_3 = fields_hash_arr[<span class="tok-number">3</span>],
            .src_line = astgen.source_line,
            .src_node = args.src_node,
        });

        <span class="tok-kw">if</span> (args.captures_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.captures_len);
        }
        <span class="tok-kw">if</span> (args.fields_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.fields_len);
        }
        <span class="tok-kw">if</span> (args.decls_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.decls_len);
        }
        astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(inst), .{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .struct_decl,
                .small = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.StructDecl.html">StructDecl</a>.<a href="std.zig.Zir.Inst.StructDecl.Small.html">Small</a>{
                    .has_captures_len = args.captures_len != <span class="tok-number">0</span>,
                    .has_fields_len = args.fields_len != <span class="tok-number">0</span>,
                    .has_decls_len = args.decls_len != <span class="tok-number">0</span>,
                    .has_backing_int = args.has_backing_int,
                    .known_non_opv = args.known_non_opv,
                    .known_comptime_only = args.known_comptime_only,
                    .name_strategy = gz.anon_name_strategy,
                    .layout = args.layout,
                    .any_comptime_fields = args.any_comptime_fields,
                    .any_default_inits = args.any_default_inits,
                    .any_aligned_fields = args.any_aligned_fields,
                }),
                .operand = payload_index,
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, args: <span class="tok-kw">struct</span> {
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        tag_type: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        captures_len: <span class="tok-type">u32</span>,
        body_len: <span class="tok-type">u32</span>,
        fields_len: <span class="tok-type">u32</span>,
        decls_len: <span class="tok-type">u32</span>,
        layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a>,
        auto_enum_tag: <span class="tok-type">bool</span>,
        any_aligned_fields: <span class="tok-type">bool</span>,
        fields_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a>,
    }) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;

        <a href="std.debug.html#std.debug.assert">assert</a>(args.src_node != <span class="tok-number">0</span>);

        <span class="tok-kw">const</span> fields_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(args.fields_hash);

        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnionDecl.html">UnionDecl</a>).@&quot;struct&quot;.fields.len + <span class="tok-number">5</span>);
        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnionDecl.html">UnionDecl</a>{
            .fields_hash_0 = fields_hash_arr[<span class="tok-number">0</span>],
            .fields_hash_1 = fields_hash_arr[<span class="tok-number">1</span>],
            .fields_hash_2 = fields_hash_arr[<span class="tok-number">2</span>],
            .fields_hash_3 = fields_hash_arr[<span class="tok-number">3</span>],
            .src_line = astgen.source_line,
            .src_node = args.src_node,
        });

        <span class="tok-kw">if</span> (args.tag_type != .none) {
            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.tag_type));
        }
        <span class="tok-kw">if</span> (args.captures_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.captures_len);
        }
        <span class="tok-kw">if</span> (args.body_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.body_len);
        }
        <span class="tok-kw">if</span> (args.fields_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.fields_len);
        }
        <span class="tok-kw">if</span> (args.decls_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.decls_len);
        }
        astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(inst), .{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .union_decl,
                .small = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.UnionDecl.html">UnionDecl</a>.<a href="std.zig.Zir.Inst.UnionDecl.Small.html">Small</a>{
                    .has_tag_type = args.tag_type != .none,
                    .has_captures_len = args.captures_len != <span class="tok-number">0</span>,
                    .has_body_len = args.body_len != <span class="tok-number">0</span>,
                    .has_fields_len = args.fields_len != <span class="tok-number">0</span>,
                    .has_decls_len = args.decls_len != <span class="tok-number">0</span>,
                    .name_strategy = gz.anon_name_strategy,
                    .layout = args.layout,
                    .auto_enum_tag = args.auto_enum_tag,
                    .any_aligned_fields = args.any_aligned_fields,
                }),
                .operand = payload_index,
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">setEnum</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, args: <span class="tok-kw">struct</span> {
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        tag_type: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        captures_len: <span class="tok-type">u32</span>,
        body_len: <span class="tok-type">u32</span>,
        fields_len: <span class="tok-type">u32</span>,
        decls_len: <span class="tok-type">u32</span>,
        nonexhaustive: <span class="tok-type">bool</span>,
        fields_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a>,
    }) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;

        <a href="std.debug.html#std.debug.assert">assert</a>(args.src_node != <span class="tok-number">0</span>);

        <span class="tok-kw">const</span> fields_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(args.fields_hash);

        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.EnumDecl.html">EnumDecl</a>).@&quot;struct&quot;.fields.len + <span class="tok-number">5</span>);
        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.EnumDecl.html">EnumDecl</a>{
            .fields_hash_0 = fields_hash_arr[<span class="tok-number">0</span>],
            .fields_hash_1 = fields_hash_arr[<span class="tok-number">1</span>],
            .fields_hash_2 = fields_hash_arr[<span class="tok-number">2</span>],
            .fields_hash_3 = fields_hash_arr[<span class="tok-number">3</span>],
            .src_line = astgen.source_line,
            .src_node = args.src_node,
        });

        <span class="tok-kw">if</span> (args.tag_type != .none) {
            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.tag_type));
        }
        <span class="tok-kw">if</span> (args.captures_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.captures_len);
        }
        <span class="tok-kw">if</span> (args.body_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.body_len);
        }
        <span class="tok-kw">if</span> (args.fields_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.fields_len);
        }
        <span class="tok-kw">if</span> (args.decls_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.decls_len);
        }
        astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(inst), .{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .enum_decl,
                .small = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.EnumDecl.html">EnumDecl</a>.<a href="std.zig.Zir.Inst.EnumDecl.Small.html">Small</a>{
                    .has_tag_type = args.tag_type != .none,
                    .has_captures_len = args.captures_len != <span class="tok-number">0</span>,
                    .has_body_len = args.body_len != <span class="tok-number">0</span>,
                    .has_fields_len = args.fields_len != <span class="tok-number">0</span>,
                    .has_decls_len = args.decls_len != <span class="tok-number">0</span>,
                    .name_strategy = gz.anon_name_strategy,
                    .nonexhaustive = args.nonexhaustive,
                }),
                .operand = payload_index,
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">setOpaque</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, args: <span class="tok-kw">struct</span> {
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        captures_len: <span class="tok-type">u32</span>,
        decls_len: <span class="tok-type">u32</span>,
    }) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> gpa = astgen.gpa;

        <a href="std.debug.html#std.debug.assert">assert</a>(args.src_node != <span class="tok-number">0</span>);

        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.OpaqueDecl.html">OpaqueDecl</a>).@&quot;struct&quot;.fields.len + <span class="tok-number">2</span>);
        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.OpaqueDecl.html">OpaqueDecl</a>{
            .src_line = astgen.source_line,
            .src_node = args.src_node,
        });

        <span class="tok-kw">if</span> (args.captures_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.captures_len);
        }
        <span class="tok-kw">if</span> (args.decls_len != <span class="tok-number">0</span>) {
            astgen.extra.appendAssumeCapacity(args.decls_len);
        }
        astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(inst), .{
            .tag = .extended,
            .data = .{ .extended = .{
                .opcode = .opaque_decl,
                .small = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.OpaqueDecl.html">OpaqueDecl</a>.<a href="std.zig.Zir.Inst.OpaqueDecl.Small.html">Small</a>{
                    .has_captures_len = args.captures_len != <span class="tok-number">0</span>,
                    .has_decls_len = args.decls_len != <span class="tok-number">0</span>,
                    .name_strategy = gz.anon_name_strategy,
                }),
                .operand = payload_index,
            } },
        });
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
        <span class="tok-kw">return</span> (<span class="tok-kw">try</span> gz.addAsIndex(inst)).toRef();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addAsIndex</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        gz.astgen.instructions.appendAssumeCapacity(inst);
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">reserveInstructionIndex</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>) !<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;
        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> new_index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);
        gz.astgen.instructions.len += <span class="tok-number">1</span>;
        gz.instructions.appendAssumeCapacity(new_index);
        <span class="tok-kw">return</span> new_index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addRet</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, ri: <a href="std.zig.AstGen.ResultInfo.html">ResultInfo</a>, operand: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (ri.rl) {
            .ptr =&gt; |ptr_res| _ = <span class="tok-kw">try</span> gz.addUnNode(.ret_load, ptr_res.inst, node),
            .coerced_ty =&gt; _ = <span class="tok-kw">try</span> gz.addUnNode(.ret_node, operand, node),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addDbgVar</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, tag: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Tag.html">Tag</a>, name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (gz.is_comptime) <span class="tok-kw">return</span>;

        _ = <span class="tok-kw">try</span> gz.add(.{ .tag = tag, .data = .{
            .str_op = .{
                .str = name,
                .operand = inst,
            },
        } });
    }
};

<span class="tok-comment">/// This can only be for short-lived references; the memory becomes invalidated</span>
<span class="tok-comment">/// when another string is added.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">nullTerminatedString</span>(astgen: <a href="std.zig.AstGen.html">AstGen</a>, index: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>) [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(index)..]);
}

<span class="tok-comment">/// Local variables shadowing detection, including function parameters.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">detectLocalShadowing</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    scope: *<a href="std.zig.AstGen.Scope.html">Scope</a>,
    ident_name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    name_token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    token_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    id_cat: <a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.IdCat.html">IdCat</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">if</span> (token_bytes[<span class="tok-number">0</span>] != <span class="tok-str">'@'</span> <span class="tok-kw">and</span> <a href="std.zig.primitives.html#std.zig.primitives.isPrimitive">isPrimitive</a>(token_bytes)) {
        <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;name shadows primitive '{s}'&quot;</span>, .{
            token_bytes,
        }, &amp;[_]<span class="tok-type">u32</span>{
            <span class="tok-kw">try</span> astgen.errNoteTok(name_token, <span class="tok-str">&quot;consider using @\&quot;{s}\&quot; to disambiguate&quot;</span>, .{
                token_bytes,
            }),
        });
    }

    <span class="tok-kw">var</span> s = scope;
    <span class="tok-kw">var</span> outer_scope = <span class="tok-null">false</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {
        .local_val =&gt; {
            <span class="tok-kw">const</span> local_val = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?;
            <span class="tok-kw">if</span> (local_val.name == ident_name) {
                <span class="tok-kw">const</span> name_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(astgen.nullTerminatedString(ident_name));
                <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name_slice);
                <span class="tok-kw">defer</span> gpa.free(name);
                <span class="tok-kw">if</span> (outer_scope) {
                    <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;{s} '{s}' shadows {s} from outer scope&quot;</span>, .{
                        <span class="tok-builtin">@tagName</span>(id_cat), name, <span class="tok-builtin">@tagName</span>(local_val.id_cat),
                    }, &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            local_val.token_src,
                            <span class="tok-str">&quot;previous declaration here&quot;</span>,
                            .{},
                        ),
                    });
                }
                <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;redeclaration of {s} '{s}'&quot;</span>, .{
                    <span class="tok-builtin">@tagName</span>(local_val.id_cat), name,
                }, &amp;[_]<span class="tok-type">u32</span>{
                    <span class="tok-kw">try</span> astgen.errNoteTok(
                        local_val.token_src,
                        <span class="tok-str">&quot;previous declaration here&quot;</span>,
                        .{},
                    ),
                });
            }
            s = local_val.parent;
        },
        .local_ptr =&gt; {
            <span class="tok-kw">const</span> local_ptr = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?;
            <span class="tok-kw">if</span> (local_ptr.name == ident_name) {
                <span class="tok-kw">const</span> name_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(astgen.nullTerminatedString(ident_name));
                <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name_slice);
                <span class="tok-kw">defer</span> gpa.free(name);
                <span class="tok-kw">if</span> (outer_scope) {
                    <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;{s} '{s}' shadows {s} from outer scope&quot;</span>, .{
                        <span class="tok-builtin">@tagName</span>(id_cat), name, <span class="tok-builtin">@tagName</span>(local_ptr.id_cat),
                    }, &amp;[_]<span class="tok-type">u32</span>{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            local_ptr.token_src,
                            <span class="tok-str">&quot;previous declaration here&quot;</span>,
                            .{},
                        ),
                    });
                }
                <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;redeclaration of {s} '{s}'&quot;</span>, .{
                    <span class="tok-builtin">@tagName</span>(local_ptr.id_cat), name,
                }, &amp;[_]<span class="tok-type">u32</span>{
                    <span class="tok-kw">try</span> astgen.errNoteTok(
                        local_ptr.token_src,
                        <span class="tok-str">&quot;previous declaration here&quot;</span>,
                        .{},
                    ),
                });
            }
            s = local_ptr.parent;
        },
        .namespace =&gt; {
            outer_scope = <span class="tok-null">true</span>;
            <span class="tok-kw">const</span> ns = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>).?;
            <span class="tok-kw">const</span> decl_node = ns.decls.get(ident_name) <span class="tok-kw">orelse</span> {
                s = ns.parent;
                <span class="tok-kw">continue</span>;
            };
            <span class="tok-kw">const</span> name_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(astgen.nullTerminatedString(ident_name));
            <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name_slice);
            <span class="tok-kw">defer</span> gpa.free(name);
            <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;{s} shadows declaration of '{s}'&quot;</span>, .{
                <span class="tok-builtin">@tagName</span>(id_cat), name,
            }, &amp;[_]<span class="tok-type">u32</span>{
                <span class="tok-kw">try</span> astgen.errNoteNode(decl_node, <span class="tok-str">&quot;declared here&quot;</span>, .{}),
            });
        },
        .gen_zir =&gt; {
            s = s.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?.parent;
            outer_scope = <span class="tok-null">true</span>;
        },
        .defer_normal, .defer_error =&gt; s = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
        .top =&gt; <span class="tok-kw">break</span>,
    };
}

<span class="tok-kw">const</span> LineColumn = <span class="tok-kw">struct</span> { <span class="tok-type">u32</span>, <span class="tok-type">u32</span> };

<span class="tok-comment">/// Advances the source cursor to the main token of `node` if not in comptime scope.</span>
<span class="tok-comment">/// Usually paired with `emitDbgStmt`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">maybeAdvanceSourceCursorToMainToken</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.AstGen.LineColumn.html">LineColumn</a> {
    <span class="tok-kw">if</span> (gz.is_comptime) <span class="tok-kw">return</span> .{ gz.astgen.source_line - gz.decl_line, gz.astgen.source_column };

    <span class="tok-kw">const</span> tree = gz.astgen.tree;
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> node_start = token_starts[main_tokens[node]];
    gz.astgen.advanceSourceCursor(node_start);

    <span class="tok-kw">return</span> .{ gz.astgen.source_line - gz.decl_line, gz.astgen.source_column };
}

<span class="tok-comment">/// Advances the source cursor to the beginning of `node`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">advanceSourceCursorToNode</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> node_start = token_starts[tree.firstToken(node)];
    astgen.advanceSourceCursor(node_start);
}

<span class="tok-comment">/// Advances the source cursor to an absolute byte offset `end` in the file.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">advanceSourceCursor</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, end: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> source = astgen.tree.source;
    <span class="tok-kw">var</span> i = astgen.source_offset;
    <span class="tok-kw">var</span> line = astgen.source_line;
    <span class="tok-kw">var</span> column = astgen.source_column;
    <a href="std.debug.html#std.debug.assert">assert</a>(i &lt;= end);
    <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (source[i] == <span class="tok-str">'\n'</span>) {
            line += <span class="tok-number">1</span>;
            column = <span class="tok-number">0</span>;
        } <span class="tok-kw">else</span> {
            column += <span class="tok-number">1</span>;
        }
    }
    astgen.source_offset = i;
    astgen.source_line = line;
    astgen.source_column = column;
}

<span class="tok-kw">const</span> SourceCursor = <span class="tok-kw">struct</span> {
    offset: <span class="tok-type">u32</span>,
    line: <span class="tok-type">u32</span>,
    column: <span class="tok-type">u32</span>,
};

<span class="tok-comment">/// Get the current source cursor, to be restored later with `restoreSourceCursor`.</span>
<span class="tok-comment">/// This is useful when analyzing source code out-of-order.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">saveSourceCursor</span>(astgen: *<span class="tok-kw">const</span> <a href="std.zig.AstGen.html">AstGen</a>) <a href="std.zig.AstGen.SourceCursor.html">SourceCursor</a> {
    <span class="tok-kw">return</span> .{
        .offset = astgen.source_offset,
        .line = astgen.source_line,
        .column = astgen.source_column,
    };
}
<span class="tok-kw">fn</span> <span class="tok-fn">restoreSourceCursor</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, cursor: <a href="std.zig.AstGen.SourceCursor.html">SourceCursor</a>) <span class="tok-type">void</span> {
    astgen.source_offset = cursor.offset;
    astgen.source_line = cursor.line;
    astgen.source_column = cursor.column;
}

<span class="tok-comment">/// Detects name conflicts for decls and fields, and populates `namespace.decls` with all named declarations.</span>
<span class="tok-comment">/// Returns the number of declarations in the namespace, including unnamed declarations (e.g. `comptime` decls).</span>
<span class="tok-kw">fn</span> <span class="tok-fn">scanContainer</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    namespace: *<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>,
    members: []<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    container_kind: <span class="tok-kw">enum</span> { @&quot;struct&quot;, @&quot;union&quot;, @&quot;enum&quot;, @&quot;opaque&quot; },
) !<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);

    <span class="tok-kw">var</span> any_invalid_declarations = <span class="tok-null">false</span>;<span class="tok-comment">

    // This type forms a linked list of source tokens declaring the same name.
    </span><span class="tok-kw">const</span> NameEntry = <span class="tok-kw">struct</span> {
        tok: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Using a linked list here simplifies memory management, and is acceptable since</span>
        <span class="tok-comment">///ewntries are only allocated in error situations. The entries are allocated into the</span>
        <span class="tok-comment">/// AstGen arena.</span>
        next: ?*<span class="tok-builtin">@This</span>(),
    };<span class="tok-comment">

    // The maps below are allocated into this SFBA to avoid using the GPA for small namespaces.
    </span><span class="tok-kw">var</span> sfba_state = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-number">512</span>, astgen.gpa);
    <span class="tok-kw">const</span> sfba = sfba_state.get();

    <span class="tok-kw">var</span> names: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, NameEntry) = .empty;
    <span class="tok-kw">var</span> test_names: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, NameEntry) = .empty;
    <span class="tok-kw">var</span> decltest_names: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>, NameEntry) = .empty;
    <span class="tok-kw">defer</span> {
        names.deinit(sfba);
        test_names.deinit(sfba);
        decltest_names.deinit(sfba);
    }

    <span class="tok-kw">var</span> any_duplicates = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> decl_count: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (members) |member_node| {
        <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> { decl, field };
        <span class="tok-kw">const</span> kind: Kind, <span class="tok-kw">const</span> name_token = <span class="tok-kw">switch</span> (node_tags[member_node]) {
            .container_field_init,
            .container_field_align,
            .container_field,
            =&gt; blk: {
                <span class="tok-kw">var</span> full = tree.fullContainerField(member_node).?;
                <span class="tok-kw">switch</span> (container_kind) {
                    .@&quot;struct&quot;, .@&quot;opaque&quot; =&gt; {},
                    .@&quot;union&quot;, .@&quot;enum&quot; =&gt; full.convertToNonTupleLike(astgen.tree.nodes),
                }
                <span class="tok-kw">if</span> (full.ast.tuple_like) <span class="tok-kw">continue</span>;
                <span class="tok-kw">break</span> :blk .{ .field, full.ast.main_token };
            },

            .global_var_decl,
            .local_var_decl,
            .simple_var_decl,
            .aligned_var_decl,
            =&gt; blk: {
                decl_count += <span class="tok-number">1</span>;
                <span class="tok-kw">break</span> :blk .{ .decl, main_tokens[member_node] + <span class="tok-number">1</span> };
            },

            .fn_proto_simple,
            .fn_proto_multi,
            .fn_proto_one,
            .fn_proto,
            .fn_decl,
            =&gt; blk: {
                decl_count += <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> ident = main_tokens[member_node] + <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (token_tags[ident] != .identifier) {
                    <span class="tok-kw">try</span> astgen.appendErrorNode(member_node, <span class="tok-str">&quot;missing function name&quot;</span>, .{});
                    any_invalid_declarations = <span class="tok-null">true</span>;
                    <span class="tok-kw">continue</span>;
                }
                <span class="tok-kw">break</span> :blk .{ .decl, ident };
            },

            .@&quot;comptime&quot;, .@&quot;usingnamespace&quot; =&gt; {
                decl_count += <span class="tok-number">1</span>;
                <span class="tok-kw">continue</span>;
            },

            .test_decl =&gt; {
                decl_count += <span class="tok-number">1</span>;<span class="tok-comment">
                // We don't want shadowing detection here, and test names work a bit differently, so
                // we must do the redeclaration detection ourselves.
                </span><span class="tok-kw">const</span> test_name_token = main_tokens[member_node] + <span class="tok-number">1</span>;
                <span class="tok-kw">const</span> new_ent: NameEntry = .{
                    .tok = test_name_token,
                    .next = <span class="tok-null">null</span>,
                };
                <span class="tok-kw">switch</span> (token_tags[test_name_token]) {
                    <span class="tok-kw">else</span> =&gt; {},<span class="tok-comment"> // unnamed test
                    </span>.string_literal =&gt; {
                        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> astgen.strLitAsString(test_name_token);
                        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> test_names.getOrPut(sfba, name.index);
                        <span class="tok-kw">if</span> (gop.found_existing) {
                            <span class="tok-kw">var</span> e = gop.value_ptr;
                            <span class="tok-kw">while</span> (e.next) |n| e = n;
                            e.next = <span class="tok-kw">try</span> astgen.arena.create(NameEntry);
                            e.next.?.* = new_ent;
                            any_duplicates = <span class="tok-null">true</span>;
                        } <span class="tok-kw">else</span> {
                            gop.value_ptr.* = new_ent;
                        }
                    },
                    .identifier =&gt; {
                        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> astgen.identAsString(test_name_token);
                        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> decltest_names.getOrPut(sfba, name);
                        <span class="tok-kw">if</span> (gop.found_existing) {
                            <span class="tok-kw">var</span> e = gop.value_ptr;
                            <span class="tok-kw">while</span> (e.next) |n| e = n;
                            e.next = <span class="tok-kw">try</span> astgen.arena.create(NameEntry);
                            e.next.?.* = new_ent;
                            any_duplicates = <span class="tok-null">true</span>;
                        } <span class="tok-kw">else</span> {
                            gop.value_ptr.* = new_ent;
                        }
                    },
                }
                <span class="tok-kw">continue</span>;
            },

            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };

        <span class="tok-kw">const</span> name_str_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);

        <span class="tok-kw">if</span> (kind == .decl) {<span class="tok-comment">
            // Put the name straight into `decls`, even if there are compile errors.
            // This avoids incorrect &quot;undeclared identifier&quot; errors later on.
            </span><span class="tok-kw">try</span> namespace.decls.put(gpa, name_str_index, member_node);
        }

        {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> names.getOrPut(sfba, name_str_index);
            <span class="tok-kw">const</span> new_ent: NameEntry = .{
                .tok = name_token,
                .next = <span class="tok-null">null</span>,
            };
            <span class="tok-kw">if</span> (gop.found_existing) {
                <span class="tok-kw">var</span> e = gop.value_ptr;
                <span class="tok-kw">while</span> (e.next) |n| e = n;
                e.next = <span class="tok-kw">try</span> astgen.arena.create(NameEntry);
                e.next.?.* = new_ent;
                any_duplicates = <span class="tok-null">true</span>;
                <span class="tok-kw">continue</span>;
            } <span class="tok-kw">else</span> {
                gop.value_ptr.* = new_ent;
            }
        }<span class="tok-comment">

        // For fields, we only needed the duplicate check! Decls have some more checks to do, though.
        </span><span class="tok-kw">switch</span> (kind) {
            .decl =&gt; {},
            .field =&gt; <span class="tok-kw">continue</span>,
        }

        <span class="tok-kw">const</span> token_bytes = astgen.tree.tokenSlice(name_token);
        <span class="tok-kw">if</span> (token_bytes[<span class="tok-number">0</span>] != <span class="tok-str">'@'</span> <span class="tok-kw">and</span> <a href="std.zig.primitives.html#std.zig.primitives.isPrimitive">isPrimitive</a>(token_bytes)) {
            <span class="tok-kw">try</span> astgen.appendErrorTokNotes(name_token, <span class="tok-str">&quot;name shadows primitive '{s}'&quot;</span>, .{
                token_bytes,
            }, &amp;.{
                <span class="tok-kw">try</span> astgen.errNoteTok(name_token, <span class="tok-str">&quot;consider using @\&quot;{s}\&quot; to disambiguate&quot;</span>, .{
                    token_bytes,
                }),
            });
            any_invalid_declarations = <span class="tok-null">true</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">var</span> s = namespace.parent;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {
            .local_val =&gt; {
                <span class="tok-kw">const</span> local_val = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalVal.html">LocalVal</a>).?;
                <span class="tok-kw">if</span> (local_val.name == name_str_index) {
                    <span class="tok-kw">try</span> astgen.appendErrorTokNotes(name_token, <span class="tok-str">&quot;declaration '{s}' shadows {s} from outer scope&quot;</span>, .{
                        token_bytes, <span class="tok-builtin">@tagName</span>(local_val.id_cat),
                    }, &amp;.{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            local_val.token_src,
                            <span class="tok-str">&quot;previous declaration here&quot;</span>,
                            .{},
                        ),
                    });
                    any_invalid_declarations = <span class="tok-null">true</span>;
                    <span class="tok-kw">break</span>;
                }
                s = local_val.parent;
            },
            .local_ptr =&gt; {
                <span class="tok-kw">const</span> local_ptr = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.LocalPtr.html">LocalPtr</a>).?;
                <span class="tok-kw">if</span> (local_ptr.name == name_str_index) {
                    <span class="tok-kw">try</span> astgen.appendErrorTokNotes(name_token, <span class="tok-str">&quot;declaration '{s}' shadows {s} from outer scope&quot;</span>, .{
                        token_bytes, <span class="tok-builtin">@tagName</span>(local_ptr.id_cat),
                    }, &amp;.{
                        <span class="tok-kw">try</span> astgen.errNoteTok(
                            local_ptr.token_src,
                            <span class="tok-str">&quot;previous declaration here&quot;</span>,
                            .{},
                        ),
                    });
                    any_invalid_declarations = <span class="tok-null">true</span>;
                    <span class="tok-kw">break</span>;
                }
                s = local_ptr.parent;
            },
            .namespace =&gt; s = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Namespace.html">Namespace</a>).?.parent,
            .gen_zir =&gt; s = s.cast(<a href="std.zig.AstGen.GenZir.html">GenZir</a>).?.parent,
            .defer_normal, .defer_error =&gt; s = s.cast(<a href="std.zig.AstGen.Scope.html">Scope</a>.<a href="std.zig.AstGen.Scope.Defer.html">Defer</a>).?.parent,
            .top =&gt; <span class="tok-kw">break</span>,
        };
    }

    <span class="tok-kw">if</span> (!any_duplicates) {
        <span class="tok-kw">if</span> (any_invalid_declarations) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;
        <span class="tok-kw">return</span> decl_count;
    }

    <span class="tok-kw">for</span> (names.keys(), names.values()) |name, first| {
        <span class="tok-kw">if</span> (first.next == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> notes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty;
        <span class="tok-kw">var</span> prev: NameEntry = first;
        <span class="tok-kw">while</span> (prev.next) |cur| : (prev = cur.*) {
            <span class="tok-kw">try</span> notes.append(astgen.arena, <span class="tok-kw">try</span> astgen.errNoteTok(cur.tok, <span class="tok-str">&quot;duplicate name here&quot;</span>, .{}));
        }
        <span class="tok-kw">try</span> notes.append(astgen.arena, <span class="tok-kw">try</span> astgen.errNoteNode(namespace.node, <span class="tok-str">&quot;{s} declared here&quot;</span>, .{<span class="tok-builtin">@tagName</span>(container_kind)}));
        <span class="tok-kw">const</span> name_duped = <span class="tok-kw">try</span> astgen.arena.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(astgen.nullTerminatedString(name)));
        <span class="tok-kw">try</span> astgen.appendErrorTokNotes(first.tok, <span class="tok-str">&quot;duplicate {s} member name '{s}'&quot;</span>, .{ <span class="tok-builtin">@tagName</span>(container_kind), name_duped }, notes.items);
        any_invalid_declarations = <span class="tok-null">true</span>;
    }

    <span class="tok-kw">for</span> (test_names.keys(), test_names.values()) |name, first| {
        <span class="tok-kw">if</span> (first.next == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> notes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty;
        <span class="tok-kw">var</span> prev: NameEntry = first;
        <span class="tok-kw">while</span> (prev.next) |cur| : (prev = cur.*) {
            <span class="tok-kw">try</span> notes.append(astgen.arena, <span class="tok-kw">try</span> astgen.errNoteTok(cur.tok, <span class="tok-str">&quot;duplicate test here&quot;</span>, .{}));
        }
        <span class="tok-kw">try</span> notes.append(astgen.arena, <span class="tok-kw">try</span> astgen.errNoteNode(namespace.node, <span class="tok-str">&quot;{s} declared here&quot;</span>, .{<span class="tok-builtin">@tagName</span>(container_kind)}));
        <span class="tok-kw">const</span> name_duped = <span class="tok-kw">try</span> astgen.arena.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(astgen.nullTerminatedString(name)));
        <span class="tok-kw">try</span> astgen.appendErrorTokNotes(first.tok, <span class="tok-str">&quot;duplicate test name '{s}'&quot;</span>, .{name_duped}, notes.items);
        any_invalid_declarations = <span class="tok-null">true</span>;
    }

    <span class="tok-kw">for</span> (decltest_names.keys(), decltest_names.values()) |name, first| {
        <span class="tok-kw">if</span> (first.next == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;
        <span class="tok-kw">var</span> notes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty;
        <span class="tok-kw">var</span> prev: NameEntry = first;
        <span class="tok-kw">while</span> (prev.next) |cur| : (prev = cur.*) {
            <span class="tok-kw">try</span> notes.append(astgen.arena, <span class="tok-kw">try</span> astgen.errNoteTok(cur.tok, <span class="tok-str">&quot;duplicate decltest here&quot;</span>, .{}));
        }
        <span class="tok-kw">try</span> notes.append(astgen.arena, <span class="tok-kw">try</span> astgen.errNoteNode(namespace.node, <span class="tok-str">&quot;{s} declared here&quot;</span>, .{<span class="tok-builtin">@tagName</span>(container_kind)}));
        <span class="tok-kw">const</span> name_duped = <span class="tok-kw">try</span> astgen.arena.dupe(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(astgen.nullTerminatedString(name)));
        <span class="tok-kw">try</span> astgen.appendErrorTokNotes(first.tok, <span class="tok-str">&quot;duplicate decltest '{s}'&quot;</span>, .{name_duped}, notes.items);
        any_invalid_declarations = <span class="tok-null">true</span>;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(any_invalid_declarations);
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;
}

<span class="tok-comment">/// Assumes capacity for body has already been added. Needed capacity taking into</span>
<span class="tok-comment">/// account fixups can be found with `countBodyLenAfterFixups`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">appendBodyWithFixups</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.appendBodyWithFixupsArrayList">appendBodyWithFixupsArrayList</a>(astgen, &amp;astgen.extra, body);
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendBodyWithFixupsArrayList</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    list: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
    body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
) <span class="tok-type">void</span> {
    astgen.appendBodyWithFixupsExtraRefsArrayList(list, body, &amp;.{});
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendBodyWithFixupsExtraRefsArrayList</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    list: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
    body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
    extra_refs: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (extra_refs) |extra_inst| {
        <span class="tok-kw">if</span> (astgen.ref_table.fetchRemove(extra_inst)) |kv| {
            <a href="std.zig.AstGen.html#std.zig.AstGen.appendPossiblyRefdBodyInst">appendPossiblyRefdBodyInst</a>(astgen, list, kv.value);
        }
    }
    <span class="tok-kw">for</span> (body) |body_inst| {
        <a href="std.zig.AstGen.html#std.zig.AstGen.appendPossiblyRefdBodyInst">appendPossiblyRefdBodyInst</a>(astgen, list, body_inst);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">appendPossiblyRefdBodyInst</span>(
    astgen: *<a href="std.zig.AstGen.html">AstGen</a>,
    list: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
    body_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
) <span class="tok-type">void</span> {
    list.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(body_inst));
    <span class="tok-kw">const</span> kv = astgen.ref_table.fetchRemove(body_inst) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> ref_inst = kv.value;
    <span class="tok-kw">return</span> <a href="std.zig.AstGen.html#std.zig.AstGen.appendPossiblyRefdBodyInst">appendPossiblyRefdBodyInst</a>(astgen, list, ref_inst);
}

<span class="tok-kw">fn</span> <span class="tok-fn">countBodyLenAfterFixups</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> astgen.countBodyLenAfterFixupsExtraRefs(body, &amp;.{});
}

<span class="tok-comment">/// Return the number of instructions in `body` after prepending the `ref` instructions in `ref_table`.</span>
<span class="tok-comment">/// As well as all instructions in `body`, we also prepend `ref`s of any instruction in `extra_refs`.</span>
<span class="tok-comment">/// For instance, if an index has been reserved with a special meaning to a child block, it must be</span>
<span class="tok-comment">/// passed to `extra_refs` to ensure `ref`s of that index are added correctly.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">countBodyLenAfterFixupsExtraRefs</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>, extra_refs: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">var</span> count = body.len;
    <span class="tok-kw">for</span> (body) |body_inst| {
        <span class="tok-kw">var</span> check_inst = body_inst;
        <span class="tok-kw">while</span> (astgen.ref_table.get(check_inst)) |ref_inst| {
            count += <span class="tok-number">1</span>;
            check_inst = ref_inst;
        }
    }
    <span class="tok-kw">for</span> (extra_refs) |extra_inst| {
        <span class="tok-kw">var</span> check_inst = extra_inst;
        <span class="tok-kw">while</span> (astgen.ref_table.get(check_inst)) |ref_inst| {
            count += <span class="tok-number">1</span>;
            check_inst = ref_inst;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(count);
}

<span class="tok-kw">fn</span> <span class="tok-fn">emitDbgStmt</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, lc: <a href="std.zig.AstGen.LineColumn.html">LineColumn</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (gz.is_comptime) <span class="tok-kw">return</span>;
    <span class="tok-kw">if</span> (gz.instructions.items.len &gt; gz.instructions_top) {
        <span class="tok-kw">const</span> astgen = gz.astgen;
        <span class="tok-kw">const</span> last = gz.instructions.items[gz.instructions.items.len - <span class="tok-number">1</span>];
        <span class="tok-kw">if</span> (astgen.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(last)] == .dbg_stmt) {
            astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(last)].dbg_stmt = .{
                .line = lc[<span class="tok-number">0</span>],
                .column = lc[<span class="tok-number">1</span>],
            };
            <span class="tok-kw">return</span>;
        }
    }

    _ = <span class="tok-kw">try</span> gz.add(.{ .tag = .dbg_stmt, .data = .{
        .dbg_stmt = .{
            .line = lc[<span class="tok-number">0</span>],
            .column = lc[<span class="tok-number">1</span>],
        },
    } });
}

<span class="tok-comment">/// In some cases, Sema expects us to generate a `dbg_stmt` at the instruction</span>
<span class="tok-comment">/// *index* directly preceding the next instruction (e.g. if a call is %10, it</span>
<span class="tok-comment">/// expects a dbg_stmt at %9). TODO: this logic may allow redundant dbg_stmt</span>
<span class="tok-comment">/// instructions; fix up Sema so we don't need it!</span>
<span class="tok-kw">fn</span> <span class="tok-fn">emitDbgStmtForceCurrentIndex</span>(gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>, lc: <a href="std.zig.AstGen.LineColumn.html">LineColumn</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> astgen = gz.astgen;
    <span class="tok-kw">if</span> (gz.instructions.items.len &gt; gz.instructions_top <span class="tok-kw">and</span>
        <span class="tok-builtin">@intFromEnum</span>(gz.instructions.items[gz.instructions.items.len - <span class="tok-number">1</span>]) == astgen.instructions.len - <span class="tok-number">1</span>)
    {
        <span class="tok-kw">const</span> last = astgen.instructions.len - <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (astgen.instructions.items(.tag)[last] == .dbg_stmt) {
            astgen.instructions.items(.data)[last].dbg_stmt = .{
                .line = lc[<span class="tok-number">0</span>],
                .column = lc[<span class="tok-number">1</span>],
            };
            <span class="tok-kw">return</span>;
        }
    }

    _ = <span class="tok-kw">try</span> gz.add(.{ .tag = .dbg_stmt, .data = .{
        .dbg_stmt = .{
            .line = lc[<span class="tok-number">0</span>],
            .column = lc[<span class="tok-number">1</span>],
        },
    } });
}

<span class="tok-kw">fn</span> <span class="tok-fn">lowerAstErrors</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gpa = astgen.gpa;
    <span class="tok-kw">const</span> tree = astgen.tree;
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.errors.len &gt; <span class="tok-number">0</span>);

    <span class="tok-kw">var</span> msg: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty;
    <span class="tok-kw">defer</span> msg.deinit(gpa);

    <span class="tok-kw">var</span> notes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty;
    <span class="tok-kw">defer</span> notes.deinit(gpa);

    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> parse_err = tree.errors[<span class="tok-number">0</span>];
    <span class="tok-kw">const</span> tok = parse_err.token + <span class="tok-builtin">@intFromBool</span>(parse_err.token_is_prev);
    <span class="tok-kw">const</span> tok_start = token_starts[tok];
    <span class="tok-kw">const</span> start_char = tree.source[tok_start];

    <span class="tok-kw">if</span> (token_tags[tok] == .invalid <span class="tok-kw">and</span>
        (start_char == <span class="tok-str">'\&quot;'</span> <span class="tok-kw">or</span> start_char == <span class="tok-str">'\''</span> <span class="tok-kw">or</span> start_char == <span class="tok-str">'/'</span> <span class="tok-kw">or</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, tree.source[tok_start..], <span class="tok-str">&quot;\\\\&quot;</span>)))
    {
        <span class="tok-kw">const</span> tok_len: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(tree.tokenSlice(tok).len);
        <span class="tok-kw">const</span> tok_end = tok_start + tok_len;
        <span class="tok-kw">const</span> bad_off = blk: {
            <span class="tok-kw">var</span> idx = tok_start;
            <span class="tok-kw">while</span> (idx &lt; tok_end) : (idx += <span class="tok-number">1</span>) {
                <span class="tok-kw">switch</span> (tree.source[idx]) {
                    <span class="tok-number">0x00</span>...<span class="tok-number">0x09</span>, <span class="tok-number">0x0b</span>...<span class="tok-number">0x1f</span>, <span class="tok-number">0x7f</span> =&gt; <span class="tok-kw">break</span>,
                    <span class="tok-kw">else</span> =&gt; {},
                }
            }
            <span class="tok-kw">break</span> :blk idx - tok_start;
        };

        <span class="tok-kw">const</span> err: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Error.html">Error</a> = .{
            .tag = <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Error.html">Error</a>.<a href="std.zig.Ast.Error.Tag.html">Tag</a>.<a href="#">invalid_byte</a>,
            .token = tok,
            .extra = .{ .offset = bad_off },
        };
        msg.clearRetainingCapacity();
        <span class="tok-kw">try</span> tree.renderError(err, msg.writer(gpa));
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> astgen.appendErrorTokNotesOff(tok, bad_off, <span class="tok-str">&quot;{s}&quot;</span>, .{msg.items}, notes.items);
    }

    <span class="tok-kw">var</span> cur_err = tree.errors[<span class="tok-number">0</span>];
    <span class="tok-kw">for</span> (tree.errors[<span class="tok-number">1</span>..]) |err| {
        <span class="tok-kw">if</span> (err.is_note) {
            <span class="tok-kw">try</span> tree.renderError(err, msg.writer(gpa));
            <span class="tok-kw">try</span> notes.append(gpa, <span class="tok-kw">try</span> astgen.errNoteTok(err.token, <span class="tok-str">&quot;{s}&quot;</span>, .{msg.items}));
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // Flush error
            </span><span class="tok-kw">const</span> extra_offset = tree.errorOffset(cur_err);
            <span class="tok-kw">try</span> tree.renderError(cur_err, msg.writer(gpa));
            <span class="tok-kw">try</span> astgen.appendErrorTokNotesOff(cur_err.token, extra_offset, <span class="tok-str">&quot;{s}&quot;</span>, .{msg.items}, notes.items);
            notes.clearRetainingCapacity();
            cur_err = err;<span class="tok-comment">

            // TODO: `Parse` currently does not have good error recovery mechanisms, so the remaining errors could be bogus.
            // As such, we'll ignore all remaining errors for now. We should improve `Parse` so that we can report all the errors.
            </span><span class="tok-kw">return</span>;
        }
        msg.clearRetainingCapacity();
    }<span class="tok-comment">

    // Flush error
    </span><span class="tok-kw">const</span> extra_offset = tree.errorOffset(cur_err);
    <span class="tok-kw">try</span> tree.renderError(cur_err, msg.writer(gpa));
    <span class="tok-kw">try</span> astgen.appendErrorTokNotesOff(cur_err.token, extra_offset, <span class="tok-str">&quot;{s}&quot;</span>, .{msg.items}, notes.items);
}

<span class="tok-kw">const</span> DeclarationName = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    named: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    named_test: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    decltest: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    unnamed_test,
    @&quot;comptime&quot;,
    @&quot;usingnamespace&quot;,
};

<span class="tok-kw">fn</span> <span class="tok-fn">addFailedDeclaration</span>(
    wip_members: *<a href="std.zig.AstGen.WipMembers.html">WipMembers</a>,
    gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    kind: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.html">Unwrapped</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.Kind.html">Kind</a>,
    name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    is_pub: <span class="tok-type">bool</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeDeclaration(src_node);
    wip_members.nextDecl(decl_inst);

    <span class="tok-kw">var</span> dummy_gz = gz.makeSubBlock(&amp;gz.base);

    <span class="tok-kw">var</span> value_gz = gz.makeSubBlock(&amp;gz.base);<span class="tok-comment"> // scope doesn't matter here
    </span>_ = <span class="tok-kw">try</span> value_gz.add(.{
        .tag = .extended,
        .data = .{ .extended = .{
            .opcode = .astgen_error,
            .small = <span class="tok-null">undefined</span>,
            .operand = <span class="tok-null">undefined</span>,
        } },
    });

    <span class="tok-kw">try</span> <a href="std.zig.AstGen.html#std.zig.AstGen.setDeclaration">setDeclaration</a>(decl_inst, .{
        .src_hash = <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>),<span class="tok-comment"> // use a fixed hash to represent an AstGen failure; we don't care about source changes if AstGen still failed!
        </span>.src_line = gz.astgen.source_line,
        .src_column = gz.astgen.source_column,
        .kind = kind,
        .name = name,
        .is_pub = is_pub,
        .is_threadlocal = <span class="tok-null">false</span>,
        .linkage = .normal,
        .type_gz = &amp;dummy_gz,
        .align_gz = &amp;dummy_gz,
        .linksection_gz = &amp;dummy_gz,
        .addrspace_gz = &amp;dummy_gz,
        .value_gz = &amp;value_gz,
    });
}

<span class="tok-comment">/// Sets all extra data for a `declaration` instruction.</span>
<span class="tok-comment">/// Unstacks `type_gz`, `align_gz`, `linksection_gz`, `addrspace_gz`, and `value_gz`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">setDeclaration</span>(
    decl_inst: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
    args: <span class="tok-kw">struct</span> {
        src_hash: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.SrcHash">SrcHash</a>,
        src_line: <span class="tok-type">u32</span>,
        src_column: <span class="tok-type">u32</span>,

        kind: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.html">Unwrapped</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.Kind.html">Kind</a>,
        name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
        is_pub: <span class="tok-type">bool</span>,
        is_threadlocal: <span class="tok-type">bool</span>,
        linkage: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.html">Unwrapped</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.Linkage.html">Linkage</a>,
        lib_name: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> = .empty,

        type_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        <span class="tok-comment">/// Must be stacked on `type_gz`.</span>
        align_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        <span class="tok-comment">/// Must be stacked on `align_gz`.</span>
        linksection_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        <span class="tok-comment">/// Must be stacked on `linksection_gz`.</span>
        addrspace_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
        <span class="tok-comment">/// Must be stacked on `addrspace_gz` and have nothing stacked on top of it.</span>
        value_gz: *<a href="std.zig.AstGen.GenZir.html">GenZir</a>,
    },
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> astgen = args.value_gz.astgen;
    <span class="tok-kw">const</span> gpa = astgen.gpa;

    <span class="tok-kw">const</span> type_body = args.type_gz.instructionsSliceUpto(args.align_gz);
    <span class="tok-kw">const</span> align_body = args.align_gz.instructionsSliceUpto(args.linksection_gz);
    <span class="tok-kw">const</span> linksection_body = args.linksection_gz.instructionsSliceUpto(args.addrspace_gz);
    <span class="tok-kw">const</span> addrspace_body = args.addrspace_gz.instructionsSliceUpto(args.value_gz);
    <span class="tok-kw">const</span> value_body = args.value_gz.instructionsSlice();

    <span class="tok-kw">const</span> has_name = args.name != .empty;
    <span class="tok-kw">const</span> has_lib_name = args.lib_name != .empty;
    <span class="tok-kw">const</span> has_type_body = type_body.len != <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> has_special_body = align_body.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> linksection_body.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> addrspace_body.len != <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> has_value_body = value_body.len != <span class="tok-number">0</span>;

    <span class="tok-kw">const</span> id: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>.<a href="std.zig.Zir.Inst.Declaration.Flags.html">Flags</a>.<a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a> = <span class="tok-kw">switch</span> (args.kind) {
        .unnamed_test =&gt; .unnamed_test,
        .@&quot;test&quot; =&gt; .@&quot;test&quot;,
        .decltest =&gt; .decltest,
        .@&quot;comptime&quot; =&gt; .@&quot;comptime&quot;,
        .@&quot;usingnamespace&quot; =&gt; <span class="tok-kw">if</span> (args.is_pub) .pub_usingnamespace <span class="tok-kw">else</span> .@&quot;usingnamespace&quot;,
        .@&quot;const&quot; =&gt; <span class="tok-kw">switch</span> (args.linkage) {
            .normal =&gt; <span class="tok-kw">if</span> (args.is_pub) id: {
                <span class="tok-kw">if</span> (has_special_body) <span class="tok-kw">break</span> :id .pub_const;
                <span class="tok-kw">if</span> (has_type_body) <span class="tok-kw">break</span> :id .pub_const_typed;
                <span class="tok-kw">break</span> :id .pub_const_simple;
            } <span class="tok-kw">else</span> id: {
                <span class="tok-kw">if</span> (has_special_body) <span class="tok-kw">break</span> :id .@&quot;const&quot;;
                <span class="tok-kw">if</span> (has_type_body) <span class="tok-kw">break</span> :id .const_typed;
                <span class="tok-kw">break</span> :id .const_simple;
            },
            .@&quot;extern&quot; =&gt; <span class="tok-kw">if</span> (args.is_pub) id: {
                <span class="tok-kw">if</span> (has_lib_name) <span class="tok-kw">break</span> :id .pub_extern_const;
                <span class="tok-kw">if</span> (has_special_body) <span class="tok-kw">break</span> :id .pub_extern_const;
                <span class="tok-kw">break</span> :id .pub_extern_const_simple;
            } <span class="tok-kw">else</span> id: {
                <span class="tok-kw">if</span> (has_lib_name) <span class="tok-kw">break</span> :id .extern_const;
                <span class="tok-kw">if</span> (has_special_body) <span class="tok-kw">break</span> :id .extern_const;
                <span class="tok-kw">break</span> :id .extern_const_simple;
            },
            .@&quot;export&quot; =&gt; <span class="tok-kw">if</span> (args.is_pub) .pub_export_const <span class="tok-kw">else</span> .export_const,
        },
        .@&quot;var&quot; =&gt; <span class="tok-kw">switch</span> (args.linkage) {
            .normal =&gt; <span class="tok-kw">if</span> (args.is_pub) id: {
                <span class="tok-kw">if</span> (args.is_threadlocal) <span class="tok-kw">break</span> :id .pub_var_threadlocal;
                <span class="tok-kw">if</span> (has_special_body) <span class="tok-kw">break</span> :id .pub_var;
                <span class="tok-kw">if</span> (has_type_body) <span class="tok-kw">break</span> :id .pub_var;
                <span class="tok-kw">break</span> :id .pub_var_simple;
            } <span class="tok-kw">else</span> id: {
                <span class="tok-kw">if</span> (args.is_threadlocal) <span class="tok-kw">break</span> :id .var_threadlocal;
                <span class="tok-kw">if</span> (has_special_body) <span class="tok-kw">break</span> :id .@&quot;var&quot;;
                <span class="tok-kw">if</span> (has_type_body) <span class="tok-kw">break</span> :id .@&quot;var&quot;;
                <span class="tok-kw">break</span> :id .var_simple;
            },
            .@&quot;extern&quot; =&gt; <span class="tok-kw">if</span> (args.is_pub) id: {
                <span class="tok-kw">if</span> (args.is_threadlocal) <span class="tok-kw">break</span> :id .pub_extern_var_threadlocal;
                <span class="tok-kw">break</span> :id .pub_extern_var;
            } <span class="tok-kw">else</span> id: {
                <span class="tok-kw">if</span> (args.is_threadlocal) <span class="tok-kw">break</span> :id .extern_var_threadlocal;
                <span class="tok-kw">break</span> :id .extern_var;
            },
            .@&quot;export&quot; =&gt; <span class="tok-kw">if</span> (args.is_pub) id: {
                <span class="tok-kw">if</span> (args.is_threadlocal) <span class="tok-kw">break</span> :id .pub_export_var_threadlocal;
                <span class="tok-kw">break</span> :id .pub_export_var;
            } <span class="tok-kw">else</span> id: {
                <span class="tok-kw">if</span> (args.is_threadlocal) <span class="tok-kw">break</span> :id .export_var_threadlocal;
                <span class="tok-kw">break</span> :id .export_var;
            },
        },
    };

    <a href="std.debug.html#std.debug.assert">assert</a>(id.hasTypeBody() <span class="tok-kw">or</span> !has_type_body);
    <a href="std.debug.html#std.debug.assert">assert</a>(id.hasSpecialBodies() <span class="tok-kw">or</span> !has_special_body);
    <a href="std.debug.html#std.debug.assert">assert</a>(id.hasValueBody() == has_value_body);
    <a href="std.debug.html#std.debug.assert">assert</a>(id.linkage() == args.linkage);
    <a href="std.debug.html#std.debug.assert">assert</a>(id.hasName() == has_name);
    <a href="std.debug.html#std.debug.assert">assert</a>(id.hasLibName() <span class="tok-kw">or</span> !has_lib_name);
    <a href="std.debug.html#std.debug.assert">assert</a>(id.isPub() == args.is_pub);
    <a href="std.debug.html#std.debug.assert">assert</a>(id.isThreadlocal() == args.is_threadlocal);

    <span class="tok-kw">const</span> type_len = astgen.countBodyLenAfterFixups(type_body);
    <span class="tok-kw">const</span> align_len = astgen.countBodyLenAfterFixups(align_body);
    <span class="tok-kw">const</span> linksection_len = astgen.countBodyLenAfterFixups(linksection_body);
    <span class="tok-kw">const</span> addrspace_len = astgen.countBodyLenAfterFixups(addrspace_body);
    <span class="tok-kw">const</span> value_len = astgen.countBodyLenAfterFixups(value_body);

    <span class="tok-kw">const</span> src_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(args.src_hash);
    <span class="tok-kw">const</span> flags: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>.<a href="std.zig.Zir.Inst.Declaration.Flags.html">Flags</a> = .{
        .src_line = <span class="tok-builtin">@intCast</span>(args.src_line),
        .src_column = <span class="tok-builtin">@intCast</span>(args.src_column),
        .id = id,
    };
    <span class="tok-kw">const</span> flags_arr: [<span class="tok-number">2</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(flags);

    <span class="tok-kw">const</span> need_extra: <span class="tok-type">usize</span> =
        <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>).@&quot;struct&quot;.fields.len +
        <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromBool</span>(id.hasName())) +
        <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromBool</span>(id.hasLibName())) +
        <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromBool</span>(id.hasTypeBody())) +
        <span class="tok-number">3</span> * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromBool</span>(id.hasSpecialBodies())) +
        <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromBool</span>(id.hasValueBody())) +
        type_len + align_len + linksection_len + addrspace_len + value_len;

    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, need_extra);

    <span class="tok-kw">const</span> extra: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Declaration.html">Declaration</a> = .{
        .src_hash_0 = src_hash_arr[<span class="tok-number">0</span>],
        .src_hash_1 = src_hash_arr[<span class="tok-number">1</span>],
        .src_hash_2 = src_hash_arr[<span class="tok-number">2</span>],
        .src_hash_3 = src_hash_arr[<span class="tok-number">3</span>],
        .flags_0 = flags_arr[<span class="tok-number">0</span>],
        .flags_1 = flags_arr[<span class="tok-number">1</span>],
    };
    astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(decl_inst)].declaration.payload_index =
        astgen.addExtraAssumeCapacity(extra);

    <span class="tok-kw">if</span> (id.hasName()) {
        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.name));
    }
    <span class="tok-kw">if</span> (id.hasLibName()) {
        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.lib_name));
    }
    <span class="tok-kw">if</span> (id.hasTypeBody()) {
        astgen.extra.appendAssumeCapacity(type_len);
    }
    <span class="tok-kw">if</span> (id.hasSpecialBodies()) {
        astgen.extra.appendSliceAssumeCapacity(&amp;.{
            align_len,
            linksection_len,
            addrspace_len,
        });
    }
    <span class="tok-kw">if</span> (id.hasValueBody()) {
        astgen.extra.appendAssumeCapacity(value_len);
    }

    astgen.appendBodyWithFixups(type_body);
    astgen.appendBodyWithFixups(align_body);
    astgen.appendBodyWithFixups(linksection_body);
    astgen.appendBodyWithFixups(addrspace_body);
    astgen.appendBodyWithFixups(value_body);

    args.value_gz.unstack();
    args.addrspace_gz.unstack();
    args.linksection_gz.unstack();
    args.align_gz.unstack();
    args.type_gz.unstack();
}

<span class="tok-comment">/// Given a list of instructions, returns a list of all instructions which are a `ref` of one of the originals,</span>
<span class="tok-comment">/// from `astgen.ref_table`, non-recursively. The entries are removed from `astgen.ref_table`, and the returned</span>
<span class="tok-comment">/// slice can then be treated as its own body, to append `ref` instructions to a body other than the one they</span>
<span class="tok-comment">/// would normally exist in.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This is used when lowering functions. Very rarely, the callconv expression, align expression, etc may reference</span>
<span class="tok-comment">/// function parameters via `&amp;param`; in this case, we need to lower to a `ref` instruction in the callconv/align/etc</span>
<span class="tok-comment">/// body, rather than in the declaration body. However, we don't append these bodies to `extra` until we've evaluated</span>
<span class="tok-comment">/// *all* of the bodies into a big `GenZir` stack. Therefore, we use this function to pull out these per-body `ref`</span>
<span class="tok-comment">/// instructions which must be emitted.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveRefEntries</span>(astgen: *<a href="std.zig.AstGen.html">AstGen</a>, param_insts: []<span class="tok-kw">const</span> <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) ![]<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a> {
    <span class="tok-kw">var</span> refs: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>) = .empty;
    <span class="tok-kw">for</span> (param_insts) |param_inst| {
        <span class="tok-kw">if</span> (astgen.ref_table.fetchRemove(param_inst)) |kv| {
            <span class="tok-kw">try</span> refs.append(astgen.arena, kv.value);
        }
    }
    <span class="tok-kw">return</span> refs.items;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
