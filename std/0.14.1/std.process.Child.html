<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">process</a></li><li><a href="std.process.Child.html" class="active">Child</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.process.Child" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.process.Child</span><a href="#src.zig-std.process.Child">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.process.Child.ResourceUsageStatistics.html">std.process.Child.ResourceUsageStatistics</a></li><li><a href="std.posix.Arg0Expand.html">std.posix.Arg0Expand</a></li><li><a href="std.process.Child.Term.html">std.process.Child.Term</a></li><li><a href="std.process.Child.StdIo.html">std.process.Child.StdIo</a></li><li><a href="std.process.Child.RunResult.html">std.process.Child.RunResult</a></li><li><a href="std.process.Child.WindowsExtension.html">std.process.Child.WindowsExtension</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.process.Child.Id" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Id</span><a href="#src.zig-std.process.Child.Id">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.Id">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Id = <span class="tok-kw">switch</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a>) {
    .windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>,
    .wasi =&gt; <span class="tok-type">void</span>,
    <span class="tok-kw">else</span> =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pid_t">pid_t</a>,
}</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>id: <a href="std.process.Child.html#std.process.Child.Id">Id</a></code></pre><div class="fieldDocs"><p>Available after calling <code>spawn()</code>. This becomes <code>undefined</code> after calling <code>wait()</code>.
On Windows this is the hProcess.
On POSIX this is the pid.</p>
</div></div><div><pre><code>thread_handle: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> <span class="tok-kw">else</span> <span class="tok-type">void</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>stdin: ?<a href="std.fs.File.html">File</a></code></pre><div class="fieldDocs"><p>The writing end of the child process's standard input pipe.
Usage requires <code>stdin_behavior == StdIo.Pipe</code>.
Available after calling <code>spawn()</code>.</p>
</div></div><div><pre><code>stdout: ?<a href="std.fs.File.html">File</a></code></pre><div class="fieldDocs"><p>The reading end of the child process's standard output pipe.
Usage requires <code>stdout_behavior == StdIo.Pipe</code>.
Available after calling <code>spawn()</code>.</p>
</div></div><div><pre><code>stderr: ?<a href="std.fs.File.html">File</a></code></pre><div class="fieldDocs"><p>The reading end of the child process's standard error pipe.
Usage requires <code>stderr_behavior == StdIo.Pipe</code>.
Available after calling <code>spawn()</code>.</p>
</div></div><div><pre><code>term: ?(<a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<a href="std.process.Child.Term.html">Term</a>)</code></pre><div class="fieldDocs"><p>Terminated state of the child process.
Available after calling <code>wait()</code>.</p>
</div></div><div><pre><code>argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a></code></pre><div class="fieldDocs"><p>Leave as null to use the current env map using the supplied allocator.</p>
</div></div><div><pre><code>stdin_behavior: <a href="std.process.Child.StdIo.html">StdIo</a></code></pre></div><div><pre><code>stdout_behavior: <a href="std.process.Child.StdIo.html">StdIo</a></code></pre></div><div><pre><code>stderr_behavior: <a href="std.process.Child.StdIo.html">StdIo</a></code></pre></div><div><pre><code>uid: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) <span class="tok-type">void</span> <span class="tok-kw">else</span> ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uid_t">uid_t</a></code></pre><div class="fieldDocs"><p>Set to change the user id when spawning the child process.</p>
</div></div><div><pre><code>gid: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) <span class="tok-type">void</span> <span class="tok-kw">else</span> ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.gid_t">gid_t</a></code></pre><div class="fieldDocs"><p>Set to change the group id when spawning the child process.</p>
</div></div><div><pre><code>pgid: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) <span class="tok-type">void</span> <span class="tok-kw">else</span> ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pid_t">pid_t</a></code></pre><div class="fieldDocs"><p>Set to change the process group id when spawning the child process.</p>
</div></div><div><pre><code>cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre><div class="fieldDocs"><p>Set to change the current working directory when spawning the child process.</p>
</div></div><div><pre><code>cwd_dir: ?<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Set to change the current working directory when spawning the child process.
This is not yet implemented for Windows. See <a href="https://github.com/ziglang/zig/issues/5190">https://github.com/ziglang/zig/issues/5190</a>
Once that is done, <code>cwd</code> will be deprecated in favor of this field.</p>
</div></div><div><pre><code>err_pipe: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) <span class="tok-type">void</span> <span class="tok-kw">else</span> ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>expand_arg0: <a href="std.posix.Arg0Expand.html">Arg0Expand</a></code></pre></div><div><pre><code>disable_aslr: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Darwin-only. Disable ASLR for the child process.</p>
</div></div><div><pre><code>start_suspended: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Darwin-only. Start child process in suspended state as if SIGSTOP was sent.</p>
</div></div><div><pre><code>request_resource_usage_statistics: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Set to true to obtain rusage information for the child process.
Depending on the target platform and implementation status, the
requested statistics may or may not be available. If they are
available, then the <code>resource_usage_statistics</code> field will be populated
after calling <code><a href="std.process.Child.html#std.process.Child.wait">wait</a></code>.
On Linux and Darwin, this obtains rusage statistics from wait4().</p>
</div></div><div><pre><code>resource_usage_statistics: <a href="std.process.Child.ResourceUsageStatistics.html">ResourceUsageStatistics</a> = .{}</code></pre><div class="fieldDocs"><p>This is available after calling wait if
<code>request_resource_usage_statistics</code> was set to <code>true</code> before calling
<code><a href="std.process.Child.html#std.process.Child.spawn">spawn</a></code>.</p>
</div></div><div><pre><code>progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a> = <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a></code></pre><div class="fieldDocs"><p>When populated, a pipe will be created for the child process to
communicate progress back to the parent. The file descriptor of the
write end of the pipe will be specified in the <code>ZIG_PROGRESS</code>
environment variable inside the child process. The progress reported by
the child will be attached to this progress node in the parent process.</p>
<p>The child's progress tree will be grafted into the parent's progress tree,
by substituting this node with the child's root node.</p>
</div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.process.Child.SpawnError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SpawnError</span><a href="#src.zig-std.process.Child.SpawnError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>BadPathName <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt></div><div><dt>CurrentWorkingDirectoryUnlinked</dt><dd><p>Windows-only. <code>cwd</code> was provided, but the path did not exist when spawning the child process.</p>
</dd></div><div><dt>FileBusy <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileSystem <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InvalidBatchScriptArg</dt><dd><p>Windows-only. NUL (U+0000), LF (U+000A), CR (U+000D) are not allowed
within arguments when executing a <code>.bat</code>/<code>.cmd</code> script.</p>
<ul>
<li>NUL/LF signifiies end of arguments, so anything afterwards
would be lost after execution.</li>
<li>CR is stripped by <code>cmd.exe</code>, so any CR codepoints
would be lost after execution.</li>
</ul>
</dd></div><div><dt>InvalidExe <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InvalidHandle <a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfoError">GetProcessMemoryInfoError</a></dt></div><div><dt>InvalidName <a href="std.os.windows.html#std.os.windows.CreateProcessError">CreateProcessError</a></dt></div><div><dt>InvalidProcessGroupId <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>InvalidUserId <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>InvalidUtf8 <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only. <code>cwd</code> or <code>argv</code> was provided and it was invalid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NoDevice</dt><dd><p>POSIX-only. <code>StdIo.Ignore</code> was selected and opening <code>/dev/null</code> returned ENODEV.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>OutOfMemory</dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>ProcessAlreadyExec <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>ResourceLimitReached <a href="std.posix.html#std.posix.SetIdError">SetIdError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WaitAbandoned <a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></dt></div><div><dt>WaitTimeOut <a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.SpawnError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SpawnError = <span class="tok-kw">error</span>{
    OutOfMemory,

    <span class="tok-comment">/// POSIX-only. `StdIo.Ignore` was selected and opening `/dev/null` returned ENODEV.</span>
    NoDevice,

    <span class="tok-comment">/// Windows-only. `cwd` or `argv` was provided and it was invalid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// Windows-only. `cwd` was provided, but the path did not exist when spawning the child process.</span>
    CurrentWorkingDirectoryUnlinked,

    <span class="tok-comment">/// Windows-only. NUL (U+0000), LF (U+000A), CR (U+000D) are not allowed</span>
    <span class="tok-comment">/// within arguments when executing a `.bat`/`.cmd` script.</span>
    <span class="tok-comment">/// - NUL/LF signifiies end of arguments, so anything afterwards</span>
    <span class="tok-comment">///   would be lost after execution.</span>
    <span class="tok-comment">/// - CR is stripped by `cmd.exe`, so any CR codepoints</span>
    <span class="tok-comment">///   would be lost after execution.</span>
    InvalidBatchScriptArg,
} ||
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ExecveError">ExecveError</a> ||
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SetIdError">SetIdError</a> ||
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a> ||
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a> ||
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateProcessError">CreateProcessError</a> ||
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfoError">GetProcessMemoryInfoError</a> ||
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.WaitError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">WaitError</span><a href="#src.zig-std.process.Child.WaitError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>BadPathName <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt></div><div><dt>CurrentWorkingDirectoryUnlinked <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. <code>cwd</code> was provided, but the path did not exist when spawning the child process.</p>
</dd></div><div><dt>FileBusy <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileSystem <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InvalidBatchScriptArg <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. NUL (U+0000), LF (U+000A), CR (U+000D) are not allowed
within arguments when executing a <code>.bat</code>/<code>.cmd</code> script.</p>
<ul>
<li>NUL/LF signifiies end of arguments, so anything afterwards
would be lost after execution.</li>
<li>CR is stripped by <code>cmd.exe</code>, so any CR codepoints
would be lost after execution.</li>
</ul>
</dd></div><div><dt>InvalidExe <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InvalidHandle <a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfoError">GetProcessMemoryInfoError</a></dt></div><div><dt>InvalidName <a href="std.os.windows.html#std.os.windows.CreateProcessError">CreateProcessError</a></dt></div><div><dt>InvalidProcessGroupId <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>InvalidUserId <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>InvalidUtf8 <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. <code>cwd</code> or <code>argv</code> was provided and it was invalid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NoDevice <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>POSIX-only. <code>StdIo.Ignore</code> was selected and opening <code>/dev/null</code> returned ENODEV.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>OutOfMemory <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>ProcessAlreadyExec <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>ResourceLimitReached <a href="std.posix.html#std.posix.SetIdError">SetIdError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WaitAbandoned <a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></dt></div><div><dt>WaitTimeOut <a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.WaitError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WaitError = <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a> || <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfoError">GetProcessMemoryInfoError</a></code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.RunError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RunError</span><a href="#src.zig-std.process.Child.RunError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BadPathName <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>CurrentWorkingDirectoryUnlinked <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. <code>cwd</code> was provided, but the path did not exist when spawning the child process.</p>
</dd></div><div><dt>FileBusy <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileSystem <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InvalidBatchScriptArg <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. NUL (U+0000), LF (U+000A), CR (U+000D) are not allowed
within arguments when executing a <code>.bat</code>/<code>.cmd</code> script.</p>
<ul>
<li>NUL/LF signifiies end of arguments, so anything afterwards
would be lost after execution.</li>
<li>CR is stripped by <code>cmd.exe</code>, so any CR codepoints
would be lost after execution.</li>
</ul>
</dd></div><div><dt>InvalidExe <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InvalidHandle <a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfoError">GetProcessMemoryInfoError</a></dt></div><div><dt>InvalidName <a href="std.os.windows.html#std.os.windows.CreateProcessError">CreateProcessError</a></dt></div><div><dt>InvalidProcessGroupId <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>InvalidUserId <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>InvalidUtf8 <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. <code>cwd</code> or <code>argv</code> was provided and it was invalid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a></dt></div><div><dt>NetworkSubsystemFailed <a href="std.posix.html#std.posix.PollError">PollError</a></dt><dd><p>The network subsystem has failed.</p>
</dd></div><div><dt>NoDevice <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>POSIX-only. <code>StdIo.Ignore</code> was selected and opening <code>/dev/null</code> returned ENODEV.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>ProcessAlreadyExec <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>ResourceLimitReached <a href="std.posix.html#std.posix.SetIdError">SetIdError</a></dt></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>StderrStreamTooLong</dt></div><div><dt>StdoutStreamTooLong</dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.PollError">PollError</a></dt><dd><p>The kernel had no space to allocate file descriptor tables.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WaitAbandoned <a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></dt></div><div><dt>WaitTimeOut <a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.RunError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RunError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a> || <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PollError">PollError</a> || <span class="tok-kw">error</span>{
    StdoutStreamTooLong,
    StderrStreamTooLong,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.process.Child.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.process.Child.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.Child.html">ChildProcess</a></code></pre></div><div class="tldDocs"><p>First argument in argv is the executable.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.Child.html">ChildProcess</a> {
    <span class="tok-kw">return</span> .{
        .allocator = allocator,
        .argv = argv,
        .id = <span class="tok-null">undefined</span>,
        .thread_handle = <span class="tok-null">undefined</span>,
        .err_pipe = <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) {} <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        .term = <span class="tok-null">null</span>,
        .env_map = <span class="tok-null">null</span>,
        .cwd = <span class="tok-null">null</span>,
        .uid = <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) {} <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        .gid = <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) {} <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        .pgid = <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) {} <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        .stdin = <span class="tok-null">null</span>,
        .stdout = <span class="tok-null">null</span>,
        .stderr = <span class="tok-null">null</span>,
        .stdin_behavior = .Inherit,
        .stdout_behavior = .Inherit,
        .stderr_behavior = .Inherit,
        .expand_arg0 = .no_expand,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.setUserName" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setUserName</span><a href="#src.zig-std.process.Child.setUserName">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUserName</span>(self: *<a href="std.process.Child.html">ChildProcess</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.process.Child.html">ChildProcess</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.setUserName">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUserName</span>(self: *<a href="std.process.Child.html">ChildProcess</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> user_info = <span class="tok-kw">try</span> <a href="std.process.html">process</a>.<a href="std.process.html#std.process.getUserInfo">getUserInfo</a>(name);
    self.uid = user_info.uid;
    self.gid = user_info.gid;
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.spawn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">spawn</span><a href="#src.zig-std.process.Child.spawn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On success must call <code><a href="std.process.Child.html#std.process.Child.kill">kill</a></code> or <code><a href="std.process.Child.html#std.process.Child.wait">wait</a></code>.
After spawning the <code>id</code> is available.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.process.Child.html">ChildProcess</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.spawn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;the target operating system cannot spawn processes&quot;</span>);
    }

    <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> self.spawnWindows();
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.spawnPosix();
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.spawnAndWait" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">spawnAndWait</span><a href="#src.zig-std.process.Child.spawnAndWait">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">spawnAndWait</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<a href="std.process.Child.Term.html">Term</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.process.Child.html">ChildProcess</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.spawnAndWait">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">spawnAndWait</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">try</span> self.spawn();
    <span class="tok-kw">return</span> self.wait();
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.kill" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">kill</span><a href="#src.zig-std.process.Child.kill">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kill</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) !<a href="std.process.Child.Term.html">Term</a></code></pre></div><div class="tldDocs"><p>Forcibly terminates child process and then cleans up all resources.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.process.Child.html">ChildProcess</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.kill">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kill</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) !<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> self.killWindows(<span class="tok-number">1</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.killPosix();
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.killWindows" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">killWindows</span><a href="#src.zig-std.process.Child.killWindows">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">killWindows</span>(self: *<a href="std.process.Child.html">ChildProcess</a>, exit_code: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UINT">UINT</a>) !<a href="std.process.Child.Term.html">Term</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.process.Child.html">ChildProcess</a></code></pre></div><div><pre><code>exit_code: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UINT">UINT</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.killWindows">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">killWindows</span>(self: *<a href="std.process.Child.html">ChildProcess</a>, exit_code: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UINT">UINT</a>) !<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">if</span> (self.term) |term| {
        self.cleanupStreams();
        <span class="tok-kw">return</span> term;
    }

    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TerminateProcess">TerminateProcess</a>(self.id, exit_code) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.PermissionDenied =&gt; {<span class="tok-comment">
            // Usually when TerminateProcess triggers a ACCESS_DENIED error, it
            // indicates that the process has already exited, but there may be
            // some rare edge cases where our process handle no longer has the
            // PROCESS_TERMINATE access right, so let's do another check to make
            // sure the process is really no longer running:
            </span><a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WaitForSingleObjectEx">WaitForSingleObjectEx</a>(self.id, <span class="tok-number">0</span>, <span class="tok-null">false</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> err;
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyTerminated;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">try</span> self.waitUnwrappedWindows();
    <span class="tok-kw">return</span> self.term.?;
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.killPosix" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">killPosix</span><a href="#src.zig-std.process.Child.killPosix">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">killPosix</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) !<a href="std.process.Child.Term.html">Term</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.process.Child.html">ChildProcess</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.killPosix">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">killPosix</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) !<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">if</span> (self.term) |term| {
        self.cleanupStreams();
        <span class="tok-kw">return</span> term;
    }
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.kill">kill</a>(self.id, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">TERM</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ProcessNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyTerminated,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    self.waitUnwrappedPosix();
    <span class="tok-kw">return</span> self.term.?;
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.waitForSpawn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">waitForSpawn</span><a href="#src.zig-std.process.Child.waitForSpawn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitForSpawn</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On some targets, <code><a href="std.process.Child.html#std.process.Child.spawn">spawn</a></code> may not report all spawn errors, such as <code>error.InvalidExe</code>.
This function will block until any spawn errors can be reported, and return them.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.process.Child.html">ChildProcess</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.waitForSpawn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitForSpawn</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) <span class="tok-kw">return</span>;<span class="tok-comment"> // `spawn` reports everything
    </span><span class="tok-kw">if</span> (self.term) |term| {
        _ = term <span class="tok-kw">catch</span> |spawn_err| <span class="tok-kw">return</span> spawn_err;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> err_pipe = self.err_pipe <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    self.err_pipe = <span class="tok-null">null</span>;<span class="tok-comment">

    // Wait for the child to report any errors in or before `execvpe`.
    </span><span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.readIntFd">readIntFd</a>(err_pipe)) |child_err_int| {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(err_pipe);
        <span class="tok-kw">const</span> child_err: <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a> = <span class="tok-builtin">@errorCast</span>(<span class="tok-builtin">@errorFromInt</span>(child_err_int));
        self.term = child_err;
        <span class="tok-kw">return</span> child_err;
    } <span class="tok-kw">else</span> |_| {<span class="tok-comment">
        // Write end closed by CLOEXEC at the time of the `execvpe` call, indicating success!
        </span><a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(err_pipe);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.wait" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">wait</span><a href="#src.zig-std.process.Child.wait">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.WaitError">WaitError</a>!<a href="std.process.Child.Term.html">Term</a></code></pre></div><div class="tldDocs"><p>Blocks until child process terminates and then cleans up all resources.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.process.Child.html">ChildProcess</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.wait">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.WaitError">WaitError</a>!<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">try</span> self.waitForSpawn();<span class="tok-comment"> // report spawn errors
    </span><span class="tok-kw">if</span> (self.term) |term| {
        self.cleanupStreams();
        <span class="tok-kw">return</span> term;
    }
    <span class="tok-kw">switch</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a>) {
        .windows =&gt; <span class="tok-kw">try</span> self.waitUnwrappedWindows(),
        <span class="tok-kw">else</span> =&gt; self.waitUnwrappedPosix(),
    }
    self.id = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> self.term.?;
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.collectOutput" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">collectOutput</span><a href="#src.zig-std.process.Child.collectOutput">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collectOutput</span>( child: <a href="std.process.Child.html">ChildProcess</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, stdout: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>), stderr: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>), max_output_bytes: <span class="tok-type">usize</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Collect the output from the process's stdout and stderr. Will return once all output
has been collected. This does not mean that the process has ended. <code><a href="std.process.Child.html#std.process.Child.wait">wait</a></code> should still
be called to wait for and clean up the process.</p>
<p>The process must be started with stdout_behavior and stderr_behavior == .Pipe</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>child: <a href="std.process.Child.html">ChildProcess</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre><div class="fieldDocs"><p>Used for <code>stdout</code> and <code>stderr</code>.</p>
</div></div><div><pre><code>stdout: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>stderr: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>max_output_bytes: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.collectOutput">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collectOutput</span>(
    child: <a href="std.process.Child.html">ChildProcess</a>,
    <span class="tok-comment">/// Used for `stdout` and `stderr`.</span>
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    stdout: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
    stderr: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
    max_output_bytes: <span class="tok-type">usize</span>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(child.stdout_behavior == .Pipe);
    <a href="std.debug.html#std.debug.assert">assert</a>(child.stderr_behavior == .Pipe);

    <span class="tok-kw">var</span> poller = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.poll">poll</a>(allocator, <span class="tok-kw">enum</span> { stdout, stderr }, .{
        .stdout = child.stdout.?,
        .stderr = child.stderr.?,
    });
    <span class="tok-kw">defer</span> poller.deinit();

    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> poller.poll()) {
        <span class="tok-kw">if</span> (poller.fifo(.stdout).count &gt; max_output_bytes)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.StdoutStreamTooLong;
        <span class="tok-kw">if</span> (poller.fifo(.stderr).count &gt; max_output_bytes)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.StderrStreamTooLong;
    }

    <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.writeFifoDataToArrayList">writeFifoDataToArrayList</a>(allocator, stdout, poller.fifo(.stdout));
    <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.writeFifoDataToArrayList">writeFifoDataToArrayList</a>(allocator, stderr, poller.fifo(.stderr));
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.Child.run" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">run</span><a href="#src.zig-std.process.Child.run">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(args: <span class="tok-kw">struct</span> { allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>, cwd_dir: ?<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a> = <span class="tok-null">null</span>, env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a> = <span class="tok-null">null</span>, max_output_bytes: <span class="tok-type">usize</span> = <span class="tok-number">50</span> * <span class="tok-number">1024</span>, expand_arg0: <a href="std.posix.Arg0Expand.html">Arg0Expand</a> = .no_expand, progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a> = <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>, }) <a href="std.process.Child.html#std.process.Child.RunError">RunError</a>!<a href="std.process.Child.RunResult.html">RunResult</a></code></pre></div><div class="tldDocs"><p>Spawns a child process, waits for it, collecting stdout and stderr, and then returns.
If it succeeds, the caller owns result.stdout and result.stderr memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>args: <span class="tok-kw">struct</span> {
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    cwd_dir: ?<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a> = <span class="tok-null">null</span>,
    env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a> = <span class="tok-null">null</span>,
    max_output_bytes: <span class="tok-type">usize</span> = <span class="tok-number">50</span> * <span class="tok-number">1024</span>,
    expand_arg0: <a href="std.posix.Arg0Expand.html">Arg0Expand</a> = .no_expand,
    progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a> = <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>,
}</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.Child.run">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(args: <span class="tok-kw">struct</span> {
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    cwd_dir: ?<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a> = <span class="tok-null">null</span>,
    env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a> = <span class="tok-null">null</span>,
    max_output_bytes: <span class="tok-type">usize</span> = <span class="tok-number">50</span> * <span class="tok-number">1024</span>,
    expand_arg0: <a href="std.posix.Arg0Expand.html">Arg0Expand</a> = .no_expand,
    progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a> = <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>,
}) <a href="std.process.Child.html#std.process.Child.RunError">RunError</a>!<a href="std.process.Child.RunResult.html">RunResult</a> {
    <span class="tok-kw">var</span> child = <a href="std.process.Child.html">ChildProcess</a>.<a href="std.process.Child.html#std.process.Child.init">init</a>(args.argv, args.allocator);
    child.stdin_behavior = .Ignore;
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = .Pipe;
    child.cwd = args.cwd;
    child.cwd_dir = args.cwd_dir;
    child.env_map = args.env_map;
    child.expand_arg0 = args.expand_arg0;
    child.progress_node = args.progress_node;

    <span class="tok-kw">var</span> stdout: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty;
    <span class="tok-kw">errdefer</span> stdout.deinit(args.allocator);
    <span class="tok-kw">var</span> stderr: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty;
    <span class="tok-kw">errdefer</span> stderr.deinit(args.allocator);

    <span class="tok-kw">try</span> child.spawn();
    <span class="tok-kw">errdefer</span> {
        _ = child.kill() <span class="tok-kw">catch</span> {};
    }
    <span class="tok-kw">try</span> child.collectOutput(args.allocator, &amp;stdout, &amp;stderr, args.max_output_bytes);

    <span class="tok-kw">return</span> <a href="std.process.Child.RunResult.html">RunResult</a>{
        .stdout = <span class="tok-kw">try</span> stdout.toOwnedSlice(args.allocator),
        .stderr = <span class="tok-kw">try</span> stderr.toOwnedSlice(args.allocator),
        .term = <span class="tok-kw">try</span> child.wait(),
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.process.Child">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> unicode = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> process = <a href="std.html">std</a>.<a href="std.process.html">process</a>;
<span class="tok-kw">const</span> File = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
<span class="tok-kw">const</span> linux = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> EnvMap = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.EnvMap.html">EnvMap</a>;
<span class="tok-kw">const</span> maxInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> native_os = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> ChildProcess = <span class="tok-builtin">@This</span>();

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Id = <span class="tok-kw">switch</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a>) {
    .windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>,
    .wasi =&gt; <span class="tok-type">void</span>,
    <span class="tok-kw">else</span> =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pid_t">pid_t</a>,
};

<span class="tok-comment">/// Available after calling `spawn()`. This becomes `undefined` after calling `wait()`.</span>
<span class="tok-comment">/// On Windows this is the hProcess.</span>
<span class="tok-comment">/// On POSIX this is the pid.</span>
id: <a href="std.process.Child.html#std.process.Child.Id">Id</a>,
thread_handle: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> <span class="tok-kw">else</span> <span class="tok-type">void</span>,

allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,

<span class="tok-comment">/// The writing end of the child process's standard input pipe.</span>
<span class="tok-comment">/// Usage requires `stdin_behavior == StdIo.Pipe`.</span>
<span class="tok-comment">/// Available after calling `spawn()`.</span>
stdin: ?<a href="std.fs.File.html">File</a>,

<span class="tok-comment">/// The reading end of the child process's standard output pipe.</span>
<span class="tok-comment">/// Usage requires `stdout_behavior == StdIo.Pipe`.</span>
<span class="tok-comment">/// Available after calling `spawn()`.</span>
stdout: ?<a href="std.fs.File.html">File</a>,

<span class="tok-comment">/// The reading end of the child process's standard error pipe.</span>
<span class="tok-comment">/// Usage requires `stderr_behavior == StdIo.Pipe`.</span>
<span class="tok-comment">/// Available after calling `spawn()`.</span>
stderr: ?<a href="std.fs.File.html">File</a>,

<span class="tok-comment">/// Terminated state of the child process.</span>
<span class="tok-comment">/// Available after calling `wait()`.</span>
term: ?(<a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<a href="std.process.Child.Term.html">Term</a>),

argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

<span class="tok-comment">/// Leave as null to use the current env map using the supplied allocator.</span>
env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>,

stdin_behavior: <a href="std.process.Child.StdIo.html">StdIo</a>,
stdout_behavior: <a href="std.process.Child.StdIo.html">StdIo</a>,
stderr_behavior: <a href="std.process.Child.StdIo.html">StdIo</a>,

<span class="tok-comment">/// Set to change the user id when spawning the child process.</span>
uid: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) <span class="tok-type">void</span> <span class="tok-kw">else</span> ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uid_t">uid_t</a>,

<span class="tok-comment">/// Set to change the group id when spawning the child process.</span>
gid: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) <span class="tok-type">void</span> <span class="tok-kw">else</span> ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.gid_t">gid_t</a>,

<span class="tok-comment">/// Set to change the process group id when spawning the child process.</span>
pgid: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) <span class="tok-type">void</span> <span class="tok-kw">else</span> ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pid_t">pid_t</a>,

<span class="tok-comment">/// Set to change the current working directory when spawning the child process.</span>
cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
<span class="tok-comment">/// Set to change the current working directory when spawning the child process.</span>
<span class="tok-comment">/// This is not yet implemented for Windows. See https://github.com/ziglang/zig/issues/5190</span>
<span class="tok-comment">/// Once that is done, `cwd` will be deprecated in favor of this field.</span>
cwd_dir: ?<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a> = <span class="tok-null">null</span>,

err_pipe: <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) <span class="tok-type">void</span> <span class="tok-kw">else</span> ?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,

expand_arg0: <a href="std.posix.Arg0Expand.html">Arg0Expand</a>,

<span class="tok-comment">/// Darwin-only. Disable ASLR for the child process.</span>
disable_aslr: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Darwin-only. Start child process in suspended state as if SIGSTOP was sent.</span>
start_suspended: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// Set to true to obtain rusage information for the child process.</span>
<span class="tok-comment">/// Depending on the target platform and implementation status, the</span>
<span class="tok-comment">/// requested statistics may or may not be available. If they are</span>
<span class="tok-comment">/// available, then the `resource_usage_statistics` field will be populated</span>
<span class="tok-comment">/// after calling `wait`.</span>
<span class="tok-comment">/// On Linux and Darwin, this obtains rusage statistics from wait4().</span>
request_resource_usage_statistics: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

<span class="tok-comment">/// This is available after calling wait if</span>
<span class="tok-comment">/// `request_resource_usage_statistics` was set to `true` before calling</span>
<span class="tok-comment">/// `spawn`.</span>
resource_usage_statistics: <a href="std.process.Child.ResourceUsageStatistics.html">ResourceUsageStatistics</a> = .{},

<span class="tok-comment">/// When populated, a pipe will be created for the child process to</span>
<span class="tok-comment">/// communicate progress back to the parent. The file descriptor of the</span>
<span class="tok-comment">/// write end of the pipe will be specified in the `ZIG_PROGRESS`</span>
<span class="tok-comment">/// environment variable inside the child process. The progress reported by</span>
<span class="tok-comment">/// the child will be attached to this progress node in the parent process.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The child's progress tree will be grafted into the parent's progress tree,</span>
<span class="tok-comment">/// by substituting this node with the child's root node.</span>
progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a> = <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ResourceUsageStatistics = <span class="tok-kw">struct</span> {
    rusage: <span class="tok-builtin">@TypeOf</span>(<a href="std.process.Child.ResourceUsageStatistics.html#std.process.Child.ResourceUsageStatistics.rusage_init">rusage_init</a>) = <a href="std.process.Child.ResourceUsageStatistics.html#std.process.Child.ResourceUsageStatistics.rusage_init">rusage_init</a>,

    <span class="tok-comment">/// Returns the peak resident set size of the child process, in bytes,</span>
    <span class="tok-comment">/// if available.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMaxRss</span>(rus: <a href="std.process.Child.ResourceUsageStatistics.html">ResourceUsageStatistics</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">switch</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a>) {
            .linux =&gt; {
                <span class="tok-kw">if</span> (rus.rusage) |ru| {
                    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(ru.maxrss)) * <span class="tok-number">1024</span>;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
            .windows =&gt; {
                <span class="tok-kw">if</span> (rus.rusage) |ru| {
                    <span class="tok-kw">return</span> ru.PeakWorkingSetSize;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
            .macos, .ios =&gt; {
                <span class="tok-kw">if</span> (rus.rusage) |ru| {<span class="tok-comment">
                    // Darwin oddly reports in bytes instead of kilobytes.
                    </span><span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(ru.maxrss));
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        }
    }

    <span class="tok-kw">const</span> rusage_init = <span class="tok-kw">switch</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a>) {
        .linux, .macos, .ios =&gt; <span class="tok-builtin">@as</span>(?<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rusage">rusage</a>, <span class="tok-null">null</span>),
        .windows =&gt; <span class="tok-builtin">@as</span>(?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.VM_COUNTERS.html">VM_COUNTERS</a>, <span class="tok-null">null</span>),
        <span class="tok-kw">else</span> =&gt; {},
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Arg0Expand = <a href="std.posix.html">posix</a>.<a href="std.posix.Arg0Expand.html">Arg0Expand</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SpawnError = <span class="tok-kw">error</span>{
    OutOfMemory,

    <span class="tok-comment">/// POSIX-only. `StdIo.Ignore` was selected and opening `/dev/null` returned ENODEV.</span>
    NoDevice,

    <span class="tok-comment">/// Windows-only. `cwd` or `argv` was provided and it was invalid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,

    <span class="tok-comment">/// Windows-only. `cwd` was provided, but the path did not exist when spawning the child process.</span>
    CurrentWorkingDirectoryUnlinked,

    <span class="tok-comment">/// Windows-only. NUL (U+0000), LF (U+000A), CR (U+000D) are not allowed</span>
    <span class="tok-comment">/// within arguments when executing a `.bat`/`.cmd` script.</span>
    <span class="tok-comment">/// - NUL/LF signifiies end of arguments, so anything afterwards</span>
    <span class="tok-comment">///   would be lost after execution.</span>
    <span class="tok-comment">/// - CR is stripped by `cmd.exe`, so any CR codepoints</span>
    <span class="tok-comment">///   would be lost after execution.</span>
    InvalidBatchScriptArg,
} ||
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ExecveError">ExecveError</a> ||
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SetIdError">SetIdError</a> ||
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a> ||
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a> ||
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateProcessError">CreateProcessError</a> ||
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfoError">GetProcessMemoryInfoError</a> ||
    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Term = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    Exited: <span class="tok-type">u8</span>,
    Signal: <span class="tok-type">u32</span>,
    Stopped: <span class="tok-type">u32</span>,
    Unknown: <span class="tok-type">u32</span>,
};

<span class="tok-comment">/// Behavior of the child process's standard input, output, and error</span>
<span class="tok-comment">/// streams.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StdIo = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// Inherit the stream from the parent process.</span>
    Inherit,

    <span class="tok-comment">/// Pass a null stream to the child process.</span>
    <span class="tok-comment">/// This is /dev/null on POSIX and NUL on Windows.</span>
    Ignore,

    <span class="tok-comment">/// Create a pipe for the stream.</span>
    <span class="tok-comment">/// The corresponding field (`stdout`, `stderr`, or `stdin`)</span>
    <span class="tok-comment">/// will be assigned a `File` object that can be used</span>
    <span class="tok-comment">/// to read from or write to the pipe.</span>
    Pipe,

    <span class="tok-comment">/// Close the stream after the child process spawns.</span>
    Close,
};

<span class="tok-comment">/// First argument in argv is the executable.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.Child.html">ChildProcess</a> {
    <span class="tok-kw">return</span> .{
        .allocator = allocator,
        .argv = argv,
        .id = <span class="tok-null">undefined</span>,
        .thread_handle = <span class="tok-null">undefined</span>,
        .err_pipe = <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) {} <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        .term = <span class="tok-null">null</span>,
        .env_map = <span class="tok-null">null</span>,
        .cwd = <span class="tok-null">null</span>,
        .uid = <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) {} <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        .gid = <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) {} <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        .pgid = <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows <span class="tok-kw">or</span> <a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .wasi) {} <span class="tok-kw">else</span> <span class="tok-null">null</span>,
        .stdin = <span class="tok-null">null</span>,
        .stdout = <span class="tok-null">null</span>,
        .stderr = <span class="tok-null">null</span>,
        .stdin_behavior = .Inherit,
        .stdout_behavior = .Inherit,
        .stderr_behavior = .Inherit,
        .expand_arg0 = .no_expand,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUserName</span>(self: *<a href="std.process.Child.html">ChildProcess</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> user_info = <span class="tok-kw">try</span> <a href="std.process.html">process</a>.<a href="std.process.html#std.process.getUserInfo">getUserInfo</a>(name);
    self.uid = user_info.uid;
    self.gid = user_info.gid;
}

<span class="tok-comment">/// On success must call `kill` or `wait`.</span>
<span class="tok-comment">/// After spawning the `id` is available.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">spawn</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;the target operating system cannot spawn processes&quot;</span>);
    }

    <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> self.spawnWindows();
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.spawnPosix();
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">spawnAndWait</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">try</span> self.spawn();
    <span class="tok-kw">return</span> self.wait();
}

<span class="tok-comment">/// Forcibly terminates child process and then cleans up all resources.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kill</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) !<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> self.killWindows(<span class="tok-number">1</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.killPosix();
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">killWindows</span>(self: *<a href="std.process.Child.html">ChildProcess</a>, exit_code: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UINT">UINT</a>) !<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">if</span> (self.term) |term| {
        self.cleanupStreams();
        <span class="tok-kw">return</span> term;
    }

    <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TerminateProcess">TerminateProcess</a>(self.id, exit_code) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.PermissionDenied =&gt; {<span class="tok-comment">
            // Usually when TerminateProcess triggers a ACCESS_DENIED error, it
            // indicates that the process has already exited, but there may be
            // some rare edge cases where our process handle no longer has the
            // PROCESS_TERMINATE access right, so let's do another check to make
            // sure the process is really no longer running:
            </span><a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WaitForSingleObjectEx">WaitForSingleObjectEx</a>(self.id, <span class="tok-number">0</span>, <span class="tok-null">false</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> err;
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyTerminated;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">try</span> self.waitUnwrappedWindows();
    <span class="tok-kw">return</span> self.term.?;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">killPosix</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) !<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">if</span> (self.term) |term| {
        self.cleanupStreams();
        <span class="tok-kw">return</span> term;
    }
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.kill">kill</a>(self.id, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">TERM</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ProcessNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AlreadyTerminated,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    self.waitUnwrappedPosix();
    <span class="tok-kw">return</span> self.term.?;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WaitError = <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a> || <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfoError">GetProcessMemoryInfoError</a>;

<span class="tok-comment">/// On some targets, `spawn` may not report all spawn errors, such as `error.InvalidExe`.</span>
<span class="tok-comment">/// This function will block until any spawn errors can be reported, and return them.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitForSpawn</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a> == .windows) <span class="tok-kw">return</span>;<span class="tok-comment"> // `spawn` reports everything
    </span><span class="tok-kw">if</span> (self.term) |term| {
        _ = term <span class="tok-kw">catch</span> |spawn_err| <span class="tok-kw">return</span> spawn_err;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> err_pipe = self.err_pipe <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
    self.err_pipe = <span class="tok-null">null</span>;<span class="tok-comment">

    // Wait for the child to report any errors in or before `execvpe`.
    </span><span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.readIntFd">readIntFd</a>(err_pipe)) |child_err_int| {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(err_pipe);
        <span class="tok-kw">const</span> child_err: <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a> = <span class="tok-builtin">@errorCast</span>(<span class="tok-builtin">@errorFromInt</span>(child_err_int));
        self.term = child_err;
        <span class="tok-kw">return</span> child_err;
    } <span class="tok-kw">else</span> |_| {<span class="tok-comment">
        // Write end closed by CLOEXEC at the time of the `execvpe` call, indicating success!
        </span><a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(err_pipe);
    }
}

<span class="tok-comment">/// Blocks until child process terminates and then cleans up all resources.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wait</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.WaitError">WaitError</a>!<a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">try</span> self.waitForSpawn();<span class="tok-comment"> // report spawn errors
    </span><span class="tok-kw">if</span> (self.term) |term| {
        self.cleanupStreams();
        <span class="tok-kw">return</span> term;
    }
    <span class="tok-kw">switch</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a>) {
        .windows =&gt; <span class="tok-kw">try</span> self.waitUnwrappedWindows(),
        <span class="tok-kw">else</span> =&gt; self.waitUnwrappedPosix(),
    }
    self.id = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> self.term.?;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RunResult = <span class="tok-kw">struct</span> {
    term: <a href="std.process.Child.Term.html">Term</a>,
    stdout: []<span class="tok-type">u8</span>,
    stderr: []<span class="tok-type">u8</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">writeFifoDataToArrayList</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, list: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>), fifo: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.PollFifo">PollFifo</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (fifo.head != <span class="tok-number">0</span>) fifo.realign();
    <span class="tok-kw">if</span> (list.capacity == <span class="tok-number">0</span>) {
        list.* = .{
            .items = fifo.buf[<span class="tok-number">0</span>..fifo.count],
            .capacity = fifo.buf.len,
        };
        fifo.* = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.PollFifo">PollFifo</a>.<a href="#">init</a>(fifo.allocator);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> list.appendSlice(allocator, fifo.buf[<span class="tok-number">0</span>..fifo.count]);
    }
}

<span class="tok-comment">/// Collect the output from the process's stdout and stderr. Will return once all output</span>
<span class="tok-comment">/// has been collected. This does not mean that the process has ended. `wait` should still</span>
<span class="tok-comment">/// be called to wait for and clean up the process.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The process must be started with stdout_behavior and stderr_behavior == .Pipe</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collectOutput</span>(
    child: <a href="std.process.Child.html">ChildProcess</a>,
    <span class="tok-comment">/// Used for `stdout` and `stderr`.</span>
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    stdout: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
    stderr: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),
    max_output_bytes: <span class="tok-type">usize</span>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(child.stdout_behavior == .Pipe);
    <a href="std.debug.html#std.debug.assert">assert</a>(child.stderr_behavior == .Pipe);

    <span class="tok-kw">var</span> poller = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.poll">poll</a>(allocator, <span class="tok-kw">enum</span> { stdout, stderr }, .{
        .stdout = child.stdout.?,
        .stderr = child.stderr.?,
    });
    <span class="tok-kw">defer</span> poller.deinit();

    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> poller.poll()) {
        <span class="tok-kw">if</span> (poller.fifo(.stdout).count &gt; max_output_bytes)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.StdoutStreamTooLong;
        <span class="tok-kw">if</span> (poller.fifo(.stderr).count &gt; max_output_bytes)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.StderrStreamTooLong;
    }

    <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.writeFifoDataToArrayList">writeFifoDataToArrayList</a>(allocator, stdout, poller.fifo(.stdout));
    <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.writeFifoDataToArrayList">writeFifoDataToArrayList</a>(allocator, stderr, poller.fifo(.stderr));
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RunError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a> || <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PollError">PollError</a> || <span class="tok-kw">error</span>{
    StdoutStreamTooLong,
    StderrStreamTooLong,
};

<span class="tok-comment">/// Spawns a child process, waits for it, collecting stdout and stderr, and then returns.</span>
<span class="tok-comment">/// If it succeeds, the caller owns result.stdout and result.stderr memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(args: <span class="tok-kw">struct</span> {
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    cwd_dir: ?<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a> = <span class="tok-null">null</span>,
    env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a> = <span class="tok-null">null</span>,
    max_output_bytes: <span class="tok-type">usize</span> = <span class="tok-number">50</span> * <span class="tok-number">1024</span>,
    expand_arg0: <a href="std.posix.Arg0Expand.html">Arg0Expand</a> = .no_expand,
    progress_node: <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a> = <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.Node.html">Node</a>.<a href="std.Progress.Node.html#std.Progress.Node.none">none</a>,
}) <a href="std.process.Child.html#std.process.Child.RunError">RunError</a>!<a href="std.process.Child.RunResult.html">RunResult</a> {
    <span class="tok-kw">var</span> child = <a href="std.process.Child.html">ChildProcess</a>.<a href="std.process.Child.html#std.process.Child.init">init</a>(args.argv, args.allocator);
    child.stdin_behavior = .Ignore;
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = .Pipe;
    child.cwd = args.cwd;
    child.cwd_dir = args.cwd_dir;
    child.env_map = args.env_map;
    child.expand_arg0 = args.expand_arg0;
    child.progress_node = args.progress_node;

    <span class="tok-kw">var</span> stdout: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty;
    <span class="tok-kw">errdefer</span> stdout.deinit(args.allocator);
    <span class="tok-kw">var</span> stderr: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty;
    <span class="tok-kw">errdefer</span> stderr.deinit(args.allocator);

    <span class="tok-kw">try</span> child.spawn();
    <span class="tok-kw">errdefer</span> {
        _ = child.kill() <span class="tok-kw">catch</span> {};
    }
    <span class="tok-kw">try</span> child.collectOutput(args.allocator, &amp;stdout, &amp;stderr, args.max_output_bytes);

    <span class="tok-kw">return</span> <a href="std.process.Child.RunResult.html">RunResult</a>{
        .stdout = <span class="tok-kw">try</span> stdout.toOwnedSlice(args.allocator),
        .stderr = <span class="tok-kw">try</span> stderr.toOwnedSlice(args.allocator),
        .term = <span class="tok-kw">try</span> child.wait(),
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">waitUnwrappedWindows</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.WaitError">WaitError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WaitForSingleObjectEx">WaitForSingleObjectEx</a>(self.id, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.INFINITE">INFINITE</a>, <span class="tok-null">false</span>);

    self.term = <span class="tok-builtin">@as</span>(<a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<a href="std.process.Child.Term.html">Term</a>, x: {
        <span class="tok-kw">var</span> exit_code: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetExitCodeProcess">GetExitCodeProcess</a>(self.id, &amp;exit_code) == <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span> :x <a href="std.process.Child.Term.html">Term</a>{ .Unknown = <span class="tok-number">0</span> };
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">break</span> :x <a href="std.process.Child.Term.html">Term</a>{ .Exited = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(exit_code)) };
        }
    });

    <span class="tok-kw">if</span> (self.request_resource_usage_statistics) {
        self.resource_usage_statistics.rusage = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfo">GetProcessMemoryInfo</a>(self.id);
    }

    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.id);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.thread_handle);
    self.cleanupStreams();
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">waitUnwrappedPosix</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> res: <a href="std.posix.html">posix</a>.<a href="std.posix.WaitPidResult.html">WaitPidResult</a> = res: {
        <span class="tok-kw">if</span> (self.request_resource_usage_statistics) {
            <span class="tok-kw">switch</span> (<a href="std.process.Child.html#std.process.Child.native_os">native_os</a>) {
                .linux, .macos, .ios =&gt; {
                    <span class="tok-kw">var</span> ru: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rusage">rusage</a> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">const</span> res = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.wait4">wait4</a>(self.id, <span class="tok-number">0</span>, &amp;ru);
                    self.resource_usage_statistics.rusage = ru;
                    <span class="tok-kw">break</span> :res res;
                },
                <span class="tok-kw">else</span> =&gt; {},
            }
        }

        <span class="tok-kw">break</span> :res <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.waitpid">waitpid</a>(self.id, <span class="tok-number">0</span>);
    };
    <span class="tok-kw">const</span> status = res.status;
    self.cleanupStreams();
    self.handleWaitResult(status);
}

<span class="tok-kw">fn</span> <span class="tok-fn">handleWaitResult</span>(self: *<a href="std.process.Child.html">ChildProcess</a>, status: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
    self.term = <a href="std.process.Child.html#std.process.Child.statusToTerm">statusToTerm</a>(status);
}

<span class="tok-kw">fn</span> <span class="tok-fn">cleanupStreams</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.stdin) |*stdin| {
        stdin.close();
        self.stdin = <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (self.stdout) |*stdout| {
        stdout.close();
        self.stdout = <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (self.stderr) |*stderr| {
        stderr.close();
        self.stderr = <span class="tok-null">null</span>;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">statusToTerm</span>(status: <span class="tok-type">u32</span>) <a href="std.process.Child.Term.html">Term</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W">W</a>.<a href="#">IFEXITED</a>(status))
        <a href="std.process.Child.Term.html">Term</a>{ .Exited = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W">W</a>.<a href="#">EXITSTATUS</a>(status) }
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W">W</a>.<a href="#">IFSIGNALED</a>(status))
        <a href="std.process.Child.Term.html">Term</a>{ .Signal = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W">W</a>.<a href="#">TERMSIG</a>(status) }
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W">W</a>.<a href="#">IFSTOPPED</a>(status))
        <a href="std.process.Child.Term.html">Term</a>{ .Stopped = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W">W</a>.<a href="#">STOPSIG</a>(status) }
    <span class="tok-kw">else</span>
        <a href="std.process.Child.Term.html">Term</a>{ .Unknown = status };
}

<span class="tok-kw">fn</span> <span class="tok-fn">spawnPosix</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // The child process does need to access (one end of) these pipes. However,
    // we must initially set CLOEXEC to avoid a race condition. If another thread
    // is racing to spawn a different child process, we don't want it to inherit
    // these FDs in any scenario; that would mean that, for instance, calls to
    // `poll` from the parent would not report the child's stdout as closing when
    // expected, since the other child may retain a reference to the write end of
    // the pipe. So, we create the pipes with CLOEXEC initially. After fork, we
    // need to do something in the new child to make sure we preserve the reference
    // we want. We could use `fcntl` to remove CLOEXEC from the FD, but as it
    // turns out, we `dup2` everything anyway, so there's no need!
    </span><span class="tok-kw">const</span> pipe_flags: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.O">O</a> = .{ .CLOEXEC = <span class="tok-null">true</span> };

    <span class="tok-kw">const</span> stdin_pipe = <span class="tok-kw">if</span> (self.stdin_behavior == .Pipe) <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pipe2">pipe2</a>(pipe_flags) <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.stdin_behavior == .Pipe) {
        <a href="std.process.Child.html#std.process.Child.destroyPipe">destroyPipe</a>(stdin_pipe);
    };

    <span class="tok-kw">const</span> stdout_pipe = <span class="tok-kw">if</span> (self.stdout_behavior == .Pipe) <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pipe2">pipe2</a>(pipe_flags) <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.stdout_behavior == .Pipe) {
        <a href="std.process.Child.html#std.process.Child.destroyPipe">destroyPipe</a>(stdout_pipe);
    };

    <span class="tok-kw">const</span> stderr_pipe = <span class="tok-kw">if</span> (self.stderr_behavior == .Pipe) <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pipe2">pipe2</a>(pipe_flags) <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.stderr_behavior == .Pipe) {
        <a href="std.process.Child.html#std.process.Child.destroyPipe">destroyPipe</a>(stderr_pipe);
    };

    <span class="tok-kw">const</span> any_ignore = (self.stdin_behavior == .Ignore <span class="tok-kw">or</span> self.stdout_behavior == .Ignore <span class="tok-kw">or</span> self.stderr_behavior == .Ignore);
    <span class="tok-kw">const</span> dev_null_fd = <span class="tok-kw">if</span> (any_ignore)
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openZ">openZ</a>(<span class="tok-str">&quot;/dev/null&quot;</span>, .{ .ACCMODE = .RDWR }, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.DeviceBusy =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    <span class="tok-kw">else</span>
        <span class="tok-null">undefined</span>;
    <span class="tok-kw">defer</span> {
        <span class="tok-kw">if</span> (any_ignore) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(dev_null_fd);
    }

    <span class="tok-kw">const</span> prog_pipe: [<span class="tok-number">2</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a> = p: {
        <span class="tok-kw">if</span> (self.progress_node.index == .none) {
            <span class="tok-kw">break</span> :p .{ -<span class="tok-number">1</span>, -<span class="tok-number">1</span> };
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // We use CLOEXEC for the same reason as in `pipe_flags`.
            </span><span class="tok-kw">break</span> :p <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pipe2">pipe2</a>(.{ .NONBLOCK = <span class="tok-null">true</span>, .CLOEXEC = <span class="tok-null">true</span> });
        }
    };
    <span class="tok-kw">errdefer</span> <a href="std.process.Child.html#std.process.Child.destroyPipe">destroyPipe</a>(prog_pipe);

    <span class="tok-kw">var</span> arena_allocator = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(self.allocator);
    <span class="tok-kw">defer</span> arena_allocator.deinit();
    <span class="tok-kw">const</span> arena = arena_allocator.allocator();<span class="tok-comment">

    // The POSIX standard does not allow malloc() between fork() and execve(),
    // and `self.allocator` may be a libc allocator.
    // I have personally observed the child process deadlocking when it tries
    // to call malloc() due to a heap allocation between fork() and execve(),
    // in musl v1.1.24.
    // Additionally, we want to reduce the number of possible ways things
    // can fail between fork() and execve().
    // Therefore, we do all the allocation for the execve() before the fork().
    // This means we must do the null-termination of argv and env vars here.
    </span><span class="tok-kw">const</span> argv_buf = <span class="tok-kw">try</span> arena.allocSentinel(?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, self.argv.len, <span class="tok-null">null</span>);
    <span class="tok-kw">for</span> (self.argv, <span class="tok-number">0</span>..) |arg, i| argv_buf[i] = (<span class="tok-kw">try</span> arena.dupeZ(<span class="tok-type">u8</span>, arg)).ptr;

    <span class="tok-kw">const</span> prog_fileno = <span class="tok-number">3</span>;
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@max</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDIN_FILENO">STDIN_FILENO</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDOUT_FILENO">STDOUT_FILENO</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDERR_FILENO">STDERR_FILENO</a>) + <span class="tok-number">1</span> == prog_fileno);

    <span class="tok-kw">const</span> envp: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = m: {
        <span class="tok-kw">const</span> prog_fd: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (prog_pipe[<span class="tok-number">1</span>] == -<span class="tok-number">1</span>) -<span class="tok-number">1</span> <span class="tok-kw">else</span> prog_fileno;
        <span class="tok-kw">if</span> (self.env_map) |env_map| {
            <span class="tok-kw">break</span> :m (<span class="tok-kw">try</span> <a href="std.process.html">process</a>.<a href="std.process.html#std.process.createEnvironFromMap">createEnvironFromMap</a>(arena, env_map, .{
                .zig_progress_fd = prog_fd,
            })).ptr;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">break</span> :m (<span class="tok-kw">try</span> <a href="std.process.html">process</a>.<a href="std.process.html#std.process.createEnvironFromExisting">createEnvironFromExisting</a>(arena, <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.environ">environ</a>, .{
                .zig_progress_fd = prog_fd,
            })).ptr;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.output_mode">output_mode</a> == .Exe) {<span class="tok-comment">
            // Then we have Zig start code and this works.
            // TODO type-safety for null-termination of `os.environ`.
            </span><span class="tok-kw">break</span> :m (<span class="tok-kw">try</span> <a href="std.process.html">process</a>.<a href="std.process.html#std.process.createEnvironFromExisting">createEnvironFromExisting</a>(arena, <span class="tok-builtin">@ptrCast</span>(<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.environ">environ</a>.<a href="#">ptr</a>), .{
                .zig_progress_fd = prog_fd,
            })).ptr;
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // TODO come up with a solution for this.
            </span><span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;missing std lib enhancement: ChildProcess implementation has no way to collect the environment variables to forward to the child process&quot;</span>);
        }
    };<span class="tok-comment">

    // This pipe communicates to the parent errors in the child between `fork` and `execvpe`.
    // It is closed by the child (via CLOEXEC) without writing if `execvpe` succeeds.
    </span><span class="tok-kw">const</span> err_pipe: [<span class="tok-number">2</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pipe2">pipe2</a>(.{ .CLOEXEC = <span class="tok-null">true</span> });
    <span class="tok-kw">errdefer</span> <a href="std.process.Child.html#std.process.Child.destroyPipe">destroyPipe</a>(err_pipe);

    <span class="tok-kw">const</span> pid_result = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fork">fork</a>();
    <span class="tok-kw">if</span> (pid_result == <span class="tok-number">0</span>) {<span class="tok-comment">
        // we are the child
        </span><a href="std.process.Child.html#std.process.Child.setUpChildIo">setUpChildIo</a>(self.stdin_behavior, stdin_pipe[<span class="tok-number">0</span>], <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDIN_FILENO">STDIN_FILENO</a>, dev_null_fd) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);
        <a href="std.process.Child.html#std.process.Child.setUpChildIo">setUpChildIo</a>(self.stdout_behavior, stdout_pipe[<span class="tok-number">1</span>], <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDOUT_FILENO">STDOUT_FILENO</a>, dev_null_fd) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);
        <a href="std.process.Child.html#std.process.Child.setUpChildIo">setUpChildIo</a>(self.stderr_behavior, stderr_pipe[<span class="tok-number">1</span>], <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDERR_FILENO">STDERR_FILENO</a>, dev_null_fd) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);

        <span class="tok-kw">if</span> (self.cwd_dir) |cwd| {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fchdir">fchdir</a>(cwd.fd) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (self.cwd) |cwd| {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.chdir">chdir</a>(cwd) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);
        }<span class="tok-comment">

        // Must happen after fchdir above, the cwd file descriptor might be
        // equal to prog_fileno and be clobbered by this dup2 call.
        </span><span class="tok-kw">if</span> (prog_pipe[<span class="tok-number">1</span>] != -<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.dup2">dup2</a>(prog_pipe[<span class="tok-number">1</span>], prog_fileno) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);

        <span class="tok-kw">if</span> (self.gid) |gid| {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setregid">setregid</a>(gid, gid) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);
        }

        <span class="tok-kw">if</span> (self.uid) |uid| {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setreuid">setreuid</a>(uid, uid) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);
        }

        <span class="tok-kw">if</span> (self.pgid) |pid| {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setpgid">setpgid</a>(<span class="tok-number">0</span>, pid) <span class="tok-kw">catch</span> |err| <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);
        }

        <span class="tok-kw">const</span> err = <span class="tok-kw">switch</span> (self.expand_arg0) {
            .expand =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.execvpeZ_expandArg0">execvpeZ_expandArg0</a>(.expand, argv_buf.ptr[<span class="tok-number">0</span>].?, argv_buf.ptr, envp),
            .no_expand =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.execvpeZ_expandArg0">execvpeZ_expandArg0</a>(.no_expand, argv_buf.ptr[<span class="tok-number">0</span>].?, argv_buf.ptr, envp),
        };
        <a href="std.process.Child.html#std.process.Child.forkChildErrReport">forkChildErrReport</a>(err_pipe[<span class="tok-number">1</span>], err);
    }<span class="tok-comment">

    // we are the parent
    </span><span class="tok-kw">errdefer</span> <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // The child is forked; we must not error from now on

    </span><a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(err_pipe[<span class="tok-number">1</span>]);<span class="tok-comment"> // make sure only the child holds the write end open
    </span>self.err_pipe = err_pipe[<span class="tok-number">0</span>];

    <span class="tok-kw">const</span> pid: <span class="tok-type">i32</span> = <span class="tok-builtin">@intCast</span>(pid_result);
    <span class="tok-kw">if</span> (self.stdin_behavior == .Pipe) {
        self.stdin = .{ .handle = stdin_pipe[<span class="tok-number">1</span>] };
    } <span class="tok-kw">else</span> {
        self.stdin = <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (self.stdout_behavior == .Pipe) {
        self.stdout = .{ .handle = stdout_pipe[<span class="tok-number">0</span>] };
    } <span class="tok-kw">else</span> {
        self.stdout = <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (self.stderr_behavior == .Pipe) {
        self.stderr = .{ .handle = stderr_pipe[<span class="tok-number">0</span>] };
    } <span class="tok-kw">else</span> {
        self.stderr = <span class="tok-null">null</span>;
    }

    self.id = pid;
    self.term = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (self.stdin_behavior == .Pipe) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(stdin_pipe[<span class="tok-number">0</span>]);
    }
    <span class="tok-kw">if</span> (self.stdout_behavior == .Pipe) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(stdout_pipe[<span class="tok-number">1</span>]);
    }
    <span class="tok-kw">if</span> (self.stderr_behavior == .Pipe) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(stderr_pipe[<span class="tok-number">1</span>]);
    }

    <span class="tok-kw">if</span> (prog_pipe[<span class="tok-number">1</span>] != -<span class="tok-number">1</span>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(prog_pipe[<span class="tok-number">1</span>]);
    }
    self.progress_node.setIpcFd(prog_pipe[<span class="tok-number">0</span>]);
}

<span class="tok-kw">fn</span> <span class="tok-fn">spawnWindows</span>(self: *<a href="std.process.Child.html">ChildProcess</a>) <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> saAttr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.SECURITY_ATTRIBUTES.html">SECURITY_ATTRIBUTES</a>{
        .nLength = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.SECURITY_ATTRIBUTES.html">SECURITY_ATTRIBUTES</a>),
        .bInheritHandle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>,
        .lpSecurityDescriptor = <span class="tok-null">null</span>,
    };

    <span class="tok-kw">const</span> any_ignore = (self.stdin_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Ignore</a> <span class="tok-kw">or</span> self.stdout_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Ignore</a> <span class="tok-kw">or</span> self.stderr_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Ignore</a>);

    <span class="tok-kw">const</span> nul_handle = <span class="tok-kw">if</span> (any_ignore)<span class="tok-comment">
        // &quot;\Device\Null&quot; or &quot;\??\NUL&quot;
        </span><a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OpenFile">OpenFile</a>(&amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'\\'</span>, <span class="tok-str">'D'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'v'</span>, <span class="tok-str">'i'</span>, <span class="tok-str">'c'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'\\'</span>, <span class="tok-str">'N'</span>, <span class="tok-str">'u'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span> }, .{
            .access_mask = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_READ">GENERIC_READ</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_WRITE">GENERIC_WRITE</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SYNCHRONIZE">SYNCHRONIZE</a>,
            .share_access = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_SHARE_READ">FILE_SHARE_READ</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_SHARE_WRITE">FILE_SHARE_WRITE</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_SHARE_DELETE">FILE_SHARE_DELETE</a>,
            .sa = &amp;saAttr,
            .creation = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OPEN_EXISTING">OPEN_EXISTING</a>,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,<span class="tok-comment"> // not possible for &quot;NUL&quot;
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    <span class="tok-kw">else</span>
        <span class="tok-null">undefined</span>;
    <span class="tok-kw">defer</span> {
        <span class="tok-kw">if</span> (any_ignore) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(nul_handle);
    }

    <span class="tok-kw">var</span> g_hChildStd_IN_Rd: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> g_hChildStd_IN_Wr: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">switch</span> (self.stdin_behavior) {
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a> =&gt; {
            <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.windowsMakePipeIn">windowsMakePipeIn</a>(&amp;g_hChildStd_IN_Rd, &amp;g_hChildStd_IN_Wr, &amp;saAttr);
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Ignore</a> =&gt; {
            g_hChildStd_IN_Rd = nul_handle;
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Inherit</a> =&gt; {
            g_hChildStd_IN_Rd = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetStdHandle">GetStdHandle</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.STD_INPUT_HANDLE">STD_INPUT_HANDLE</a>) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Close</a> =&gt; {
            g_hChildStd_IN_Rd = <span class="tok-null">null</span>;
        },
    }
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.stdin_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a>) {
        <a href="std.process.Child.html#std.process.Child.windowsDestroyPipe">windowsDestroyPipe</a>(g_hChildStd_IN_Rd, g_hChildStd_IN_Wr);
    };

    <span class="tok-kw">var</span> g_hChildStd_OUT_Rd: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> g_hChildStd_OUT_Wr: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">switch</span> (self.stdout_behavior) {
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a> =&gt; {
            <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.windowsMakeAsyncPipe">windowsMakeAsyncPipe</a>(&amp;g_hChildStd_OUT_Rd, &amp;g_hChildStd_OUT_Wr, &amp;saAttr);
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Ignore</a> =&gt; {
            g_hChildStd_OUT_Wr = nul_handle;
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Inherit</a> =&gt; {
            g_hChildStd_OUT_Wr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetStdHandle">GetStdHandle</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.STD_OUTPUT_HANDLE">STD_OUTPUT_HANDLE</a>) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Close</a> =&gt; {
            g_hChildStd_OUT_Wr = <span class="tok-null">null</span>;
        },
    }
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.stdout_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a>) {
        <a href="std.process.Child.html#std.process.Child.windowsDestroyPipe">windowsDestroyPipe</a>(g_hChildStd_OUT_Rd, g_hChildStd_OUT_Wr);
    };

    <span class="tok-kw">var</span> g_hChildStd_ERR_Rd: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> g_hChildStd_ERR_Wr: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">switch</span> (self.stderr_behavior) {
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a> =&gt; {
            <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.windowsMakeAsyncPipe">windowsMakeAsyncPipe</a>(&amp;g_hChildStd_ERR_Rd, &amp;g_hChildStd_ERR_Wr, &amp;saAttr);
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Ignore</a> =&gt; {
            g_hChildStd_ERR_Wr = nul_handle;
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Inherit</a> =&gt; {
            g_hChildStd_ERR_Wr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetStdHandle">GetStdHandle</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.STD_ERROR_HANDLE">STD_ERROR_HANDLE</a>) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
        },
        <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Close</a> =&gt; {
            g_hChildStd_ERR_Wr = <span class="tok-null">null</span>;
        },
    }
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (self.stderr_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a>) {
        <a href="std.process.Child.html#std.process.Child.windowsDestroyPipe">windowsDestroyPipe</a>(g_hChildStd_ERR_Rd, g_hChildStd_ERR_Wr);
    };

    <span class="tok-kw">var</span> siStartInfo = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.STARTUPINFOW.html">STARTUPINFOW</a>{
        .cb = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.STARTUPINFOW.html">STARTUPINFOW</a>),
        .hStdError = g_hChildStd_ERR_Wr,
        .hStdOutput = g_hChildStd_OUT_Wr,
        .hStdInput = g_hChildStd_IN_Rd,
        .dwFlags = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.STARTF_USESTDHANDLES">STARTF_USESTDHANDLES</a>,

        .lpReserved = <span class="tok-null">null</span>,
        .lpDesktop = <span class="tok-null">null</span>,
        .lpTitle = <span class="tok-null">null</span>,
        .dwX = <span class="tok-number">0</span>,
        .dwY = <span class="tok-number">0</span>,
        .dwXSize = <span class="tok-number">0</span>,
        .dwYSize = <span class="tok-number">0</span>,
        .dwXCountChars = <span class="tok-number">0</span>,
        .dwYCountChars = <span class="tok-number">0</span>,
        .dwFillAttribute = <span class="tok-number">0</span>,
        .wShowWindow = <span class="tok-number">0</span>,
        .cbReserved2 = <span class="tok-number">0</span>,
        .lpReserved2 = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">var</span> piProcInfo: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.PROCESS_INFORMATION.html">PROCESS_INFORMATION</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> cwd_w = <span class="tok-kw">if</span> (self.cwd) |cwd| <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(self.allocator, cwd) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cwd_w) |cwd| self.allocator.free(cwd);
    <span class="tok-kw">const</span> cwd_w_ptr = <span class="tok-kw">if</span> (cwd_w) |cwd| cwd.ptr <span class="tok-kw">else</span> <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> maybe_envp_buf = <span class="tok-kw">if</span> (self.env_map) |env_map| <span class="tok-kw">try</span> <a href="std.process.html">process</a>.<a href="std.process.html#std.process.createWindowsEnvBlock">createWindowsEnvBlock</a>(self.allocator, env_map) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (maybe_envp_buf) |envp_buf| self.allocator.free(envp_buf);
    <span class="tok-kw">const</span> envp_ptr = <span class="tok-kw">if</span> (maybe_envp_buf) |envp_buf| envp_buf.ptr <span class="tok-kw">else</span> <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> app_name_wtf8 = self.argv[<span class="tok-number">0</span>];
    <span class="tok-kw">const</span> app_name_is_absolute = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(app_name_wtf8);<span class="tok-comment">

    // the cwd set in ChildProcess is in effect when choosing the executable path
    // to match posix semantics
    </span><span class="tok-kw">var</span> cwd_path_w_needs_free = <span class="tok-null">false</span>;
    <span class="tok-kw">const</span> cwd_path_w = x: {<span class="tok-comment">
        // If the app name is absolute, then we need to use its dirname as the cwd
        </span><span class="tok-kw">if</span> (app_name_is_absolute) {
            cwd_path_w_needs_free = <span class="tok-null">true</span>;
            <span class="tok-kw">const</span> dir = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(app_name_wtf8).?;
            <span class="tok-kw">break</span> :x <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(self.allocator, dir);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (self.cwd) |cwd| {
            cwd_path_w_needs_free = <span class="tok-null">true</span>;
            <span class="tok-kw">break</span> :x <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(self.allocator, cwd);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">break</span> :x &amp;[_:<span class="tok-number">0</span>]<span class="tok-type">u16</span>{};<span class="tok-comment"> // empty for cwd
        </span>}
    };
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cwd_path_w_needs_free) self.allocator.free(cwd_path_w);<span class="tok-comment">

    // If the app name has more than just a filename, then we need to separate that
    // into the basename and dirname and use the dirname as an addition to the cwd
    // path. This is because NtQueryDirectoryFile cannot accept FileName params with
    // path separators.
    </span><span class="tok-kw">const</span> app_basename_wtf8 = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(app_name_wtf8);<span class="tok-comment">
    // If the app name is absolute, then the cwd will already have the app's dirname in it,
    // so only populate app_dirname if app name is a relative path with &gt; 0 path separators.
    </span><span class="tok-kw">const</span> maybe_app_dirname_wtf8 = <span class="tok-kw">if</span> (!app_name_is_absolute) <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(app_name_wtf8) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> app_dirname_w: ?[:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = x: {
        <span class="tok-kw">if</span> (maybe_app_dirname_wtf8) |app_dirname_wtf8| {
            <span class="tok-kw">break</span> :x <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(self.allocator, app_dirname_wtf8);
        }
        <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;
    };
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (app_dirname_w != <span class="tok-null">null</span>) self.allocator.free(app_dirname_w.?);

    <span class="tok-kw">const</span> app_name_w = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(self.allocator, app_basename_wtf8);
    <span class="tok-kw">defer</span> self.allocator.free(app_name_w);

    run: {
        <span class="tok-kw">const</span> PATH: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = <a href="std.process.html">process</a>.<a href="std.process.html#std.process.getenvW">getenvW</a>(<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;PATH&quot;</span>)) <span class="tok-kw">orelse</span> &amp;[_:<span class="tok-number">0</span>]<span class="tok-type">u16</span>{};
        <span class="tok-kw">const</span> PATHEXT: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = <a href="std.process.html">process</a>.<a href="std.process.html#std.process.getenvW">getenvW</a>(<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;PATHEXT&quot;</span>)) <span class="tok-kw">orelse</span> &amp;[_:<span class="tok-number">0</span>]<span class="tok-type">u16</span>{};<span class="tok-comment">

        // In case the command ends up being a .bat/.cmd script, we need to escape things using the cmd.exe rules
        // and invoke cmd.exe ourselves in order to mitigate arbitrary command execution from maliciously
        // constructed arguments.
        //
        // We'll need to wait until we're actually trying to run the command to know for sure
        // if the resolved command has the `.bat` or `.cmd` extension, so we defer actually
        // serializing the command line until we determine how it should be serialized.
        </span><span class="tok-kw">var</span> cmd_line_cache = <a href="std.process.Child.WindowsCommandLineCache.html">WindowsCommandLineCache</a>.<a href="std.process.Child.WindowsCommandLineCache.html#std.process.Child.WindowsCommandLineCache.init">init</a>(self.allocator, self.argv);
        <span class="tok-kw">defer</span> cmd_line_cache.deinit();

        <span class="tok-kw">var</span> app_buf: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u16</span>) = .empty;
        <span class="tok-kw">defer</span> app_buf.deinit(self.allocator);

        <span class="tok-kw">try</span> app_buf.appendSlice(self.allocator, app_name_w);

        <span class="tok-kw">var</span> dir_buf: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u16</span>) = .empty;
        <span class="tok-kw">defer</span> dir_buf.deinit(self.allocator);

        <span class="tok-kw">if</span> (cwd_path_w.len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> dir_buf.appendSlice(self.allocator, cwd_path_w);
        }
        <span class="tok-kw">if</span> (app_dirname_w) |app_dir| {
            <span class="tok-kw">if</span> (dir_buf.items.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> dir_buf.append(self.allocator, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>);
            <span class="tok-kw">try</span> dir_buf.appendSlice(self.allocator, app_dir);
        }
        <span class="tok-kw">if</span> (dir_buf.items.len &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
            // Need to normalize the path, openDirW can't handle things like double backslashes
            </span><span class="tok-kw">const</span> normalized_len = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.normalizePath">normalizePath</a>(<span class="tok-type">u16</span>, dir_buf.items) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName;
            dir_buf.shrinkRetainingCapacity(normalized_len);
        }

        <a href="std.process.Child.html#std.process.Child.windowsCreateProcessPathExt">windowsCreateProcessPathExt</a>(self.allocator, &amp;dir_buf, &amp;app_buf, PATHEXT, &amp;cmd_line_cache, envp_ptr, cwd_w_ptr, &amp;siStartInfo, &amp;piProcInfo) <span class="tok-kw">catch</span> |no_path_err| {
            <span class="tok-kw">const</span> original_err = <span class="tok-kw">switch</span> (no_path_err) {<span class="tok-comment">
                // argv[0] contains unsupported characters that will never resolve to a valid exe.
                </span><span class="tok-kw">error</span>.InvalidArg0 =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
                <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.InvalidExe, <span class="tok-kw">error</span>.AccessDenied =&gt; |e| e,
                <span class="tok-kw">error</span>.UnrecoverableInvalidExe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };<span class="tok-comment">

            // If the app name had path separators, that disallows PATH searching,
            // and there's no need to search the PATH if the app name is absolute.
            // We still search the path if the cwd is absolute because of the
            // &quot;cwd set in ChildProcess is in effect when choosing the executable path
            // to match posix semantics&quot; behavior--we don't want to skip searching
            // the PATH just because we were trying to set the cwd of the child process.
            </span><span class="tok-kw">if</span> (app_dirname_w != <span class="tok-null">null</span> <span class="tok-kw">or</span> app_name_is_absolute) {
                <span class="tok-kw">return</span> original_err;
            }

            <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u16</span>, PATH, <span class="tok-str">';'</span>);
            <span class="tok-kw">while</span> (it.next()) |search_path| {
                dir_buf.clearRetainingCapacity();
                <span class="tok-kw">try</span> dir_buf.appendSlice(self.allocator, search_path);<span class="tok-comment">
                // Need to normalize the path, some PATH values can contain things like double
                // backslashes which openDirW can't handle
                </span><span class="tok-kw">const</span> normalized_len = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.normalizePath">normalizePath</a>(<span class="tok-type">u16</span>, dir_buf.items) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
                dir_buf.shrinkRetainingCapacity(normalized_len);

                <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.windowsCreateProcessPathExt">windowsCreateProcessPathExt</a>(self.allocator, &amp;dir_buf, &amp;app_buf, PATHEXT, &amp;cmd_line_cache, envp_ptr, cwd_w_ptr, &amp;siStartInfo, &amp;piProcInfo)) {
                    <span class="tok-kw">break</span> :run;
                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
                    // argv[0] contains unsupported characters that will never resolve to a valid exe.
                    </span><span class="tok-kw">error</span>.InvalidArg0 =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
                    <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.AccessDenied, <span class="tok-kw">error</span>.InvalidExe =&gt; <span class="tok-kw">continue</span>,
                    <span class="tok-kw">error</span>.UnrecoverableInvalidExe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExe,
                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                }
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> original_err;
            }
        };
    }

    <span class="tok-kw">if</span> (g_hChildStd_IN_Wr) |h| {
        self.stdin = <a href="std.fs.File.html">File</a>{ .handle = h };
    } <span class="tok-kw">else</span> {
        self.stdin = <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (g_hChildStd_OUT_Rd) |h| {
        self.stdout = <a href="std.fs.File.html">File</a>{ .handle = h };
    } <span class="tok-kw">else</span> {
        self.stdout = <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (g_hChildStd_ERR_Rd) |h| {
        self.stderr = <a href="std.fs.File.html">File</a>{ .handle = h };
    } <span class="tok-kw">else</span> {
        self.stderr = <span class="tok-null">null</span>;
    }

    self.id = piProcInfo.hProcess;
    self.thread_handle = piProcInfo.hThread;
    self.term = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (self.stdin_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(g_hChildStd_IN_Rd.?);
    }
    <span class="tok-kw">if</span> (self.stderr_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(g_hChildStd_ERR_Wr.?);
    }
    <span class="tok-kw">if</span> (self.stdout_behavior == <a href="std.process.Child.StdIo.html">StdIo</a>.<a href="#">Pipe</a>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(g_hChildStd_OUT_Wr.?);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">setUpChildIo</span>(stdio: <a href="std.process.Child.StdIo.html">StdIo</a>, pipe_fd: <span class="tok-type">i32</span>, std_fileno: <span class="tok-type">i32</span>, dev_null_fd: <span class="tok-type">i32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (stdio) {
        .Pipe =&gt; <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.dup2">dup2</a>(pipe_fd, std_fileno),
        .Close =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(std_fileno),
        .Inherit =&gt; {},
        .Ignore =&gt; <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.dup2">dup2</a>(dev_null_fd, std_fileno),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">destroyPipe</span>(pipe: [<span class="tok-number">2</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (pipe[<span class="tok-number">0</span>] != -<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(pipe[<span class="tok-number">0</span>]);
    <span class="tok-kw">if</span> (pipe[<span class="tok-number">0</span>] != pipe[<span class="tok-number">1</span>]) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(pipe[<span class="tok-number">1</span>]);
}<span class="tok-comment">

// Child of fork calls this to report an error to the fork parent.
// Then the child exits.
</span><span class="tok-kw">fn</span> <span class="tok-fn">forkChildErrReport</span>(fd: <span class="tok-type">i32</span>, err: <a href="std.process.Child.html">ChildProcess</a>.<a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>) <span class="tok-type">noreturn</span> {
    <a href="std.process.Child.html#std.process.Child.writeIntFd">writeIntFd</a>(fd, <span class="tok-builtin">@as</span>(<a href="std.process.Child.html#std.process.Child.ErrInt">ErrInt</a>, <span class="tok-builtin">@intFromError</span>(err))) <span class="tok-kw">catch</span> {};<span class="tok-comment">
    // If we're linking libc, some naughty applications may have registered atexit handlers
    // which we really do not want to run in the fork child. I caught LLVM doing this and
    // it caused a deadlock instead of doing an exit syscall. In the words of Avril Lavigne,
    // &quot;Why'd you have to go and make things so complicated?&quot;
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {<span class="tok-comment">
        // The _exit(2) function does nothing but make the exit syscall, unlike exit(3)
        </span><a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._exit">_exit</a>(<span class="tok-number">1</span>);
    }
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">writeIntFd</span>(fd: <span class="tok-type">i32</span>, value: <a href="std.process.Child.html#std.process.Child.ErrInt">ErrInt</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = fd };
    file.writer().writeInt(<span class="tok-type">u64</span>, <span class="tok-builtin">@intCast</span>(value), .little) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources;
}

<span class="tok-kw">fn</span> <span class="tok-fn">readIntFd</span>(fd: <span class="tok-type">i32</span>) !<a href="std.process.Child.html#std.process.Child.ErrInt">ErrInt</a> {
    <span class="tok-kw">const</span> file: <a href="std.fs.File.html">File</a> = .{ .handle = fd };
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(file.reader().readInt(<span class="tok-type">u64</span>, .little) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources);
}

<span class="tok-kw">const</span> ErrInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">anyerror</span>) * <span class="tok-number">8</span>);

<span class="tok-comment">/// Expects `app_buf` to contain exactly the app name, and `dir_buf` to contain exactly the dir path.</span>
<span class="tok-comment">/// After return, `app_buf` will always contain exactly the app name and `dir_buf` will always contain exactly the dir path.</span>
<span class="tok-comment">/// Note: `app_buf` should not contain any leading path separators.</span>
<span class="tok-comment">/// Note: If the dir is the cwd, dir_buf should be empty (len = 0).</span>
<span class="tok-kw">fn</span> <span class="tok-fn">windowsCreateProcessPathExt</span>(
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    dir_buf: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u16</span>),
    app_buf: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u16</span>),
    pathext: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    cmd_line_cache: *<a href="std.process.Child.WindowsCommandLineCache.html">WindowsCommandLineCache</a>,
    envp_ptr: ?[*]<span class="tok-type">u16</span>,
    cwd_ptr: ?[*:<span class="tok-number">0</span>]<span class="tok-type">u16</span>,
    lpStartupInfo: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.STARTUPINFOW.html">STARTUPINFOW</a>,
    lpProcessInformation: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.PROCESS_INFORMATION.html">PROCESS_INFORMATION</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> app_name_len = app_buf.items.len;
    <span class="tok-kw">const</span> dir_path_len = dir_buf.items.len;

    <span class="tok-kw">if</span> (app_name_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;

    <span class="tok-kw">defer</span> app_buf.shrinkRetainingCapacity(app_name_len);
    <span class="tok-kw">defer</span> dir_buf.shrinkRetainingCapacity(dir_path_len);<span class="tok-comment">

    // The name of the game here is to avoid CreateProcessW calls at all costs,
    // and only ever try calling it when we have a real candidate for execution.
    // Secondarily, we want to minimize the number of syscalls used when checking
    // for each PATHEXT-appended version of the app name.
    //
    // An overview of the technique used:
    // - Open the search directory for iteration (either cwd or a path from PATH)
    // - Use NtQueryDirectoryFile with a wildcard filename of `&lt;app name&gt;*` to
    //   check if anything that could possibly match either the unappended version
    //   of the app name or any of the versions with a PATHEXT value appended exists.
    // - If the wildcard NtQueryDirectoryFile call found nothing, we can exit early
    //   without needing to use PATHEXT at all.
    //
    // This allows us to use a &lt;open dir, NtQueryDirectoryFile, close dir&gt; sequence
    // for any directory that doesn't contain any possible matches, instead of having
    // to use a separate look up for each individual filename combination (unappended +
    // each PATHEXT appended). For directories where the wildcard *does* match something,
    // we iterate the matches and take note of any that are either the unappended version,
    // or a version with a supported PATHEXT appended. We then try calling CreateProcessW
    // with the found versions in the appropriate order.

    </span><span class="tok-kw">var</span> dir = dir: {<span class="tok-comment">
        // needs to be null-terminated
        </span><span class="tok-kw">try</span> dir_buf.append(allocator, <span class="tok-number">0</span>);
        <span class="tok-kw">defer</span> dir_buf.shrinkRetainingCapacity(dir_path_len);
        <span class="tok-kw">const</span> dir_path_z = dir_buf.items[<span class="tok-number">0</span> .. dir_buf.items.len - <span class="tok-number">1</span> :<span class="tok-number">0</span>];
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.wToPrefixedFileW">wToPrefixedFileW</a>(<span class="tok-null">null</span>, dir_path_z);
        <span class="tok-kw">break</span> :dir <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openDirW(prefixed_path.span().ptr, .{ .iterate = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span>
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
    };
    <span class="tok-kw">defer</span> dir.close();<span class="tok-comment">

    // Add wildcard and null-terminator
    </span><span class="tok-kw">try</span> app_buf.append(allocator, <span class="tok-str">'*'</span>);
    <span class="tok-kw">try</span> app_buf.append(allocator, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> app_name_wildcard = app_buf.items[<span class="tok-number">0</span> .. app_buf.items.len - <span class="tok-number">1</span> :<span class="tok-number">0</span>];<span class="tok-comment">

    // This 2048 is arbitrary, we just want it to be large enough to get multiple FILE_DIRECTORY_INFORMATION entries
    // returned per NtQueryDirectoryFile call.
    </span><span class="tok-kw">var</span> file_information_buf: [<span class="tok-number">2048</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_DIRECTORY_INFORMATION.html">FILE_DIRECTORY_INFORMATION</a>)) = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> file_info_maximum_single_entry_size = <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_DIRECTORY_INFORMATION.html">FILE_DIRECTORY_INFORMATION</a>) + (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.NAME_MAX">NAME_MAX</a> * <span class="tok-number">2</span>);
    <span class="tok-kw">if</span> (file_information_buf.len &lt; file_info_maximum_single_entry_size) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;file_information_buf must be large enough to contain at least one maximum size FILE_DIRECTORY_INFORMATION entry&quot;</span>);
    }
    <span class="tok-kw">var</span> io_status: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> num_supported_pathext = <span class="tok-builtin">@typeInfo</span>(<a href="std.process.Child.WindowsExtension.html">WindowsExtension</a>).@&quot;enum&quot;.fields.len;
    <span class="tok-kw">var</span> pathext_seen = [_]<span class="tok-type">bool</span>{<span class="tok-null">false</span>} ** num_supported_pathext;
    <span class="tok-kw">var</span> any_pathext_seen = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> unappended_exists = <span class="tok-null">false</span>;<span class="tok-comment">

    // Fully iterate the wildcard matches via NtQueryDirectoryFile and take note of all versions
    // of the app_name we should try to spawn.
    // Note: This is necessary because the order of the files returned is filesystem-dependent:
    //       On NTFS, `blah.exe*` will always return `blah.exe` first if it exists.
    //       On FAT32, it's possible for something like `blah.exe.obj` to be returned first.
    </span><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> app_name_len_bytes = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u16</span>, app_name_wildcard.len * <span class="tok-number">2</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        <span class="tok-kw">var</span> app_name_unicode_string = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.UNICODE_STRING.html">UNICODE_STRING</a>{
            .Length = app_name_len_bytes,
            .MaximumLength = app_name_len_bytes,
            .Buffer = <span class="tok-builtin">@constCast</span>(app_name_wildcard.ptr),
        };
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryDirectoryFile">NtQueryDirectoryFile</a>(
            dir.fd,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            &amp;io_status,
            &amp;file_information_buf,
            file_information_buf.len,
            .FileDirectoryInformation,
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FALSE">FALSE</a>,<span class="tok-comment"> // single result
            </span>&amp;app_name_unicode_string,
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FALSE">FALSE</a>,<span class="tok-comment"> // restart iteration
        </span>);<span class="tok-comment">

        // If we get nothing with the wildcard, then we can just bail out
        // as we know appending PATHEXT will not yield anything.
        </span><span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; {},
            .NO_SUCH_FILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
            .NO_MORE_FILES =&gt; <span class="tok-kw">break</span>,
            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
        }<span class="tok-comment">

        // According to the docs, this can only happen if there is not enough room in the
        // buffer to write at least one complete FILE_DIRECTORY_INFORMATION entry.
        // Therefore, this condition should not be possible to hit with the buffer size we use.
        </span><a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(io_status.Information != <span class="tok-number">0</span>);

        <span class="tok-kw">var</span> it = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FileInformationIterator">FileInformationIterator</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_DIRECTORY_INFORMATION.html">FILE_DIRECTORY_INFORMATION</a>){ .buf = &amp;file_information_buf };
        <span class="tok-kw">while</span> (it.next()) |info| {<span class="tok-comment">
            // Skip directories
            </span><span class="tok-kw">if</span> (info.FileAttributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_DIRECTORY">FILE_ATTRIBUTE_DIRECTORY</a> != <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
            <span class="tok-kw">const</span> filename = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;info.FileName))[<span class="tok-number">0</span> .. info.FileNameLength / <span class="tok-number">2</span>];<span class="tok-comment">
            // Because all results start with the app_name since we're using the wildcard `app_name*`,
            // if the length is equal to app_name then this is an exact match
            </span><span class="tok-kw">if</span> (filename.len == app_name_len) {<span class="tok-comment">
                // Note: We can't break early here because it's possible that the unappended version
                //       fails to spawn, in which case we still want to try the PATHEXT appended versions.
                </span>unappended_exists = <span class="tok-null">true</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.windowsCreateProcessSupportsExtension">windowsCreateProcessSupportsExtension</a>(filename[app_name_len..])) |pathext_ext| {
                pathext_seen[<span class="tok-builtin">@intFromEnum</span>(pathext_ext)] = <span class="tok-null">true</span>;
                any_pathext_seen = <span class="tok-null">true</span>;
            }
        }
    }

    <span class="tok-kw">const</span> unappended_err = unappended: {
        <span class="tok-kw">if</span> (unappended_exists) {
            <span class="tok-kw">if</span> (dir_path_len != <span class="tok-number">0</span>) <span class="tok-kw">switch</span> (dir_buf.items[dir_buf.items.len - <span class="tok-number">1</span>]) {
                <span class="tok-str">'/'</span>, <span class="tok-str">'\\'</span> =&gt; {},
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> dir_buf.append(allocator, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>),
            };
            <span class="tok-kw">try</span> dir_buf.appendSlice(allocator, app_buf.items[<span class="tok-number">0</span>..app_name_len]);
            <span class="tok-kw">try</span> dir_buf.append(allocator, <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> full_app_name = dir_buf.items[<span class="tok-number">0</span> .. dir_buf.items.len - <span class="tok-number">1</span> :<span class="tok-number">0</span>];

            <span class="tok-kw">const</span> is_bat_or_cmd = bat_or_cmd: {
                <span class="tok-kw">const</span> app_name = app_buf.items[<span class="tok-number">0</span>..app_name_len];
                <span class="tok-kw">const</span> ext_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(<span class="tok-type">u16</span>, app_name, <span class="tok-str">'.'</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :bat_or_cmd <span class="tok-null">false</span>;
                <span class="tok-kw">const</span> ext = app_name[ext_start..];
                <span class="tok-kw">const</span> ext_enum = <a href="std.process.Child.html#std.process.Child.windowsCreateProcessSupportsExtension">windowsCreateProcessSupportsExtension</a>(ext) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :bat_or_cmd <span class="tok-null">false</span>;
                <span class="tok-kw">switch</span> (ext_enum) {
                    .cmd, .bat =&gt; <span class="tok-kw">break</span> :bat_or_cmd <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :bat_or_cmd <span class="tok-null">false</span>,
                }
            };
            <span class="tok-kw">const</span> cmd_line_w = <span class="tok-kw">if</span> (is_bat_or_cmd)
                <span class="tok-kw">try</span> cmd_line_cache.scriptCommandLine(full_app_name)
            <span class="tok-kw">else</span>
                <span class="tok-kw">try</span> cmd_line_cache.commandLine();
            <span class="tok-kw">const</span> app_name_w = <span class="tok-kw">if</span> (is_bat_or_cmd)
                <span class="tok-kw">try</span> cmd_line_cache.cmdExePath()
            <span class="tok-kw">else</span>
                full_app_name;

            <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.windowsCreateProcess">windowsCreateProcess</a>(app_name_w.ptr, cmd_line_w.ptr, envp_ptr, cwd_ptr, lpStartupInfo, lpProcessInformation)) |_| {
                <span class="tok-kw">return</span>;
            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound,
                <span class="tok-kw">error</span>.AccessDenied,
                =&gt; <span class="tok-kw">break</span> :unappended err,
                <span class="tok-kw">error</span>.InvalidExe =&gt; {<span class="tok-comment">
                    // On InvalidExe, if the extension of the app name is .exe then
                    // it's treated as an unrecoverable error. Otherwise, it'll be
                    // skipped as normal.
                    </span><span class="tok-kw">const</span> app_name = app_buf.items[<span class="tok-number">0</span>..app_name_len];
                    <span class="tok-kw">const</span> ext_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(<span class="tok-type">u16</span>, app_name, <span class="tok-str">'.'</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :unappended err;
                    <span class="tok-kw">const</span> ext = app_name[ext_start..];
                    <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.eqlIgnoreCaseWTF16">eqlIgnoreCaseWTF16</a>(ext, <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;.EXE&quot;</span>))) {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnrecoverableInvalidExe;
                    }
                    <span class="tok-kw">break</span> :unappended err;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            }
        }
        <span class="tok-kw">break</span> :unappended <span class="tok-kw">error</span>.FileNotFound;
    };

    <span class="tok-kw">if</span> (!any_pathext_seen) <span class="tok-kw">return</span> unappended_err;<span class="tok-comment">

    // Now try any PATHEXT appended versions that we've seen
    </span><span class="tok-kw">var</span> ext_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u16</span>, pathext, <span class="tok-str">';'</span>);
    <span class="tok-kw">while</span> (ext_it.next()) |ext| {
        <span class="tok-kw">const</span> ext_enum = <a href="std.process.Child.html#std.process.Child.windowsCreateProcessSupportsExtension">windowsCreateProcessSupportsExtension</a>(ext) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        <span class="tok-kw">if</span> (!pathext_seen[<span class="tok-builtin">@intFromEnum</span>(ext_enum)]) <span class="tok-kw">continue</span>;

        dir_buf.shrinkRetainingCapacity(dir_path_len);
        <span class="tok-kw">if</span> (dir_path_len != <span class="tok-number">0</span>) <span class="tok-kw">switch</span> (dir_buf.items[dir_buf.items.len - <span class="tok-number">1</span>]) {
            <span class="tok-str">'/'</span>, <span class="tok-str">'\\'</span> =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> dir_buf.append(allocator, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>),
        };
        <span class="tok-kw">try</span> dir_buf.appendSlice(allocator, app_buf.items[<span class="tok-number">0</span>..app_name_len]);
        <span class="tok-kw">try</span> dir_buf.appendSlice(allocator, ext);
        <span class="tok-kw">try</span> dir_buf.append(allocator, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> full_app_name = dir_buf.items[<span class="tok-number">0</span> .. dir_buf.items.len - <span class="tok-number">1</span> :<span class="tok-number">0</span>];

        <span class="tok-kw">const</span> is_bat_or_cmd = <span class="tok-kw">switch</span> (ext_enum) {
            .cmd, .bat =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        };
        <span class="tok-kw">const</span> cmd_line_w = <span class="tok-kw">if</span> (is_bat_or_cmd)
            <span class="tok-kw">try</span> cmd_line_cache.scriptCommandLine(full_app_name)
        <span class="tok-kw">else</span>
            <span class="tok-kw">try</span> cmd_line_cache.commandLine();
        <span class="tok-kw">const</span> app_name_w = <span class="tok-kw">if</span> (is_bat_or_cmd)
            <span class="tok-kw">try</span> cmd_line_cache.cmdExePath()
        <span class="tok-kw">else</span>
            full_app_name;

        <span class="tok-kw">if</span> (<a href="std.process.Child.html#std.process.Child.windowsCreateProcess">windowsCreateProcess</a>(app_name_w.ptr, cmd_line_w.ptr, envp_ptr, cwd_ptr, lpStartupInfo, lpProcessInformation)) |_| {
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span>,
            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">continue</span>,
            <span class="tok-kw">error</span>.InvalidExe =&gt; {<span class="tok-comment">
                // On InvalidExe, if the extension of the app name is .exe then
                // it's treated as an unrecoverable error. Otherwise, it'll be
                // skipped as normal.
                </span><span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.eqlIgnoreCaseWTF16">eqlIgnoreCaseWTF16</a>(ext, <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;.EXE&quot;</span>))) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnrecoverableInvalidExe;
                }
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
        }
    }

    <span class="tok-kw">return</span> unappended_err;
}

<span class="tok-kw">fn</span> <span class="tok-fn">windowsCreateProcess</span>(
    app_name: [*:<span class="tok-number">0</span>]<span class="tok-type">u16</span>,
    cmd_line: [*:<span class="tok-number">0</span>]<span class="tok-type">u16</span>,
    envp_ptr: ?[*]<span class="tok-type">u16</span>,
    cwd_ptr: ?[*:<span class="tok-number">0</span>]<span class="tok-type">u16</span>,
    lpStartupInfo: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.STARTUPINFOW.html">STARTUPINFOW</a>,
    lpProcessInformation: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.PROCESS_INFORMATION.html">PROCESS_INFORMATION</a>,
) !<span class="tok-type">void</span> {<span class="tok-comment">
    // TODO the docs for environment pointer say:
    // &gt; A pointer to the environment block for the new process. If this parameter
    // &gt; is NULL, the new process uses the environment of the calling process.
    // &gt; ...
    // &gt; An environment block can contain either Unicode or ANSI characters. If
    // &gt; the environment block pointed to by lpEnvironment contains Unicode
    // &gt; characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
    // &gt; If this parameter is NULL and the environment block of the parent process
    // &gt; contains Unicode characters, you must also ensure that dwCreationFlags
    // &gt; includes CREATE_UNICODE_ENVIRONMENT.
    // This seems to imply that we have to somehow know whether our process parent passed
    // CREATE_UNICODE_ENVIRONMENT if we want to pass NULL for the environment parameter.
    // Since we do not know this information that would imply that we must not pass NULL
    // for the parameter.
    // However this would imply that programs compiled with -DUNICODE could not pass
    // environment variables to programs that were not, which seems unlikely.
    // More investigation is needed.
    </span><span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateProcessW">CreateProcessW</a>(
        app_name,
        cmd_line,
        <span class="tok-null">null</span>,
        <span class="tok-null">null</span>,
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>,
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CREATE_UNICODE_ENVIRONMENT">CREATE_UNICODE_ENVIRONMENT</a>,
        <span class="tok-builtin">@as</span>(?*<span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(envp_ptr)),
        cwd_ptr,
        lpStartupInfo,
        lpProcessInformation,
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">windowsMakePipeIn</span>(rd: *?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>, wr: *?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>, sattr: *<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.SECURITY_ATTRIBUTES.html">SECURITY_ATTRIBUTES</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> rd_h: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> wr_h: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreatePipe">CreatePipe</a>(&amp;rd_h, &amp;wr_h, sattr);
    <span class="tok-kw">errdefer</span> <a href="std.process.Child.html#std.process.Child.windowsDestroyPipe">windowsDestroyPipe</a>(rd_h, wr_h);
    <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetHandleInformation">SetHandleInformation</a>(wr_h, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE_FLAG_INHERIT">HANDLE_FLAG_INHERIT</a>, <span class="tok-number">0</span>);
    rd.* = rd_h;
    wr.* = wr_h;
}

<span class="tok-kw">fn</span> <span class="tok-fn">windowsDestroyPipe</span>(rd: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>, wr: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (rd) |h| <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(h);
    <span class="tok-kw">if</span> (wr) |h| <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(h);
}

<span class="tok-kw">fn</span> <span class="tok-fn">windowsMakeAsyncPipe</span>(rd: *?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>, wr: *?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a>, sattr: *<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.SECURITY_ATTRIBUTES.html">SECURITY_ATTRIBUTES</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> tmp_bufw: [<span class="tok-number">128</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">

    // Anonymous pipes are built upon Named pipes.
    // https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe
    // Asynchronous (overlapped) read and write operations are not supported by anonymous pipes.
    // https://docs.microsoft.com/en-us/windows/win32/ipc/anonymous-pipe-operations
    </span><span class="tok-kw">const</span> pipe_path = blk: {
        <span class="tok-kw">var</span> tmp_buf: [<span class="tok-number">128</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
        // Forge a random path for the pipe.
        </span><span class="tok-kw">const</span> pipe_path = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrintZ">bufPrintZ</a>(
            &amp;tmp_buf,
            <span class="tok-str">&quot;\\\\.\\pipe\\zig-childprocess-{d}-{d}&quot;</span>,
            .{ <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetCurrentProcessId">GetCurrentProcessId</a>(), <a href="std.process.Child.html#std.process.Child.pipe_name_counter">pipe_name_counter</a>.<a href="#">fetchAdd</a>(<span class="tok-number">1</span>, .monotonic) },
        ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        <span class="tok-kw">const</span> len = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;tmp_bufw, pipe_path) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        tmp_bufw[len] = <span class="tok-number">0</span>;
        <span class="tok-kw">break</span> :blk tmp_bufw[<span class="tok-number">0</span>..len :<span class="tok-number">0</span>];
    };<span class="tok-comment">

    // Create the read handle that can be used with overlapped IO ops.
    </span><span class="tok-kw">const</span> read_handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.CreateNamedPipeW">CreateNamedPipeW</a>(
        pipe_path.ptr,
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PIPE_ACCESS_INBOUND">PIPE_ACCESS_INBOUND</a> | <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_FLAG_OVERLAPPED">FILE_FLAG_OVERLAPPED</a>,
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PIPE_TYPE_BYTE">PIPE_TYPE_BYTE</a>,
        <span class="tok-number">1</span>,
        <span class="tok-number">4096</span>,
        <span class="tok-number">4096</span>,
        <span class="tok-number">0</span>,
        sattr,
    );
    <span class="tok-kw">if</span> (read_handle == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.INVALID_HANDLE_VALUE">INVALID_HANDLE_VALUE</a>) {
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetLastError">GetLastError</a>()) {
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedError">unexpectedError</a>(err),
        }
    }
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(read_handle);

    <span class="tok-kw">var</span> sattr_copy = sattr.*;
    <span class="tok-kw">const</span> write_handle = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.CreateFileW">CreateFileW</a>(
        pipe_path.ptr,
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GENERIC_WRITE">GENERIC_WRITE</a>,
        <span class="tok-number">0</span>,
        &amp;sattr_copy,
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.OPEN_EXISTING">OPEN_EXISTING</a>,
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_NORMAL">FILE_ATTRIBUTE_NORMAL</a>,
        <span class="tok-null">null</span>,
    );
    <span class="tok-kw">if</span> (write_handle == <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.INVALID_HANDLE_VALUE">INVALID_HANDLE_VALUE</a>) {
        <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetLastError">GetLastError</a>()) {
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedError">unexpectedError</a>(err),
        }
    }
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(write_handle);

    <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetHandleInformation">SetHandleInformation</a>(read_handle, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE_FLAG_INHERIT">HANDLE_FLAG_INHERIT</a>, <span class="tok-number">0</span>);

    rd.* = read_handle;
    wr.* = write_handle;
}

<span class="tok-kw">var</span> pipe_name_counter = <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.Value">Value</a>(<span class="tok-type">u32</span>).init(<span class="tok-number">1</span>);

<span class="tok-comment">/// File name extensions supported natively by `CreateProcess()` on Windows.</span><span class="tok-comment">
// Should be kept in sync with `windowsCreateProcessSupportsExtension`.
</span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WindowsExtension = <span class="tok-kw">enum</span> {
    bat,
    cmd,
    com,
    exe,
};

<span class="tok-comment">/// Case-insensitive WTF-16 lookup</span>
<span class="tok-kw">fn</span> <span class="tok-fn">windowsCreateProcessSupportsExtension</span>(ext: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) ?<a href="std.process.Child.WindowsExtension.html">WindowsExtension</a> {
    <span class="tok-kw">if</span> (ext.len != <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
        start,
        dot,
        b,
        ba,
        c,
        cm,
        co,
        e,
        ex,
    };
    <span class="tok-kw">var</span> state: State = .start;
    <span class="tok-kw">for</span> (ext) |c| <span class="tok-kw">switch</span> (state) {
        .start =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'.'</span> =&gt; state = .dot,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
        .dot =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'b'</span>, <span class="tok-str">'B'</span> =&gt; state = .b,
            <span class="tok-str">'c'</span>, <span class="tok-str">'C'</span> =&gt; state = .c,
            <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; state = .e,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
        .b =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'a'</span>, <span class="tok-str">'A'</span> =&gt; state = .ba,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
        .c =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'m'</span>, <span class="tok-str">'M'</span> =&gt; state = .cm,
            <span class="tok-str">'o'</span>, <span class="tok-str">'O'</span> =&gt; state = .co,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
        .e =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'x'</span>, <span class="tok-str">'X'</span> =&gt; state = .ex,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
        .ba =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'t'</span>, <span class="tok-str">'T'</span> =&gt; <span class="tok-kw">return</span> .bat,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
        .cm =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'d'</span>, <span class="tok-str">'D'</span> =&gt; <span class="tok-kw">return</span> .cmd,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
        .co =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'m'</span>, <span class="tok-str">'M'</span> =&gt; <span class="tok-kw">return</span> .com,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
        .ex =&gt; <span class="tok-kw">switch</span> (c) {
            <span class="tok-str">'e'</span>, <span class="tok-str">'E'</span> =&gt; <span class="tok-kw">return</span> .exe,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
        },
    };
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> windowsCreateProcessSupportsExtension {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.process.Child.WindowsExtension.html">WindowsExtension</a>.<a href="#">exe</a>, <a href="std.process.Child.html#std.process.Child.windowsCreateProcessSupportsExtension">windowsCreateProcessSupportsExtension</a>(&amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'.'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'X'</span>, <span class="tok-str">'e'</span> }).?);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.process.Child.html#std.process.Child.windowsCreateProcessSupportsExtension">windowsCreateProcessSupportsExtension</a>(&amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'.'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'X'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'c'</span> }) == <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Serializes argv into a WTF-16 encoded command-line string for use with CreateProcessW.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Serialization is done on-demand and the result is cached in order to allow for:</span>
<span class="tok-comment">/// - Only serializing the particular type of command line needed (`.bat`/`.cmd`</span>
<span class="tok-comment">///   command line serialization is different from `.exe`/etc)</span>
<span class="tok-comment">/// - Reusing the serialized command lines if necessary (i.e. if the execution</span>
<span class="tok-comment">///   of a command fails and the PATH is going to be continued to be searched</span>
<span class="tok-comment">///   for more candidates)</span>
<span class="tok-kw">const</span> WindowsCommandLineCache = <span class="tok-kw">struct</span> {
    cmd_line: ?[:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = <span class="tok-null">null</span>,
    script_cmd_line: ?[:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = <span class="tok-null">null</span>,
    cmd_exe_path: ?[:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = <span class="tok-null">null</span>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.Child.WindowsCommandLineCache.html">WindowsCommandLineCache</a> {
        <span class="tok-kw">return</span> .{
            .allocator = allocator,
            .argv = argv,
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.Child.WindowsCommandLineCache.html">WindowsCommandLineCache</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.cmd_line) |cmd_line| self.allocator.free(cmd_line);
        <span class="tok-kw">if</span> (self.script_cmd_line) |script_cmd_line| self.allocator.free(script_cmd_line);
        <span class="tok-kw">if</span> (self.cmd_exe_path) |cmd_exe_path| self.allocator.free(cmd_exe_path);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">commandLine</span>(self: *<a href="std.process.Child.WindowsCommandLineCache.html">WindowsCommandLineCache</a>) ![:<span class="tok-number">0</span>]<span class="tok-type">u16</span> {
        <span class="tok-kw">if</span> (self.cmd_line == <span class="tok-null">null</span>) {
            self.cmd_line = <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.argvToCommandLineWindows">argvToCommandLineWindows</a>(self.allocator, self.argv);
        }
        <span class="tok-kw">return</span> self.cmd_line.?;
    }

    <span class="tok-comment">/// Not cached, since the path to the batch script will change during PATH searching.</span>
    <span class="tok-comment">/// `script_path` should be as qualified as possible, e.g. if the PATH is being searched,</span>
    <span class="tok-comment">/// then script_path should include both the search path and the script filename</span>
    <span class="tok-comment">/// (this allows avoiding cmd.exe having to search the PATH again).</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">scriptCommandLine</span>(self: *<a href="std.process.Child.WindowsCommandLineCache.html">WindowsCommandLineCache</a>, script_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) ![:<span class="tok-number">0</span>]<span class="tok-type">u16</span> {
        <span class="tok-kw">if</span> (self.script_cmd_line) |v| self.allocator.free(v);
        self.script_cmd_line = <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.argvToScriptCommandLineWindows">argvToScriptCommandLineWindows</a>(
            self.allocator,
            script_path,
            self.argv[<span class="tok-number">1</span>..],
        );
        <span class="tok-kw">return</span> self.script_cmd_line.?;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">cmdExePath</span>(self: *<a href="std.process.Child.WindowsCommandLineCache.html">WindowsCommandLineCache</a>) ![:<span class="tok-number">0</span>]<span class="tok-type">u16</span> {
        <span class="tok-kw">if</span> (self.cmd_exe_path == <span class="tok-null">null</span>) {
            self.cmd_exe_path = <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.windowsCmdExePath">windowsCmdExePath</a>(self.allocator);
        }
        <span class="tok-kw">return</span> self.cmd_exe_path.?;
    }
};

<span class="tok-comment">/// Returns the absolute path of `cmd.exe` within the Windows system directory.</span>
<span class="tok-comment">/// The caller owns the returned slice.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">windowsCmdExePath</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-kw">error</span>{ OutOfMemory, Unexpected }![:<span class="tok-number">0</span>]<span class="tok-type">u16</span> {
    <span class="tok-kw">var</span> buf = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u16</span>).initCapacity(allocator, <span class="tok-number">128</span>);
    <span class="tok-kw">errdefer</span> buf.deinit(allocator);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> unused_slice = buf.unusedCapacitySlice();<span class="tok-comment">
        // TODO: Get the system directory from PEB.ReadOnlyStaticServerData
        </span><span class="tok-kw">const</span> len = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetSystemDirectoryW">GetSystemDirectoryW</a>(<span class="tok-builtin">@ptrCast</span>(unused_slice), <span class="tok-builtin">@intCast</span>(unused_slice.len));
        <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) {
            <span class="tok-kw">switch</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetLastError">GetLastError</a>()) {
                <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedError">unexpectedError</a>(err),
            }
        }
        <span class="tok-kw">if</span> (len &gt; unused_slice.len) {
            <span class="tok-kw">try</span> buf.ensureUnusedCapacity(allocator, len);
        } <span class="tok-kw">else</span> {
            buf.items.len = len;
            <span class="tok-kw">break</span>;
        }
    }
    <span class="tok-kw">switch</span> (buf.items[buf.items.len - <span class="tok-number">1</span>]) {
        <span class="tok-str">'/'</span>, <span class="tok-str">'\\'</span> =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> buf.append(allocator, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>),
    }
    <span class="tok-kw">try</span> buf.appendSlice(allocator, <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;cmd.exe&quot;</span>));
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> buf.toOwnedSliceSentinel(allocator, <span class="tok-number">0</span>);
}

<span class="tok-kw">const</span> ArgvToCommandLineError = <span class="tok-kw">error</span>{ OutOfMemory, InvalidWtf8, InvalidArg0 };

<span class="tok-comment">/// Serializes `argv` to a Windows command-line string suitable for passing to a child process and</span>
<span class="tok-comment">/// parsing by the `CommandLineToArgvW` algorithm. The caller owns the returned slice.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// To avoid arbitrary command execution, this function should not be used when spawning `.bat`/`.cmd` scripts.</span>
<span class="tok-comment">/// https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// When executing `.bat`/`.cmd` scripts, use `argvToScriptCommandLineWindows` instead.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">argvToCommandLineWindows</span>(
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.process.Child.html#std.process.Child.ArgvToCommandLineError">ArgvToCommandLineError</a>![:<span class="tok-number">0</span>]<span class="tok-type">u16</span> {
    <span class="tok-kw">var</span> buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
    <span class="tok-kw">defer</span> buf.deinit();

    <span class="tok-kw">if</span> (argv.len != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> arg0 = argv[<span class="tok-number">0</span>];<span class="tok-comment">

        // The first argument must be quoted if it contains spaces or ASCII control characters
        // (excluding DEL). It also follows special quoting rules where backslashes have no special
        // interpretation, which makes it impossible to pass certain first arguments containing
        // double quotes to a child process without characters from the first argument leaking into
        // subsequent ones (which could have security implications).
        //
        // Empty arguments technically don't need quotes, but we quote them anyway for maximum
        // compatibility with different implementations of the 'CommandLineToArgvW' algorithm.
        //
        // Double quotes are illegal in paths on Windows, so for the sake of simplicity we reject
        // all first arguments containing double quotes, even ones that we could theoretically
        // serialize in unquoted form.
        </span><span class="tok-kw">var</span> needs_quotes = arg0.len == <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (arg0) |c| {
            <span class="tok-kw">if</span> (c &lt;= <span class="tok-str">' '</span>) {
                needs_quotes = <span class="tok-null">true</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (c == <span class="tok-str">'&quot;'</span>) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArg0;
            }
        }
        <span class="tok-kw">if</span> (needs_quotes) {
            <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);
            <span class="tok-kw">try</span> buf.appendSlice(arg0);
            <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> buf.appendSlice(arg0);
        }

        <span class="tok-kw">for</span> (argv[<span class="tok-number">1</span>..]) |arg| {
            <span class="tok-kw">try</span> buf.append(<span class="tok-str">' '</span>);<span class="tok-comment">

            // Subsequent arguments must be quoted if they contain spaces, tabs or double quotes,
            // or if they are empty. For simplicity and for maximum compatibility with different
            // implementations of the 'CommandLineToArgvW' algorithm, we also quote all ASCII
            // control characters (again, excluding DEL).
            </span>needs_quotes = <span class="tok-kw">for</span> (arg) |c| {
                <span class="tok-kw">if</span> (c &lt;= <span class="tok-str">' '</span> <span class="tok-kw">or</span> c == <span class="tok-str">'&quot;'</span>) {
                    <span class="tok-kw">break</span> <span class="tok-null">true</span>;
                }
            } <span class="tok-kw">else</span> arg.len == <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (!needs_quotes) {
                <span class="tok-kw">try</span> buf.appendSlice(arg);
                <span class="tok-kw">continue</span>;
            }

            <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);
            <span class="tok-kw">var</span> backslash_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (arg) |byte| {
                <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'\\'</span> =&gt; {
                        backslash_count += <span class="tok-number">1</span>;
                    },
                    <span class="tok-str">'&quot;'</span> =&gt; {
                        <span class="tok-kw">try</span> buf.appendNTimes(<span class="tok-str">'\\'</span>, backslash_count * <span class="tok-number">2</span> + <span class="tok-number">1</span>);
                        <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);
                        backslash_count = <span class="tok-number">0</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">try</span> buf.appendNTimes(<span class="tok-str">'\\'</span>, backslash_count);
                        <span class="tok-kw">try</span> buf.append(byte);
                        backslash_count = <span class="tok-number">0</span>;
                    },
                }
            }
            <span class="tok-kw">try</span> buf.appendNTimes(<span class="tok-str">'\\'</span>, backslash_count * <span class="tok-number">2</span>);
            <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);
        }
    }

    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(allocator, buf.items);
}

<span class="tok-kw">test</span> argvToCommandLineWindows {
    <span class="tok-kw">const</span> t = <a href="std.process.Child.html#std.process.Child.testArgvToCommandLineWindows">testArgvToCommandLineWindows</a>;

    <span class="tok-kw">try</span> t(&amp;.{
        <span class="tok-str">\\C:\Program Files\zig\zig.exe</span>
        ,
        <span class="tok-str">\\run</span>
        ,
        <span class="tok-str">\\.\src\main.zig</span>
        ,
        <span class="tok-str">\\-target</span>
        ,
        <span class="tok-str">\\x86_64-windows-gnu</span>
        ,
        <span class="tok-str">\\-O</span>
        ,
        <span class="tok-str">\\ReleaseSafe</span>
        ,
        <span class="tok-str">\\--</span>
        ,
        <span class="tok-str">\\--emoji=🗿</span>
        ,
        <span class="tok-str">\\--eval=new Regex(&quot;Dwayne \&quot;The Rock\&quot; Johnson&quot;)</span>
        ,
    },
        <span class="tok-str">\\&quot;C:\Program Files\zig\zig.exe&quot; run .\src\main.zig -target x86_64-windows-gnu -O ReleaseSafe -- --emoji=🗿 &quot;--eval=new Regex(\&quot;Dwayne \\\&quot;The Rock\\\&quot; Johnson\&quot;)&quot;</span>
    );

    <span class="tok-kw">try</span> t(&amp;.{}, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> t(&amp;.{<span class="tok-str">&quot;&quot;</span>}, <span class="tok-str">&quot;\&quot;\&quot;&quot;</span>);
    <span class="tok-kw">try</span> t(&amp;.{<span class="tok-str">&quot; &quot;</span>}, <span class="tok-str">&quot;\&quot; \&quot;&quot;</span>);
    <span class="tok-kw">try</span> t(&amp;.{<span class="tok-str">&quot;\t&quot;</span>}, <span class="tok-str">&quot;\&quot;\t\&quot;&quot;</span>);
    <span class="tok-kw">try</span> t(&amp;.{<span class="tok-str">&quot;\x07&quot;</span>}, <span class="tok-str">&quot;\&quot;\x07\&quot;&quot;</span>);
    <span class="tok-kw">try</span> t(&amp;.{<span class="tok-str">&quot;🦎&quot;</span>}, <span class="tok-str">&quot;🦎&quot;</span>);

    <span class="tok-kw">try</span> t(
        &amp;.{ <span class="tok-str">&quot;zig&quot;</span>, <span class="tok-str">&quot;aa aa&quot;</span>, <span class="tok-str">&quot;bb\tbb&quot;</span>, <span class="tok-str">&quot;cc\ncc&quot;</span>, <span class="tok-str">&quot;dd\r\ndd&quot;</span>, <span class="tok-str">&quot;ee\x7Fee&quot;</span> },
        <span class="tok-str">&quot;zig \&quot;aa aa\&quot; \&quot;bb\tbb\&quot; \&quot;cc\ncc\&quot; \&quot;dd\r\ndd\&quot; ee\x7Fee&quot;</span>,
    );

    <span class="tok-kw">try</span> t(
        &amp;.{ <span class="tok-str">&quot;\\\\foo bar\\foo bar\\&quot;</span>, <span class="tok-str">&quot;\\\\zig zag\\zig zag\\&quot;</span> },
        <span class="tok-str">&quot;\&quot;\\\\foo bar\\foo bar\\\&quot; \&quot;\\\\zig zag\\zig zag\\\\\&quot;&quot;</span>,
    );

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
        <span class="tok-kw">error</span>.InvalidArg0,
        <a href="std.process.Child.html#std.process.Child.argvToCommandLineWindows">argvToCommandLineWindows</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, &amp;.{<span class="tok-str">&quot;\&quot;quotes\&quot;quotes\&quot;&quot;</span>}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
        <span class="tok-kw">error</span>.InvalidArg0,
        <a href="std.process.Child.html#std.process.Child.argvToCommandLineWindows">argvToCommandLineWindows</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, &amp;.{<span class="tok-str">&quot;quotes\&quot;quotes&quot;</span>}),
    );
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
        <span class="tok-kw">error</span>.InvalidArg0,
        <a href="std.process.Child.html#std.process.Child.argvToCommandLineWindows">argvToCommandLineWindows</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, &amp;.{<span class="tok-str">&quot;q u o t e s \&quot; q u o t e s&quot;</span>}),
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">testArgvToCommandLineWindows</span>(argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected_cmd_line: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> cmd_line_w = <span class="tok-kw">try</span> <a href="std.process.Child.html#std.process.Child.argvToCommandLineWindows">argvToCommandLineWindows</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, argv);
    <span class="tok-kw">defer</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(cmd_line_w);

    <span class="tok-kw">const</span> cmd_line = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8Alloc">wtf16LeToWtf8Alloc</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, cmd_line_w);
    <span class="tok-kw">defer</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(cmd_line);

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected_cmd_line, cmd_line);
}

<span class="tok-kw">const</span> ArgvToScriptCommandLineError = <span class="tok-kw">error</span>{
    OutOfMemory,
    InvalidWtf8,
    <span class="tok-comment">/// NUL (U+0000), LF (U+000A), CR (U+000D) are not allowed</span>
    <span class="tok-comment">/// within arguments when executing a `.bat`/`.cmd` script.</span>
    <span class="tok-comment">/// - NUL/LF signifiies end of arguments, so anything afterwards</span>
    <span class="tok-comment">///   would be lost after execution.</span>
    <span class="tok-comment">/// - CR is stripped by `cmd.exe`, so any CR codepoints</span>
    <span class="tok-comment">///   would be lost after execution.</span>
    InvalidBatchScriptArg,
};

<span class="tok-comment">/// Serializes `argv` to a Windows command-line string that uses `cmd.exe /c` and `cmd.exe`-specific</span>
<span class="tok-comment">/// escaping rules. The caller owns the returned slice.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Escapes `argv` using the suggested mitigation against arbitrary command execution from:</span>
<span class="tok-comment">/// https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The return of this function will look like</span>
<span class="tok-comment">/// `cmd.exe /d /e:ON /v:OFF /c &quot;&lt;escaped command line&gt;&quot;`</span>
<span class="tok-comment">/// and should be used as the `lpCommandLine` of `CreateProcessW`, while the</span>
<span class="tok-comment">/// return of `windowsCmdExePath` should be used as `lpApplicationName`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Should only be used when spawning `.bat`/`.cmd` scripts, see `argvToCommandLineWindows` otherwise.</span>
<span class="tok-comment">/// The `.bat`/`.cmd` file must be known to both have the `.bat`/`.cmd` extension and exist on the filesystem.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">argvToScriptCommandLineWindows</span>(
    allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-comment">/// Path to the `.bat`/`.cmd` script. If this path is relative, it is assumed to be relative to the CWD.</span>
    <span class="tok-comment">/// The script must have been verified to exist at this path before calling this function.</span>
    script_path: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    <span class="tok-comment">/// Arguments, not including the script name itself. Expected to be encoded as WTF-8.</span>
    script_args: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) <a href="std.process.Child.html#std.process.Child.ArgvToScriptCommandLineError">ArgvToScriptCommandLineError</a>![:<span class="tok-number">0</span>]<span class="tok-type">u16</span> {
    <span class="tok-kw">var</span> buf = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).initCapacity(allocator, <span class="tok-number">64</span>);
    <span class="tok-kw">defer</span> buf.deinit();<span class="tok-comment">

    // `/d` disables execution of AutoRun commands.
    // `/e:ON` and `/v:OFF` are needed for BatBadBut mitigation:
    // &gt; If delayed expansion is enabled via the registry value DelayedExpansion,
    // &gt; it must be disabled by explicitly calling cmd.exe with the /V:OFF option.
    // &gt; Escaping for % requires the command extension to be enabled.
    // &gt; If it’s disabled via the registry value EnableExtensions, it must be enabled with the /E:ON option.
    // https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/
    </span>buf.appendSliceAssumeCapacity(<span class="tok-str">&quot;cmd.exe /d /e:ON /v:OFF /c \&quot;&quot;</span>);<span class="tok-comment">

    // Always quote the path to the script arg
    </span>buf.appendAssumeCapacity(<span class="tok-str">'&quot;'</span>);<span class="tok-comment">
    // We always want the path to the batch script to include a path separator in order to
    // avoid cmd.exe searching the PATH for the script. This is not part of the arbitrary
    // command execution mitigation, we just know exactly what script we want to execute
    // at this point, and potentially making cmd.exe re-find it is unnecessary.
    //
    // If the script path does not have a path separator, then we know its relative to CWD and
    // we can just put `.\` in the front.
    </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfAny">indexOfAny</a>(<span class="tok-type">u16</span>, script_path, &amp;[_]<span class="tok-type">u16</span>{ <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(<span class="tok-type">u16</span>, <span class="tok-str">'\\'</span>), <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(<span class="tok-type">u16</span>, <span class="tok-str">'/'</span>) }) == <span class="tok-null">null</span>) {
        <span class="tok-kw">try</span> buf.appendSlice(<span class="tok-str">&quot;.\\&quot;</span>);
    }<span class="tok-comment">
    // Note that we don't do any escaping/mitigations for this argument, since the relevant
    // characters (&quot;, %, etc) are illegal in file paths and this function should only be called
    // with script paths that have been verified to exist.
    </span><span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8ArrayList">wtf16LeToWtf8ArrayList</a>(&amp;buf, script_path);
    buf.appendAssumeCapacity(<span class="tok-str">'&quot;'</span>);

    <span class="tok-kw">for</span> (script_args) |arg| {<span class="tok-comment">
        // Literal carriage returns get stripped when run through cmd.exe
        // and NUL/newlines act as 'end of command.' Because of this, it's basically
        // always a mistake to include these characters in argv, so it's
        // an error condition in order to ensure that the return of this
        // function can always roundtrip through cmd.exe.
        </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfAny">indexOfAny</a>(<span class="tok-type">u8</span>, arg, <span class="tok-str">&quot;\x00\r\n&quot;</span>) != <span class="tok-null">null</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBatchScriptArg;
        }<span class="tok-comment">

        // Separate args with a space.
        </span><span class="tok-kw">try</span> buf.append(<span class="tok-str">' '</span>);<span class="tok-comment">

        // Need to quote if the argument is empty (otherwise the arg would just be lost)
        // or if the last character is a `\`, since then something like &quot;%~2&quot; in a .bat
        // script would cause the closing &quot; to be escaped which we don't want.
        </span><span class="tok-kw">var</span> needs_quotes = arg.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> arg[arg.len - <span class="tok-number">1</span>] == <span class="tok-str">'\\'</span>;
        <span class="tok-kw">if</span> (!needs_quotes) {
            <span class="tok-kw">for</span> (arg) |c| {
                <span class="tok-kw">switch</span> (c) {<span class="tok-comment">
                    // Known good characters that don't need to be quoted
                    </span><span class="tok-str">'A'</span>...<span class="tok-str">'Z'</span>, <span class="tok-str">'a'</span>...<span class="tok-str">'z'</span>, <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span>, <span class="tok-str">'#'</span>, <span class="tok-str">'</code></pre></details></div></span>, <span class="tok-str">'*'</span>, <span class="tok-str">'+'</span>, <span class="tok-str">'-'</span>, <span class="tok-str">'.'</span>, <span class="tok-str">'/'</span>, <span class="tok-str">':'</span>, <span class="tok-str">'?'</span>, <span class="tok-str">'@'</span>, <span class="tok-str">'\\'</span>, <span class="tok-str">'_'</span> =&gt; {},<span class="tok-comment">
                    // When in doubt, quote
                    </span><span class="tok-kw">else</span> =&gt; {
                        needs_quotes = <span class="tok-null">true</span>;
                        <span class="tok-kw">break</span>;
                    },
                }
            }
        }
        <span class="tok-kw">if</span> (needs_quotes) {
            <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);
        }
        <span class="tok-kw">var</span> backslashes: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (arg) |c| {
            <span class="tok-kw">switch</span> (c) {
                <span class="tok-str">'\\'</span> =&gt; {
                    backslashes += <span class="tok-number">1</span>;
                },
                <span class="tok-str">'&quot;'</span> =&gt; {
                    <span class="tok-kw">try</span> buf.appendNTimes(<span class="tok-str">'\\'</span>, backslashes);
                    <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);
                    backslashes = <span class="tok-number">0</span>;
                },<span class="tok-comment">
                // Replace `%` with `%%cd:~,%`.
                //
                // cmd.exe allows extracting a substring from an environment
                // variable with the syntax: `%foo:~&lt;start_index&gt;,&lt;end_index&gt;%`.
                // Therefore, `%cd:~,%` will always expand to an empty string
                // since both the start and end index are blank, and it is assumed
                // that `%cd%` is always available since it is a built-in variable
                // that corresponds to the current directory.
                //
                // This means that replacing `%foo%` with `%%cd:~,%foo%%cd:~,%`
                // will stop `%foo%` from being expanded and *after* expansion
                // we'll still be left with `%foo%` (the literal string).
                </span><span class="tok-str">'%'</span> =&gt; {<span class="tok-comment">
                    // the trailing `%` is appended outside the switch
                    </span><span class="tok-kw">try</span> buf.appendSlice(<span class="tok-str">&quot;%%cd:~,&quot;</span>);
                    backslashes = <span class="tok-number">0</span>;
                },
                <span class="tok-kw">else</span> =&gt; {
                    backslashes = <span class="tok-number">0</span>;
                },
            }
            <span class="tok-kw">try</span> buf.append(c);
        }
        <span class="tok-kw">if</span> (needs_quotes) {
            <span class="tok-kw">try</span> buf.appendNTimes(<span class="tok-str">'\\'</span>, backslashes);
            <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);
        }
    }

    <span class="tok-kw">try</span> buf.append(<span class="tok-str">'&quot;'</span>);

    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(allocator, buf.items);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
