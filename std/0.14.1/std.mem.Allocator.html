<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">mem</a></li><li><a href="std.mem.Allocator.html" class="active">Allocator</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.mem.Allocator" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.mem.Allocator</span><a href="#src.zig-std.mem.Allocator">[src]</a></h1><div class="tldDocs"><p>The standard memory allocation interface.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.mem.Allocator.VTable.html">std.mem.Allocator.VTable</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.mem.Allocator.Log2Align" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Log2Align</span><a href="#src.zig-std.mem.Allocator.Log2Align">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.Log2Align">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Log2Align = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<span class="tok-type">usize</span>)</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>ptr: *<span class="tok-type">anyopaque</span></code></pre><div class="fieldDocs"><p>The type erased pointer to the allocator implementation.</p>
<p>Any comparison of this field may result in illegal behavior, since it may
be set to <code>undefined</code> in cases where the allocator implementation does not
have any associated state.</p>
</div></div><div><pre><code>vtable: *<span class="tok-kw">const</span> <a href="std.mem.Allocator.VTable.html">VTable</a></code></pre></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.mem.Allocator.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.mem.Allocator.Error">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.Error">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{OutOfMemory}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.mem.Allocator.noResize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">noResize</span><a href="#src.zig-std.mem.Allocator.noResize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noResize</span>( self: *<span class="tok-type">anyopaque</span>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>, ) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>memory: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.noResize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noResize</span>(
    self: *<span class="tok-type">anyopaque</span>,
    memory: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    new_len: <span class="tok-type">usize</span>,
    ret_addr: <span class="tok-type">usize</span>,
) <span class="tok-type">bool</span> {
    _ = self;
    _ = memory;
    _ = alignment;
    _ = new_len;
    _ = ret_addr;
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.noRemap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">noRemap</span><a href="#src.zig-std.mem.Allocator.noRemap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noRemap</span>( self: *<span class="tok-type">anyopaque</span>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>, ) ?[*]<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>memory: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.noRemap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noRemap</span>(
    self: *<span class="tok-type">anyopaque</span>,
    memory: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    new_len: <span class="tok-type">usize</span>,
    ret_addr: <span class="tok-type">usize</span>,
) ?[*]<span class="tok-type">u8</span> {
    _ = self;
    _ = memory;
    _ = alignment;
    _ = new_len;
    _ = ret_addr;
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.noFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">noFree</span><a href="#src.zig-std.mem.Allocator.noFree">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noFree</span>( self: *<span class="tok-type">anyopaque</span>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>, ) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>memory: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.noFree">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noFree</span>(
    self: *<span class="tok-type">anyopaque</span>,
    memory: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    ret_addr: <span class="tok-type">usize</span>,
) <span class="tok-type">void</span> {
    _ = self;
    _ = memory;
    _ = alignment;
    _ = ret_addr;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.rawAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rawAlloc</span><a href="#src.zig-std.mem.Allocator.rawAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawAlloc</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, len: <span class="tok-type">usize</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>This function is not intended to be called except from within the
implementation of an <code><a href="std.mem.Allocator.html">Allocator</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.rawAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawAlloc</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, len: <span class="tok-type">usize</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> a.vtable.alloc(a.ptr, len, alignment, ret_addr);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.rawResize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rawResize</span><a href="#src.zig-std.mem.Allocator.rawResize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawResize</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>This function is not intended to be called except from within the
implementation of an <code><a href="std.mem.Allocator.html">Allocator</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>memory: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.rawResize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawResize</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a.vtable.resize(a.ptr, memory, alignment, new_len, ret_addr);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.rawRemap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rawRemap</span><a href="#src.zig-std.mem.Allocator.rawRemap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawRemap</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>This function is not intended to be called except from within the
implementation of an <code><a href="std.mem.Allocator.html">Allocator</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>memory: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.rawRemap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawRemap</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> a.vtable.remap(a.ptr, memory, alignment, new_len, ret_addr);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.rawFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rawFree</span><a href="#src.zig-std.mem.Allocator.rawFree">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawFree</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>This function is not intended to be called except from within the
implementation of an <code><a href="std.mem.Allocator.html">Allocator</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>memory: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.rawFree">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawFree</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> a.vtable.free(a.ptr, memory, alignment, ret_addr);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.create" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">create</span><a href="#src.zig-std.mem.Allocator.create">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T</code></pre></div><div class="tldDocs"><p>Returns a pointer to undefined memory.
Call <code><a href="std.mem.Allocator.html#std.mem.Allocator.destroy">destroy</a></code> with the result to free the memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.create">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> ptr = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(<span class="tok-type">usize</span>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>), <span class="tok-builtin">@alignOf</span>(T));
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(*T, <span class="tok-builtin">@ptrFromInt</span>(ptr));
    }
    <span class="tok-kw">const</span> ptr: *T = <span class="tok-builtin">@ptrCast</span>(<span class="tok-kw">try</span> a.allocBytesWithAlignment(<span class="tok-builtin">@alignOf</span>(T), <span class="tok-builtin">@sizeOf</span>(T), <span class="tok-builtin">@returnAddress</span>()));
    <span class="tok-kw">return</span> ptr;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.destroy" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">destroy</span><a href="#src.zig-std.mem.Allocator.destroy">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">destroy</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, ptr: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p><code>ptr</code> should be the return value of <code><a href="std.mem.Allocator.html#std.mem.Allocator.create">create</a></code>, or otherwise
have the same address and alignment property.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.destroy">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">destroy</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, ptr: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)).pointer;
    <span class="tok-kw">if</span> (info.size != .one) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ptr must be a single item pointer&quot;</span>);
    <span class="tok-kw">const</span> T = info.child;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> non_const_ptr = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@constCast</span>(ptr)));
    self.rawFree(non_const_ptr[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(T)], .fromByteUnits(info.alignment), <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.alloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alloc</span><a href="#src.zig-std.mem.Allocator.alloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Allocates an array of <code>n</code> items of type <code>T</code> and sets all the
items to <code>undefined</code>. Depending on the Allocator
implementation, it may be required to call <code><a href="std.mem.Allocator.html#std.mem.Allocator.free">free</a></code> once the
memory is no longer needed, to avoid a resource leak. If the
<code><a href="std.mem.Allocator.html">Allocator</a></code> implementation is unknown, then correct code will
call <code><a href="std.mem.Allocator.html#std.mem.Allocator.free">free</a></code> when done.</p>
<p>For allocating a single item, see <code><a href="std.mem.Allocator.html#std.mem.Allocator.create">create</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.alloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">return</span> self.allocAdvancedWithRetAddr(T, <span class="tok-null">null</span>, n, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.allocWithOptions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocWithOptions</span><a href="#src.zig-std.mem.Allocator.allocWithOptions">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocWithOptions</span>( self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>, n: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> optional_alignment: ?<span class="tok-type">u29</span>, <span class="tok-kw">comptime</span> optional_sentinel: ?Elem, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.mem.Allocator.html#std.mem.Allocator.AllocWithOptionsPayload">AllocWithOptionsPayload</a>(Elem, optional_alignment, optional_sentinel)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>Elem: <span class="tok-type">type</span></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div><div><pre><code>optional_alignment: ?<span class="tok-type">u29</span></code></pre><div class="fieldDocs"><p>null means naturally aligned</p>
</div></div><div><pre><code>optional_sentinel: ?Elem</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.allocWithOptions">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocWithOptions</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>,
    n: <span class="tok-type">usize</span>,
    <span class="tok-comment">/// null means naturally aligned</span>
    <span class="tok-kw">comptime</span> optional_alignment: ?<span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> optional_sentinel: ?Elem,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.mem.Allocator.html#std.mem.Allocator.AllocWithOptionsPayload">AllocWithOptionsPayload</a>(Elem, optional_alignment, optional_sentinel) {
    <span class="tok-kw">return</span> self.allocWithOptionsRetAddr(Elem, n, optional_alignment, optional_sentinel, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.allocWithOptionsRetAddr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocWithOptionsRetAddr</span><a href="#src.zig-std.mem.Allocator.allocWithOptionsRetAddr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocWithOptionsRetAddr</span>( self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>, n: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> optional_alignment: ?<span class="tok-type">u29</span>, <span class="tok-kw">comptime</span> optional_sentinel: ?Elem, return_address: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.mem.Allocator.html#std.mem.Allocator.AllocWithOptionsPayload">AllocWithOptionsPayload</a>(Elem, optional_alignment, optional_sentinel)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>Elem: <span class="tok-type">type</span></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div><div><pre><code>optional_alignment: ?<span class="tok-type">u29</span></code></pre><div class="fieldDocs"><p>null means naturally aligned</p>
</div></div><div><pre><code>optional_sentinel: ?Elem</code></pre></div><div><pre><code>return_address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.allocWithOptionsRetAddr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocWithOptionsRetAddr</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>,
    n: <span class="tok-type">usize</span>,
    <span class="tok-comment">/// null means naturally aligned</span>
    <span class="tok-kw">comptime</span> optional_alignment: ?<span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> optional_sentinel: ?Elem,
    return_address: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.mem.Allocator.html#std.mem.Allocator.AllocWithOptionsPayload">AllocWithOptionsPayload</a>(Elem, optional_alignment, optional_sentinel) {
    <span class="tok-kw">if</span> (optional_sentinel) |sentinel| {
        <span class="tok-kw">const</span> ptr = <span class="tok-kw">try</span> self.allocAdvancedWithRetAddr(Elem, optional_alignment, n + <span class="tok-number">1</span>, return_address);
        ptr[n] = sentinel;
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..n :sentinel];
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.allocAdvancedWithRetAddr(Elem, optional_alignment, n, return_address);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.allocSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocSentinel</span><a href="#src.zig-std.mem.Allocator.allocSentinel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocSentinel</span>( self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>, n: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> sentinel: Elem, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:sentinel]Elem</code></pre></div><div class="tldDocs"><p>Allocates an array of <code>n + 1</code> items of type <code>T</code> and sets the first <code>n</code>
items to <code>undefined</code> and the last item to <code>sentinel</code>. Depending on the
Allocator implementation, it may be required to call <code><a href="std.mem.Allocator.html#std.mem.Allocator.free">free</a></code> once the
memory is no longer needed, to avoid a resource leak. If the
<code><a href="std.mem.Allocator.html">Allocator</a></code> implementation is unknown, then correct code will
call <code><a href="std.mem.Allocator.html#std.mem.Allocator.free">free</a></code> when done.</p>
<p>For allocating a single item, see <code><a href="std.mem.Allocator.html#std.mem.Allocator.create">create</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>Elem: <span class="tok-type">type</span></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div><div><pre><code>sentinel: Elem</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.allocSentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocSentinel</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>,
    n: <span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> sentinel: Elem,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:sentinel]Elem {
    <span class="tok-kw">return</span> self.allocWithOptionsRetAddr(Elem, n, <span class="tok-null">null</span>, sentinel, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.alignedAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignedAlloc</span><a href="#src.zig-std.mem.Allocator.alignedAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignedAlloc</span>( self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>, n: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(T)) T</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>alignment: ?<span class="tok-type">u29</span></code></pre><div class="fieldDocs"><p>null means naturally aligned</p>
</div></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.alignedAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignedAlloc</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    <span class="tok-comment">/// null means naturally aligned</span>
    <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>,
    n: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(T)) T {
    <span class="tok-kw">return</span> self.allocAdvancedWithRetAddr(T, alignment, n, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.allocAdvancedWithRetAddr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocAdvancedWithRetAddr</span><a href="#src.zig-std.mem.Allocator.allocAdvancedWithRetAddr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocAdvancedWithRetAddr</span>( self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>, n: <span class="tok-type">usize</span>, return_address: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(T)) T</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>alignment: ?<span class="tok-type">u29</span></code></pre><div class="fieldDocs"><p>null means naturally aligned</p>
</div></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div><div><pre><code>return_address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.allocAdvancedWithRetAddr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocAdvancedWithRetAddr</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    <span class="tok-comment">/// null means naturally aligned</span>
    <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>,
    n: <span class="tok-type">usize</span>,
    return_address: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(T)) T {
    <span class="tok-kw">const</span> a = alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(T);
    <span class="tok-kw">const</span> ptr: [*]<span class="tok-kw">align</span>(a) T = <span class="tok-builtin">@ptrCast</span>(<span class="tok-kw">try</span> self.allocWithSizeAndAlignment(<span class="tok-builtin">@sizeOf</span>(T), a, n, return_address));
    <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..n];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.mem.Allocator.resize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, allocation: <span class="tok-kw">anytype</span>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Request to modify the size of an allocation.</p>
<p>It is guaranteed to not move the pointer, however the allocator
implementation may refuse the resize request by returning <code>false</code>.</p>
<p><code>allocation</code> may be an empty slice, in which case a new allocation is made.</p>
<p><code>new_len</code> may be zero, in which case the allocation is freed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.resize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, allocation: <span class="tok-kw">anytype</span>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(allocation)).pointer;
    <span class="tok-kw">const</span> T = Slice.child;
    <span class="tok-kw">const</span> alignment = Slice.alignment;
    <span class="tok-kw">if</span> (new_len == <span class="tok-number">0</span>) {
        self.free(allocation);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">if</span> (allocation.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">const</span> old_memory = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(allocation);<span class="tok-comment">
    // I would like to use saturating multiplication here, but LLVM cannot lower it
    // on WebAssembly: https://github.com/ziglang/zig/issues/9660
    //const new_len_bytes = new_len *| @sizeOf(T);
    </span><span class="tok-kw">const</span> new_len_bytes = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@sizeOf</span>(T), new_len) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">return</span> self.rawResize(old_memory, .fromByteUnits(alignment), new_len_bytes, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.remap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remap</span><a href="#src.zig-std.mem.Allocator.remap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remap</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, allocation: <span class="tok-kw">anytype</span>, new_len: <span class="tok-type">usize</span>) t: { <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(allocation)).pointer; <span class="tok-kw">break</span> :t ?[]<span class="tok-kw">align</span>(Slice.alignment) Slice.child; }</code></pre></div><div class="tldDocs"><p>Request to modify the size of an allocation, allowing relocation.</p>
<p>A non-<code>null</code> return value indicates the resize was successful. The
allocation may have same address, or may have been relocated. In either
case, the allocation now has size of <code>new_len</code>. A <code>null</code> return value
indicates that the resize would be equivalent to allocating new memory,
copying the bytes from the old memory, and then freeing the old memory.
In such case, it is more efficient for the caller to perform those
operations.</p>
<p><code>allocation</code> may be an empty slice, in which case <code>null</code> is returned,
unless <code>new_len</code> is also 0, in which case <code>allocation</code> is returned.</p>
<p><code>new_len</code> may be zero, in which case the allocation is freed.</p>
<p>If the allocation's elements' type is zero bytes sized, <code>allocation.len</code> is set to <code>new_len</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.remap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remap</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, allocation: <span class="tok-kw">anytype</span>, new_len: <span class="tok-type">usize</span>) t: {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(allocation)).pointer;
    <span class="tok-kw">break</span> :t ?[]<span class="tok-kw">align</span>(Slice.alignment) Slice.child;
} {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(allocation)).pointer;
    <span class="tok-kw">const</span> T = Slice.child;

    <span class="tok-kw">const</span> alignment = Slice.alignment;
    <span class="tok-kw">if</span> (new_len == <span class="tok-number">0</span>) {
        self.free(allocation);
        <span class="tok-kw">return</span> allocation[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    }
    <span class="tok-kw">if</span> (allocation.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        <span class="tok-kw">var</span> new_memory = allocation;
        new_memory.len = new_len;
        <span class="tok-kw">return</span> new_memory;
    }
    <span class="tok-kw">const</span> old_memory = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(allocation);<span class="tok-comment">
    // I would like to use saturating multiplication here, but LLVM cannot lower it
    // on WebAssembly: https://github.com/ziglang/zig/issues/9660
    //const new_len_bytes = new_len *| @sizeOf(T);
    </span><span class="tok-kw">const</span> new_len_bytes = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@sizeOf</span>(T), new_len) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> new_ptr = self.rawRemap(old_memory, .fromByteUnits(alignment), new_len_bytes, <span class="tok-builtin">@returnAddress</span>()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> new_memory: []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(new_ptr[<span class="tok-number">0</span>..new_len_bytes]);
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(T, new_memory);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.realloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realloc</span><a href="#src.zig-std.mem.Allocator.realloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realloc</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, old_mem: <span class="tok-kw">anytype</span>, new_n: <span class="tok-type">usize</span>) t: { <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(old_mem)).pointer; <span class="tok-kw">break</span> :t <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(Slice.alignment) Slice.child; }</code></pre></div><div class="tldDocs"><p>This function requests a new byte size for an existing allocation, which
can be larger, smaller, or the same size as the old memory allocation.</p>
<p>If <code>new_n</code> is 0, this is the same as <code><a href="std.mem.Allocator.html#std.mem.Allocator.free">free</a></code> and it always succeeds.</p>
<p><code>old_mem</code> may have length zero, which makes a new allocation.</p>
<p>This function only fails on out-of-memory conditions, unlike:</p>
<ul>
<li><code><a href="std.mem.Allocator.html#std.mem.Allocator.remap">remap</a></code> which returns <code>null</code> when the <code><a href="std.mem.Allocator.html">Allocator</a></code> implementation cannot
do the realloc more efficiently than the caller</li>
<li><code><a href="std.mem.Allocator.html#std.mem.Allocator.resize">resize</a></code> which returns <code>false</code> when the <code><a href="std.mem.Allocator.html">Allocator</a></code> implementation cannot
change the size without relocating the allocation.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_n: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.realloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realloc</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, old_mem: <span class="tok-kw">anytype</span>, new_n: <span class="tok-type">usize</span>) t: {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(old_mem)).pointer;
    <span class="tok-kw">break</span> :t <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(Slice.alignment) Slice.child;
} {
    <span class="tok-kw">return</span> self.reallocAdvanced(old_mem, new_n, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.reallocAdvanced" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reallocAdvanced</span><a href="#src.zig-std.mem.Allocator.reallocAdvanced">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reallocAdvanced</span>( self: <a href="std.mem.Allocator.html">Allocator</a>, old_mem: <span class="tok-kw">anytype</span>, new_n: <span class="tok-type">usize</span>, return_address: <span class="tok-type">usize</span>, ) t: { <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(old_mem)).pointer; <span class="tok-kw">break</span> :t <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(Slice.alignment) Slice.child; }</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_n: <span class="tok-type">usize</span></code></pre></div><div><pre><code>return_address: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.reallocAdvanced">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reallocAdvanced</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    old_mem: <span class="tok-kw">anytype</span>,
    new_n: <span class="tok-type">usize</span>,
    return_address: <span class="tok-type">usize</span>,
) t: {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(old_mem)).pointer;
    <span class="tok-kw">break</span> :t <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(Slice.alignment) Slice.child;
} {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(old_mem)).pointer;
    <span class="tok-kw">const</span> T = Slice.child;
    <span class="tok-kw">if</span> (old_mem.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> self.allocAdvancedWithRetAddr(T, Slice.alignment, new_n, return_address);
    }
    <span class="tok-kw">if</span> (new_n == <span class="tok-number">0</span>) {
        self.free(old_mem);
        <span class="tok-kw">const</span> ptr = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(<span class="tok-type">usize</span>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>), Slice.alignment);
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(Slice.alignment) T, <span class="tok-builtin">@ptrFromInt</span>(ptr))[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    }

    <span class="tok-kw">const</span> old_byte_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(old_mem);
    <span class="tok-kw">const</span> byte_count = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@sizeOf</span>(T), new_n) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>.<a href="#">OutOfMemory</a>;<span class="tok-comment">
    // Note: can't set shrunk memory to undefined as memory shouldn't be modified on realloc failure
    </span><span class="tok-kw">if</span> (self.rawRemap(old_byte_slice, .fromByteUnits(Slice.alignment), byte_count, return_address)) |p| {
        <span class="tok-kw">const</span> new_bytes: []<span class="tok-kw">align</span>(Slice.alignment) <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(p[<span class="tok-number">0</span>..byte_count]);
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(T, new_bytes);
    }

    <span class="tok-kw">const</span> new_mem = self.rawAlloc(byte_count, .fromByteUnits(Slice.alignment), return_address) <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
    <span class="tok-kw">const</span> copy_len = <span class="tok-builtin">@min</span>(byte_count, old_byte_slice.len);
    <span class="tok-builtin">@memcpy</span>(new_mem[<span class="tok-number">0</span>..copy_len], old_byte_slice[<span class="tok-number">0</span>..copy_len]);
    <span class="tok-builtin">@memset</span>(old_byte_slice, <span class="tok-null">undefined</span>);
    self.rawFree(old_byte_slice, .fromByteUnits(Slice.alignment), return_address);

    <span class="tok-kw">const</span> new_bytes: []<span class="tok-kw">align</span>(Slice.alignment) <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(new_mem[<span class="tok-number">0</span>..byte_count]);
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(T, new_bytes);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.free" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">free</span><a href="#src.zig-std.mem.Allocator.free">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, memory: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Free an array allocated with <code><a href="std.mem.Allocator.html#std.mem.Allocator.alloc">alloc</a></code>.
If memory has length 0, free is a no-op.
To free a single item, see <code><a href="std.mem.Allocator.html#std.mem.Allocator.destroy">destroy</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.free">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, memory: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(memory)).pointer;
    <span class="tok-kw">const</span> bytes = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(memory);
    <span class="tok-kw">const</span> bytes_len = bytes.len + <span class="tok-kw">if</span> (Slice.sentinel() != <span class="tok-null">null</span>) <span class="tok-builtin">@sizeOf</span>(Slice.child) <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (bytes_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> non_const_ptr = <span class="tok-builtin">@constCast</span>(bytes.ptr);
    <span class="tok-builtin">@memset</span>(non_const_ptr[<span class="tok-number">0</span>..bytes_len], <span class="tok-null">undefined</span>);
    self.rawFree(non_const_ptr[<span class="tok-number">0</span>..bytes_len], .fromByteUnits(Slice.alignment), <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.dupe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dupe</span><a href="#src.zig-std.mem.Allocator.dupe">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, m: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Copies <code>m</code> to newly allocated memory. Caller owns the memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>m: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.dupe">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, m: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> new_buf = <span class="tok-kw">try</span> allocator.alloc(T, m.len);
    <span class="tok-builtin">@memcpy</span>(new_buf, m);
    <span class="tok-kw">return</span> new_buf;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.Allocator.dupeZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dupeZ</span><a href="#src.zig-std.mem.Allocator.dupeZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeZ</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, m: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-number">0</span>]T</code></pre></div><div class="tldDocs"><p>Copies <code>m</code> to newly allocated memory, with a null-terminated element. Caller owns the memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>m: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.Allocator.dupeZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeZ</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, m: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-number">0</span>]T {
    <span class="tok-kw">const</span> new_buf = <span class="tok-kw">try</span> allocator.alloc(T, m.len + <span class="tok-number">1</span>);
    <span class="tok-builtin">@memcpy</span>(new_buf[<span class="tok-number">0</span>..m.len], m);
    new_buf[m.len] = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> new_buf[<span class="tok-number">0</span>..m.len :<span class="tok-number">0</span>];
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.mem.Allocator">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! The standard memory allocation interface.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> Allocator = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> Alignment = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{OutOfMemory};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Log2Align = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<span class="tok-type">usize</span>);

<span class="tok-comment">/// The type erased pointer to the allocator implementation.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Any comparison of this field may result in illegal behavior, since it may</span>
<span class="tok-comment">/// be set to `undefined` in cases where the allocator implementation does not</span>
<span class="tok-comment">/// have any associated state.</span>
ptr: *<span class="tok-type">anyopaque</span>,
vtable: *<span class="tok-kw">const</span> <a href="std.mem.Allocator.VTable.html">VTable</a>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> VTable = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Return a pointer to `len` bytes with specified `alignment`, or return</span>
    <span class="tok-comment">/// `null` indicating the allocation failed.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `ret_addr` is optionally provided as the first return address of the</span>
    <span class="tok-comment">/// allocation call stack. If the value is `0` it means no return address</span>
    <span class="tok-comment">/// has been provided.</span>
    alloc: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (*<span class="tok-type">anyopaque</span>, len: <span class="tok-type">usize</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span>,

    <span class="tok-comment">/// Attempt to expand or shrink memory in place.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `memory.len` must equal the length requested from the most recent</span>
    <span class="tok-comment">/// successful call to `alloc`, `resize`, or `remap`. `alignment` must</span>
    <span class="tok-comment">/// equal the same value that was passed as the `alignment` parameter to</span>
    <span class="tok-comment">/// the original `alloc` call.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// A result of `true` indicates the resize was successful and the</span>
    <span class="tok-comment">/// allocation now has the same address but a size of `new_len`. `false`</span>
    <span class="tok-comment">/// indicates the resize could not be completed without moving the</span>
    <span class="tok-comment">/// allocation to a different address.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `new_len` must be greater than zero.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `ret_addr` is optionally provided as the first return address of the</span>
    <span class="tok-comment">/// allocation call stack. If the value is `0` it means no return address</span>
    <span class="tok-comment">/// has been provided.</span>
    resize: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (*<span class="tok-type">anyopaque</span>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>,

    <span class="tok-comment">/// Attempt to expand or shrink memory, allowing relocation.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `memory.len` must equal the length requested from the most recent</span>
    <span class="tok-comment">/// successful call to `alloc`, `resize`, or `remap`. `alignment` must</span>
    <span class="tok-comment">/// equal the same value that was passed as the `alignment` parameter to</span>
    <span class="tok-comment">/// the original `alloc` call.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// A non-`null` return value indicates the resize was successful. The</span>
    <span class="tok-comment">/// allocation may have same address, or may have been relocated. In either</span>
    <span class="tok-comment">/// case, the allocation now has size of `new_len`. A `null` return value</span>
    <span class="tok-comment">/// indicates that the resize would be equivalent to allocating new memory,</span>
    <span class="tok-comment">/// copying the bytes from the old memory, and then freeing the old memory.</span>
    <span class="tok-comment">/// In such case, it is more efficient for the caller to perform the copy.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `new_len` must be greater than zero.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `ret_addr` is optionally provided as the first return address of the</span>
    <span class="tok-comment">/// allocation call stack. If the value is `0` it means no return address</span>
    <span class="tok-comment">/// has been provided.</span>
    remap: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (*<span class="tok-type">anyopaque</span>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span>,

    <span class="tok-comment">/// Free and invalidate a region of memory.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `memory.len` must equal the length requested from the most recent</span>
    <span class="tok-comment">/// successful call to `alloc`, `resize`, or `remap`. `alignment` must</span>
    <span class="tok-comment">/// equal the same value that was passed as the `alignment` parameter to</span>
    <span class="tok-comment">/// the original `alloc` call.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `ret_addr` is optionally provided as the first return address of the</span>
    <span class="tok-comment">/// allocation call stack. If the value is `0` it means no return address</span>
    <span class="tok-comment">/// has been provided.</span>
    free: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (*<span class="tok-type">anyopaque</span>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noResize</span>(
    self: *<span class="tok-type">anyopaque</span>,
    memory: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    new_len: <span class="tok-type">usize</span>,
    ret_addr: <span class="tok-type">usize</span>,
) <span class="tok-type">bool</span> {
    _ = self;
    _ = memory;
    _ = alignment;
    _ = new_len;
    _ = ret_addr;
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noRemap</span>(
    self: *<span class="tok-type">anyopaque</span>,
    memory: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    new_len: <span class="tok-type">usize</span>,
    ret_addr: <span class="tok-type">usize</span>,
) ?[*]<span class="tok-type">u8</span> {
    _ = self;
    _ = memory;
    _ = alignment;
    _ = new_len;
    _ = ret_addr;
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noFree</span>(
    self: *<span class="tok-type">anyopaque</span>,
    memory: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    ret_addr: <span class="tok-type">usize</span>,
) <span class="tok-type">void</span> {
    _ = self;
    _ = memory;
    _ = alignment;
    _ = ret_addr;
}

<span class="tok-comment">/// This function is not intended to be called except from within the</span>
<span class="tok-comment">/// implementation of an `Allocator`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawAlloc</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, len: <span class="tok-type">usize</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> a.vtable.alloc(a.ptr, len, alignment, ret_addr);
}

<span class="tok-comment">/// This function is not intended to be called except from within the</span>
<span class="tok-comment">/// implementation of an `Allocator`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawResize</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a.vtable.resize(a.ptr, memory, alignment, new_len, ret_addr);
}

<span class="tok-comment">/// This function is not intended to be called except from within the</span>
<span class="tok-comment">/// implementation of an `Allocator`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawRemap</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> a.vtable.remap(a.ptr, memory, alignment, new_len, ret_addr);
}

<span class="tok-comment">/// This function is not intended to be called except from within the</span>
<span class="tok-comment">/// implementation of an `Allocator`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rawFree</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, memory: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> a.vtable.free(a.ptr, memory, alignment, ret_addr);
}

<span class="tok-comment">/// Returns a pointer to undefined memory.</span>
<span class="tok-comment">/// Call `destroy` with the result to free the memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(a: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*T {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> ptr = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(<span class="tok-type">usize</span>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>), <span class="tok-builtin">@alignOf</span>(T));
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(*T, <span class="tok-builtin">@ptrFromInt</span>(ptr));
    }
    <span class="tok-kw">const</span> ptr: *T = <span class="tok-builtin">@ptrCast</span>(<span class="tok-kw">try</span> a.allocBytesWithAlignment(<span class="tok-builtin">@alignOf</span>(T), <span class="tok-builtin">@sizeOf</span>(T), <span class="tok-builtin">@returnAddress</span>()));
    <span class="tok-kw">return</span> ptr;
}

<span class="tok-comment">/// `ptr` should be the return value of `create`, or otherwise</span>
<span class="tok-comment">/// have the same address and alignment property.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">destroy</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, ptr: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)).pointer;
    <span class="tok-kw">if</span> (info.size != .one) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;ptr must be a single item pointer&quot;</span>);
    <span class="tok-kw">const</span> T = info.child;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> non_const_ptr = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@constCast</span>(ptr)));
    self.rawFree(non_const_ptr[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(T)], .fromByteUnits(info.alignment), <span class="tok-builtin">@returnAddress</span>());
}

<span class="tok-comment">/// Allocates an array of `n` items of type `T` and sets all the</span>
<span class="tok-comment">/// items to `undefined`. Depending on the Allocator</span>
<span class="tok-comment">/// implementation, it may be required to call `free` once the</span>
<span class="tok-comment">/// memory is no longer needed, to avoid a resource leak. If the</span>
<span class="tok-comment">/// `Allocator` implementation is unknown, then correct code will</span>
<span class="tok-comment">/// call `free` when done.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For allocating a single item, see `create`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, n: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">return</span> self.allocAdvancedWithRetAddr(T, <span class="tok-null">null</span>, n, <span class="tok-builtin">@returnAddress</span>());
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocWithOptions</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>,
    n: <span class="tok-type">usize</span>,
    <span class="tok-comment">/// null means naturally aligned</span>
    <span class="tok-kw">comptime</span> optional_alignment: ?<span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> optional_sentinel: ?Elem,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.mem.Allocator.html#std.mem.Allocator.AllocWithOptionsPayload">AllocWithOptionsPayload</a>(Elem, optional_alignment, optional_sentinel) {
    <span class="tok-kw">return</span> self.allocWithOptionsRetAddr(Elem, n, optional_alignment, optional_sentinel, <span class="tok-builtin">@returnAddress</span>());
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocWithOptionsRetAddr</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>,
    n: <span class="tok-type">usize</span>,
    <span class="tok-comment">/// null means naturally aligned</span>
    <span class="tok-kw">comptime</span> optional_alignment: ?<span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> optional_sentinel: ?Elem,
    return_address: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.mem.Allocator.html#std.mem.Allocator.AllocWithOptionsPayload">AllocWithOptionsPayload</a>(Elem, optional_alignment, optional_sentinel) {
    <span class="tok-kw">if</span> (optional_sentinel) |sentinel| {
        <span class="tok-kw">const</span> ptr = <span class="tok-kw">try</span> self.allocAdvancedWithRetAddr(Elem, optional_alignment, n + <span class="tok-number">1</span>, return_address);
        ptr[n] = sentinel;
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..n :sentinel];
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> self.allocAdvancedWithRetAddr(Elem, optional_alignment, n, return_address);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">AllocWithOptionsPayload</span>(<span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>, <span class="tok-kw">comptime</span> sentinel: ?Elem) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (sentinel) |s| {
        <span class="tok-kw">return</span> [:s]<span class="tok-kw">align</span>(alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(Elem)) Elem;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> []<span class="tok-kw">align</span>(alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(Elem)) Elem;
    }
}

<span class="tok-comment">/// Allocates an array of `n + 1` items of type `T` and sets the first `n`</span>
<span class="tok-comment">/// items to `undefined` and the last item to `sentinel`. Depending on the</span>
<span class="tok-comment">/// Allocator implementation, it may be required to call `free` once the</span>
<span class="tok-comment">/// memory is no longer needed, to avoid a resource leak. If the</span>
<span class="tok-comment">/// `Allocator` implementation is unknown, then correct code will</span>
<span class="tok-comment">/// call `free` when done.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// For allocating a single item, see `create`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocSentinel</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> Elem: <span class="tok-type">type</span>,
    n: <span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> sentinel: Elem,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:sentinel]Elem {
    <span class="tok-kw">return</span> self.allocWithOptionsRetAddr(Elem, n, <span class="tok-null">null</span>, sentinel, <span class="tok-builtin">@returnAddress</span>());
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignedAlloc</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    <span class="tok-comment">/// null means naturally aligned</span>
    <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>,
    n: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(T)) T {
    <span class="tok-kw">return</span> self.allocAdvancedWithRetAddr(T, alignment, n, <span class="tok-builtin">@returnAddress</span>());
}

<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocAdvancedWithRetAddr</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    <span class="tok-comment">/// null means naturally aligned</span>
    <span class="tok-kw">comptime</span> alignment: ?<span class="tok-type">u29</span>,
    n: <span class="tok-type">usize</span>,
    return_address: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(T)) T {
    <span class="tok-kw">const</span> a = alignment <span class="tok-kw">orelse</span> <span class="tok-builtin">@alignOf</span>(T);
    <span class="tok-kw">const</span> ptr: [*]<span class="tok-kw">align</span>(a) T = <span class="tok-builtin">@ptrCast</span>(<span class="tok-kw">try</span> self.allocWithSizeAndAlignment(<span class="tok-builtin">@sizeOf</span>(T), a, n, return_address));
    <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..n];
}

<span class="tok-kw">fn</span> <span class="tok-fn">allocWithSizeAndAlignment</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>, n: <span class="tok-type">usize</span>, return_address: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![*]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> byte_count = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, size, n) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>.<a href="#">OutOfMemory</a>;
    <span class="tok-kw">return</span> self.allocBytesWithAlignment(alignment, byte_count, return_address);
}

<span class="tok-kw">fn</span> <span class="tok-fn">allocBytesWithAlignment</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>, byte_count: <span class="tok-type">usize</span>, return_address: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![*]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (byte_count == <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> ptr = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(<span class="tok-type">usize</span>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>), alignment);
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(ptr));
    }

    <span class="tok-kw">const</span> byte_ptr = self.rawAlloc(byte_count, .fromByteUnits(alignment), return_address) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>.<a href="#">OutOfMemory</a>;
    <span class="tok-builtin">@memset</span>(byte_ptr[<span class="tok-number">0</span>..byte_count], <span class="tok-null">undefined</span>);
    <span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(byte_ptr);
}

<span class="tok-comment">/// Request to modify the size of an allocation.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// It is guaranteed to not move the pointer, however the allocator</span>
<span class="tok-comment">/// implementation may refuse the resize request by returning `false`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `allocation` may be an empty slice, in which case a new allocation is made.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `new_len` may be zero, in which case the allocation is freed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, allocation: <span class="tok-kw">anytype</span>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(allocation)).pointer;
    <span class="tok-kw">const</span> T = Slice.child;
    <span class="tok-kw">const</span> alignment = Slice.alignment;
    <span class="tok-kw">if</span> (new_len == <span class="tok-number">0</span>) {
        self.free(allocation);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">if</span> (allocation.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">const</span> old_memory = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(allocation);<span class="tok-comment">
    // I would like to use saturating multiplication here, but LLVM cannot lower it
    // on WebAssembly: https://github.com/ziglang/zig/issues/9660
    //const new_len_bytes = new_len *| @sizeOf(T);
    </span><span class="tok-kw">const</span> new_len_bytes = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@sizeOf</span>(T), new_len) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">return</span> self.rawResize(old_memory, .fromByteUnits(alignment), new_len_bytes, <span class="tok-builtin">@returnAddress</span>());
}

<span class="tok-comment">/// Request to modify the size of an allocation, allowing relocation.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// A non-`null` return value indicates the resize was successful. The</span>
<span class="tok-comment">/// allocation may have same address, or may have been relocated. In either</span>
<span class="tok-comment">/// case, the allocation now has size of `new_len`. A `null` return value</span>
<span class="tok-comment">/// indicates that the resize would be equivalent to allocating new memory,</span>
<span class="tok-comment">/// copying the bytes from the old memory, and then freeing the old memory.</span>
<span class="tok-comment">/// In such case, it is more efficient for the caller to perform those</span>
<span class="tok-comment">/// operations.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `allocation` may be an empty slice, in which case `null` is returned,</span>
<span class="tok-comment">/// unless `new_len` is also 0, in which case `allocation` is returned.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `new_len` may be zero, in which case the allocation is freed.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If the allocation's elements' type is zero bytes sized, `allocation.len` is set to `new_len`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remap</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, allocation: <span class="tok-kw">anytype</span>, new_len: <span class="tok-type">usize</span>) t: {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(allocation)).pointer;
    <span class="tok-kw">break</span> :t ?[]<span class="tok-kw">align</span>(Slice.alignment) Slice.child;
} {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(allocation)).pointer;
    <span class="tok-kw">const</span> T = Slice.child;

    <span class="tok-kw">const</span> alignment = Slice.alignment;
    <span class="tok-kw">if</span> (new_len == <span class="tok-number">0</span>) {
        self.free(allocation);
        <span class="tok-kw">return</span> allocation[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    }
    <span class="tok-kw">if</span> (allocation.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        <span class="tok-kw">var</span> new_memory = allocation;
        new_memory.len = new_len;
        <span class="tok-kw">return</span> new_memory;
    }
    <span class="tok-kw">const</span> old_memory = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(allocation);<span class="tok-comment">
    // I would like to use saturating multiplication here, but LLVM cannot lower it
    // on WebAssembly: https://github.com/ziglang/zig/issues/9660
    //const new_len_bytes = new_len *| @sizeOf(T);
    </span><span class="tok-kw">const</span> new_len_bytes = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@sizeOf</span>(T), new_len) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> new_ptr = self.rawRemap(old_memory, .fromByteUnits(alignment), new_len_bytes, <span class="tok-builtin">@returnAddress</span>()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> new_memory: []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(new_ptr[<span class="tok-number">0</span>..new_len_bytes]);
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(T, new_memory);
}

<span class="tok-comment">/// This function requests a new byte size for an existing allocation, which</span>
<span class="tok-comment">/// can be larger, smaller, or the same size as the old memory allocation.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `new_n` is 0, this is the same as `free` and it always succeeds.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `old_mem` may have length zero, which makes a new allocation.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function only fails on out-of-memory conditions, unlike:</span>
<span class="tok-comment">/// * `remap` which returns `null` when the `Allocator` implementation cannot</span>
<span class="tok-comment">///   do the realloc more efficiently than the caller</span>
<span class="tok-comment">/// * `resize` which returns `false` when the `Allocator` implementation cannot</span>
<span class="tok-comment">///   change the size without relocating the allocation.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realloc</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, old_mem: <span class="tok-kw">anytype</span>, new_n: <span class="tok-type">usize</span>) t: {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(old_mem)).pointer;
    <span class="tok-kw">break</span> :t <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(Slice.alignment) Slice.child;
} {
    <span class="tok-kw">return</span> self.reallocAdvanced(old_mem, new_n, <span class="tok-builtin">@returnAddress</span>());
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reallocAdvanced</span>(
    self: <a href="std.mem.Allocator.html">Allocator</a>,
    old_mem: <span class="tok-kw">anytype</span>,
    new_n: <span class="tok-type">usize</span>,
    return_address: <span class="tok-type">usize</span>,
) t: {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(old_mem)).pointer;
    <span class="tok-kw">break</span> :t <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-kw">align</span>(Slice.alignment) Slice.child;
} {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(old_mem)).pointer;
    <span class="tok-kw">const</span> T = Slice.child;
    <span class="tok-kw">if</span> (old_mem.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> self.allocAdvancedWithRetAddr(T, Slice.alignment, new_n, return_address);
    }
    <span class="tok-kw">if</span> (new_n == <span class="tok-number">0</span>) {
        self.free(old_mem);
        <span class="tok-kw">const</span> ptr = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(<span class="tok-type">usize</span>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>), Slice.alignment);
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(Slice.alignment) T, <span class="tok-builtin">@ptrFromInt</span>(ptr))[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    }

    <span class="tok-kw">const</span> old_byte_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(old_mem);
    <span class="tok-kw">const</span> byte_count = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@sizeOf</span>(T), new_n) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>.<a href="#">OutOfMemory</a>;<span class="tok-comment">
    // Note: can't set shrunk memory to undefined as memory shouldn't be modified on realloc failure
    </span><span class="tok-kw">if</span> (self.rawRemap(old_byte_slice, .fromByteUnits(Slice.alignment), byte_count, return_address)) |p| {
        <span class="tok-kw">const</span> new_bytes: []<span class="tok-kw">align</span>(Slice.alignment) <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(p[<span class="tok-number">0</span>..byte_count]);
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(T, new_bytes);
    }

    <span class="tok-kw">const</span> new_mem = self.rawAlloc(byte_count, .fromByteUnits(Slice.alignment), return_address) <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
    <span class="tok-kw">const</span> copy_len = <span class="tok-builtin">@min</span>(byte_count, old_byte_slice.len);
    <span class="tok-builtin">@memcpy</span>(new_mem[<span class="tok-number">0</span>..copy_len], old_byte_slice[<span class="tok-number">0</span>..copy_len]);
    <span class="tok-builtin">@memset</span>(old_byte_slice, <span class="tok-null">undefined</span>);
    self.rawFree(old_byte_slice, .fromByteUnits(Slice.alignment), return_address);

    <span class="tok-kw">const</span> new_bytes: []<span class="tok-kw">align</span>(Slice.alignment) <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(new_mem[<span class="tok-number">0</span>..byte_count]);
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(T, new_bytes);
}

<span class="tok-comment">/// Free an array allocated with `alloc`.</span>
<span class="tok-comment">/// If memory has length 0, free is a no-op.</span>
<span class="tok-comment">/// To free a single item, see `destroy`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(self: <a href="std.mem.Allocator.html">Allocator</a>, memory: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(memory)).pointer;
    <span class="tok-kw">const</span> bytes = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(memory);
    <span class="tok-kw">const</span> bytes_len = bytes.len + <span class="tok-kw">if</span> (Slice.sentinel() != <span class="tok-null">null</span>) <span class="tok-builtin">@sizeOf</span>(Slice.child) <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (bytes_len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
    <span class="tok-kw">const</span> non_const_ptr = <span class="tok-builtin">@constCast</span>(bytes.ptr);
    <span class="tok-builtin">@memset</span>(non_const_ptr[<span class="tok-number">0</span>..bytes_len], <span class="tok-null">undefined</span>);
    self.rawFree(non_const_ptr[<span class="tok-number">0</span>..bytes_len], .fromByteUnits(Slice.alignment), <span class="tok-builtin">@returnAddress</span>());
}

<span class="tok-comment">/// Copies `m` to newly allocated memory. Caller owns the memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, m: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> new_buf = <span class="tok-kw">try</span> allocator.alloc(T, m.len);
    <span class="tok-builtin">@memcpy</span>(new_buf, m);
    <span class="tok-kw">return</span> new_buf;
}

<span class="tok-comment">/// Copies `m` to newly allocated memory, with a null-terminated element. Caller owns the memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeZ</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, m: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-number">0</span>]T {
    <span class="tok-kw">const</span> new_buf = <span class="tok-kw">try</span> allocator.alloc(T, m.len + <span class="tok-number">1</span>);
    <span class="tok-builtin">@memcpy</span>(new_buf[<span class="tok-number">0</span>..m.len], m);
    new_buf[m.len] = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> new_buf[<span class="tok-number">0</span>..m.len :<span class="tok-number">0</span>];
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
