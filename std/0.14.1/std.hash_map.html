<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.hash_map.html" class="active">hash_map</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.hash_map" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.hash_map</span><a href="#src.zig-std.hash_map">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.hash_map.StringContext.html">std.hash_map.StringContext</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.hash_map.StringIndexContext.html">std.hash_map.StringIndexContext</a></li><li><a href="std.hash_map.StringIndexAdapter.html">std.hash_map.StringIndexAdapter</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.hash_map.AutoHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoHashMap</span><a href="#src.zig-std.hash_map.AutoHashMap">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMap.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.hash_map.HashMap.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The type of the unmanaged hash map underlying this wrapper</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMap.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.hash_map.HashMap.Entry">[src]</a></h3><div class="tldDocs"><p>An entry, containing pointers to a key and value stored in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.hash_map.HashMap.KV">[src]</a></h3><div class="tldDocs"><p>A copy of a key and value which are no longer in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMap.Hash">[src]</a></h3><div class="tldDocs"><p>The integer type that is the result of hashing</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.hash_map.HashMap.Iterator">[src]</a></h3><div class="tldDocs"><p>The iterator type returned by iterator()</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KeyIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMap.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ValueIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMap.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Size" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMap.Size">[src]</a></h3><div class="tldDocs"><p>The integer type used to store the size of the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.hash_map.HashMap.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>The type returned from getOrPut and variants</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMap.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.hash_map.HashMap.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with an empty context.
If the context is not zero-sized, you must use
initContext(allocator, ctx) instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
    }
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
    </span>};
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.hash_map.HashMap.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with a context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMap.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMap.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMap.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release the backing array and invalidate this map.
This does <em>not</em> deinit keys, values, or the context!
If your keys or values need to be released, ensure
that that is done before calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMap.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map, but keep the backing allocation for future use.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMap.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map and release the backing allocation.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMap.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Return the number of items in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMap.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the entries in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMap.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the keys in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.keyIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMap.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the values in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.valueIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMap.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMap.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMap.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMap.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMap.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMap.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes a value from the map and returns the removed kv pair.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMap.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMap.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Finds the value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMap.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMap.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMap.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Finds the actual key associated with an adapted key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMap.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds the key and value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMap.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMap.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check if the map contains a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMap.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMap.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMap.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMap.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
    self.unmanaged.removeByPtr(key_ptr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMap.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using the same allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>( self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
    self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
    new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    new_ctx: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMap.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMap.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.rehash(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.AutoHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoHashMap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <a href="std.hash_map.html#std.hash_map.AutoContext">AutoContext</a>(K), <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.AutoHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoHashMapUnmanaged</span><a href="#src.zig-std.hash_map.AutoHashMapUnmanaged">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.hash_map.HashMapUnmanaged.Entry.html">std.hash_map.HashMapUnmanaged.Entry</a></li><li><a href="std.hash_map.HashMapUnmanaged.KV.html">std.hash_map.HashMapUnmanaged.KV</a></li><li><a href="std.hash_map.HashMapUnmanaged.Iterator.html">std.hash_map.HashMapUnmanaged.Iterator</a></li><li><a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">std.hash_map.HashMapUnmanaged.GetOrPutResult</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Size" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Size">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Hash">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.KeyIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ValueIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Managed">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Pointer to the metadata.</p>
</div></div><div><pre><code>size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Current number of elements in the hashmap.</p>
</div></div><div><pre><code>available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Number of available slots before a grow is needed to satisfy the
<code>max_load_percentage</code>.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
    .metadata = <span class="tok-null">null</span>,
    .size = <span class="tok-number">0</span>,
    .available = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.deallocate(allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (new_size &gt; self.size)
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (self.metadata) |_| {
        self.initMetadatas();
        self.size = <span class="tok-number">0</span>;
        self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    self.deallocate(allocator);
    self.size = <span class="tok-number">0</span>;
    self.available = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">return</span> self.size;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">return</span> self.header().capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{ .hm = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.keys(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.values(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
    }
    self.putAssumeCapacityNoClobberContext(key, value, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    gop.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present,
and that no allocation is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

    <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

    <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
    self.available -= <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    self.keys()[idx] = key;
    self.values()[idx] = value;

    self.size += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
        <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
        <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = old_key.*,
            .value = old_val.*,
        };
        self.metadata.?[idx].remove();
        old_key.* = <span class="tok-null">undefined</span>;
        old_val.* = <span class="tok-null">undefined</span>;
        self.size -= <span class="tok-number">1</span>;
        self.available += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
            .key_ptr = &amp;self.keys()[idx],
            .value_ptr = &amp;self.values()[idx],
        };
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry if the associated key is not already present, otherwise update preexisting value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Get a copy of the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Get a copy of the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // If allocation fails, try to do the lookup anyway.
            // If we find an existing item, we can return it.
            // Otherwise return the error, we could not add another.
            </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = &amp;self.keys()[index],
                .value_ptr = &amp;self.values()[index],
                .found_existing = <span class="tok-null">true</span>,
            };
        };
    }
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!result.found_existing) {
        result.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

    // If you get a compile error on this line, it means that your generic hash
    // function is invalid for these parameters.
    </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    <span class="tok-kw">var</span> limit = self.capacity();
    <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

    <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
    </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
            <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
            // If you get a compile error on this line, it means that your generic eql
            // function is invalid for these parameters.

            </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = test_key,
                    .value_ptr = &amp;self.values()[idx],
                    .found_existing = <span class="tok-null">true</span>,
                };
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
            first_tombstone_idx = idx;
        }

        limit -= <span class="tok-number">1</span>;
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
        // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
        </span>idx = first_tombstone_idx;
        metadata = self.metadata.? + idx;
    }<span class="tok-comment">
    // We're using a slot previously free or a tombstone.
    </span>self.available -= <span class="tok-number">1</span>;

    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
    <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
    new_key.* = <span class="tok-null">undefined</span>;
    new_value.* = <span class="tok-null">undefined</span>;
    self.size += <span class="tok-number">1</span>;

    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
        .key_ptr = new_key,
        .value_ptr = new_value,
        .found_existing = <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Return true if there is a value associated with key in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        self.removeByIndex(idx);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
    // TODO: replace with pointer subtraction once supported by zig
    // if @sizeOf(K) == 0 then there is at most one item in the hash
    // map, which is assumed to exist as key_ptr must be valid.  This
    // item must be at index 0.
    </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
        (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;

    self.removeByIndex(idx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
    <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> other;

    <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
    <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
    other.initMetadatas();
    other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

    <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">const</span> keys_ptr = self.keys();
    <span class="tok-kw">const</span> values_ptr = self.values();
    <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (metadata[i].isUsed()) {
            other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
            <span class="tok-kw">if</span> (other.size == self.size)
                <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">var</span> keys_ptr = self.keys();
    <span class="tok-kw">var</span> values_ptr = self.values();
    <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

    // While we are re-hashing every slot, we will use the
    // fingerprint to mark used buckets as being used and either free
    // (needing to be rehashed) or tombstone (already rehashed).

    </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
    }<span class="tok-comment">

    // Now iterate over all the buckets, rehashing them

    </span>curr = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
        <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            curr += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
        <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
        <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

        // For each bucket, rehash to an index:
        // 1) before the cursor, probed into a free slot, or
        // 2) equal to the cursor, no need to move, or
        // 3) ahead of the cursor, probing over already rehashed

        </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
            (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
        {
            idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        }

        <span class="tok-kw">if</span> (idx &lt; curr) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
            metadata[idx].fill(fingerprint);
            keys_ptr[idx] = keys_ptr[curr];
            values_ptr[idx] = values_ptr[curr];

            metadata[curr].used = <span class="tok-number">0</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            keys_ptr[curr] = <span class="tok-null">undefined</span>;
            values_ptr[curr] = <span class="tok-null">undefined</span>;

            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
            metadata[idx].fingerprint = fingerprint;
            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
            metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
            } <span class="tok-kw">else</span> {
                metadata[idx].used = <span class="tok-number">1</span>;
                keys_ptr[idx] = keys_ptr[curr];
                values_ptr[idx] = values_ptr[curr];

                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                metadata[curr].used = <span class="tok-number">0</span>;
                keys_ptr[curr] = <span class="tok-null">undefined</span>;
                values_ptr[curr] = <span class="tok-null">undefined</span>;

                curr += <span class="tok-number">1</span>;
            }
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.AutoHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <a href="std.hash_map.html#std.hash_map.AutoContext">AutoContext</a>(K), <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.AutoContext" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoContext</span><a href="#src.zig-std.hash_map.AutoContext">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.AutoContext.hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">hash</span><a href="#src.zig-std.hash_map.AutoContext.hash">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.AutoContext.hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hash = <a href="std.hash_map.html#std.hash_map.getAutoHashFn">getAutoHashFn</a>(K, <span class="tok-builtin">@This</span>())</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.AutoContext.eql" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.hash_map.AutoContext.eql">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.AutoContext.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> eql = <a href="std.hash_map.html#std.hash_map.getAutoEqlFn">getAutoEqlFn</a>(K, <span class="tok-builtin">@This</span>())</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.AutoContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoContext</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hash = <a href="std.hash_map.html#std.hash_map.getAutoHashFn">getAutoHashFn</a>(K, <span class="tok-builtin">@This</span>());
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> eql = <a href="std.hash_map.html#std.hash_map.getAutoEqlFn">getAutoEqlFn</a>(K, <span class="tok-builtin">@This</span>());
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.StringHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StringHashMap</span><a href="#src.zig-std.hash_map.StringHashMap">[src]</a></h2><div class="tldDocs"><p>Builtin hashmap for strings as keys.
Key memory is managed by the caller.  Keys and values
will not automatically be freed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMap.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.hash_map.HashMap.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The type of the unmanaged hash map underlying this wrapper</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMap.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.hash_map.HashMap.Entry">[src]</a></h3><div class="tldDocs"><p>An entry, containing pointers to a key and value stored in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.hash_map.HashMap.KV">[src]</a></h3><div class="tldDocs"><p>A copy of a key and value which are no longer in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMap.Hash">[src]</a></h3><div class="tldDocs"><p>The integer type that is the result of hashing</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.hash_map.HashMap.Iterator">[src]</a></h3><div class="tldDocs"><p>The iterator type returned by iterator()</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KeyIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMap.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ValueIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMap.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Size" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMap.Size">[src]</a></h3><div class="tldDocs"><p>The integer type used to store the size of the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.hash_map.HashMap.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>The type returned from getOrPut and variants</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMap.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.hash_map.HashMap.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with an empty context.
If the context is not zero-sized, you must use
initContext(allocator, ctx) instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
    }
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
    </span>};
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.hash_map.HashMap.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with a context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMap.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMap.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMap.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release the backing array and invalidate this map.
This does <em>not</em> deinit keys, values, or the context!
If your keys or values need to be released, ensure
that that is done before calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMap.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map, but keep the backing allocation for future use.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMap.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map and release the backing allocation.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMap.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Return the number of items in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMap.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the entries in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMap.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the keys in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.keyIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMap.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the values in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.valueIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMap.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMap.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMap.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMap.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMap.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMap.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes a value from the map and returns the removed kv pair.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMap.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMap.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Finds the value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMap.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMap.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMap.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Finds the actual key associated with an adapted key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMap.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds the key and value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMap.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMap.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check if the map contains a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMap.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMap.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMap.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMap.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
    self.unmanaged.removeByPtr(key_ptr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMap.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using the same allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>( self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
    self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
    new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    new_ctx: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMap.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMap.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.rehash(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.StringHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringHashMap</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.hash_map.StringContext.html">StringContext</a>, <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.StringHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StringHashMapUnmanaged</span><a href="#src.zig-std.hash_map.StringHashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>Key memory is managed by the caller.  Keys and values
will not automatically be freed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.hash_map.HashMapUnmanaged.Entry.html">std.hash_map.HashMapUnmanaged.Entry</a></li><li><a href="std.hash_map.HashMapUnmanaged.KV.html">std.hash_map.HashMapUnmanaged.KV</a></li><li><a href="std.hash_map.HashMapUnmanaged.Iterator.html">std.hash_map.HashMapUnmanaged.Iterator</a></li><li><a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">std.hash_map.HashMapUnmanaged.GetOrPutResult</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Size" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Size">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Hash">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.KeyIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ValueIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Managed">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Pointer to the metadata.</p>
</div></div><div><pre><code>size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Current number of elements in the hashmap.</p>
</div></div><div><pre><code>available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Number of available slots before a grow is needed to satisfy the
<code>max_load_percentage</code>.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
    .metadata = <span class="tok-null">null</span>,
    .size = <span class="tok-number">0</span>,
    .available = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.deallocate(allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (new_size &gt; self.size)
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (self.metadata) |_| {
        self.initMetadatas();
        self.size = <span class="tok-number">0</span>;
        self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    self.deallocate(allocator);
    self.size = <span class="tok-number">0</span>;
    self.available = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">return</span> self.size;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">return</span> self.header().capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{ .hm = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.keys(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.values(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
    }
    self.putAssumeCapacityNoClobberContext(key, value, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    gop.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present,
and that no allocation is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

    <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

    <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
    self.available -= <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    self.keys()[idx] = key;
    self.values()[idx] = value;

    self.size += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
        <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
        <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = old_key.*,
            .value = old_val.*,
        };
        self.metadata.?[idx].remove();
        old_key.* = <span class="tok-null">undefined</span>;
        old_val.* = <span class="tok-null">undefined</span>;
        self.size -= <span class="tok-number">1</span>;
        self.available += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
            .key_ptr = &amp;self.keys()[idx],
            .value_ptr = &amp;self.values()[idx],
        };
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry if the associated key is not already present, otherwise update preexisting value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Get a copy of the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Get a copy of the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // If allocation fails, try to do the lookup anyway.
            // If we find an existing item, we can return it.
            // Otherwise return the error, we could not add another.
            </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = &amp;self.keys()[index],
                .value_ptr = &amp;self.values()[index],
                .found_existing = <span class="tok-null">true</span>,
            };
        };
    }
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!result.found_existing) {
        result.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

    // If you get a compile error on this line, it means that your generic hash
    // function is invalid for these parameters.
    </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    <span class="tok-kw">var</span> limit = self.capacity();
    <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

    <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
    </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
            <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
            // If you get a compile error on this line, it means that your generic eql
            // function is invalid for these parameters.

            </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = test_key,
                    .value_ptr = &amp;self.values()[idx],
                    .found_existing = <span class="tok-null">true</span>,
                };
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
            first_tombstone_idx = idx;
        }

        limit -= <span class="tok-number">1</span>;
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
        // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
        </span>idx = first_tombstone_idx;
        metadata = self.metadata.? + idx;
    }<span class="tok-comment">
    // We're using a slot previously free or a tombstone.
    </span>self.available -= <span class="tok-number">1</span>;

    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
    <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
    new_key.* = <span class="tok-null">undefined</span>;
    new_value.* = <span class="tok-null">undefined</span>;
    self.size += <span class="tok-number">1</span>;

    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
        .key_ptr = new_key,
        .value_ptr = new_value,
        .found_existing = <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Return true if there is a value associated with key in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        self.removeByIndex(idx);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
    // TODO: replace with pointer subtraction once supported by zig
    // if @sizeOf(K) == 0 then there is at most one item in the hash
    // map, which is assumed to exist as key_ptr must be valid.  This
    // item must be at index 0.
    </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
        (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;

    self.removeByIndex(idx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
    <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> other;

    <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
    <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
    other.initMetadatas();
    other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

    <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">const</span> keys_ptr = self.keys();
    <span class="tok-kw">const</span> values_ptr = self.values();
    <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (metadata[i].isUsed()) {
            other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
            <span class="tok-kw">if</span> (other.size == self.size)
                <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">var</span> keys_ptr = self.keys();
    <span class="tok-kw">var</span> values_ptr = self.values();
    <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

    // While we are re-hashing every slot, we will use the
    // fingerprint to mark used buckets as being used and either free
    // (needing to be rehashed) or tombstone (already rehashed).

    </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
    }<span class="tok-comment">

    // Now iterate over all the buckets, rehashing them

    </span>curr = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
        <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            curr += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
        <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
        <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

        // For each bucket, rehash to an index:
        // 1) before the cursor, probed into a free slot, or
        // 2) equal to the cursor, no need to move, or
        // 3) ahead of the cursor, probing over already rehashed

        </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
            (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
        {
            idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        }

        <span class="tok-kw">if</span> (idx &lt; curr) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
            metadata[idx].fill(fingerprint);
            keys_ptr[idx] = keys_ptr[curr];
            values_ptr[idx] = values_ptr[curr];

            metadata[curr].used = <span class="tok-number">0</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            keys_ptr[curr] = <span class="tok-null">undefined</span>;
            values_ptr[curr] = <span class="tok-null">undefined</span>;

            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
            metadata[idx].fingerprint = fingerprint;
            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
            metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
            } <span class="tok-kw">else</span> {
                metadata[idx].used = <span class="tok-number">1</span>;
                keys_ptr[idx] = keys_ptr[curr];
                values_ptr[idx] = values_ptr[curr];

                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                metadata[curr].used = <span class="tok-number">0</span>;
                keys_ptr[curr] = <span class="tok-null">undefined</span>;
                values_ptr[curr] = <span class="tok-null">undefined</span>;

                curr += <span class="tok-number">1</span>;
            }
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.StringHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.hash_map.StringContext.html">StringContext</a>, <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.HashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">HashMap</span><a href="#src.zig-std.hash_map.HashMap">[src]</a></h2><div class="tldDocs"><p>General purpose hash table.
No order is guaranteed and any modification invalidates live iterators.
It provides fast operations (lookup, insertion, deletion) with quite high
load factors (up to 80% by default) for low memory usage.
For a hash map that can be initialized directly that does not store an Allocator
field, see <code><a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a></code>.
If iterating over the table entries is a strong usecase and needs to be fast,
prefer the alternative <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">std.ArrayHashMap</a></code>.
Context must be a struct type with two member functions:
hash(self, K) u64
eql(self, K, K) bool
Adapted variants of many functions are provided.  These variants
take a pseudo key instead of a key.  Their context must have the functions:
hash(self, PseudoKey) u64
eql(self, PseudoKey, K) bool</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div><div><pre><code>max_load_percentage: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMap.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.hash_map.HashMap.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The type of the unmanaged hash map underlying this wrapper</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMap.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.hash_map.HashMap.Entry">[src]</a></h3><div class="tldDocs"><p>An entry, containing pointers to a key and value stored in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.hash_map.HashMap.KV">[src]</a></h3><div class="tldDocs"><p>A copy of a key and value which are no longer in the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMap.Hash">[src]</a></h3><div class="tldDocs"><p>The integer type that is the result of hashing</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.hash_map.HashMap.Iterator">[src]</a></h3><div class="tldDocs"><p>The iterator type returned by iterator()</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.KeyIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMap.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ValueIterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMap.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.Size" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMap.Size">[src]</a></h3><div class="tldDocs"><p>The integer type used to store the size of the map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.hash_map.HashMap.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>The type returned from getOrPut and variants</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMap.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.hash_map.HashMap.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with an empty context.
If the context is not zero-sized, you must use
initContext(allocator, ctx) instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
    }
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
    </span>};
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.hash_map.HashMap.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Create a managed hash map with a context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMap.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMap.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMap.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Release the backing array and invalidate this map.
This does <em>not</em> deinit keys, values, or the context!
If your keys or values need to be released, ensure
that that is done before calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMap.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map, but keep the backing allocation for future use.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMap.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Empty the map and release the backing allocation.
This does <em>not</em> free keys or values! Be sure to
release them if they need deinitialization before
calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMap.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Return the number of items in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMap.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the entries in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMap.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the keys in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.keyIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMap.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a></code></pre></div><div class="tldDocs"><p>Create an iterator over the values in the map.
The iterator is invalidated if the map is modified.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.valueIterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMap.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result's
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
the key and value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMap.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMap.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMap.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMap.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMap.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMap.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes a value from the map and returns the removed kv pair.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMap.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMap.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Finds the value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMap.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMap.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMap.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Finds the actual key associated with an adapted key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMap.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMap.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds the key and value associated with a key in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMap.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMap.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check if the map contains a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMap.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMap.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMap.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMap.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
    self.unmanaged.removeByPtr(key_ptr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMap.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using the same allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified context</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>( self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="tldDocs"><p>Creates a copy of this map, using a specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div><pre><code>new_allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
    self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
    new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    new_ctx: <span class="tok-kw">anytype</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
    <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMap.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMap.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMap.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMap.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.rehash(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.HashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">HashMap</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> max_load_percentage: <span class="tok-type">u64</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        ctx: Context,

        <span class="tok-comment">/// The type of the unmanaged hash map underlying this wrapper</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage);
        <span class="tok-comment">/// An entry, containing pointers to a key and value stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a>;
        <span class="tok-comment">/// A copy of a key and value which are no longer in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a>;
        <span class="tok-comment">/// The integer type that is the result of hashing</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a>;
        <span class="tok-comment">/// The iterator type returned by iterator()</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a>;

        <span class="tok-comment">/// The integer type used to store the size of the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a>;
        <span class="tok-comment">/// The type returned from getOrPut and variants</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a>;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Create a managed hash map with an empty context.</span>
        <span class="tok-comment">/// If the context is not zero-sized, you must use</span>
        <span class="tok-comment">/// initContext(allocator, ctx) instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
            }
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
            </span>};
        }

        <span class="tok-comment">/// Create a managed hash map with a context</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.lockPointers();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.unlockPointers();
        }

        <span class="tok-comment">/// Release the backing array and invalidate this map.</span>
        <span class="tok-comment">/// This does *not* deinit keys, values, or the context!</span>
        <span class="tok-comment">/// If your keys or values need to be released, ensure</span>
        <span class="tok-comment">/// that that is done before calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.deinit(self.allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Empty the map, but keep the backing allocation for future use.</span>
        <span class="tok-comment">/// This does *not* free keys or values! Be sure to</span>
        <span class="tok-comment">/// release them if they need deinitialization before</span>
        <span class="tok-comment">/// calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
        }

        <span class="tok-comment">/// Empty the map and release the backing allocation.</span>
        <span class="tok-comment">/// This does *not* free keys or values! Be sure to</span>
        <span class="tok-comment">/// release them if they need deinitialization before</span>
        <span class="tok-comment">/// calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
        }

        <span class="tok-comment">/// Return the number of items in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
            <span class="tok-kw">return</span> self.unmanaged.count();
        }

        <span class="tok-comment">/// Create an iterator over the entries in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.iterator();
        }

        <span class="tok-comment">/// Create an iterator over the keys in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.keyIterator();
        }

        <span class="tok-comment">/// Create an iterator over the values in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.valueIterator();
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined key and value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// the key and value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// the key and value.</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
            <span class="tok-kw">return</span> self.unmanaged.capacity();
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Removes a value from the map and returns the removed kv pair.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the value associated with a key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the actual key associated with an adapted key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the key and value associated with a key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
        }

        <span class="tok-comment">/// Check if the map contains a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and this function returns true.  Otherwise this</span>
        <span class="tok-comment">/// function returns false.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
        }

        <span class="tok-comment">/// Delete the entry with key pointed to by key_ptr from the hash map.</span>
        <span class="tok-comment">/// key_ptr is assumed to be a valid pointer to a key that is present</span>
        <span class="tok-comment">/// in the hash map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
            self.unmanaged.removeByPtr(key_ptr);
        }

        <span class="tok-comment">/// Creates a copy of this map, using the same allocator</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified allocator</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified context</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified allocator and context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
            self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
            new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
            new_ctx: <span class="tok-kw">anytype</span>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
            <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            self.unmanaged.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.unmanaged = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Rehash the map, in-place.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Over time, due to the current tombstone-based implementation, a</span>
        <span class="tok-comment">/// HashMap could become fragmented due to the buildup of tombstone</span>
        <span class="tok-comment">/// entries that causes a performance degradation due to excessive</span>
        <span class="tok-comment">/// probing. The kind of pattern that might cause this is a long-lived</span>
        <span class="tok-comment">/// HashMap with repeated inserts and deletes.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// After this function is called, there will be no tombstones in</span>
        <span class="tok-comment">/// the HashMap, each of the entries is rehashed and any existing</span>
        <span class="tok-comment">/// key/value pointers into the HashMap are invalidated.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.rehash(self.ctx);
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.HashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">HashMapUnmanaged</span><a href="#src.zig-std.hash_map.HashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>A HashMap based on open addressing and linear probing.
A lookup or modification typically incurs only 2 cache misses.
No order is guaranteed and any modification invalidates live iterators.
It achieves good performance with quite high load factors (by default,
grow is triggered at 80% full) and only one byte of overhead per element.
The struct itself is only 16 bytes for a small footprint. This comes at
the price of handling size with u32, which should be reasonable enough
for almost all uses.
Deletions are achieved with tombstones.</p>
<p>Default initialization of this struct is deprecated; use <code>.empty</code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div><div><pre><code>max_load_percentage: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.hash_map.HashMapUnmanaged.Entry.html">std.hash_map.HashMapUnmanaged.Entry</a></li><li><a href="std.hash_map.HashMapUnmanaged.KV.html">std.hash_map.HashMapUnmanaged.KV</a></li><li><a href="std.hash_map.HashMapUnmanaged.Iterator.html">std.hash_map.HashMapUnmanaged.Iterator</a></li><li><a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">std.hash_map.HashMapUnmanaged.GetOrPutResult</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Size" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Size</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Size">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Size">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Hash">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span></code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.KeyIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">KeyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.KeyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ValueIterator" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ValueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ValueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V)</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.Managed">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>Pointer to the metadata.</p>
</div></div><div><pre><code>size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Current number of elements in the hashmap.</p>
</div></div><div><pre><code>available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>Number of available slots before a grow is needed to satisfy the
<code>max_load_percentage</code>.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
    .metadata = <span class="tok-null">null</span>,
    .size = <span class="tok-number">0</span>,
    .available = <span class="tok-number">0</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.deallocate(allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (new_size &gt; self.size)
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    <span class="tok-kw">if</span> (self.metadata) |_| {
        self.initMetadatas();
        self.size = <span class="tok-number">0</span>;
        self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();
    self.deallocate(allocator);
    self.size = <span class="tok-number">0</span>;
    self.available = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">return</span> self.size;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
    <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">return</span> self.header().capacity;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">return</span> .{ .hm = self };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.keyIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keyIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.keyIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.keyIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.keys(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.valueIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">valueIterator</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.valueIterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.valueIterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
    <span class="tok-kw">if</span> (self.metadata) |metadata| {
        <span class="tok-kw">return</span> .{
            .len = self.capacity(),
            .metadata = metadata,
            .items = self.values(),
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{
            .len = <span class="tok-number">0</span>,
            .metadata = <span class="tok-null">undefined</span>,
            .items = <span class="tok-null">undefined</span>,
        };
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
    }
    self.putAssumeCapacityNoClobberContext(key, value, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    gop.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry in the map. Assumes it is not already present,
and that no allocation is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

    <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

    <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
    self.available -= <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    self.keys()[idx] = key;
    self.values()[idx] = value;

    self.size += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.fetchRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchRemoveAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.fetchRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
        <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
        <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
            .key = old_key.*,
            .value = old_val.*,
        };
        self.metadata.?[idx].remove();
        old_key.* = <span class="tok-null">undefined</span>;
        old_val.* = <span class="tok-null">undefined</span>;
        self.size -= <span class="tok-number">1</span>;
        self.available += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
            .key_ptr = &amp;self.keys()[idx],
            .value_ptr = &amp;self.values()[idx],
        };
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Insert an entry if the associated key is not already present, otherwise update preexisting value.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Get a copy of the actual key associated with adapted key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.keys()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Get an optional pointer to the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> &amp;self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Get a copy of the value associated with key, if present.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        <span class="tok-kw">return</span> self.values()[idx];
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    {
        self.pointer_stability.lock();
        <span class="tok-kw">defer</span> self.pointer_stability.unlock();
        self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // If allocation fails, try to do the lookup anyway.
            // If we find an existing item, we can return it.
            // Otherwise return the error, we could not add another.
            </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = &amp;self.keys()[index],
                .value_ptr = &amp;self.values()[index],
                .found_existing = <span class="tok-null">true</span>,
            };
        };
    }
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!result.found_existing) {
        result.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

    // If you get a compile error on this line, it means that your generic hash
    // function is invalid for these parameters.
    </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
    <span class="tok-kw">var</span> limit = self.capacity();
    <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

    <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
    </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
    <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
            <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
            // If you get a compile error on this line, it means that your generic eql
            // function is invalid for these parameters.

            </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = test_key,
                    .value_ptr = &amp;self.values()[idx],
                    .found_existing = <span class="tok-null">true</span>,
                };
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
            first_tombstone_idx = idx;
        }

        limit -= <span class="tok-number">1</span>;
        idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        metadata = self.metadata.? + idx;
    }

    <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
        // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
        </span>idx = first_tombstone_idx;
        metadata = self.metadata.? + idx;
    }<span class="tok-comment">
    // We're using a slot previously free or a tombstone.
    </span>self.available -= <span class="tok-number">1</span>;

    metadata[<span class="tok-number">0</span>].fill(fingerprint);
    <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
    <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
    new_key.* = <span class="tok-null">undefined</span>;
    new_value.* = <span class="tok-null">undefined</span>;
    self.size += <span class="tok-number">1</span>;

    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
        .key_ptr = new_key,
        .value_ptr = new_value,
        .found_existing = <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Return true if there is a value associated with key in the map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.remove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and this function returns true.  Otherwise this
function returns false.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.remove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeAdapted</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
        self.removeByIndex(idx);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.removeByPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">removeByPtr</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete the entry with key pointed to by key_ptr from the hash map.
key_ptr is assumed to be a valid pointer to a key that is present
in the hash map.</p>
<p>TODO: answer the question in these doc comments, does this
increase the unused capacity by one?</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key_ptr: *K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.removeByPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
    // TODO: replace with pointer subtraction once supported by zig
    // if @sizeOf(K) == 0 then there is at most one item in the hash
    // map, which is assumed to exist as key_ptr must be valid.  This
    // item must be at index 0.
    </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
        (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;

    self.removeByIndex(idx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
    <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
    <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> other;

    <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
    <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
    other.initMetadatas();
    other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

    <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">const</span> keys_ptr = self.keys();
    <span class="tok-kw">const</span> values_ptr = self.values();
    <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (metadata[i].isUsed()) {
            other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
            <span class="tok-kw">if</span> (other.size == self.size)
                <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.hash_map.HashMapUnmanaged.rehash" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rehash</span><a href="#src.zig-std.hash_map.HashMapUnmanaged.rehash">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rehash the map, in-place.</p>
<p>Over time, due to the current tombstone-based implementation, a
HashMap could become fragmented due to the buildup of tombstone
entries that causes a performance degradation due to excessive
probing. The kind of pattern that might cause this is a long-lived
HashMap with repeated inserts and deletes.</p>
<p>After this function is called, there will be no tombstones in
the HashMap, each of the entries is rehashed and any existing
key/value pointers into the HashMap are invalidated.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged.rehash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

    <span class="tok-kw">var</span> metadata = self.metadata.?;
    <span class="tok-kw">var</span> keys_ptr = self.keys();
    <span class="tok-kw">var</span> values_ptr = self.values();
    <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

    // While we are re-hashing every slot, we will use the
    // fingerprint to mark used buckets as being used and either free
    // (needing to be rehashed) or tombstone (already rehashed).

    </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
    }<span class="tok-comment">

    // Now iterate over all the buckets, rehashing them

    </span>curr = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
        <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            curr += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
        <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
        <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

        // For each bucket, rehash to an index:
        // 1) before the cursor, probed into a free slot, or
        // 2) equal to the cursor, no need to move, or
        // 3) ahead of the cursor, probing over already rehashed

        </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
            (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
        {
            idx = (idx + <span class="tok-number">1</span>) &amp; mask;
        }

        <span class="tok-kw">if</span> (idx &lt; curr) {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
            metadata[idx].fill(fingerprint);
            keys_ptr[idx] = keys_ptr[curr];
            values_ptr[idx] = values_ptr[curr];

            metadata[curr].used = <span class="tok-number">0</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
            keys_ptr[curr] = <span class="tok-null">undefined</span>;
            values_ptr[curr] = <span class="tok-null">undefined</span>;

            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
            metadata[idx].fingerprint = fingerprint;
            curr += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
            metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
            } <span class="tok-kw">else</span> {
                metadata[idx].used = <span class="tok-number">1</span>;
                keys_ptr[idx] = keys_ptr[curr];
                values_ptr[idx] = values_ptr[curr];

                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                metadata[curr].used = <span class="tok-number">0</span>;
                keys_ptr[curr] = <span class="tok-null">undefined</span>;
                values_ptr[curr] = <span class="tok-null">undefined</span>;

                curr += <span class="tok-number">1</span>;
            }
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.HashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">HashMapUnmanaged</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> max_load_percentage: <span class="tok-type">u64</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (max_load_percentage &lt;= <span class="tok-number">0</span> <span class="tok-kw">or</span> max_load_percentage &gt;= <span class="tok-number">100</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;max_load_percentage must be between 0 and 100.&quot;</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // This is actually a midway pointer to the single buffer containing
        // a `Header` field, the `Metadata`s and `Entry`s.
        // At `-@sizeOf(Header)` is the Header field.
        // At `sizeOf(Metadata) * capacity + offset`, which is pointed to by
        // self.header().entries, is the array of entries.
        // This means that the hashmap only holds one live allocation, to
        // reduce memory fragmentation and struct size.
        </span><span class="tok-comment">/// Pointer to the metadata.</span>
        metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span>,

        <span class="tok-comment">/// Current number of elements in the hashmap.</span>
        size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,<span class="tok-comment">

        // Having a countdown to grow reduces the number of instructions to
        // execute when determining if the hashmap has enough capacity already.
        </span><span class="tok-comment">/// Number of available slots before a grow is needed to satisfy the</span>
        <span class="tok-comment">/// `max_load_percentage`.</span>
        available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,

        <span class="tok-comment">/// Used to detect memory safety violations.</span>
        pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{},<span class="tok-comment">

        // This is purely empirical and not a /very smart magic constant™/.
        </span><span class="tok-comment">/// Capacity of the first grow when bootstrapping the hashmap.</span>
        <span class="tok-kw">const</span> minimal_capacity = <span class="tok-number">8</span>;

        <span class="tok-comment">/// A map containing no keys or values.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
            .metadata = <span class="tok-null">null</span>,
            .size = <span class="tok-number">0</span>,
            .available = <span class="tok-number">0</span>,
        };<span class="tok-comment">

        // This hashmap is specially designed for sizes that fit in a u32.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span>;<span class="tok-comment">

        // u64 hashes guarantee us that the fingerprint bits will never be used
        // to compute the index of a slot, maximizing the use of entropy.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <span class="tok-kw">struct</span> {
            key: K,
            value: V,
        };

        <span class="tok-kw">const</span> Header = <span class="tok-kw">struct</span> {
            values: [*]V,
            keys: [*]K,
            capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>,
        };

        <span class="tok-comment">/// Metadata for a slot. It can be in three states: empty, used or</span>
        <span class="tok-comment">/// tombstone. Tombstones indicate that an entry was previously used,</span>
        <span class="tok-comment">/// they are a simple way to handle removal.</span>
        <span class="tok-comment">/// To this state, we add 7 bits from the slot's key hash. These are</span>
        <span class="tok-comment">/// used as a fast way to disambiguate between entries without</span>
        <span class="tok-comment">/// having to use the equality function. If two fingerprints are</span>
        <span class="tok-comment">/// different, we know that we don't have to compare the keys at all.</span>
        <span class="tok-comment">/// The 7 bits are the highest ones from a 64 bit hash. This way, not</span>
        <span class="tok-comment">/// only we use the `log2(capacity)` lowest bits from the hash to determine</span>
        <span class="tok-comment">/// a slot index, but we use 7 more bits to quickly resolve collisions</span>
        <span class="tok-comment">/// when multiple elements with different hashes end up wanting to be in the same slot.</span>
        <span class="tok-comment">/// Not using the equality function means we don't have to read into</span>
        <span class="tok-comment">/// the entries array, likely avoiding a cache miss and a potentially</span>
        <span class="tok-comment">/// costly function call.</span>
        <span class="tok-kw">const</span> Metadata = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">const</span> FingerPrint = <span class="tok-type">u7</span>;

            <span class="tok-kw">const</span> free: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> tombstone: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <span class="tok-number">1</span>;

            fingerprint: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>,
            used: <span class="tok-type">u1</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">const</span> slot_free = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>{ .fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a> }));
            <span class="tok-kw">const</span> slot_tombstone = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>{ .fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a> }));

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isUsed</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> self.used == <span class="tok-number">1</span>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isTombstone</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(self)) == <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.slot_tombstone">slot_tombstone</a>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isFree</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(self)) == <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.slot_free">slot_free</a>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">takeFingerprint</span>(hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a>) <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> {
                <span class="tok-kw">const</span> hash_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a>).int.bits;
                <span class="tok-kw">const</span> fp_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>).int.bits;
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>, <span class="tok-builtin">@truncate</span>(hash &gt;&gt; (hash_bits - fp_bits)));
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fill</span>(self: *<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>, fp: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>) <span class="tok-type">void</span> {
                self.used = <span class="tok-number">1</span>;
                self.fingerprint = fp;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">void</span> {
                self.used = <span class="tok-number">0</span>;
                self.fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            }
        };

        <span class="tok-kw">comptime</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            hm: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>,
            index: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
                <a href="std.debug.html#std.debug.assert">assert</a>(it.index &lt;= it.hm.capacity());
                <span class="tok-kw">if</span> (it.hm.size == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                <span class="tok-kw">const</span> cap = it.hm.capacity();
                <span class="tok-kw">const</span> end = it.hm.metadata.? + cap;
                <span class="tok-kw">var</span> metadata = it.hm.metadata.? + it.index;

                <span class="tok-kw">while</span> (metadata != end) : ({
                    metadata += <span class="tok-number">1</span>;
                    it.index += <span class="tok-number">1</span>;
                }) {
                    <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
                        <span class="tok-kw">const</span> key = &amp;it.hm.keys()[it.index];
                        <span class="tok-kw">const</span> value = &amp;it.hm.values()[it.index];
                        it.index += <span class="tok-number">1</span>;
                        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = key, .value_ptr = value };
                    }
                }

                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V);

        <span class="tok-kw">fn</span> <span class="tok-fn">FieldIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
                len: <span class="tok-type">usize</span>,
                metadata: [*]<span class="tok-kw">const</span> <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>,
                items: [*]T,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) ?*T {
                    <span class="tok-kw">while</span> (self.len &gt; <span class="tok-number">0</span>) {
                        self.len -= <span class="tok-number">1</span>;
                        <span class="tok-kw">const</span> used = self.metadata[<span class="tok-number">0</span>].isUsed();
                        <span class="tok-kw">const</span> item = &amp;self.items[<span class="tok-number">0</span>];
                        self.metadata += <span class="tok-number">1</span>;
                        self.items += <span class="tok-number">1</span>;
                        <span class="tok-kw">if</span> (used) {
                            <span class="tok-kw">return</span> item;
                        }
                    }
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
            found_existing: <span class="tok-type">bool</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage);

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = self,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.unlock();
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">isUnderMaxLoadPercentage</span>(size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, cap: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> size * <span class="tok-number">100</span> &lt; max_load_percentage * cap;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.assertUnlocked();
            self.deallocate(allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">capacityForSize</span>(size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">var</span> new_cap: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, size) * <span class="tok-number">100</span>) / max_load_percentage + <span class="tok-number">1</span>);
            new_cap = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwo">ceilPowerOfTwo</a>(<span class="tok-type">u32</span>, new_cap) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> new_cap;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            <span class="tok-kw">if</span> (new_size &gt; self.size)
                <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            <span class="tok-kw">if</span> (self.metadata) |_| {
                self.initMetadatas();
                self.size = <span class="tok-number">0</span>;
                self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            self.deallocate(allocator);
            self.size = <span class="tok-number">0</span>;
            self.available = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">return</span> self.size;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">header</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) *<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@as</span>([*]<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(self.metadata.?))) - <span class="tok-number">1</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) [*]K {
            <span class="tok-kw">return</span> self.header().keys;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) [*]V {
            <span class="tok-kw">return</span> self.header().values;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

            <span class="tok-kw">return</span> self.header().capacity;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{ .hm = self };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
            <span class="tok-kw">if</span> (self.metadata) |metadata| {
                <span class="tok-kw">return</span> .{
                    .len = self.capacity(),
                    .metadata = metadata,
                    .items = self.keys(),
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{
                    .len = <span class="tok-number">0</span>,
                    .metadata = <span class="tok-null">undefined</span>,
                    .items = <span class="tok-null">undefined</span>,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
            <span class="tok-kw">if</span> (self.metadata) |metadata| {
                <span class="tok-kw">return</span> .{
                    .len = self.capacity(),
                    .metadata = metadata,
                    .items = self.values(),
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{
                    .len = <span class="tok-number">0</span>,
                    .metadata = <span class="tok-null">undefined</span>,
                    .items = <span class="tok-null">undefined</span>,
                };
            }
        }

        <span class="tok-comment">/// Insert an entry in the map. Assumes it is not already present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            {
                self.pointer_stability.lock();
                <span class="tok-kw">defer</span> self.pointer_stability.unlock();
                <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
            }
            self.putAssumeCapacityNoClobberContext(key, value, ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            gop.value_ptr.* = value;
        }

        <span class="tok-comment">/// Insert an entry in the map. Assumes it is not already present,</span>
        <span class="tok-comment">/// and that no allocation is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

            <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

            <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
            self.available -= <span class="tok-number">1</span>;

            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
            metadata[<span class="tok-number">0</span>].fill(fingerprint);
            self.keys()[idx] = key;
            self.values()[idx] = value;

            self.size += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
                <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
                <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = old_key.*,
                    .value = old_val.*,
                };
                self.metadata.?[idx].remove();
                old_key.* = <span class="tok-null">undefined</span>;
                old_val.* = <span class="tok-null">undefined</span>;
                self.size -= <span class="tok-number">1</span>;
                self.available += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Find the index containing the data for the given key.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>) {<span class="tok-comment">
                // We use cold instead of unlikely to force a jump to this case,
                // no matter the weight of the opposing side.
                </span><span class="tok-builtin">@branchHint</span>(.cold);
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }<span class="tok-comment">

            // If you get a compile error on this line, it means that your generic hash
            // function is invalid for these parameters.
            </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);<span class="tok-comment">
            // Don't loop indefinitely when there are no empty slots.
            </span><span class="tok-kw">var</span> limit = self.capacity();
            <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

            <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
                    <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];

                    <span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                        <span class="tok-kw">return</span> idx;
                    }
                }

                limit -= <span class="tok-number">1</span>;
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
                    .key_ptr = &amp;self.keys()[idx],
                    .value_ptr = &amp;self.values()[idx],
                };
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Insert an entry if the associated key is not already present, otherwise update preexisting value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Get an optional pointer to the actual key associated with adapted key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
            <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> &amp;self.keys()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get a copy of the actual key associated with adapted key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
            <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> self.keys()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get an optional pointer to the value associated with key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
            <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> &amp;self.values()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get a copy of the value associated with key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
            <span class="tok-kw">return</span> self.getAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> self.values()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            {
                self.pointer_stability.lock();
                <span class="tok-kw">defer</span> self.pointer_stability.unlock();
                self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
                    // If allocation fails, try to do the lookup anyway.
                    // If we find an existing item, we can return it.
                    // Otherwise return the error, we could not add another.
                    </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                        .key_ptr = &amp;self.keys()[index],
                        .value_ptr = &amp;self.values()[index],
                        .found_existing = <span class="tok-null">true</span>,
                    };
                };
            }
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
            <span class="tok-kw">if</span> (!result.found_existing) {
                result.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> result;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

            // If you get a compile error on this line, it means that your generic hash
            // function is invalid for these parameters.
            </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
            <span class="tok-kw">var</span> limit = self.capacity();
            <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

            <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
            </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
                    <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
                    // If you get a compile error on this line, it means that your generic eql
                    // function is invalid for these parameters.

                    </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                            .key_ptr = test_key,
                            .value_ptr = &amp;self.values()[idx],
                            .found_existing = <span class="tok-null">true</span>,
                        };
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
                    first_tombstone_idx = idx;
                }

                limit -= <span class="tok-number">1</span>;
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
                // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
                </span>idx = first_tombstone_idx;
                metadata = self.metadata.? + idx;
            }<span class="tok-comment">
            // We're using a slot previously free or a tombstone.
            </span>self.available -= <span class="tok-number">1</span>;

            metadata[<span class="tok-number">0</span>].fill(fingerprint);
            <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
            <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
            new_key.* = <span class="tok-null">undefined</span>;
            new_value.* = <span class="tok-null">undefined</span>;
            self.size += <span class="tok-number">1</span>;

            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = new_key,
                .value_ptr = new_value,
                .found_existing = <span class="tok-null">false</span>,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
            <span class="tok-kw">if</span> (!res.found_existing) {
                res.key_ptr.* = key;
                res.value_ptr.* = value;
            }
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
        }

        <span class="tok-comment">/// Return true if there is a value associated with key in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndex</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, idx: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.metadata.?[idx].remove();
            self.keys()[idx] = <span class="tok-null">undefined</span>;
            self.values()[idx] = <span class="tok-null">undefined</span>;
            self.size -= <span class="tok-number">1</span>;
            self.available += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and this function returns true.  Otherwise this</span>
        <span class="tok-comment">/// function returns false.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                self.removeByIndex(idx);
                <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            }

            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }

        <span class="tok-comment">/// Delete the entry with key pointed to by key_ptr from the hash map.</span>
        <span class="tok-comment">/// key_ptr is assumed to be a valid pointer to a key that is present</span>
        <span class="tok-comment">/// in the hash map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
            // TODO: replace with pointer subtraction once supported by zig
            // if @sizeOf(K) == 0 then there is at most one item in the hash
            // map, which is assumed to exist as key_ptr must be valid.  This
            // item must be at index 0.
            </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
                (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
            <span class="tok-kw">else</span>
                <span class="tok-number">0</span>;

            self.removeByIndex(idx);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">initMetadatas</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-builtin">@memset</span>(<span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(self.metadata.?))[<span class="tok-number">0</span> .. <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) * self.capacity()], <span class="tok-number">0</span>);
        }<span class="tok-comment">

        // This counts the number of occupied slots (not counting tombstones), which is
        // what has to stay under the max_load_percentage of capacity.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">load</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">const</span> max_load = (self.capacity() * max_load_percentage) / <span class="tok-number">100</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(max_load &gt;= self.available);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, <span class="tok-builtin">@truncate</span>(max_load - self.available));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">growIfNeeded</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_count: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (new_count &gt; self.available) {
                <span class="tok-kw">try</span> self.grow(allocator, <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.load() + new_count), ctx);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
            <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> other;

            <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
            <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
            other.initMetadatas();
            other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

            <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> metadata = self.metadata.?;
            <span class="tok-kw">const</span> keys_ptr = self.keys();
            <span class="tok-kw">const</span> values_ptr = self.values();
            <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (metadata[i].isUsed()) {
                    other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
                    <span class="tok-kw">if</span> (other.size == self.size)
                        <span class="tok-kw">break</span>;
                }
            }

            <span class="tok-kw">return</span> other;
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
            self.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.* = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Rehash the map, in-place.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Over time, due to the current tombstone-based implementation, a</span>
        <span class="tok-comment">/// HashMap could become fragmented due to the buildup of tombstone</span>
        <span class="tok-comment">/// entries that causes a performance degradation due to excessive</span>
        <span class="tok-comment">/// probing. The kind of pattern that might cause this is a long-lived</span>
        <span class="tok-comment">/// HashMap with repeated inserts and deletes.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// After this function is called, there will be no tombstones in</span>
        <span class="tok-comment">/// the HashMap, each of the entries is rehashed and any existing</span>
        <span class="tok-comment">/// key/value pointers into the HashMap are invalidated.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

            <span class="tok-kw">var</span> metadata = self.metadata.?;
            <span class="tok-kw">var</span> keys_ptr = self.keys();
            <span class="tok-kw">var</span> values_ptr = self.values();
            <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

            // While we are re-hashing every slot, we will use the
            // fingerprint to mark used buckets as being used and either free
            // (needing to be rehashed) or tombstone (already rehashed).

            </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
            }<span class="tok-comment">

            // Now iterate over all the buckets, rehashing them

            </span>curr = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
                <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
                    curr += <span class="tok-number">1</span>;
                    <span class="tok-kw">continue</span>;
                }

                <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
                <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
                <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

                // For each bucket, rehash to an index:
                // 1) before the cursor, probed into a free slot, or
                // 2) equal to the cursor, no need to move, or
                // 3) ahead of the cursor, probing over already rehashed

                </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
                    (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
                {
                    idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                }

                <span class="tok-kw">if</span> (idx &lt; curr) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
                    metadata[idx].fill(fingerprint);
                    keys_ptr[idx] = keys_ptr[curr];
                    values_ptr[idx] = values_ptr[curr];

                    metadata[curr].used = <span class="tok-number">0</span>;
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
                    keys_ptr[curr] = <span class="tok-null">undefined</span>;
                    values_ptr[curr] = <span class="tok-null">undefined</span>;

                    curr += <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
                    metadata[idx].fingerprint = fingerprint;
                    curr += <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
                    metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
                    <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
                    } <span class="tok-kw">else</span> {
                        metadata[idx].used = <span class="tok-number">1</span>;
                        keys_ptr[idx] = keys_ptr[curr];
                        values_ptr[idx] = values_ptr[curr];

                        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                        metadata[curr].used = <span class="tok-number">0</span>;
                        keys_ptr[curr] = <span class="tok-null">undefined</span>;
                        values_ptr[curr] = <span class="tok-null">undefined</span>;

                        curr += <span class="tok-number">1</span>;
                    }
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">grow</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <span class="tok-kw">const</span> new_cap = <span class="tok-builtin">@max</span>(new_capacity, <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.minimal_capacity">minimal_capacity</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(new_cap &gt; self.capacity());
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(new_cap));

            <span class="tok-kw">var</span> map: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{};
            <span class="tok-kw">try</span> map.allocate(allocator, new_cap);
            <span class="tok-kw">errdefer</span> <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;
            map.pointer_stability.lock();
            map.initMetadatas();
            map.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

            <span class="tok-kw">if</span> (self.size != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> old_capacity = self.capacity();
                <span class="tok-kw">for</span> (
                    self.metadata.?[<span class="tok-number">0</span>..old_capacity],
                    self.keys()[<span class="tok-number">0</span>..old_capacity],
                    self.values()[<span class="tok-number">0</span>..old_capacity],
                ) |m, k, v| {
                    <span class="tok-kw">if</span> (!m.isUsed()) <span class="tok-kw">continue</span>;
                    map.putAssumeCapacityNoClobberContext(k, v, ctx);
                    <span class="tok-kw">if</span> (map.size == self.size) <span class="tok-kw">break</span>;
                }
            }

            self.size = <span class="tok-number">0</span>;
            self.pointer_stability = .{};
            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, self, &amp;map);
            map.deinit(allocator);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">allocate</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> header_align = <span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);
            <span class="tok-kw">const</span> key_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(K);
            <span class="tok-kw">const</span> val_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(V) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(V);
            <span class="tok-kw">const</span> max_align = <span class="tok-kw">comptime</span> <span class="tok-builtin">@max</span>(header_align, key_align, val_align);

            <span class="tok-kw">const</span> new_cap: <span class="tok-type">usize</span> = new_capacity;
            <span class="tok-kw">const</span> meta_size = <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>) + new_cap * <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>);
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);

            <span class="tok-kw">const</span> keys_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, meta_size, key_align);
            <span class="tok-kw">const</span> keys_end = keys_start + new_cap * <span class="tok-builtin">@sizeOf</span>(K);

            <span class="tok-kw">const</span> vals_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, keys_end, val_align);
            <span class="tok-kw">const</span> vals_end = vals_start + new_cap * <span class="tok-builtin">@sizeOf</span>(V);

            <span class="tok-kw">const</span> total_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, vals_end, max_align);

            <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> allocator.alignedAlloc(<span class="tok-type">u8</span>, max_align, total_size);
            <span class="tok-kw">const</span> ptr: [*]<span class="tok-type">u8</span> = <span class="tok-builtin">@ptrCast</span>(slice.ptr);

            <span class="tok-kw">const</span> metadata = ptr + <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);

            <span class="tok-kw">const</span> hdr = <span class="tok-builtin">@as</span>(*<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr)));
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>([*]V) != <span class="tok-number">0</span>) {
                hdr.values = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>((ptr + vals_start)));
            }
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>([*]K) != <span class="tok-number">0</span>) {
                hdr.keys = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>((ptr + keys_start)));
            }
            hdr.capacity = new_capacity;
            self.metadata = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(metadata));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">deallocate</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> header_align = <span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);
            <span class="tok-kw">const</span> key_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(K);
            <span class="tok-kw">const</span> val_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(V) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(V);
            <span class="tok-kw">const</span> max_align = <span class="tok-kw">comptime</span> <span class="tok-builtin">@max</span>(header_align, key_align, val_align);

            <span class="tok-kw">const</span> cap: <span class="tok-type">usize</span> = self.capacity();
            <span class="tok-kw">const</span> meta_size = <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>) + cap * <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>);
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);

            <span class="tok-kw">const</span> keys_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, meta_size, key_align);
            <span class="tok-kw">const</span> keys_end = keys_start + cap * <span class="tok-builtin">@sizeOf</span>(K);

            <span class="tok-kw">const</span> vals_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, keys_end, val_align);
            <span class="tok-kw">const</span> vals_end = vals_start + cap * <span class="tok-builtin">@sizeOf</span>(V);

            <span class="tok-kw">const</span> total_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, vals_end, max_align);

            <span class="tok-kw">const</span> slice = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(max_align) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(self.header())))[<span class="tok-number">0</span>..total_size];
            allocator.free(slice);

            self.metadata = <span class="tok-null">null</span>;
            self.available = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// This function is used in the debugger pretty formatters in tools/ to fetch the</span>
        <span class="tok-comment">/// header type to facilitate fancy debug printing for this type.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">dbHelper</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, hdr: *<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, entry: *<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>) <span class="tok-type">void</span> {
            _ = self;
            _ = hdr;
            _ = entry;
        }

        <span class="tok-kw">comptime</span> {
            <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) _ = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a>) {
                .stage2_llvm =&gt; &amp;<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.dbHelper">dbHelper</a>,
                .stage2_x86_64 =&gt; <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>,
                <span class="tok-kw">else</span> =&gt; {},
            };
        }
    };
}</code></pre></details></div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.hash_map.default_max_load_percentage" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">default_max_load_percentage</span><a href="#src.zig-std.hash_map.default_max_load_percentage">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.default_max_load_percentage">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_max_load_percentage = <span class="tok-number">80</span></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.hash_map.getAutoHashFn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAutoHashFn</span><a href="#src.zig-std.hash_map.getAutoHashFn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u64</span>)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.getAutoHashFn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u64</span>) {
    <span class="tok-kw">comptime</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@hasDecl</span>(<a href="std.html">std</a>, <span class="tok-str">&quot;StringHashMap&quot;</span>));<span class="tok-comment"> // detect when the following message needs updated
        </span><span class="tok-kw">if</span> (K == []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.hash.autoHash does not allow slices here (&quot;</span> ++
                <span class="tok-builtin">@typeName</span>(K) ++
                <span class="tok-str">&quot;) because the intent is unclear. &quot;</span> ++
                <span class="tok-str">&quot;Consider using std.StringHashMap for hashing the contents of []const u8. &quot;</span> ++
                <span class="tok-str">&quot;Alternatively, consider using std.hash.autoHashStrat or providing your own hash function instead.&quot;</span>);
        }
    }

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: Context, key: K) <span class="tok-type">u64</span> {
            _ = ctx;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(K)) {
                <span class="tok-kw">return</span> <a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key));
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> hasher = <a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
                <a href="std.hash.auto_hash.html#std.hash.auto_hash.autoHash">autoHash</a>(&amp;hasher, key);
                <span class="tok-kw">return</span> hasher.final();
            }
        }
    }.hash;
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.getAutoEqlFn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAutoEqlFn</span><a href="#src.zig-std.hash_map.getAutoEqlFn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K) <span class="tok-type">bool</span>)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.getAutoEqlFn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K) <span class="tok-type">bool</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: Context, a: K, b: K) <span class="tok-type">bool</span> {
            _ = ctx;
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(a, b);
        }
    }.eql;
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.eqlString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eqlString</span><a href="#src.zig-std.hash_map.eqlString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlString</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.eqlString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlString</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, b);
}</code></pre></details></div></div><div class="decl"><h2 id="std.hash_map.hashString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hashString</span><a href="#src.zig-std.hash_map.hashString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hashString</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.hash_map.hashString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hashString</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, s);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.hash_map">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> autoHash = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.auto_hash.html#std.hash.auto_hash.autoHash">autoHash</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> Wyhash = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u64</span>) {
    <span class="tok-kw">comptime</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@hasDecl</span>(<a href="std.html">std</a>, <span class="tok-str">&quot;StringHashMap&quot;</span>));<span class="tok-comment"> // detect when the following message needs updated
        </span><span class="tok-kw">if</span> (K == []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.hash.autoHash does not allow slices here (&quot;</span> ++
                <span class="tok-builtin">@typeName</span>(K) ++
                <span class="tok-str">&quot;) because the intent is unclear. &quot;</span> ++
                <span class="tok-str">&quot;Consider using std.StringHashMap for hashing the contents of []const u8. &quot;</span> ++
                <span class="tok-str">&quot;Alternatively, consider using std.hash.autoHashStrat or providing your own hash function instead.&quot;</span>);
        }
    }

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: Context, key: K) <span class="tok-type">u64</span> {
            _ = ctx;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(K)) {
                <span class="tok-kw">return</span> <a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key));
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> hasher = <a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
                <a href="std.hash.auto_hash.html#std.hash.auto_hash.autoHash">autoHash</a>(&amp;hasher, key);
                <span class="tok-kw">return</span> hasher.final();
            }
        }
    }.hash;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K) <span class="tok-type">bool</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: Context, a: K, b: K) <span class="tok-type">bool</span> {
            _ = ctx;
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(a, b);
        }
    }.eql;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoHashMap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <a href="std.hash_map.html#std.hash_map.AutoContext">AutoContext</a>(K), <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <a href="std.hash_map.html#std.hash_map.AutoContext">AutoContext</a>(K), <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoContext</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hash = <a href="std.hash_map.html#std.hash_map.getAutoHashFn">getAutoHashFn</a>(K, <span class="tok-builtin">@This</span>());
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> eql = <a href="std.hash_map.html#std.hash_map.getAutoEqlFn">getAutoEqlFn</a>(K, <span class="tok-builtin">@This</span>());
    };
}

<span class="tok-comment">/// Builtin hashmap for strings as keys.</span>
<span class="tok-comment">/// Key memory is managed by the caller.  Keys and values</span>
<span class="tok-comment">/// will not automatically be freed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringHashMap</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.hash_map.StringContext.html">StringContext</a>, <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}

<span class="tok-comment">/// Key memory is managed by the caller.  Keys and values</span>
<span class="tok-comment">/// will not automatically be freed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.hash_map.StringContext.html">StringContext</a>, <a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringContext = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: <span class="tok-builtin">@This</span>(), s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
        _ = self;
        <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.hashString">hashString</a>(s);
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <span class="tok-builtin">@This</span>(), a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
        _ = self;
        <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.eqlString">eqlString</a>(a, b);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlString</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, b);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hashString</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, s);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringIndexContext = <span class="tok-kw">struct</span> {
    bytes: *<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(_: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">u32</span>, b: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> a == b;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: <span class="tok-builtin">@This</span>(), key: <span class="tok-type">u32</span>) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.hashString">hashString</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(ctx.bytes.items[key..], <span class="tok-number">0</span>));
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringIndexAdapter = <span class="tok-kw">struct</span> {
    bytes: *<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(ctx.bytes.items[b..], <span class="tok-number">0</span>));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), adapted_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, adapted_key, <span class="tok-number">0</span>) == <span class="tok-null">null</span>);
        <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.hashString">hashString</a>(adapted_key);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_max_load_percentage = <span class="tok-number">80</span>;

<span class="tok-comment">/// General purpose hash table.</span>
<span class="tok-comment">/// No order is guaranteed and any modification invalidates live iterators.</span>
<span class="tok-comment">/// It provides fast operations (lookup, insertion, deletion) with quite high</span>
<span class="tok-comment">/// load factors (up to 80% by default) for low memory usage.</span>
<span class="tok-comment">/// For a hash map that can be initialized directly that does not store an Allocator</span>
<span class="tok-comment">/// field, see `HashMapUnmanaged`.</span>
<span class="tok-comment">/// If iterating over the table entries is a strong usecase and needs to be fast,</span>
<span class="tok-comment">/// prefer the alternative `std.ArrayHashMap`.</span>
<span class="tok-comment">/// Context must be a struct type with two member functions:</span>
<span class="tok-comment">///   hash(self, K) u64</span>
<span class="tok-comment">///   eql(self, K, K) bool</span>
<span class="tok-comment">/// Adapted variants of many functions are provided.  These variants</span>
<span class="tok-comment">/// take a pseudo key instead of a key.  Their context must have the functions:</span>
<span class="tok-comment">///   hash(self, PseudoKey) u64</span>
<span class="tok-comment">///   eql(self, PseudoKey, K) bool</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">HashMap</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> max_load_percentage: <span class="tok-type">u64</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        unmanaged: <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        ctx: Context,

        <span class="tok-comment">/// The type of the unmanaged hash map underlying this wrapper</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, Context, max_load_percentage);
        <span class="tok-comment">/// An entry, containing pointers to a key and value stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Entry</a>;
        <span class="tok-comment">/// A copy of a key and value which are no longer in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KV</a>;
        <span class="tok-comment">/// The integer type that is the result of hashing</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Hash</a>;
        <span class="tok-comment">/// The iterator type returned by iterator()</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">KeyIterator</a>;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">ValueIterator</a>;

        <span class="tok-comment">/// The integer type used to store the size of the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">Size</a>;
        <span class="tok-comment">/// The type returned from getOrPut and variants</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.hash_map.html#std.hash_map.HashMap.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a>;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Create a managed hash map with an empty context.</span>
        <span class="tok-comment">/// If the context is not zero-sized, you must use</span>
        <span class="tok-comment">/// initContext(allocator, ctx) instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Context must be specified! Call initContext(allocator, ctx) instead.&quot;</span>);
            }
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = <span class="tok-null">undefined</span>,<span class="tok-comment"> // ctx is zero-sized so this is safe.
            </span>};
        }

        <span class="tok-comment">/// Create a managed hash map with a context</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.lockPointers();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.unlockPointers();
        }

        <span class="tok-comment">/// Release the backing array and invalidate this map.</span>
        <span class="tok-comment">/// This does *not* deinit keys, values, or the context!</span>
        <span class="tok-comment">/// If your keys or values need to be released, ensure</span>
        <span class="tok-comment">/// that that is done before calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.deinit(self.allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Empty the map, but keep the backing allocation for future use.</span>
        <span class="tok-comment">/// This does *not* free keys or values! Be sure to</span>
        <span class="tok-comment">/// release them if they need deinitialization before</span>
        <span class="tok-comment">/// calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
        }

        <span class="tok-comment">/// Empty the map and release the backing allocation.</span>
        <span class="tok-comment">/// This does *not* free keys or values! Be sure to</span>
        <span class="tok-comment">/// release them if they need deinitialization before</span>
        <span class="tok-comment">/// calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
        }

        <span class="tok-comment">/// Return the number of items in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
            <span class="tok-kw">return</span> self.unmanaged.count();
        }

        <span class="tok-comment">/// Create an iterator over the entries in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.iterator();
        }

        <span class="tok-comment">/// Create an iterator over the keys in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.KeyIterator">KeyIterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.keyIterator();
        }

        <span class="tok-comment">/// Create an iterator over the values in the map.</span>
        <span class="tok-comment">/// The iterator is invalidated if the map is modified.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.ValueIterator">ValueIterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.valueIterator();
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined key and value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// the key and value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result's</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// the key and value.</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.html#std.hash_map.HashMap.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, expected_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, expected_count, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, additional_count: <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap.Size">Size</a> {
            <span class="tok-kw">return</span> self.unmanaged.capacity();
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K, value: V) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Removes a value from the map and returns the removed kv pair.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchRemoveContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchRemoveAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the value associated with a key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the actual key associated with an adapted key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the key and value associated with a key in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.html#std.hash_map.HashMap.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
        }

        <span class="tok-comment">/// Check if the map contains a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and this function returns true.  Otherwise this</span>
        <span class="tok-comment">/// function returns false.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.removeContext(key, self.ctx);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.removeAdapted(key, ctx);
        }

        <span class="tok-comment">/// Delete the entry with key pointed to by key_ptr from the hash map.</span>
        <span class="tok-comment">/// key_ptr is assumed to be a valid pointer to a key that is present</span>
        <span class="tok-comment">/// in the hash map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {
            self.unmanaged.removeByPtr(key_ptr);
        }

        <span class="tok-comment">/// Creates a copy of this map, using the same allocator</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified allocator</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(new_allocator, self.ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified context</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, new_ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, new_ctx);
        }

        <span class="tok-comment">/// Creates a copy of this map, using a specified allocator and context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(
            self: <a href="std.hash_map.html#std.hash_map.HashMap">Self</a>,
            new_allocator: <a href="std.mem.Allocator.html">Allocator</a>,
            new_ctx: <span class="tok-kw">anytype</span>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(new_allocator, new_ctx);
            <span class="tok-kw">return</span> other.promoteContext(new_allocator, new_ctx);
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMap">Self</a> {
            self.unmanaged.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.unmanaged = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Rehash the map, in-place.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Over time, due to the current tombstone-based implementation, a</span>
        <span class="tok-comment">/// HashMap could become fragmented due to the buildup of tombstone</span>
        <span class="tok-comment">/// entries that causes a performance degradation due to excessive</span>
        <span class="tok-comment">/// probing. The kind of pattern that might cause this is a long-lived</span>
        <span class="tok-comment">/// HashMap with repeated inserts and deletes.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// After this function is called, there will be no tombstones in</span>
        <span class="tok-comment">/// the HashMap, each of the entries is rehashed and any existing</span>
        <span class="tok-comment">/// key/value pointers into the HashMap are invalidated.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMap">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.rehash(self.ctx);
        }
    };
}

<span class="tok-comment">/// A HashMap based on open addressing and linear probing.</span>
<span class="tok-comment">/// A lookup or modification typically incurs only 2 cache misses.</span>
<span class="tok-comment">/// No order is guaranteed and any modification invalidates live iterators.</span>
<span class="tok-comment">/// It achieves good performance with quite high load factors (by default,</span>
<span class="tok-comment">/// grow is triggered at 80% full) and only one byte of overhead per element.</span>
<span class="tok-comment">/// The struct itself is only 16 bytes for a small footprint. This comes at</span>
<span class="tok-comment">/// the price of handling size with u32, which should be reasonable enough</span>
<span class="tok-comment">/// for almost all uses.</span>
<span class="tok-comment">/// Deletions are achieved with tombstones.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Default initialization of this struct is deprecated; use `.empty` instead.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">HashMapUnmanaged</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> max_load_percentage: <span class="tok-type">u64</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">if</span> (max_load_percentage &lt;= <span class="tok-number">0</span> <span class="tok-kw">or</span> max_load_percentage &gt;= <span class="tok-number">100</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;max_load_percentage must be between 0 and 100.&quot;</span>);
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();<span class="tok-comment">

        // This is actually a midway pointer to the single buffer containing
        // a `Header` field, the `Metadata`s and `Entry`s.
        // At `-@sizeOf(Header)` is the Header field.
        // At `sizeOf(Metadata) * capacity + offset`, which is pointed to by
        // self.header().entries, is the array of entries.
        // This means that the hashmap only holds one live allocation, to
        // reduce memory fragmentation and struct size.
        </span><span class="tok-comment">/// Pointer to the metadata.</span>
        metadata: ?[*]<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a> = <span class="tok-null">null</span>,

        <span class="tok-comment">/// Current number of elements in the hashmap.</span>
        size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,<span class="tok-comment">

        // Having a countdown to grow reduces the number of instructions to
        // execute when determining if the hashmap has enough capacity already.
        </span><span class="tok-comment">/// Number of available slots before a grow is needed to satisfy the</span>
        <span class="tok-comment">/// `max_load_percentage`.</span>
        available: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,

        <span class="tok-comment">/// Used to detect memory safety violations.</span>
        pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{},<span class="tok-comment">

        // This is purely empirical and not a /very smart magic constant™/.
        </span><span class="tok-comment">/// Capacity of the first grow when bootstrapping the hashmap.</span>
        <span class="tok-kw">const</span> minimal_capacity = <span class="tok-number">8</span>;

        <span class="tok-comment">/// A map containing no keys or values.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{
            .metadata = <span class="tok-null">null</span>,
            .size = <span class="tok-number">0</span>,
            .available = <span class="tok-number">0</span>,
        };<span class="tok-comment">

        // This hashmap is specially designed for sizes that fit in a u32.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-type">u32</span>;<span class="tok-comment">

        // u64 hashes guarantee us that the fingerprint bits will never be used
        // to compute the index of a slot, maximizing the use of entropy.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-type">u64</span>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <span class="tok-kw">struct</span> {
            key: K,
            value: V,
        };

        <span class="tok-kw">const</span> Header = <span class="tok-kw">struct</span> {
            values: [*]V,
            keys: [*]K,
            capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>,
        };

        <span class="tok-comment">/// Metadata for a slot. It can be in three states: empty, used or</span>
        <span class="tok-comment">/// tombstone. Tombstones indicate that an entry was previously used,</span>
        <span class="tok-comment">/// they are a simple way to handle removal.</span>
        <span class="tok-comment">/// To this state, we add 7 bits from the slot's key hash. These are</span>
        <span class="tok-comment">/// used as a fast way to disambiguate between entries without</span>
        <span class="tok-comment">/// having to use the equality function. If two fingerprints are</span>
        <span class="tok-comment">/// different, we know that we don't have to compare the keys at all.</span>
        <span class="tok-comment">/// The 7 bits are the highest ones from a 64 bit hash. This way, not</span>
        <span class="tok-comment">/// only we use the `log2(capacity)` lowest bits from the hash to determine</span>
        <span class="tok-comment">/// a slot index, but we use 7 more bits to quickly resolve collisions</span>
        <span class="tok-comment">/// when multiple elements with different hashes end up wanting to be in the same slot.</span>
        <span class="tok-comment">/// Not using the equality function means we don't have to read into</span>
        <span class="tok-comment">/// the entries array, likely avoiding a cache miss and a potentially</span>
        <span class="tok-comment">/// costly function call.</span>
        <span class="tok-kw">const</span> Metadata = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            <span class="tok-kw">const</span> FingerPrint = <span class="tok-type">u7</span>;

            <span class="tok-kw">const</span> free: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> tombstone: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <span class="tok-number">1</span>;

            fingerprint: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>,
            used: <span class="tok-type">u1</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">const</span> slot_free = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>{ .fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a> }));
            <span class="tok-kw">const</span> slot_tombstone = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>{ .fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a> }));

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isUsed</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> self.used == <span class="tok-number">1</span>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isTombstone</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(self)) == <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.slot_tombstone">slot_tombstone</a>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isFree</span>(self: <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(self)) == <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.slot_free">slot_free</a>;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">takeFingerprint</span>(hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a>) <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a> {
                <span class="tok-kw">const</span> hash_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a>).int.bits;
                <span class="tok-kw">const</span> fp_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>).int.bits;
                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>, <span class="tok-builtin">@truncate</span>(hash &gt;&gt; (hash_bits - fp_bits)));
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fill</span>(self: *<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>, fp: <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.FingerPrint">FingerPrint</a>) <span class="tok-type">void</span> {
                self.used = <span class="tok-number">1</span>;
                self.fingerprint = fp;
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) <span class="tok-type">void</span> {
                self.used = <span class="tok-number">0</span>;
                self.fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
            }
        };

        <span class="tok-kw">comptime</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            hm: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>,
            index: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
                <a href="std.debug.html#std.debug.assert">assert</a>(it.index &lt;= it.hm.capacity());
                <span class="tok-kw">if</span> (it.hm.size == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                <span class="tok-kw">const</span> cap = it.hm.capacity();
                <span class="tok-kw">const</span> end = it.hm.metadata.? + cap;
                <span class="tok-kw">var</span> metadata = it.hm.metadata.? + it.index;

                <span class="tok-kw">while</span> (metadata != end) : ({
                    metadata += <span class="tok-number">1</span>;
                    it.index += <span class="tok-number">1</span>;
                }) {
                    <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
                        <span class="tok-kw">const</span> key = &amp;it.hm.keys()[it.index];
                        <span class="tok-kw">const</span> value = &amp;it.hm.values()[it.index];
                        it.index += <span class="tok-number">1</span>;
                        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = key, .value_ptr = value };
                    }
                }

                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(K);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValueIterator = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.FieldIterator">FieldIterator</a>(V);

        <span class="tok-kw">fn</span> <span class="tok-fn">FieldIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
                len: <span class="tok-type">usize</span>,
                metadata: [*]<span class="tok-kw">const</span> <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>,
                items: [*]T,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) ?*T {
                    <span class="tok-kw">while</span> (self.len &gt; <span class="tok-number">0</span>) {
                        self.len -= <span class="tok-number">1</span>;
                        <span class="tok-kw">const</span> used = self.metadata[<span class="tok-number">0</span>].isUsed();
                        <span class="tok-kw">const</span> item = &amp;self.items[<span class="tok-number">0</span>];
                        self.metadata += <span class="tok-number">1</span>;
                        self.items += <span class="tok-number">1</span>;
                        <span class="tok-kw">if</span> (used) {
                            <span class="tok-kw">return</span> item;
                        }
                    }
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
            found_existing: <span class="tok-type">bool</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(K, V, Context, max_load_percentage);

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.promoteContext">promoteContext</a>(self, allocator, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = self,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.unlock();
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">isUnderMaxLoadPercentage</span>(size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, cap: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> size * <span class="tok-number">100</span> &lt; max_load_percentage * cap;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.assertUnlocked();
            self.deallocate(allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">capacityForSize</span>(size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">var</span> new_cap: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, size) * <span class="tok-number">100</span>) / max_load_percentage + <span class="tok-number">1</span>);
            new_cap = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwo">ceilPowerOfTwo</a>(<span class="tok-type">u32</span>, new_cap) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> new_cap;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, new_size, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            <span class="tok-kw">if</span> (new_size &gt; self.size)
                <span class="tok-kw">try</span> self.growIfNeeded(allocator, new_size - self.size, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureUnusedCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext">ensureUnusedCapacityContext</a>(self, allocator, additional_size, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, additional_size: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext">ensureTotalCapacityContext</a>(self, allocator, self.count() + additional_size, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            <span class="tok-kw">if</span> (self.metadata) |_| {
                self.initMetadatas();
                self.size = <span class="tok-number">0</span>;
                self.available = <span class="tok-builtin">@truncate</span>((self.capacity() * max_load_percentage) / <span class="tok-number">100</span>);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();
            self.deallocate(allocator);
            self.size = <span class="tok-number">0</span>;
            self.available = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">return</span> self.size;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">header</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) *<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@as</span>([*]<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(self.metadata.?))) - <span class="tok-number">1</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) [*]K {
            <span class="tok-kw">return</span> self.header().keys;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) [*]V {
            <span class="tok-kw">return</span> self.header().values;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

            <span class="tok-kw">return</span> self.header().capacity;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.HashMapUnmanaged.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{ .hm = self };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keyIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.KeyIterator">KeyIterator</a> {
            <span class="tok-kw">if</span> (self.metadata) |metadata| {
                <span class="tok-kw">return</span> .{
                    .len = self.capacity(),
                    .metadata = metadata,
                    .items = self.keys(),
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{
                    .len = <span class="tok-number">0</span>,
                    .metadata = <span class="tok-null">undefined</span>,
                    .items = <span class="tok-null">undefined</span>,
                };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIterator</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.ValueIterator">ValueIterator</a> {
            <span class="tok-kw">if</span> (self.metadata) |metadata| {
                <span class="tok-kw">return</span> .{
                    .len = self.capacity(),
                    .metadata = metadata,
                    .items = self.values(),
                };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{
                    .len = <span class="tok-number">0</span>,
                    .metadata = <span class="tok-null">undefined</span>,
                    .items = <span class="tok-null">undefined</span>,
                };
            }
        }

        <span class="tok-comment">/// Insert an entry in the map. Assumes it is not already present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putNoClobberContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            {
                self.pointer_stability.lock();
                <span class="tok-kw">defer</span> self.pointer_stability.unlock();
                <span class="tok-kw">try</span> self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx);
            }
            self.putAssumeCapacityNoClobberContext(key, value, ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            gop.value_ptr.* = value;
        }

        <span class="tok-comment">/// Insert an entry in the map. Assumes it is not already present,</span>
        <span class="tok-comment">/// and that no allocation is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(!self.containsContext(key, ctx));

            <span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);
            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(hash &amp; mask);

            <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (metadata[<span class="tok-number">0</span>].isUsed()) {
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <a href="std.debug.html#std.debug.assert">assert</a>(self.available &gt; <span class="tok-number">0</span>);
            self.available -= <span class="tok-number">1</span>;

            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
            metadata[<span class="tok-number">0</span>].fill(fingerprint);
            self.keys()[idx] = key;
            self.values()[idx] = value;

            self.size += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchRemoveAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">const</span> old_key = &amp;self.keys()[idx];
                <span class="tok-kw">const</span> old_val = &amp;self.values()[idx];
                <span class="tok-kw">const</span> result = <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>{
                    .key = old_key.*,
                    .value = old_val.*,
                };
                self.metadata.?[idx].remove();
                old_key.* = <span class="tok-null">undefined</span>;
                old_val.* = <span class="tok-null">undefined</span>;
                self.size -= <span class="tok-number">1</span>;
                self.available += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Find the index containing the data for the given key.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>) {<span class="tok-comment">
                // We use cold instead of unlikely to force a jump to this case,
                // no matter the weight of the opposing side.
                </span><span class="tok-builtin">@branchHint</span>(.cold);
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }<span class="tok-comment">

            // If you get a compile error on this line, it means that your generic hash
            // function is invalid for these parameters.
            </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);<span class="tok-comment">
            // Don't loop indefinitely when there are no empty slots.
            </span><span class="tok-kw">var</span> limit = self.capacity();
            <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

            <span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
                    <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];

                    <span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                        <span class="tok-kw">return</span> idx;
                    }
                }

                limit -= <span class="tok-number">1</span>;
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{
                    .key_ptr = &amp;self.keys()[idx],
                    .value_ptr = &amp;self.values()[idx],
                };
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Insert an entry if the associated key is not already present, otherwise update preexisting value.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(allocator, key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Get an optional pointer to the actual key associated with adapted key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
            <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> &amp;self.keys()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get a copy of the actual key associated with adapted key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
            <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> self.keys()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get an optional pointer to the value associated with key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?*V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
            <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> &amp;self.values()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// Get a copy of the value associated with key, if present.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) ?V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
            <span class="tok-kw">return</span> self.getAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                <span class="tok-kw">return</span> self.values()[idx];
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContext(allocator, key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(allocator, key, ctx, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContextAdapted(allocator, key, key_ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            {
                self.pointer_stability.lock();
                <span class="tok-kw">defer</span> self.pointer_stability.unlock();
                self.growIfNeeded(allocator, <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
                    // If allocation fails, try to do the lookup anyway.
                    // If we find an existing item, we can return it.
                    // Otherwise return the error, we could not add another.
                    </span><span class="tok-kw">const</span> index = self.getIndex(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                    <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                        .key_ptr = &amp;self.keys()[index],
                        .value_ptr = &amp;self.values()[index],
                        .found_existing = <span class="tok-null">true</span>,
                    };
                };
            }
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityAdapted(key, ctx);
            <span class="tok-kw">if</span> (!result.found_existing) {
                result.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> result;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {<span class="tok-comment">

            // If you get a compile error on this line, it means that your generic hash
            // function is invalid for these parameters.
            </span><span class="tok-kw">const</span> hash: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Hash">Hash</a> = ctx.hash(key);

            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
            <span class="tok-kw">var</span> limit = self.capacity();
            <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));

            <span class="tok-kw">var</span> first_tombstone_idx: <span class="tok-type">usize</span> = self.capacity();<span class="tok-comment"> // invalid index
            </span><span class="tok-kw">var</span> metadata = self.metadata.? + idx;
            <span class="tok-kw">while</span> (!metadata[<span class="tok-number">0</span>].isFree() <span class="tok-kw">and</span> limit != <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (metadata[<span class="tok-number">0</span>].isUsed() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].fingerprint == fingerprint) {
                    <span class="tok-kw">const</span> test_key = &amp;self.keys()[idx];<span class="tok-comment">
                    // If you get a compile error on this line, it means that your generic eql
                    // function is invalid for these parameters.

                    </span><span class="tok-kw">if</span> (ctx.eql(key, test_key.*)) {
                        <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                            .key_ptr = test_key,
                            .value_ptr = &amp;self.values()[idx],
                            .found_existing = <span class="tok-null">true</span>,
                        };
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_tombstone_idx == self.capacity() <span class="tok-kw">and</span> metadata[<span class="tok-number">0</span>].isTombstone()) {
                    first_tombstone_idx = idx;
                }

                limit -= <span class="tok-number">1</span>;
                idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                metadata = self.metadata.? + idx;
            }

            <span class="tok-kw">if</span> (first_tombstone_idx &lt; self.capacity()) {<span class="tok-comment">
                // Cheap try to lower probing lengths after deletions. Recycle a tombstone.
                </span>idx = first_tombstone_idx;
                metadata = self.metadata.? + idx;
            }<span class="tok-comment">
            // We're using a slot previously free or a tombstone.
            </span>self.available -= <span class="tok-number">1</span>;

            metadata[<span class="tok-number">0</span>].fill(fingerprint);
            <span class="tok-kw">const</span> new_key = &amp;self.keys()[idx];
            <span class="tok-kw">const</span> new_value = &amp;self.values()[idx];
            new_key.* = <span class="tok-null">undefined</span>;
            new_value.* = <span class="tok-null">undefined</span>;
            self.size += <span class="tok-number">1</span>;

            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                .key_ptr = new_key,
                .value_ptr = new_value,
                .found_existing = <span class="tok-null">false</span>,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutValueContext(allocator, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutAdapted(allocator, key, ctx);
            <span class="tok-kw">if</span> (!res.found_existing) {
                res.key_ptr.* = key;
                res.value_ptr.* = value;
            }
            <span class="tok-kw">return</span> <a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>{ .key_ptr = res.key_ptr, .value_ptr = res.value_ptr };
        }

        <span class="tok-comment">/// Return true if there is a value associated with key in the map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.getIndex(key, ctx) != <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndex</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, idx: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.metadata.?[idx].remove();
            self.keys()[idx] = <span class="tok-null">undefined</span>;
            self.values()[idx] = <span class="tok-null">undefined</span>;
            self.size -= <span class="tok-number">1</span>;
            self.available += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and this function returns true.  Otherwise this</span>
        <span class="tok-comment">/// function returns false.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call removeContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.removeContext(key, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeContext</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.removeAdapted(key, ctx);
        }

        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeAdapted</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (self.getIndex(key, ctx)) |idx| {
                self.removeByIndex(idx);
                <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            }

            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }

        <span class="tok-comment">/// Delete the entry with key pointed to by key_ptr from the hash map.</span>
        <span class="tok-comment">/// key_ptr is assumed to be a valid pointer to a key that is present</span>
        <span class="tok-comment">/// in the hash map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// TODO: answer the question in these doc comments, does this</span>
        <span class="tok-comment">/// increase the unused capacity by one?</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeByPtr</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, key_ptr: *K) <span class="tok-type">void</span> {<span class="tok-comment">
            // TODO: replace with pointer subtraction once supported by zig
            // if @sizeOf(K) == 0 then there is at most one item in the hash
            // map, which is assumed to exist as key_ptr must be valid.  This
            // item must be at index 0.
            </span><span class="tok-kw">const</span> idx = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) &gt; <span class="tok-number">0</span>)
                (<span class="tok-builtin">@intFromPtr</span>(key_ptr) - <span class="tok-builtin">@intFromPtr</span>(self.keys())) / <span class="tok-builtin">@sizeOf</span>(K)
            <span class="tok-kw">else</span>
                <span class="tok-number">0</span>;

            self.removeByIndex(idx);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">initMetadatas</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-builtin">@memset</span>(<span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(self.metadata.?))[<span class="tok-number">0</span> .. <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) * self.capacity()], <span class="tok-number">0</span>);
        }<span class="tok-comment">

        // This counts the number of occupied slots (not counting tombstones), which is
        // what has to stay under the max_load_percentage of capacity.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">load</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> {
            <span class="tok-kw">const</span> max_load = (self.capacity() * max_load_percentage) / <span class="tok-number">100</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(max_load &gt;= self.available);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, <span class="tok-builtin">@truncate</span>(max_load - self.available));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">growIfNeeded</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_count: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (new_count &gt; self.available) {
                <span class="tok-kw">try</span> self.grow(allocator, <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.load() + new_count), ctx);
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.cloneContext(allocator, <span class="tok-builtin">@as</span>(Context, <span class="tok-null">undefined</span>));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) {
            <span class="tok-kw">var</span> other: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(K, V, <span class="tok-builtin">@TypeOf</span>(new_ctx), max_load_percentage) = .empty;
            <span class="tok-kw">if</span> (self.size == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> other;

            <span class="tok-kw">const</span> new_cap = <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.capacityForSize">capacityForSize</a>(self.size);
            <span class="tok-kw">try</span> other.allocate(allocator, new_cap);
            other.initMetadatas();
            other.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

            <span class="tok-kw">var</span> i: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> metadata = self.metadata.?;
            <span class="tok-kw">const</span> keys_ptr = self.keys();
            <span class="tok-kw">const</span> values_ptr = self.values();
            <span class="tok-kw">while</span> (i &lt; self.capacity()) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (metadata[i].isUsed()) {
                    other.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], new_ctx);
                    <span class="tok-kw">if</span> (other.size == self.size)
                        <span class="tok-kw">break</span>;
                }
            }

            <span class="tok-kw">return</span> other;
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>) <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> {
            self.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.* = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Rehash the map, in-place.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Over time, due to the current tombstone-based implementation, a</span>
        <span class="tok-comment">/// HashMap could become fragmented due to the buildup of tombstone</span>
        <span class="tok-comment">/// entries that causes a performance degradation due to excessive</span>
        <span class="tok-comment">/// probing. The kind of pattern that might cause this is a long-lived</span>
        <span class="tok-comment">/// HashMap with repeated inserts and deletes.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// After this function is called, there will be no tombstones in</span>
        <span class="tok-comment">/// the HashMap, each of the entries is rehashed and any existing</span>
        <span class="tok-comment">/// key/value pointers into the HashMap are invalidated.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rehash</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> mask = self.capacity() - <span class="tok-number">1</span>;

            <span class="tok-kw">var</span> metadata = self.metadata.?;
            <span class="tok-kw">var</span> keys_ptr = self.keys();
            <span class="tok-kw">var</span> values_ptr = self.values();
            <span class="tok-kw">var</span> curr: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a> = <span class="tok-number">0</span>;<span class="tok-comment">

            // While we are re-hashing every slot, we will use the
            // fingerprint to mark used buckets as being used and either free
            // (needing to be rehashed) or tombstone (already rehashed).

            </span><span class="tok-kw">while</span> (curr &lt; self.capacity()) : (curr += <span class="tok-number">1</span>) {
                metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
            }<span class="tok-comment">

            // Now iterate over all the buckets, rehashing them

            </span>curr = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (curr &lt; self.capacity()) {
                <span class="tok-kw">if</span> (!metadata[curr].isUsed()) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
                    curr += <span class="tok-number">1</span>;
                    <span class="tok-kw">continue</span>;
                }

                <span class="tok-kw">const</span> hash = ctx.hash(keys_ptr[curr]);
                <span class="tok-kw">const</span> fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.takeFingerprint">takeFingerprint</a>(hash);
                <span class="tok-kw">var</span> idx = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(hash &amp; mask));<span class="tok-comment">

                // For each bucket, rehash to an index:
                // 1) before the cursor, probed into a free slot, or
                // 2) equal to the cursor, no need to move, or
                // 3) ahead of the cursor, probing over already rehashed

                </span><span class="tok-kw">while</span> ((idx &lt; curr <span class="tok-kw">and</span> metadata[idx].isUsed()) <span class="tok-kw">or</span>
                    (idx &gt; curr <span class="tok-kw">and</span> metadata[idx].fingerprint == <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>))
                {
                    idx = (idx + <span class="tok-number">1</span>) &amp; mask;
                }

                <span class="tok-kw">if</span> (idx &lt; curr) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].isFree());
                    metadata[idx].fill(fingerprint);
                    keys_ptr[idx] = keys_ptr[curr];
                    values_ptr[idx] = values_ptr[curr];

                    metadata[curr].used = <span class="tok-number">0</span>;
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[curr].isFree());
                    keys_ptr[curr] = <span class="tok-null">undefined</span>;
                    values_ptr[curr] = <span class="tok-null">undefined</span>;

                    curr += <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (idx == curr) {
                    metadata[idx].fingerprint = fingerprint;
                    curr += <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> {
                    <a href="std.debug.html#std.debug.assert">assert</a>(metadata[idx].fingerprint != <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>);
                    metadata[idx].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.tombstone">tombstone</a>;
                    <span class="tok-kw">if</span> (metadata[idx].isUsed()) {
                        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(K, &amp;keys_ptr[curr], &amp;keys_ptr[idx]);
                        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(V, &amp;values_ptr[curr], &amp;values_ptr[idx]);
                    } <span class="tok-kw">else</span> {
                        metadata[idx].used = <span class="tok-number">1</span>;
                        keys_ptr[idx] = keys_ptr[curr];
                        values_ptr[idx] = values_ptr[curr];

                        metadata[curr].fingerprint = <a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>.<a href="std.hash_map.HashMapUnmanaged.Metadata.html#std.hash_map.HashMapUnmanaged.Metadata.free">free</a>;
                        metadata[curr].used = <span class="tok-number">0</span>;
                        keys_ptr[curr] = <span class="tok-null">undefined</span>;
                        values_ptr[curr] = <span class="tok-null">undefined</span>;

                        curr += <span class="tok-number">1</span>;
                    }
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">grow</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>, ctx: Context) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <span class="tok-kw">const</span> new_cap = <span class="tok-builtin">@max</span>(new_capacity, <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.minimal_capacity">minimal_capacity</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(new_cap &gt; self.capacity());
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(new_cap));

            <span class="tok-kw">var</span> map: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a> = .{};
            <span class="tok-kw">try</span> map.allocate(allocator, new_cap);
            <span class="tok-kw">errdefer</span> <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;
            map.pointer_stability.lock();
            map.initMetadatas();
            map.available = <span class="tok-builtin">@truncate</span>((new_cap * max_load_percentage) / <span class="tok-number">100</span>);

            <span class="tok-kw">if</span> (self.size != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> old_capacity = self.capacity();
                <span class="tok-kw">for</span> (
                    self.metadata.?[<span class="tok-number">0</span>..old_capacity],
                    self.keys()[<span class="tok-number">0</span>..old_capacity],
                    self.values()[<span class="tok-number">0</span>..old_capacity],
                ) |m, k, v| {
                    <span class="tok-kw">if</span> (!m.isUsed()) <span class="tok-kw">continue</span>;
                    map.putAssumeCapacityNoClobberContext(k, v, ctx);
                    <span class="tok-kw">if</span> (map.size == self.size) <span class="tok-kw">break</span>;
                }
            }

            self.size = <span class="tok-number">0</span>;
            self.pointer_stability = .{};
            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, self, &amp;map);
            map.deinit(allocator);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">allocate</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.Size">Size</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> header_align = <span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);
            <span class="tok-kw">const</span> key_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(K);
            <span class="tok-kw">const</span> val_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(V) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(V);
            <span class="tok-kw">const</span> max_align = <span class="tok-kw">comptime</span> <span class="tok-builtin">@max</span>(header_align, key_align, val_align);

            <span class="tok-kw">const</span> new_cap: <span class="tok-type">usize</span> = new_capacity;
            <span class="tok-kw">const</span> meta_size = <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>) + new_cap * <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>);
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);

            <span class="tok-kw">const</span> keys_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, meta_size, key_align);
            <span class="tok-kw">const</span> keys_end = keys_start + new_cap * <span class="tok-builtin">@sizeOf</span>(K);

            <span class="tok-kw">const</span> vals_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, keys_end, val_align);
            <span class="tok-kw">const</span> vals_end = vals_start + new_cap * <span class="tok-builtin">@sizeOf</span>(V);

            <span class="tok-kw">const</span> total_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, vals_end, max_align);

            <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> allocator.alignedAlloc(<span class="tok-type">u8</span>, max_align, total_size);
            <span class="tok-kw">const</span> ptr: [*]<span class="tok-type">u8</span> = <span class="tok-builtin">@ptrCast</span>(slice.ptr);

            <span class="tok-kw">const</span> metadata = ptr + <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);

            <span class="tok-kw">const</span> hdr = <span class="tok-builtin">@as</span>(*<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr)));
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>([*]V) != <span class="tok-number">0</span>) {
                hdr.values = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>((ptr + vals_start)));
            }
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>([*]K) != <span class="tok-number">0</span>) {
                hdr.keys = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>((ptr + keys_start)));
            }
            hdr.capacity = new_capacity;
            self.metadata = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(metadata));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">deallocate</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.metadata == <span class="tok-null">null</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> header_align = <span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>);
            <span class="tok-kw">const</span> key_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(K) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(K);
            <span class="tok-kw">const</span> val_align = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(V) == <span class="tok-number">0</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(V);
            <span class="tok-kw">const</span> max_align = <span class="tok-kw">comptime</span> <span class="tok-builtin">@max</span>(header_align, key_align, val_align);

            <span class="tok-kw">const</span> cap: <span class="tok-type">usize</span> = self.capacity();
            <span class="tok-kw">const</span> meta_size = <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>) + cap * <span class="tok-builtin">@sizeOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>);
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@alignOf</span>(<a href="std.hash_map.HashMapUnmanaged.Metadata.html">Metadata</a>) == <span class="tok-number">1</span>);

            <span class="tok-kw">const</span> keys_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, meta_size, key_align);
            <span class="tok-kw">const</span> keys_end = keys_start + cap * <span class="tok-builtin">@sizeOf</span>(K);

            <span class="tok-kw">const</span> vals_start = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, keys_end, val_align);
            <span class="tok-kw">const</span> vals_end = vals_start + cap * <span class="tok-builtin">@sizeOf</span>(V);

            <span class="tok-kw">const</span> total_size = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, vals_end, max_align);

            <span class="tok-kw">const</span> slice = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(max_align) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(self.header())))[<span class="tok-number">0</span>..total_size];
            allocator.free(slice);

            self.metadata = <span class="tok-null">null</span>;
            self.available = <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// This function is used in the debugger pretty formatters in tools/ to fetch the</span>
        <span class="tok-comment">/// header type to facilitate fancy debug printing for this type.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">dbHelper</span>(self: *<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">Self</a>, hdr: *<a href="std.hash_map.HashMapUnmanaged.Header.html">Header</a>, entry: *<a href="std.hash_map.HashMapUnmanaged.Entry.html">Entry</a>) <span class="tok-type">void</span> {
            _ = self;
            _ = hdr;
            _ = entry;
        }

        <span class="tok-kw">comptime</span> {
            <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) _ = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a>) {
                .stage2_llvm =&gt; &amp;<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged.dbHelper">dbHelper</a>,
                .stage2_x86_64 =&gt; <a href="std.hash_map.HashMapUnmanaged.KV.html">KV</a>,
                <span class="tok-kw">else</span> =&gt; {},
            };
        }
    };
}

<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> expect = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>;
<span class="tok-kw">const</span> expectEqual = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;basic usage&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">const</span> count = <span class="tok-number">5</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> total: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; count) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, i);
        total += i;
    }

    <span class="tok-kw">var</span> sum: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> it = map.iterator();
    <span class="tok-kw">while</span> (it.next()) |kv| {
        sum += kv.key_ptr.*;
    }
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(total, sum);

    i = <span class="tok-number">0</span>;
    sum = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; count) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i, map.get(i).?);
        sum += map.get(i).?;
    }
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(total, sum);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ensureTotalCapacity&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.ensureTotalCapacity(<span class="tok-number">20</span>);
    <span class="tok-kw">const</span> initial_capacity = map.capacity();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(initial_capacity &gt;= <span class="tok-number">20</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.fetchPutAssumeCapacity(i, i + <span class="tok-number">10</span>) == <span class="tok-null">null</span>);
    }<span class="tok-comment">
    // shouldn't resize from putAssumeCapacity
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(initial_capacity == map.capacity());
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ensureUnusedCapacity with tombstones&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">100</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.ensureUnusedCapacity(<span class="tok-number">1</span>);
        map.putAssumeCapacity(i, i);
        _ = map.remove(i);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;clearRetainingCapacity&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    map.clearRetainingCapacity();

    <span class="tok-kw">try</span> map.put(<span class="tok-number">1</span>, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">1</span>).?, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), <span class="tok-number">1</span>);

    map.clearRetainingCapacity();
    map.putAssumeCapacity(<span class="tok-number">1</span>, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">1</span>).?, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> cap = map.capacity();
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(cap &gt; <span class="tok-number">0</span>);

    map.clearRetainingCapacity();
    map.clearRetainingCapacity();
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.capacity(), cap);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(!map.contains(<span class="tok-number">1</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;grow&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">const</span> growTo = <span class="tok-number">12456</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; growTo) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, i);
    }
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), growTo);

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> it = map.iterator();
    <span class="tok-kw">while</span> (it.next()) |kv| {
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(kv.key_ptr.*, kv.value_ptr.*);
        i += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(i, growTo);

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; growTo) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(i).?, i);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;clone&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> a = <span class="tok-kw">try</span> map.clone();
    <span class="tok-kw">defer</span> a.deinit();

    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(a.count(), <span class="tok-number">0</span>);

    <span class="tok-kw">try</span> a.put(<span class="tok-number">1</span>, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> a.put(<span class="tok-number">2</span>, <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> a.put(<span class="tok-number">3</span>, <span class="tok-number">3</span>);

    <span class="tok-kw">var</span> b = <span class="tok-kw">try</span> a.clone();
    <span class="tok-kw">defer</span> b.deinit();

    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(b.count(), <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(b.get(<span class="tok-number">1</span>).?, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(b.get(<span class="tok-number">2</span>).?, <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(b.get(<span class="tok-number">3</span>).?, <span class="tok-number">3</span>);

    <span class="tok-kw">var</span> original = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> original.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> original.putNoClobber(i, i * <span class="tok-number">10</span>);
    }

    <span class="tok-kw">var</span> copy = <span class="tok-kw">try</span> original.clone();
    <span class="tok-kw">defer</span> copy.deinit();

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(copy.get(i).? == i * <span class="tok-number">10</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ensureTotalCapacity with existing elements&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.put(<span class="tok-number">0</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.capacity(), <span class="tok-builtin">@TypeOf</span>(map).Unmanaged.minimal_capacity);

    <span class="tok-kw">try</span> map.ensureTotalCapacity(<span class="tok-number">65</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.capacity(), <span class="tok-number">128</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ensureTotalCapacity satisfies max load factor&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.ensureTotalCapacity(<span class="tok-number">127</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.capacity(), <span class="tok-number">256</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;remove&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, i);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (i % <span class="tok-number">3</span> == <span class="tok-number">0</span>) {
            _ = map.remove(i);
        }
    }
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), <span class="tok-number">10</span>);
    <span class="tok-kw">var</span> it = map.iterator();
    <span class="tok-kw">while</span> (it.next()) |kv| {
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(kv.key_ptr.*, kv.value_ptr.*);
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(kv.key_ptr.* % <span class="tok-number">3</span> != <span class="tok-number">0</span>);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (i % <span class="tok-number">3</span> == <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(!map.contains(i));
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(i).?, i);
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;reverse removes&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.putNoClobber(i, i);
    }

    i = <span class="tok-number">16</span>;
    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) : (i -= <span class="tok-number">1</span>) {
        _ = map.remove(i - <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(!map.contains(i - <span class="tok-number">1</span>));
        <span class="tok-kw">var</span> j: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (j &lt; i - <span class="tok-number">1</span>) : (j += <span class="tok-number">1</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(j).?, j);
        }
    }

    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;multiple removes on same metadata&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, i);
    }

    _ = map.remove(<span class="tok-number">7</span>);
    _ = map.remove(<span class="tok-number">15</span>);
    _ = map.remove(<span class="tok-number">14</span>);
    _ = map.remove(<span class="tok-number">13</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(!map.contains(<span class="tok-number">7</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(!map.contains(<span class="tok-number">15</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(!map.contains(<span class="tok-number">14</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(!map.contains(<span class="tok-number">13</span>));

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">13</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (i == <span class="tok-number">7</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expect">expect</a>(!map.contains(i));
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(i).?, i);
        }
    }

    <span class="tok-kw">try</span> map.put(<span class="tok-number">15</span>, <span class="tok-number">15</span>);
    <span class="tok-kw">try</span> map.put(<span class="tok-number">13</span>, <span class="tok-number">13</span>);
    <span class="tok-kw">try</span> map.put(<span class="tok-number">14</span>, <span class="tok-number">14</span>);
    <span class="tok-kw">try</span> map.put(<span class="tok-number">7</span>, <span class="tok-number">7</span>);
    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(i).?, i);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;put and remove loop in random order&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> keys = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> keys.deinit();

    <span class="tok-kw">const</span> size = <span class="tok-number">32</span>;
    <span class="tok-kw">const</span> iterations = <span class="tok-number">100</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; size) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> keys.append(i);
    }
    <span class="tok-kw">var</span> prng = <a href="std.html">std</a>.<a href="std.Random.html">Random</a>.<a href="std.Random.Xoshiro256.html">DefaultPrng</a>.<a href="std.Random.Xoshiro256.html#std.Random.Xoshiro256.init">init</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.random_seed">random_seed</a>);
    <span class="tok-kw">const</span> random = prng.random();

    <span class="tok-kw">while</span> (i &lt; iterations) : (i += <span class="tok-number">1</span>) {
        random.shuffle(<span class="tok-type">u32</span>, keys.items);

        <span class="tok-kw">for</span> (keys.items) |key| {
            <span class="tok-kw">try</span> map.put(key, key);
        }
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), size);

        <span class="tok-kw">for</span> (keys.items) |key| {
            _ = map.remove(key);
        }
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), <span class="tok-number">0</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;remove one million elements in random order&quot;</span> {
    <span class="tok-kw">const</span> Map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>);
    <span class="tok-kw">const</span> n = <span class="tok-number">1000</span> * <span class="tok-number">1000</span>;
    <span class="tok-kw">var</span> map = Map.init(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_allocator">page_allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> keys = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_allocator">page_allocator</a>);
    <span class="tok-kw">defer</span> keys.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; n) : (i += <span class="tok-number">1</span>) {
        keys.append(i) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">var</span> prng = <a href="std.html">std</a>.<a href="std.Random.html">Random</a>.<a href="std.Random.Xoshiro256.html">DefaultPrng</a>.<a href="std.Random.Xoshiro256.html#std.Random.Xoshiro256.init">init</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.random_seed">random_seed</a>);
    <span class="tok-kw">const</span> random = prng.random();
    random.shuffle(<span class="tok-type">u32</span>, keys.items);

    <span class="tok-kw">for</span> (keys.items) |key| {
        map.put(key, key) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }

    random.shuffle(<span class="tok-type">u32</span>, keys.items);
    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; n) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> key = keys.items[i];
        _ = map.remove(key);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;put&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, i);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(i).?, i);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, i * <span class="tok-number">16</span> + <span class="tok-number">1</span>);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(i).?, i * <span class="tok-number">16</span> + <span class="tok-number">1</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;putAssumeCapacity&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.ensureTotalCapacity(<span class="tok-number">20</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        map.putAssumeCapacityNoClobber(i, i);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum = i;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        sum += map.getPtr(i).?.*;
    }
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(sum, <span class="tok-number">190</span>);

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        map.putAssumeCapacity(i, <span class="tok-number">1</span>);
    }

    i = <span class="tok-number">0</span>;
    sum = i;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        sum += map.get(i).?;
    }
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(sum, <span class="tok-number">20</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;repeat putAssumeCapacity/remove&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.ensureTotalCapacity(<span class="tok-number">20</span>);
    <span class="tok-kw">const</span> limit = map.unmanaged.available;

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; limit) : (i += <span class="tok-number">1</span>) {
        map.putAssumeCapacityNoClobber(i, i);
    }<span class="tok-comment">

    // Repeatedly delete/insert an entry without resizing the map.
    // Put to different keys so entries don't land in the just-freed slot.
    </span>i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span> * limit) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.remove(i));
        <span class="tok-kw">if</span> (i % <span class="tok-number">2</span> == <span class="tok-number">0</span>) {
            map.putAssumeCapacityNoClobber(limit + i, i);
        } <span class="tok-kw">else</span> {
            map.putAssumeCapacity(limit + i, i);
        }
    }

    i = <span class="tok-number">9</span> * limit;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span> * limit) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(limit + i), i);
    }
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.unmanaged.available, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.unmanaged.count(), limit);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;getOrPut&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u32</span>, <span class="tok-type">u32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i * <span class="tok-number">2</span>, <span class="tok-number">2</span>);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        _ = <span class="tok-kw">try</span> map.getOrPutValue(i, <span class="tok-number">1</span>);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum = i;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        sum += map.get(i).?;
    }

    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(sum, <span class="tok-number">30</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;basic hash map usage&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">1</span>, <span class="tok-number">11</span>)) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">2</span>, <span class="tok-number">22</span>)) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">3</span>, <span class="tok-number">33</span>)) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">4</span>, <span class="tok-number">44</span>)) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> map.putNoClobber(<span class="tok-number">5</span>, <span class="tok-number">55</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">5</span>, <span class="tok-number">66</span>)).?.value == <span class="tok-number">55</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">5</span>, <span class="tok-number">55</span>)).?.value == <span class="tok-number">66</span>);

    <span class="tok-kw">const</span> gop1 = <span class="tok-kw">try</span> map.getOrPut(<span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop1.found_existing == <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop1.value_ptr.* == <span class="tok-number">55</span>);
    gop1.value_ptr.* = <span class="tok-number">77</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">5</span>).?.value_ptr.* == <span class="tok-number">77</span>);

    <span class="tok-kw">const</span> gop2 = <span class="tok-kw">try</span> map.getOrPut(<span class="tok-number">99</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop2.found_existing == <span class="tok-null">false</span>);
    gop2.value_ptr.* = <span class="tok-number">42</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">99</span>).?.value_ptr.* == <span class="tok-number">42</span>);

    <span class="tok-kw">const</span> gop3 = <span class="tok-kw">try</span> map.getOrPutValue(<span class="tok-number">5</span>, <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop3.value_ptr.* == <span class="tok-number">77</span>);

    <span class="tok-kw">const</span> gop4 = <span class="tok-kw">try</span> map.getOrPutValue(<span class="tok-number">100</span>, <span class="tok-number">41</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop4.value_ptr.* == <span class="tok-number">41</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.contains(<span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">2</span>).?.value_ptr.* == <span class="tok-number">22</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">2</span>).? == <span class="tok-number">22</span>);

    <span class="tok-kw">const</span> rmv1 = map.fetchRemove(<span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(rmv1.?.key == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(rmv1.?.value == <span class="tok-number">22</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.fetchRemove(<span class="tok-number">2</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.remove(<span class="tok-number">2</span>) == <span class="tok-null">false</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">2</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">2</span>) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.remove(<span class="tok-number">3</span>) == <span class="tok-null">true</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;getOrPutAdapted&quot;</span> {
    <span class="tok-kw">const</span> AdaptedContext = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <span class="tok-builtin">@This</span>(), adapted_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, test_key: <span class="tok-type">u64</span>) <span class="tok-type">bool</span> {
            _ = self;
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, adapted_key, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span> == test_key;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: <span class="tok-builtin">@This</span>(), adapted_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
            _ = self;
            <span class="tok-kw">const</span> key = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, adapted_key, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> (<a href="std.hash_map.html#std.hash_map.AutoContext">AutoContext</a>(<span class="tok-type">u64</span>){}).hash(key);
        }
    };
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u64</span>, <span class="tok-type">u64</span>).init(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">const</span> keys = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
        <span class="tok-str">&quot;1231&quot;</span>,
        <span class="tok-str">&quot;4564&quot;</span>,
        <span class="tok-str">&quot;7894&quot;</span>,
        <span class="tok-str">&quot;1132&quot;</span>,
        <span class="tok-str">&quot;65235&quot;</span>,
        <span class="tok-str">&quot;95462&quot;</span>,
        <span class="tok-str">&quot;0112305&quot;</span>,
        <span class="tok-str">&quot;00658&quot;</span>,
        <span class="tok-str">&quot;0&quot;</span>,
        <span class="tok-str">&quot;2&quot;</span>,
    };

    <span class="tok-kw">var</span> real_keys: [keys.len]<span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (keys, <span class="tok-number">0</span>..) |key_str, i| {
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> map.getOrPutAdapted(key_str, AdaptedContext{});
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!result.found_existing);
        real_keys[i] = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, key_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        result.key_ptr.* = real_keys[i];
        result.value_ptr.* = i * <span class="tok-number">2</span>;
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), keys.len);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (keys, <span class="tok-number">0</span>..) |key_str, i| {
        <span class="tok-kw">const</span> result = map.getOrPutAssumeCapacityAdapted(key_str, AdaptedContext{});
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(result.found_existing);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(real_keys[i], result.key_ptr.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, i) * <span class="tok-number">2</span>, result.value_ptr.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(real_keys[i], map.getKeyAdapted(key_str, AdaptedContext{}).?);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ensureUnusedCapacity&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u64</span>, <span class="tok-type">u64</span>).init(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.ensureUnusedCapacity(<span class="tok-number">32</span>);
    <span class="tok-kw">const</span> capacity = map.capacity();
    <span class="tok-kw">try</span> map.ensureUnusedCapacity(<span class="tok-number">32</span>);<span class="tok-comment">

    // Repeated ensureUnusedCapacity() calls with no insertions between
    // should not change the capacity.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(capacity, map.capacity());
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;removeByPtr&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">u64</span>).init(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, <span class="tok-number">0</span>);
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.count() == <span class="tok-number">10</span>);

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> key_ptr = map.getKeyPtr(i);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(key_ptr != <span class="tok-null">null</span>);

        <span class="tok-kw">if</span> (key_ptr) |ptr| {
            map.removeByPtr(ptr);
        }
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.count() == <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;removeByPtr 0 sized key&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">u0</span>, <span class="tok-type">u64</span>).init(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.put(<span class="tok-number">0</span>, <span class="tok-number">0</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.count() == <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> key_ptr = map.getKeyPtr(<span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(key_ptr != <span class="tok-null">null</span>);

    <span class="tok-kw">if</span> (key_ptr) |ptr| {
        map.removeByPtr(ptr);
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.count() == <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;repeat fetchRemove&quot;</span> {
    <span class="tok-kw">var</span> map: <a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<span class="tok-type">u64</span>, <span class="tok-type">void</span>) = .empty;
    <span class="tok-kw">defer</span> map.deinit(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);

    <span class="tok-kw">try</span> map.ensureTotalCapacity(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-number">4</span>);

    map.putAssumeCapacity(<span class="tok-number">0</span>, {});
    map.putAssumeCapacity(<span class="tok-number">1</span>, {});
    map.putAssumeCapacity(<span class="tok-number">2</span>, {});
    map.putAssumeCapacity(<span class="tok-number">3</span>, {});<span class="tok-comment">

    // fetchRemove() should make slots available.
    </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.fetchRemove(<span class="tok-number">3</span>) != <span class="tok-null">null</span>);
        map.putAssumeCapacity(<span class="tok-number">3</span>, {});
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">0</span>) != <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">1</span>) != <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">2</span>) != <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">3</span>) != <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;getOrPut allocation failure&quot;</span> {
    <span class="tok-kw">var</span> map: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMapUnmanaged">StringHashMapUnmanaged</a>(<span class="tok-type">void</span>) = .empty;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.OutOfMemory, map.getOrPut(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.failing_allocator">failing_allocator</a>, <span class="tok-str">&quot;hello&quot;</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;std.hash_map rehash&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">usize</span>, <span class="tok-type">usize</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> prng = <a href="std.html">std</a>.<a href="std.Random.html">Random</a>.<a href="std.Random.Xoshiro256.html">DefaultPrng</a>.<a href="std.Random.Xoshiro256.html#std.Random.Xoshiro256.init">init</a>(<span class="tok-number">0</span>);
    <span class="tok-kw">const</span> random = prng.random();

    <span class="tok-kw">const</span> count = <span class="tok-number">6</span> * random.intRangeLessThan(<span class="tok-type">u32</span>, <span class="tok-number">100_000</span>, <span class="tok-number">500_000</span>);

    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..count) |i| {
        <span class="tok-kw">try</span> map.put(i, i);
        <span class="tok-kw">if</span> (i % <span class="tok-number">3</span> == <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.remove(i), <span class="tok-null">true</span>);
        }
    }

    map.rehash();

    <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.count(), count * <span class="tok-number">2</span> / <span class="tok-number">3</span>);

    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..count) |i| {
        <span class="tok-kw">if</span> (i % <span class="tok-number">3</span> == <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(i), <span class="tok-null">null</span>);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(i).?, i);
        }
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
