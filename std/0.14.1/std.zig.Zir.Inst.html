<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.Zir.html" class="">Zir</a></li><li><a href="std.zig.Zir.Inst.html" class="active">Inst</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.Zir.Inst" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zig.Zir.Inst</span><a href="#src.zig-std.zig.Zir.Inst">[src]</a></h1><div class="tldDocs"><p>These are untyped instructions generated from an Abstract Syntax Tree.
The data here is immutable because it is possible to have multiple
analyses on the same ZIR happening at the same time.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.zig.Zir.Inst.Tag.html">std.zig.Zir.Inst.Tag</a></li><li><a href="std.zig.Zir.Inst.Extended.html">std.zig.Zir.Inst.Extended</a></li><li><a href="std.zig.Zir.Inst.Index.html">std.zig.Zir.Inst.Index</a></li><li><a href="std.zig.Zir.Inst.OptionalIndex.html">std.zig.Zir.Inst.OptionalIndex</a></li><li><a href="std.zig.Zir.Inst.Ref.html">std.zig.Zir.Inst.Ref</a></li><li><a href="std.zig.Zir.Inst.Data.html">std.zig.Zir.Inst.Data</a></li><li><a href="std.zig.Zir.Inst.Break.html">std.zig.Zir.Inst.Break</a></li><li><a href="std.zig.Zir.Inst.Asm.html">std.zig.Zir.Inst.Asm</a></li><li><a href="std.zig.Zir.Inst.Func.html">std.zig.Zir.Inst.Func</a></li><li><a href="std.zig.Zir.Inst.FuncFancy.html">std.zig.Zir.Inst.FuncFancy</a></li><li><a href="std.zig.Zir.Inst.MultiOp.html">std.zig.Zir.Inst.MultiOp</a></li><li><a href="std.zig.Zir.Inst.NodeMultiOp.html">std.zig.Zir.Inst.NodeMultiOp</a></li><li><a href="std.zig.Zir.Inst.Block.html">std.zig.Zir.Inst.Block</a></li><li><a href="std.zig.Zir.Inst.BlockComptime.html">std.zig.Zir.Inst.BlockComptime</a></li><li><a href="std.zig.Zir.Inst.BoolBr.html">std.zig.Zir.Inst.BoolBr</a></li><li><a href="std.zig.Zir.Inst.Declaration.html">std.zig.Zir.Inst.Declaration</a></li><li><a href="std.zig.Zir.Inst.Call.html">std.zig.Zir.Inst.Call</a></li><li><a href="std.zig.Zir.Inst.FieldCall.html">std.zig.Zir.Inst.FieldCall</a></li><li><a href="std.zig.Zir.Inst.TypeOfPeer.html">std.zig.Zir.Inst.TypeOfPeer</a></li><li><a href="std.zig.Zir.Inst.BuiltinCall.html">std.zig.Zir.Inst.BuiltinCall</a></li><li><a href="std.zig.Zir.Inst.CondBr.html">std.zig.Zir.Inst.CondBr</a></li><li><a href="std.zig.Zir.Inst.Try.html">std.zig.Zir.Inst.Try</a></li><li><a href="std.zig.Zir.Inst.PtrType.html">std.zig.Zir.Inst.PtrType</a></li><li><a href="std.zig.Zir.Inst.ArrayTypeSentinel.html">std.zig.Zir.Inst.ArrayTypeSentinel</a></li><li><a href="std.zig.Zir.Inst.SliceStart.html">std.zig.Zir.Inst.SliceStart</a></li><li><a href="std.zig.Zir.Inst.SliceEnd.html">std.zig.Zir.Inst.SliceEnd</a></li><li><a href="std.zig.Zir.Inst.SliceSentinel.html">std.zig.Zir.Inst.SliceSentinel</a></li><li><a href="std.zig.Zir.Inst.SliceLength.html">std.zig.Zir.Inst.SliceLength</a></li><li><a href="std.zig.Zir.Inst.Bin.html">std.zig.Zir.Inst.Bin</a></li><li><a href="std.zig.Zir.Inst.BinNode.html">std.zig.Zir.Inst.BinNode</a></li><li><a href="std.zig.Zir.Inst.UnNode.html">std.zig.Zir.Inst.UnNode</a></li><li><a href="std.zig.Zir.Inst.ElemPtrImm.html">std.zig.Zir.Inst.ElemPtrImm</a></li><li><a href="std.zig.Zir.Inst.Reify.html">std.zig.Zir.Inst.Reify</a></li><li><a href="std.zig.Zir.Inst.SwitchBlockErrUnion.html">std.zig.Zir.Inst.SwitchBlockErrUnion</a></li><li><a href="std.zig.Zir.Inst.SwitchBlock.html">std.zig.Zir.Inst.SwitchBlock</a></li><li><a href="std.zig.Zir.Inst.ArrayInitRefTy.html">std.zig.Zir.Inst.ArrayInitRefTy</a></li><li><a href="std.zig.Zir.Inst.Field.html">std.zig.Zir.Inst.Field</a></li><li><a href="std.zig.Zir.Inst.FieldNamed.html">std.zig.Zir.Inst.FieldNamed</a></li><li><a href="std.zig.Zir.Inst.As.html">std.zig.Zir.Inst.As</a></li><li><a href="std.zig.Zir.Inst.StructDecl.html">std.zig.Zir.Inst.StructDecl</a></li><li><a href="std.zig.Zir.Inst.Capture.html">std.zig.Zir.Inst.Capture</a></li><li><a href="std.zig.Zir.Inst.NameStrategy.html">std.zig.Zir.Inst.NameStrategy</a></li><li><a href="std.zig.Zir.Inst.FullPtrCastFlags.html">std.zig.Zir.Inst.FullPtrCastFlags</a></li><li><a href="std.zig.Zir.Inst.BuiltinValue.html">std.zig.Zir.Inst.BuiltinValue</a></li><li><a href="std.zig.Zir.Inst.InplaceOp.html">std.zig.Zir.Inst.InplaceOp</a></li><li><a href="std.zig.Zir.Inst.EnumDecl.html">std.zig.Zir.Inst.EnumDecl</a></li><li><a href="std.zig.Zir.Inst.UnionDecl.html">std.zig.Zir.Inst.UnionDecl</a></li><li><a href="std.zig.Zir.Inst.OpaqueDecl.html">std.zig.Zir.Inst.OpaqueDecl</a></li><li><a href="std.zig.Zir.Inst.TupleDecl.html">std.zig.Zir.Inst.TupleDecl</a></li><li><a href="std.zig.Zir.Inst.ErrorSetDecl.html">std.zig.Zir.Inst.ErrorSetDecl</a></li><li><a href="std.zig.Zir.Inst.Float128.html">std.zig.Zir.Inst.Float128</a></li><li><a href="std.zig.Zir.Inst.StructInit.html">std.zig.Zir.Inst.StructInit</a></li><li><a href="std.zig.Zir.Inst.StructInitAnon.html">std.zig.Zir.Inst.StructInitAnon</a></li><li><a href="std.zig.Zir.Inst.FieldType.html">std.zig.Zir.Inst.FieldType</a></li><li><a href="std.zig.Zir.Inst.FieldTypeRef.html">std.zig.Zir.Inst.FieldTypeRef</a></li><li><a href="std.zig.Zir.Inst.Cmpxchg.html">std.zig.Zir.Inst.Cmpxchg</a></li><li><a href="std.zig.Zir.Inst.AtomicRmw.html">std.zig.Zir.Inst.AtomicRmw</a></li><li><a href="std.zig.Zir.Inst.UnionInit.html">std.zig.Zir.Inst.UnionInit</a></li><li><a href="std.zig.Zir.Inst.AtomicStore.html">std.zig.Zir.Inst.AtomicStore</a></li><li><a href="std.zig.Zir.Inst.AtomicLoad.html">std.zig.Zir.Inst.AtomicLoad</a></li><li><a href="std.zig.Zir.Inst.MulAdd.html">std.zig.Zir.Inst.MulAdd</a></li><li><a href="std.zig.Zir.Inst.FieldParentPtr.html">std.zig.Zir.Inst.FieldParentPtr</a></li><li><a href="std.zig.Zir.Inst.Shuffle.html">std.zig.Zir.Inst.Shuffle</a></li><li><a href="std.zig.Zir.Inst.Select.html">std.zig.Zir.Inst.Select</a></li><li><a href="std.zig.Zir.Inst.AsyncCall.html">std.zig.Zir.Inst.AsyncCall</a></li><li><a href="std.zig.Zir.Inst.Param.html">std.zig.Zir.Inst.Param</a></li><li><a href="std.zig.Zir.Inst.AllocExtended.html">std.zig.Zir.Inst.AllocExtended</a></li><li><a href="std.zig.Zir.Inst.Export.html">std.zig.Zir.Inst.Export</a></li><li><a href="std.zig.Zir.Inst.CompileErrors.html">std.zig.Zir.Inst.CompileErrors</a></li><li><a href="std.zig.Zir.Inst.Imports.html">std.zig.Zir.Inst.Imports</a></li><li><a href="std.zig.Zir.Inst.LineColumn.html">std.zig.Zir.Inst.LineColumn</a></li><li><a href="std.zig.Zir.Inst.ArrayInit.html">std.zig.Zir.Inst.ArrayInit</a></li><li><a href="std.zig.Zir.Inst.Src.html">std.zig.Zir.Inst.Src</a></li><li><a href="std.zig.Zir.Inst.DeferErrCode.html">std.zig.Zir.Inst.DeferErrCode</a></li><li><a href="std.zig.Zir.Inst.ValidateDestructure.html">std.zig.Zir.Inst.ValidateDestructure</a></li><li><a href="std.zig.Zir.Inst.ArrayMul.html">std.zig.Zir.Inst.ArrayMul</a></li><li><a href="std.zig.Zir.Inst.RestoreErrRetIndex.html">std.zig.Zir.Inst.RestoreErrRetIndex</a></li><li><a href="std.zig.Zir.Inst.Import.html">std.zig.Zir.Inst.Import</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>tag: <a href="std.zig.Zir.Inst.Tag.html">Tag</a></code></pre></div><div><pre><code>data: <a href="std.zig.Zir.Inst.Data.html">Data</a></code></pre></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.Zir.Inst">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Inst = <span class="tok-kw">struct</span> {
    tag: <a href="std.zig.Zir.Inst.Tag.html">Tag</a>,
    data: <a href="std.zig.Zir.Inst.Data.html">Data</a>,

    <span class="tok-comment">/// These names are used directly as the instruction names in the text format.</span>
    <span class="tok-comment">/// See `data_field_map` for a list of which `Data` fields are used by each `Tag`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        <span class="tok-comment">/// Arithmetic addition, asserts no integer overflow.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        add,
        <span class="tok-comment">/// Twos complement wrapping integer addition.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        addwrap,
        <span class="tok-comment">/// Saturating addition.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        add_sat,
        <span class="tok-comment">/// The same as `add` except no safety check.</span>
        add_unsafe,
        <span class="tok-comment">/// Arithmetic subtraction. Asserts no integer overflow.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        sub,
        <span class="tok-comment">/// Twos complement wrapping integer subtraction.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        subwrap,
        <span class="tok-comment">/// Saturating subtraction.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        sub_sat,
        <span class="tok-comment">/// Arithmetic multiplication. Asserts no integer overflow.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        mul,
        <span class="tok-comment">/// Twos complement wrapping integer multiplication.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        mulwrap,
        <span class="tok-comment">/// Saturating multiplication.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        mul_sat,
        <span class="tok-comment">/// Implements the `@divExact` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        div_exact,
        <span class="tok-comment">/// Implements the `@divFloor` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        div_floor,
        <span class="tok-comment">/// Implements the `@divTrunc` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        div_trunc,
        <span class="tok-comment">/// Implements the `@mod` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        mod,
        <span class="tok-comment">/// Implements the `@rem` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        rem,
        <span class="tok-comment">/// Ambiguously remainder division or modulus. If the computation would possibly have</span>
        <span class="tok-comment">/// a different value depending on whether the operation is remainder division or modulus,</span>
        <span class="tok-comment">/// a compile error is emitted. Otherwise the computation is performed.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        mod_rem,
        <span class="tok-comment">/// Integer shift-left. Zeroes are shifted in from the right hand side.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        shl,
        <span class="tok-comment">/// Implements the `@shlExact` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        shl_exact,
        <span class="tok-comment">/// Saturating shift-left.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        shl_sat,
        <span class="tok-comment">/// Integer shift-right. Arithmetic or logical depending on the signedness of</span>
        <span class="tok-comment">/// the integer type.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        shr,
        <span class="tok-comment">/// Implements the `@shrExact` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        shr_exact,

        <span class="tok-comment">/// Declares a parameter of the current function. Used for:</span>
        <span class="tok-comment">/// * debug info</span>
        <span class="tok-comment">/// * checking shadowing against declarations in the current namespace</span>
        <span class="tok-comment">/// * parameter type expressions referencing other parameters</span>
        <span class="tok-comment">/// These occur in the block outside a function body (the same block as</span>
        <span class="tok-comment">/// contains the func instruction).</span>
        <span class="tok-comment">/// Uses the `pl_tok` field. Token is the parameter name, payload is a `Param`.</span>
        param,
        <span class="tok-comment">/// Same as `param` except the parameter is marked comptime.</span>
        param_comptime,
        <span class="tok-comment">/// Same as `param` except the parameter is marked anytype.</span>
        <span class="tok-comment">/// Uses the `str_tok` field. Token is the parameter name. String is the parameter name.</span>
        param_anytype,
        <span class="tok-comment">/// Same as `param` except the parameter is marked both comptime and anytype.</span>
        <span class="tok-comment">/// Uses the `str_tok` field. Token is the parameter name. String is the parameter name.</span>
        param_anytype_comptime,
        <span class="tok-comment">/// Array concatenation. `a ++ b`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        array_cat,
        <span class="tok-comment">/// Array multiplication `a ** b`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `ArrayMul`.</span>
        array_mul,
        <span class="tok-comment">/// `[N]T` syntax. No source location provided.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`. lhs is length, rhs is element type.</span>
        array_type,
        <span class="tok-comment">/// `[N:S]T` syntax. Source location is the array type expression node.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `ArrayTypeSentinel`.</span>
        array_type_sentinel,
        <span class="tok-comment">/// `@Vector` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with `Bin` payload.</span>
        <span class="tok-comment">/// lhs is length, rhs is element type.</span>
        vector_type,
        <span class="tok-comment">/// Given a pointer type, returns its element type. Reaches through any optional or error</span>
        <span class="tok-comment">/// union types wrapping the pointer. Asserts that the underlying type is a pointer type.</span>
        <span class="tok-comment">/// Returns generic poison if the element type is `anyopaque`.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        elem_type,
        <span class="tok-comment">/// Given an indexable pointer (slice, many-ptr, single-ptr-to-array), returns its</span>
        <span class="tok-comment">/// element type. Emits a compile error if the type is not an indexable pointer.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        indexable_ptr_elem_type,
        <span class="tok-comment">/// Given a vector or array type, returns its element type.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        vec_arr_elem_type,
        <span class="tok-comment">/// Given a pointer to an indexable object, returns the len property. This is</span>
        <span class="tok-comment">/// used by for loops. This instruction also emits a for-loop specific compile</span>
        <span class="tok-comment">/// error if the indexable object is not indexable.</span>
        <span class="tok-comment">/// Uses the `un_node` field. The AST node is the for loop node.</span>
        indexable_ptr_len,
        <span class="tok-comment">/// Create a `anyframe-&gt;T` type.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        anyframe_type,
        <span class="tok-comment">/// Type coercion to the function's return type.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `As`. AST node could be many things.</span>
        as_node,
        <span class="tok-comment">/// Same as `as_node` but ignores runtime to comptime int error.</span>
        as_shift_operand,
        <span class="tok-comment">/// Bitwise AND. `&amp;`</span>
        bit_and,
        <span class="tok-comment">/// Reinterpret the memory representation of a value as a different type.</span>
        <span class="tok-comment">/// Uses the pl_node field with payload `Bin`.</span>
        bitcast,
        <span class="tok-comment">/// Bitwise NOT. `~`</span>
        <span class="tok-comment">/// Uses `un_node`.</span>
        bit_not,
        <span class="tok-comment">/// Bitwise OR. `|`</span>
        bit_or,
        <span class="tok-comment">/// A labeled block of code, which can return a value.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Block`.</span>
        block,
        <span class="tok-comment">/// Like `block`, but forces full evaluation of its contents at compile-time.</span>
        <span class="tok-comment">/// Exited with `break_inline`.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `BlockComptime`.</span>
        block_comptime,
        <span class="tok-comment">/// A list of instructions which are analyzed in the parent context, without</span>
        <span class="tok-comment">/// generating a runtime block. Must terminate with an &quot;inline&quot; variant of</span>
        <span class="tok-comment">/// a noreturn instruction.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Block`.</span>
        block_inline,
        <span class="tok-comment">/// This instruction may only ever appear in the list of declarations for a</span>
        <span class="tok-comment">/// namespace type, e.g. within a `struct_decl` instruction. It represents a</span>
        <span class="tok-comment">/// single source declaration (`const`/`var`/`fn`), containing the name,</span>
        <span class="tok-comment">/// attributes, type, and value of the declaration.</span>
        <span class="tok-comment">/// Uses the `declaration` union field. Payload is `Declaration`.</span>
        declaration,
        <span class="tok-comment">/// Implements `suspend {...}`.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Block`.</span>
        suspend_block,
        <span class="tok-comment">/// Boolean NOT. See also `bit_not`.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        bool_not,
        <span class="tok-comment">/// Short-circuiting boolean `and`. `lhs` is a boolean `Ref` and the other operand</span>
        <span class="tok-comment">/// is a block, which is evaluated if `lhs` is `true`.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `BoolBr`.</span>
        bool_br_and,
        <span class="tok-comment">/// Short-circuiting boolean `or`. `lhs` is a boolean `Ref` and the other operand</span>
        <span class="tok-comment">/// is a block, which is evaluated if `lhs` is `false`.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `BoolBr`.</span>
        bool_br_or,
        <span class="tok-comment">/// Return a value from a block.</span>
        <span class="tok-comment">/// Uses the `break` union field.</span>
        <span class="tok-comment">/// Uses the source information from previous instruction.</span>
        @&quot;break&quot;,
        <span class="tok-comment">/// Return a value from a block. This instruction is used as the terminator</span>
        <span class="tok-comment">/// of a `block_inline`. It allows using the return value from `Sema.analyzeBody`.</span>
        <span class="tok-comment">/// This instruction may also be used when it is known that there is only one</span>
        <span class="tok-comment">/// break instruction in a block, and the target block is the parent.</span>
        <span class="tok-comment">/// Uses the `break` union field.</span>
        break_inline,
        <span class="tok-comment">/// Branch from within a switch case to the case specified by the operand.</span>
        <span class="tok-comment">/// Uses the `break` union field. `block_inst` refers to a `switch_block` or `switch_block_ref`.</span>
        switch_continue,
        <span class="tok-comment">/// Checks that comptime control flow does not happen inside a runtime block.</span>
        <span class="tok-comment">/// Uses the `un_node` union field.</span>
        check_comptime_control_flow,
        <span class="tok-comment">/// Function call.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Call`.</span>
        <span class="tok-comment">/// AST node is the function call.</span>
        call,
        <span class="tok-comment">/// Function call using `a.b()` syntax.</span>
        <span class="tok-comment">/// Uses the named field as the callee. If there is no such field, searches in the type for</span>
        <span class="tok-comment">/// a decl matching the field name. The decl is resolved and we ensure that it's a function</span>
        <span class="tok-comment">/// which can accept the object as the first parameter, with one pointer fixup. This</span>
        <span class="tok-comment">/// function is then used as the callee, with the object as an implicit first parameter.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `FieldCall`.</span>
        <span class="tok-comment">/// AST node is the function call.</span>
        field_call,
        <span class="tok-comment">/// Implements the `@call` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `BuiltinCall`.</span>
        <span class="tok-comment">/// AST node is the builtin call.</span>
        builtin_call,
        <span class="tok-comment">/// `&lt;`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        cmp_lt,
        <span class="tok-comment">/// `&lt;=`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        cmp_lte,
        <span class="tok-comment">/// `==`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        cmp_eq,
        <span class="tok-comment">/// `&gt;=`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        cmp_gte,
        <span class="tok-comment">/// `&gt;`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        cmp_gt,
        <span class="tok-comment">/// `!=`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        cmp_neq,
        <span class="tok-comment">/// Conditional branch. Splits control flow based on a boolean condition value.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is an if, while, for, etc.</span>
        <span class="tok-comment">/// Payload is `CondBr`.</span>
        condbr,
        <span class="tok-comment">/// Same as `condbr`, except the condition is coerced to a comptime value, and</span>
        <span class="tok-comment">/// only the taken branch is analyzed. The then block and else block must</span>
        <span class="tok-comment">/// terminate with an &quot;inline&quot; variant of a noreturn instruction.</span>
        condbr_inline,
        <span class="tok-comment">/// Given an operand which is an error union, splits control flow. In</span>
        <span class="tok-comment">/// case of error, control flow goes into the block that is part of this</span>
        <span class="tok-comment">/// instruction, which is guaranteed to end with a return instruction</span>
        <span class="tok-comment">/// and never breaks out of the block.</span>
        <span class="tok-comment">/// In the case of non-error, control flow proceeds to the next instruction</span>
        <span class="tok-comment">/// after the `try`, with the result of this instruction being the unwrapped</span>
        <span class="tok-comment">/// payload value, as if `err_union_payload_unsafe` was executed on the operand.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Try`.</span>
        @&quot;try&quot;,
        <span class="tok-comment">/// Same as `try` except the operand is a pointer and the result is a pointer.</span>
        try_ptr,
        <span class="tok-comment">/// An error set type definition. Contains a list of field names.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `ErrorSetDecl`.</span>
        error_set_decl,
        <span class="tok-comment">/// Declares the beginning of a statement. Used for debug info.</span>
        <span class="tok-comment">/// Uses the `dbg_stmt` union field. The line and column are offset</span>
        <span class="tok-comment">/// from the parent declaration.</span>
        dbg_stmt,
        <span class="tok-comment">/// Marks a variable declaration. Used for debug info.</span>
        <span class="tok-comment">/// Uses the `str_op` union field. The string is the local variable name,</span>
        <span class="tok-comment">/// and the operand is the pointer to the variable's location. The local</span>
        <span class="tok-comment">/// may be a const or a var.</span>
        dbg_var_ptr,
        <span class="tok-comment">/// Same as `dbg_var_ptr` but the local is always a const and the operand</span>
        <span class="tok-comment">/// is the local's value.</span>
        dbg_var_val,
        <span class="tok-comment">/// Uses a name to identify a Decl and takes a pointer to it.</span>
        <span class="tok-comment">/// Uses the `str_tok` union field.</span>
        decl_ref,
        <span class="tok-comment">/// Uses a name to identify a Decl and uses it as a value.</span>
        <span class="tok-comment">/// Uses the `str_tok` union field.</span>
        decl_val,
        <span class="tok-comment">/// Load the value from a pointer. Assumes `x.*` syntax.</span>
        <span class="tok-comment">/// Uses `un_node` field. AST node is the `x.*` syntax.</span>
        load,
        <span class="tok-comment">/// Arithmetic division. Asserts no integer overflow.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        div,
        <span class="tok-comment">/// Given a pointer to an array, slice, or pointer, returns a pointer to the element at</span>
        <span class="tok-comment">/// the provided index.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is a[b] syntax. Payload is `Bin`.</span>
        elem_ptr_node,
        <span class="tok-comment">/// Same as `elem_ptr_node` but used only for for loop.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is the condition of a for loop.</span>
        <span class="tok-comment">/// Payload is `Bin`.</span>
        <span class="tok-comment">/// No OOB safety check is emitted.</span>
        elem_ptr,
        <span class="tok-comment">/// Given an array, slice, or pointer, returns the element at the provided index.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is a[b] syntax. Payload is `Bin`.</span>
        elem_val_node,
        <span class="tok-comment">/// Same as `elem_val_node` but used only for for loop.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is the condition of a for loop.</span>
        <span class="tok-comment">/// Payload is `Bin`.</span>
        <span class="tok-comment">/// No OOB safety check is emitted.</span>
        elem_val,
        <span class="tok-comment">/// Same as `elem_val` but takes the index as an immediate value.</span>
        <span class="tok-comment">/// No OOB safety check is emitted. A prior instruction must validate this operation.</span>
        <span class="tok-comment">/// Uses the `elem_val_imm` union field.</span>
        elem_val_imm,
        <span class="tok-comment">/// Emits a compile error if the operand is not `void`.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        ensure_result_used,
        <span class="tok-comment">/// Emits a compile error if an error is ignored.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        ensure_result_non_error,
        <span class="tok-comment">/// Emits a compile error error union payload is not void.</span>
        ensure_err_union_payload_void,
        <span class="tok-comment">/// Create a `E!T` type.</span>
        <span class="tok-comment">/// Uses the `pl_node` field with `Bin` payload.</span>
        error_union_type,
        <span class="tok-comment">/// `error.Foo` syntax. Uses the `str_tok` field of the Data union.</span>
        error_value,
        <span class="tok-comment">/// Implements the `@export` builtin function.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Export`.</span>
        @&quot;export&quot;,
        <span class="tok-comment">/// Given a pointer to a struct or object that contains virtual fields, returns a pointer</span>
        <span class="tok-comment">/// to the named field. The field name is stored in string_bytes. Used by a.b syntax.</span>
        <span class="tok-comment">/// Uses `pl_node` field. The AST node is the a.b syntax. Payload is Field.</span>
        field_ptr,
        <span class="tok-comment">/// Given a struct or object that contains virtual fields, returns the named field.</span>
        <span class="tok-comment">/// The field name is stored in string_bytes. Used by a.b syntax.</span>
        <span class="tok-comment">/// This instruction also accepts a pointer.</span>
        <span class="tok-comment">/// Uses `pl_node` field. The AST node is the a.b syntax. Payload is Field.</span>
        field_val,
        <span class="tok-comment">/// Given a pointer to a struct or object that contains virtual fields, returns a pointer</span>
        <span class="tok-comment">/// to the named field. The field name is a comptime instruction. Used by @field.</span>
        <span class="tok-comment">/// Uses `pl_node` field. The AST node is the builtin call. Payload is FieldNamed.</span>
        field_ptr_named,
        <span class="tok-comment">/// Given a struct or object that contains virtual fields, returns the named field.</span>
        <span class="tok-comment">/// The field name is a comptime instruction. Used by @field.</span>
        <span class="tok-comment">/// Uses `pl_node` field. The AST node is the builtin call. Payload is FieldNamed.</span>
        field_val_named,
        <span class="tok-comment">/// Returns a function type, or a function instance, depending on whether</span>
        <span class="tok-comment">/// the body_len is 0. Calling convention is auto.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. `payload_index` points to a `Func`.</span>
        func,
        <span class="tok-comment">/// Same as `func` but has an inferred error set.</span>
        func_inferred,
        <span class="tok-comment">/// Represents a function declaration or function prototype, depending on</span>
        <span class="tok-comment">/// whether body_len is 0.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. `payload_index` points to a `FuncFancy`.</span>
        func_fancy,
        <span class="tok-comment">/// Implements the `@import` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_tok` field.</span>
        import,
        <span class="tok-comment">/// Integer literal that fits in a u64. Uses the `int` union field.</span>
        int,
        <span class="tok-comment">/// Arbitrary sized integer literal. Uses the `str` union field.</span>
        int_big,
        <span class="tok-comment">/// A float literal that fits in a f64. Uses the float union value.</span>
        float,
        <span class="tok-comment">/// A float literal that fits in a f128. Uses the `pl_node` union value.</span>
        <span class="tok-comment">/// Payload is `Float128`.</span>
        float128,
        <span class="tok-comment">/// Make an integer type out of signedness and bit count.</span>
        <span class="tok-comment">/// Payload is `int_type`</span>
        int_type,
        <span class="tok-comment">/// Return a boolean false if an optional is null. `x != null`</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        is_non_null,
        <span class="tok-comment">/// Return a boolean false if an optional is null. `x.* != null`</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        is_non_null_ptr,
        <span class="tok-comment">/// Return a boolean false if value is an error</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        is_non_err,
        <span class="tok-comment">/// Return a boolean false if dereferenced pointer is an error</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        is_non_err_ptr,
        <span class="tok-comment">/// Same as `is_non_er` but doesn't validate that the type can be an error.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        ret_is_non_err,
        <span class="tok-comment">/// A labeled block of code that loops forever. At the end of the body will have either</span>
        <span class="tok-comment">/// a `repeat` instruction or a `repeat_inline` instruction.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. The AST node is either a for loop or while loop.</span>
        <span class="tok-comment">/// This ZIR instruction is needed because AIR does not (yet?) match ZIR, and Sema</span>
        <span class="tok-comment">/// needs to emit more than 1 AIR block for this instruction.</span>
        <span class="tok-comment">/// The payload is `Block`.</span>
        loop,
        <span class="tok-comment">/// Sends runtime control flow back to the beginning of the current block.</span>
        <span class="tok-comment">/// Uses the `node` field.</span>
        repeat,
        <span class="tok-comment">/// Sends comptime control flow back to the beginning of the current block.</span>
        <span class="tok-comment">/// Uses the `node` field.</span>
        repeat_inline,
        <span class="tok-comment">/// Asserts that all the lengths provided match. Used to build a for loop.</span>
        <span class="tok-comment">/// Return value is the length as a usize.</span>
        <span class="tok-comment">/// Uses the `pl_node` field with payload `MultiOp`.</span>
        <span class="tok-comment">/// There are two items for each AST node inside the for loop condition.</span>
        <span class="tok-comment">/// If both items in a pair are `.none`, then this node is an unbounded range.</span>
        <span class="tok-comment">/// If only the second item in a pair is `.none`, then the first is an indexable.</span>
        <span class="tok-comment">/// Otherwise, the node is a bounded range `a..b`, with the items being `a` and `b`.</span>
        <span class="tok-comment">/// Illegal behaviors:</span>
        <span class="tok-comment">///  * If all lengths are unbounded ranges (always a compile error).</span>
        <span class="tok-comment">///  * If any two lengths do not match each other.</span>
        for_len,
        <span class="tok-comment">/// Merge two error sets into one, `E1 || E2`.</span>
        <span class="tok-comment">/// Uses the `pl_node` field with payload `Bin`.</span>
        merge_error_sets,
        <span class="tok-comment">/// Turns an R-Value into a const L-Value. In other words, it takes a value,</span>
        <span class="tok-comment">/// stores it in a memory location, and returns a const pointer to it. If the value</span>
        <span class="tok-comment">/// is `comptime`, the memory location is global static constant data. Otherwise,</span>
        <span class="tok-comment">/// the memory location is in the stack frame, local to the scope containing the</span>
        <span class="tok-comment">/// instruction.</span>
        <span class="tok-comment">/// Uses the `un_tok` union field.</span>
        ref,
        <span class="tok-comment">/// Sends control flow back to the function's callee.</span>
        <span class="tok-comment">/// Includes an operand as the return value.</span>
        <span class="tok-comment">/// Includes an AST node source location.</span>
        <span class="tok-comment">/// Uses the `un_node` union field.</span>
        ret_node,
        <span class="tok-comment">/// Sends control flow back to the function's callee.</span>
        <span class="tok-comment">/// The operand is a `ret_ptr` instruction, where the return value can be found.</span>
        <span class="tok-comment">/// Includes an AST node source location.</span>
        <span class="tok-comment">/// Uses the `un_node` union field.</span>
        ret_load,
        <span class="tok-comment">/// Sends control flow back to the function's callee.</span>
        <span class="tok-comment">/// Includes an operand as the return value.</span>
        <span class="tok-comment">/// Includes a token source location.</span>
        <span class="tok-comment">/// Uses the `un_tok` union field.</span>
        ret_implicit,
        <span class="tok-comment">/// Sends control flow back to the function's callee.</span>
        <span class="tok-comment">/// The return operand is `error.foo` where `foo` is given by the string.</span>
        <span class="tok-comment">/// If the current function has an inferred error set, the error given by the</span>
        <span class="tok-comment">/// name is added to it.</span>
        <span class="tok-comment">/// Uses the `str_tok` union field.</span>
        ret_err_value,
        <span class="tok-comment">/// A string name is provided which is an anonymous error set value.</span>
        <span class="tok-comment">/// If the current function has an inferred error set, the error given by the</span>
        <span class="tok-comment">/// name is added to it.</span>
        <span class="tok-comment">/// Results in the error code. Note that control flow is not diverted with</span>
        <span class="tok-comment">/// this instruction; a following 'ret' instruction will do the diversion.</span>
        <span class="tok-comment">/// Uses the `str_tok` union field.</span>
        ret_err_value_code,
        <span class="tok-comment">/// Obtains a pointer to the return value.</span>
        <span class="tok-comment">/// Uses the `node` union field.</span>
        ret_ptr,
        <span class="tok-comment">/// Obtains the return type of the in-scope function.</span>
        <span class="tok-comment">/// Uses the `node` union field.</span>
        ret_type,
        <span class="tok-comment">/// Create a pointer type which can have a sentinel, alignment, address space, and/or bit range.</span>
        <span class="tok-comment">/// Uses the `ptr_type` union field.</span>
        ptr_type,
        <span class="tok-comment">/// Slice operation `lhs[rhs..]`. No sentinel and no end offset.</span>
        <span class="tok-comment">/// Returns a pointer to the subslice.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. AST node is the slice syntax. Payload is `SliceStart`.</span>
        slice_start,
        <span class="tok-comment">/// Slice operation `array_ptr[start..end]`. No sentinel.</span>
        <span class="tok-comment">/// Returns a pointer to the subslice.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. AST node is the slice syntax. Payload is `SliceEnd`.</span>
        slice_end,
        <span class="tok-comment">/// Slice operation `array_ptr[start..end:sentinel]`.</span>
        <span class="tok-comment">/// Returns a pointer to the subslice.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. AST node is the slice syntax. Payload is `SliceSentinel`.</span>
        slice_sentinel,
        <span class="tok-comment">/// Slice operation `array_ptr[start..][0..len]`. Optional sentinel.</span>
        <span class="tok-comment">/// Returns a pointer to the subslice.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. AST node is the slice syntax. Payload is `SliceLength`.</span>
        slice_length,
        <span class="tok-comment">/// Given a value which is a pointer to the LHS of a slice operation, return the sentinel</span>
        <span class="tok-comment">/// type, used as the result type of the slice sentinel (i.e. `s` in `lhs[a..b :s]`).</span>
        <span class="tok-comment">/// Uses the `un_node` field. AST node is the slice syntax. Operand is `lhs`.</span>
        slice_sentinel_ty,
        <span class="tok-comment">/// Same as `store` except provides a source location.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        store_node,
        <span class="tok-comment">/// Same as `store_node` but the type of the value being stored will be</span>
        <span class="tok-comment">/// used to infer the pointer type of an `alloc_inferred`.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        store_to_inferred_ptr,
        <span class="tok-comment">/// String Literal. Makes an anonymous Decl and then takes a pointer to it.</span>
        <span class="tok-comment">/// Uses the `str` union field.</span>
        str,
        <span class="tok-comment">/// Arithmetic negation. Asserts no integer overflow.</span>
        <span class="tok-comment">/// Same as sub with a lhs of 0, split into a separate instruction to save memory.</span>
        <span class="tok-comment">/// Uses `un_node`.</span>
        negate,
        <span class="tok-comment">/// Twos complement wrapping integer negation.</span>
        <span class="tok-comment">/// Same as subwrap with a lhs of 0, split into a separate instruction to save memory.</span>
        <span class="tok-comment">/// Uses `un_node`.</span>
        negate_wrap,
        <span class="tok-comment">/// Returns the type of a value.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        typeof,
        <span class="tok-comment">/// Implements `@TypeOf` for one operand.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `Block`.</span>
        typeof_builtin,
        <span class="tok-comment">/// Given a value, look at the type of it, which must be an integer type.</span>
        <span class="tok-comment">/// Returns the integer type for the RHS of a shift operation.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        typeof_log2_int_type,
        <span class="tok-comment">/// Asserts control-flow will not reach this instruction (`unreachable`).</span>
        <span class="tok-comment">/// Uses the `@&quot;unreachable&quot;` union field.</span>
        @&quot;unreachable&quot;,
        <span class="tok-comment">/// Bitwise XOR. `^`</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        xor,
        <span class="tok-comment">/// Create an optional type '?T'</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        optional_type,
        <span class="tok-comment">/// ?T =&gt; T with safety.</span>
        <span class="tok-comment">/// Given an optional value, returns the payload value, with a safety check that</span>
        <span class="tok-comment">/// the value is non-null. Used for `orelse`, `if` and `while`.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        optional_payload_safe,
        <span class="tok-comment">/// ?T =&gt; T without safety.</span>
        <span class="tok-comment">/// Given an optional value, returns the payload value. No safety checks.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        optional_payload_unsafe,
        <span class="tok-comment">/// *?T =&gt; *T with safety.</span>
        <span class="tok-comment">/// Given a pointer to an optional value, returns a pointer to the payload value,</span>
        <span class="tok-comment">/// with a safety check that the value is non-null. Used for `orelse`, `if` and `while`.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        optional_payload_safe_ptr,
        <span class="tok-comment">/// *?T =&gt; *T without safety.</span>
        <span class="tok-comment">/// Given a pointer to an optional value, returns a pointer to the payload value.</span>
        <span class="tok-comment">/// No safety checks.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        optional_payload_unsafe_ptr,
        <span class="tok-comment">/// E!T =&gt; T without safety.</span>
        <span class="tok-comment">/// Given an error union value, returns the payload value. No safety checks.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        err_union_payload_unsafe,
        <span class="tok-comment">/// *E!T =&gt; *T without safety.</span>
        <span class="tok-comment">/// Given a pointer to a error union value, returns a pointer to the payload value.</span>
        <span class="tok-comment">/// No safety checks.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        err_union_payload_unsafe_ptr,
        <span class="tok-comment">/// E!T =&gt; E without safety.</span>
        <span class="tok-comment">/// Given an error union value, returns the error code. No safety checks.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        err_union_code,
        <span class="tok-comment">/// *E!T =&gt; E without safety.</span>
        <span class="tok-comment">/// Given a pointer to an error union value, returns the error code. No safety checks.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        err_union_code_ptr,
        <span class="tok-comment">/// An enum literal. Uses the `str_tok` union field.</span>
        enum_literal,
        <span class="tok-comment">/// A decl literal. This is similar to `field`, but unwraps error unions and optionals,</span>
        <span class="tok-comment">/// and coerces the result to the given type.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Field`.</span>
        decl_literal,
        <span class="tok-comment">/// The same as `decl_literal`, but the coercion is omitted. This is used for decl literal</span>
        <span class="tok-comment">/// function call syntax, i.e. `.foo()`.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Field`.</span>
        decl_literal_no_coerce,
        <span class="tok-comment">/// A switch expression. Uses the `pl_node` union field.</span>
        <span class="tok-comment">/// AST node is the switch, payload is `SwitchBlock`.</span>
        switch_block,
        <span class="tok-comment">/// A switch expression. Uses the `pl_node` union field.</span>
        <span class="tok-comment">/// AST node is the switch, payload is `SwitchBlock`. Operand is a pointer.</span>
        switch_block_ref,
        <span class="tok-comment">/// A switch on an error union `a catch |err| switch (err) {...}`.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is the `catch`, payload is `SwitchBlockErrUnion`.</span>
        switch_block_err_union,
        <span class="tok-comment">/// Check that operand type supports the dereference operand (.*).</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        validate_deref,
        <span class="tok-comment">/// Check that the operand's type is an array or tuple with the given number of elements.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `ValidateDestructure`.</span>
        validate_destructure,
        <span class="tok-comment">/// Given a struct or union, and a field name as a Ref,</span>
        <span class="tok-comment">/// returns the field type. Uses the `pl_node` field. Payload is `FieldTypeRef`.</span>
        field_type_ref,
        <span class="tok-comment">/// Given a pointer, initializes all error unions and optionals in the pointee to payloads,</span>
        <span class="tok-comment">/// returning the base payload pointer. For instance, converts *E!?T into a valid *T</span>
        <span class="tok-comment">/// (clobbering any existing error or null value).</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        opt_eu_base_ptr_init,
        <span class="tok-comment">/// Coerce a given value such that when a reference is taken, the resulting pointer will be</span>
        <span class="tok-comment">/// coercible to the given type. For instance, given a value of type 'u32' and the pointer</span>
        <span class="tok-comment">/// type '*u64', coerces the value to a 'u64'. Asserts that the type is a pointer type.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `Bin`.</span>
        <span class="tok-comment">/// LHS is the pointer type, RHS is the value.</span>
        coerce_ptr_elem_ty,
        <span class="tok-comment">/// Given a type, validate that it is a pointer type suitable for return from the address-of</span>
        <span class="tok-comment">/// operator. Emit a compile error if not.</span>
        <span class="tok-comment">/// Uses the `un_tok` union field. Token is the `&amp;` operator. Operand is the type.</span>
        validate_ref_ty,
        <span class="tok-comment">/// Given a value, check whether it is a valid local constant in this scope.</span>
        <span class="tok-comment">/// In a runtime scope, this is always a nop.</span>
        <span class="tok-comment">/// In a comptime scope, raises a compile error if the value is runtime-known.</span>
        <span class="tok-comment">/// Result is always void.</span>
        <span class="tok-comment">/// Uses the `un_node` union field. Node is the initializer. Operand is the initializer value.</span>
        validate_const,<span class="tok-comment">

        // The following tags all relate to struct initialization expressions.

        </span><span class="tok-comment">/// A struct literal with a specified explicit type, with no fields.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        struct_init_empty,
        <span class="tok-comment">/// An anonymous struct literal with a known result type, with no fields.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        struct_init_empty_result,
        <span class="tok-comment">/// An anonymous struct literal with no fields, returned by reference, with a known result</span>
        <span class="tok-comment">/// type for the pointer. Asserts that the type is a pointer.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        struct_init_empty_ref_result,
        <span class="tok-comment">/// Struct initialization without a type. Creates a value of an anonymous struct type.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `StructInitAnon`.</span>
        struct_init_anon,
        <span class="tok-comment">/// Finalizes a typed struct or union initialization, performs validation, and returns the</span>
        <span class="tok-comment">/// struct or union value. The given type must be validated prior to this instruction, using</span>
        <span class="tok-comment">/// `validate_struct_init_ty` or `validate_struct_init_result_ty`. If the given type is</span>
        <span class="tok-comment">/// generic poison, this is downgraded to an anonymous initialization.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `StructInit`.</span>
        struct_init,
        <span class="tok-comment">/// Struct initialization syntax, make the result a pointer. Equivalent to `struct_init`</span>
        <span class="tok-comment">/// followed by `ref` - this ZIR tag exists as an optimization for a common pattern.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `StructInit`.</span>
        struct_init_ref,
        <span class="tok-comment">/// Checks that the type supports struct init syntax. Always returns void.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        validate_struct_init_ty,
        <span class="tok-comment">/// Like `validate_struct_init_ty`, but additionally accepts types which structs coerce to.</span>
        <span class="tok-comment">/// Used on the known result type of a struct init expression. Always returns void.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        validate_struct_init_result_ty,
        <span class="tok-comment">/// Given a set of `struct_init_field_ptr` instructions, assumes they are all part of a</span>
        <span class="tok-comment">/// struct initialization expression, and emits compile errors for duplicate fields as well</span>
        <span class="tok-comment">/// as missing fields, if applicable.</span>
        <span class="tok-comment">/// This instruction asserts that there is at least one struct_init_field_ptr instruction,</span>
        <span class="tok-comment">/// because it must use one of them to find out the struct type.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `Block`.</span>
        validate_ptr_struct_init,
        <span class="tok-comment">/// Given a type being used for a struct initialization expression, returns the type of the</span>
        <span class="tok-comment">/// field with the given name.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `FieldType`.</span>
        struct_init_field_type,
        <span class="tok-comment">/// Given a pointer being used as the result pointer of a struct initialization expression,</span>
        <span class="tok-comment">/// return a pointer to the field of the given name.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. The AST node is the field initializer. Payload is Field.</span>
        struct_init_field_ptr,<span class="tok-comment">

        // The following tags all relate to array initialization expressions.

        </span><span class="tok-comment">/// Array initialization without a type. Creates a value of a tuple type.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `MultiOp`.</span>
        array_init_anon,
        <span class="tok-comment">/// Array initialization syntax with a known type. The given type must be validated prior to</span>
        <span class="tok-comment">/// this instruction, using some `validate_array_init_*_ty` instruction.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `MultiOp`, where the first operand is the type.</span>
        array_init,
        <span class="tok-comment">/// Array initialization syntax, make the result a pointer. Equivalent to `array_init`</span>
        <span class="tok-comment">/// followed by `ref`- this ZIR tag exists as an optimization for a common pattern.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `MultiOp`, where the first operand is the type.</span>
        array_init_ref,
        <span class="tok-comment">/// Checks that the type supports array init syntax. Always returns void.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `ArrayInit`.</span>
        validate_array_init_ty,
        <span class="tok-comment">/// Like `validate_array_init_ty`, but additionally accepts types which arrays coerce to.</span>
        <span class="tok-comment">/// Used on the known result type of an array init expression. Always returns void.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `ArrayInit`.</span>
        validate_array_init_result_ty,
        <span class="tok-comment">/// Given a pointer or slice type and an element count, return the expected type of an array</span>
        <span class="tok-comment">/// initializer such that a pointer to the initializer has the given pointer type, checking</span>
        <span class="tok-comment">/// that this type supports array init syntax and emitting a compile error if not. Preserves</span>
        <span class="tok-comment">/// error union and optional wrappers on the array type, if any.</span>
        <span class="tok-comment">/// Asserts that the given type is a pointer or slice type.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `ArrayInitRefTy`.</span>
        validate_array_init_ref_ty,
        <span class="tok-comment">/// Given a set of `array_init_elem_ptr` instructions, assumes they are all part of an array</span>
        <span class="tok-comment">/// initialization expression, and emits a compile error if the number of elements does not</span>
        <span class="tok-comment">/// match the array type.</span>
        <span class="tok-comment">/// This instruction asserts that there is at least one `array_init_elem_ptr` instruction,</span>
        <span class="tok-comment">/// because it must use one of them to find out the array type.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `Block`.</span>
        validate_ptr_array_init,
        <span class="tok-comment">/// Given a type being used for an array initialization expression, returns the type of the</span>
        <span class="tok-comment">/// element at the given index.</span>
        <span class="tok-comment">/// Uses the `bin` union field. lhs is the indexable type, rhs is the index.</span>
        array_init_elem_type,
        <span class="tok-comment">/// Given a pointer being used as the result pointer of an array initialization expression,</span>
        <span class="tok-comment">/// return a pointer to the element at the given index.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is an element inside array initialization</span>
        <span class="tok-comment">/// syntax. Payload is `ElemPtrImm`.</span>
        array_init_elem_ptr,

        <span class="tok-comment">/// Implements the `@unionInit` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `UnionInit`.</span>
        union_init,
        <span class="tok-comment">/// Implements the `@typeInfo` builtin. Uses `un_node`.</span>
        type_info,
        <span class="tok-comment">/// Implements the `@sizeOf` builtin. Uses `un_node`.</span>
        size_of,
        <span class="tok-comment">/// Implements the `@bitSizeOf` builtin. Uses `un_node`.</span>
        bit_size_of,

        <span class="tok-comment">/// Implement builtin `@intFromPtr`. Uses `un_node`.</span>
        <span class="tok-comment">/// Convert a pointer to a `usize` integer.</span>
        int_from_ptr,
        <span class="tok-comment">/// Emit an error message and fail compilation.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        compile_error,
        <span class="tok-comment">/// Changes the maximum number of backwards branches that compile-time</span>
        <span class="tok-comment">/// code execution can use before giving up and making a compile error.</span>
        <span class="tok-comment">/// Uses the `un_node` union field.</span>
        set_eval_branch_quota,
        <span class="tok-comment">/// Converts an enum value into an integer. Resulting type will be the tag type</span>
        <span class="tok-comment">/// of the enum. Uses `un_node`.</span>
        int_from_enum,
        <span class="tok-comment">/// Implement builtin `@alignOf`. Uses `un_node`.</span>
        align_of,
        <span class="tok-comment">/// Implement builtin `@intFromBool`. Uses `un_node`.</span>
        int_from_bool,
        <span class="tok-comment">/// Implement builtin `@embedFile`. Uses `un_node`.</span>
        embed_file,
        <span class="tok-comment">/// Implement builtin `@errorName`. Uses `un_node`.</span>
        error_name,
        <span class="tok-comment">/// Implement builtin `@panic`. Uses `un_node`.</span>
        panic,
        <span class="tok-comment">/// Implements `@trap`.</span>
        <span class="tok-comment">/// Uses the `node` field.</span>
        trap,
        <span class="tok-comment">/// Implement builtin `@setRuntimeSafety`. Uses `un_node`.</span>
        set_runtime_safety,
        <span class="tok-comment">/// Implement builtin `@sqrt`. Uses `un_node`.</span>
        sqrt,
        <span class="tok-comment">/// Implement builtin `@sin`. Uses `un_node`.</span>
        sin,
        <span class="tok-comment">/// Implement builtin `@cos`. Uses `un_node`.</span>
        cos,
        <span class="tok-comment">/// Implement builtin `@tan`. Uses `un_node`.</span>
        tan,
        <span class="tok-comment">/// Implement builtin `@exp`. Uses `un_node`.</span>
        exp,
        <span class="tok-comment">/// Implement builtin `@exp2`. Uses `un_node`.</span>
        exp2,
        <span class="tok-comment">/// Implement builtin `@log`. Uses `un_node`.</span>
        log,
        <span class="tok-comment">/// Implement builtin `@log2`. Uses `un_node`.</span>
        log2,
        <span class="tok-comment">/// Implement builtin `@log10`. Uses `un_node`.</span>
        log10,
        <span class="tok-comment">/// Implement builtin `@abs`. Uses `un_node`.</span>
        abs,
        <span class="tok-comment">/// Implement builtin `@floor`. Uses `un_node`.</span>
        floor,
        <span class="tok-comment">/// Implement builtin `@ceil`. Uses `un_node`.</span>
        ceil,
        <span class="tok-comment">/// Implement builtin `@trunc`. Uses `un_node`.</span>
        trunc,
        <span class="tok-comment">/// Implement builtin `@round`. Uses `un_node`.</span>
        round,
        <span class="tok-comment">/// Implement builtin `@tagName`. Uses `un_node`.</span>
        tag_name,
        <span class="tok-comment">/// Implement builtin `@typeName`. Uses `un_node`.</span>
        type_name,
        <span class="tok-comment">/// Implement builtin `@Frame`. Uses `un_node`.</span>
        frame_type,
        <span class="tok-comment">/// Implement builtin `@frameSize`. Uses `un_node`.</span>
        frame_size,

        <span class="tok-comment">/// Implements the `@intFromFloat` builtin.</span>
        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span>
        int_from_float,
        <span class="tok-comment">/// Implements the `@floatFromInt` builtin.</span>
        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span>
        float_from_int,
        <span class="tok-comment">/// Implements the `@ptrFromInt` builtin.</span>
        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span>
        ptr_from_int,
        <span class="tok-comment">/// Converts an integer into an enum value.</span>
        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span>
        enum_from_int,
        <span class="tok-comment">/// Convert a larger float type to any other float type, possibly causing</span>
        <span class="tok-comment">/// a loss of precision.</span>
        <span class="tok-comment">/// Uses the `pl_node` field. AST is the `@floatCast` syntax.</span>
        <span class="tok-comment">/// Payload is `Bin` with lhs as the dest type, rhs the operand.</span>
        float_cast,
        <span class="tok-comment">/// Implements the `@intCast` builtin.</span>
        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span>
        <span class="tok-comment">/// Convert an integer value to another integer type, asserting that the destination type</span>
        <span class="tok-comment">/// can hold the same mathematical value.</span>
        int_cast,
        <span class="tok-comment">/// Implements the `@ptrCast` builtin.</span>
        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span>
        <span class="tok-comment">/// Not every `@ptrCast` will correspond to this instruction - see also</span>
        <span class="tok-comment">/// `ptr_cast_full` in `Extended`.</span>
        ptr_cast,
        <span class="tok-comment">/// Implements the `@truncate` builtin.</span>
        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span>
        truncate,

        <span class="tok-comment">/// Implements the `@hasDecl` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        has_decl,
        <span class="tok-comment">/// Implements the `@hasField` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span>
        has_field,

        <span class="tok-comment">/// Implements the `@clz` builtin. Uses the `un_node` union field.</span>
        clz,
        <span class="tok-comment">/// Implements the `@ctz` builtin. Uses the `un_node` union field.</span>
        ctz,
        <span class="tok-comment">/// Implements the `@popCount` builtin. Uses the `un_node` union field.</span>
        pop_count,
        <span class="tok-comment">/// Implements the `@byteSwap` builtin. Uses the `un_node` union field.</span>
        byte_swap,
        <span class="tok-comment">/// Implements the `@bitReverse` builtin. Uses the `un_node` union field.</span>
        bit_reverse,

        <span class="tok-comment">/// Implements the `@bitOffsetOf` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        bit_offset_of,
        <span class="tok-comment">/// Implements the `@offsetOf` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        offset_of,
        <span class="tok-comment">/// Implements the `@splat` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        splat,
        <span class="tok-comment">/// Implements the `@reduce` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        reduce,
        <span class="tok-comment">/// Implements the `@shuffle` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Shuffle`.</span>
        shuffle,
        <span class="tok-comment">/// Implements the `@atomicLoad` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `AtomicLoad`.</span>
        atomic_load,
        <span class="tok-comment">/// Implements the `@atomicRmw` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `AtomicRmw`.</span>
        atomic_rmw,
        <span class="tok-comment">/// Implements the `@atomicStore` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `AtomicStore`.</span>
        atomic_store,
        <span class="tok-comment">/// Implements the `@mulAdd` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `MulAdd`.</span>
        <span class="tok-comment">/// The addend communicates the type of the builtin.</span>
        <span class="tok-comment">/// The mulends need to be coerced to the same type.</span>
        mul_add,
        <span class="tok-comment">/// Implements the `@memcpy` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        memcpy,
        <span class="tok-comment">/// Implements the `@memset` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span>
        memset,
        <span class="tok-comment">/// Implements the `@min` builtin for 2 args.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`</span>
        min,
        <span class="tok-comment">/// Implements the `@max` builtin for 2 args.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`</span>
        max,
        <span class="tok-comment">/// Implements the `@cImport` builtin.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Block`.</span>
        c_import,

        <span class="tok-comment">/// Allocates stack local memory.</span>
        <span class="tok-comment">/// Uses the `un_node` union field. The operand is the type of the allocated object.</span>
        <span class="tok-comment">/// The node source location points to a var decl node.</span>
        <span class="tok-comment">/// A `make_ptr_const` instruction should be used once the value has</span>
        <span class="tok-comment">/// been stored to the allocation. To ensure comptime value detection</span>
        <span class="tok-comment">/// functions, there are some restrictions on how this pointer should be</span>
        <span class="tok-comment">/// used prior to the `make_ptr_const` instruction: no pointer derived</span>
        <span class="tok-comment">/// from this `alloc` may be returned from a block or stored to another</span>
        <span class="tok-comment">/// address. In other words, it must be trivial to determine whether any</span>
        <span class="tok-comment">/// given pointer derives from this one.</span>
        alloc,
        <span class="tok-comment">/// Same as `alloc` except mutable. As such, `make_ptr_const` need not be used,</span>
        <span class="tok-comment">/// and there are no restrictions on the usage of the pointer.</span>
        alloc_mut,
        <span class="tok-comment">/// Allocates comptime-mutable memory.</span>
        <span class="tok-comment">/// Uses the `un_node` union field. The operand is the type of the allocated object.</span>
        <span class="tok-comment">/// The node source location points to a var decl node.</span>
        alloc_comptime_mut,
        <span class="tok-comment">/// Same as `alloc` except the type is inferred.</span>
        <span class="tok-comment">/// Uses the `node` union field.</span>
        alloc_inferred,
        <span class="tok-comment">/// Same as `alloc_inferred` except mutable.</span>
        alloc_inferred_mut,
        <span class="tok-comment">/// Allocates comptime const memory.</span>
        <span class="tok-comment">/// Uses the `node` union field. The type of the allocated object is inferred.</span>
        <span class="tok-comment">/// The node source location points to a var decl node.</span>
        alloc_inferred_comptime,
        <span class="tok-comment">/// Same as `alloc_comptime_mut` except the type is inferred.</span>
        alloc_inferred_comptime_mut,
        <span class="tok-comment">/// Each `store_to_inferred_ptr` puts the type of the stored value into a set,</span>
        <span class="tok-comment">/// and then `resolve_inferred_alloc` triggers peer type resolution on the set.</span>
        <span class="tok-comment">/// The operand is a `alloc_inferred` or `alloc_inferred_mut` instruction, which</span>
        <span class="tok-comment">/// is the allocation that needs to have its type inferred.</span>
        <span class="tok-comment">/// Results in the final resolved pointer. The `alloc_inferred[_comptime][_mut]`</span>
        <span class="tok-comment">/// instruction should never be referred to after this instruction.</span>
        <span class="tok-comment">/// Uses the `un_node` field. The AST node is the var decl.</span>
        resolve_inferred_alloc,
        <span class="tok-comment">/// Turns a pointer coming from an `alloc` or `Extended.alloc` into a constant</span>
        <span class="tok-comment">/// version of the same pointer. For inferred allocations this is instead implicitly</span>
        <span class="tok-comment">/// handled by the `resolve_inferred_alloc` instruction.</span>
        <span class="tok-comment">/// Uses the `un_node` union field.</span>
        make_ptr_const,

        <span class="tok-comment">/// Implements `resume` syntax. Uses `un_node` field.</span>
        @&quot;resume&quot;,
        @&quot;await&quot;,

        <span class="tok-comment">/// A defer statement.</span>
        <span class="tok-comment">/// Uses the `defer` union field.</span>
        @&quot;defer&quot;,
        <span class="tok-comment">/// An errdefer statement with a code.</span>
        <span class="tok-comment">/// Uses the `err_defer_code` union field.</span>
        defer_err_code,

        <span class="tok-comment">/// Requests that Sema update the saved error return trace index for the enclosing</span>
        <span class="tok-comment">/// block, if the operand is .none or of an error/error-union type.</span>
        <span class="tok-comment">/// Uses the `save_err_ret_index` field.</span>
        save_err_ret_index,
        <span class="tok-comment">/// Specialized form of `Extended.restore_err_ret_index`.</span>
        <span class="tok-comment">/// Unconditionally restores the error return index to its last saved state</span>
        <span class="tok-comment">/// in the block referred to by `operand`. If `operand` is `none`, restores</span>
        <span class="tok-comment">/// to the point of function entry.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        restore_err_ret_index_unconditional,
        <span class="tok-comment">/// Specialized form of `Extended.restore_err_ret_index`.</span>
        <span class="tok-comment">/// Restores the error return index to its state at the entry of</span>
        <span class="tok-comment">/// the current function conditional on `operand` being a non-error.</span>
        <span class="tok-comment">/// If `operand` is `none`, restores unconditionally.</span>
        <span class="tok-comment">/// Uses the `un_node` field.</span>
        restore_err_ret_index_fn_entry,

        <span class="tok-comment">/// The ZIR instruction tag is one of the `Extended` ones.</span>
        <span class="tok-comment">/// Uses the `extended` union field.</span>
        extended,

        <span class="tok-comment">/// Returns whether the instruction is one of the control flow &quot;noreturn&quot; types.</span>
        <span class="tok-comment">/// Function calls do not count.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNoReturn</span>(tag: <a href="std.zig.Zir.Inst.Tag.html">Tag</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {
                .param,
                .param_comptime,
                .param_anytype,
                .param_anytype_comptime,
                .add,
                .addwrap,
                .add_sat,
                .add_unsafe,
                .alloc,
                .alloc_mut,
                .alloc_comptime_mut,
                .alloc_inferred,
                .alloc_inferred_mut,
                .alloc_inferred_comptime,
                .alloc_inferred_comptime_mut,
                .make_ptr_const,
                .array_cat,
                .array_mul,
                .array_type,
                .array_type_sentinel,
                .vector_type,
                .elem_type,
                .indexable_ptr_elem_type,
                .vec_arr_elem_type,
                .indexable_ptr_len,
                .anyframe_type,
                .as_node,
                .as_shift_operand,
                .bit_and,
                .bitcast,
                .bit_or,
                .block,
                .block_comptime,
                .block_inline,
                .declaration,
                .suspend_block,
                .loop,
                .bool_br_and,
                .bool_br_or,
                .bool_not,
                .call,
                .field_call,
                .cmp_lt,
                .cmp_lte,
                .cmp_eq,
                .cmp_gte,
                .cmp_gt,
                .cmp_neq,
                .error_set_decl,
                .dbg_stmt,
                .dbg_var_ptr,
                .dbg_var_val,
                .decl_ref,
                .decl_val,
                .load,
                .div,
                .elem_ptr,
                .elem_val,
                .elem_ptr_node,
                .elem_val_node,
                .elem_val_imm,
                .ensure_result_used,
                .ensure_result_non_error,
                .ensure_err_union_payload_void,
                .@&quot;export&quot;,
                .field_ptr,
                .field_val,
                .field_ptr_named,
                .field_val_named,
                .func,
                .func_inferred,
                .func_fancy,
                .has_decl,
                .int,
                .int_big,
                .float,
                .float128,
                .int_type,
                .is_non_null,
                .is_non_null_ptr,
                .is_non_err,
                .is_non_err_ptr,
                .ret_is_non_err,
                .mod_rem,
                .mul,
                .mulwrap,
                .mul_sat,
                .ref,
                .shl,
                .shl_sat,
                .shr,
                .store_node,
                .store_to_inferred_ptr,
                .str,
                .sub,
                .subwrap,
                .sub_sat,
                .negate,
                .negate_wrap,
                .typeof,
                .typeof_builtin,
                .xor,
                .optional_type,
                .optional_payload_safe,
                .optional_payload_unsafe,
                .optional_payload_safe_ptr,
                .optional_payload_unsafe_ptr,
                .err_union_payload_unsafe,
                .err_union_payload_unsafe_ptr,
                .err_union_code,
                .err_union_code_ptr,
                .ptr_type,
                .enum_literal,
                .decl_literal,
                .decl_literal_no_coerce,
                .merge_error_sets,
                .error_union_type,
                .bit_not,
                .error_value,
                .slice_start,
                .slice_end,
                .slice_sentinel,
                .slice_length,
                .slice_sentinel_ty,
                .import,
                .typeof_log2_int_type,
                .resolve_inferred_alloc,
                .set_eval_branch_quota,
                .switch_block,
                .switch_block_ref,
                .switch_block_err_union,
                .validate_deref,
                .validate_destructure,
                .union_init,
                .field_type_ref,
                .enum_from_int,
                .int_from_enum,
                .type_info,
                .size_of,
                .bit_size_of,
                .int_from_ptr,
                .align_of,
                .int_from_bool,
                .embed_file,
                .error_name,
                .set_runtime_safety,
                .sqrt,
                .sin,
                .cos,
                .tan,
                .exp,
                .exp2,
                .log,
                .log2,
                .log10,
                .abs,
                .floor,
                .ceil,
                .trunc,
                .round,
                .tag_name,
                .type_name,
                .frame_type,
                .frame_size,
                .int_from_float,
                .float_from_int,
                .ptr_from_int,
                .float_cast,
                .int_cast,
                .ptr_cast,
                .truncate,
                .has_field,
                .clz,
                .ctz,
                .pop_count,
                .byte_swap,
                .bit_reverse,
                .div_exact,
                .div_floor,
                .div_trunc,
                .mod,
                .rem,
                .shl_exact,
                .shr_exact,
                .bit_offset_of,
                .offset_of,
                .splat,
                .reduce,
                .shuffle,
                .atomic_load,
                .atomic_rmw,
                .atomic_store,
                .mul_add,
                .builtin_call,
                .max,
                .memcpy,
                .memset,
                .min,
                .c_import,
                .@&quot;resume&quot;,
                .@&quot;await&quot;,
                .ret_err_value_code,
                .extended,
                .ret_ptr,
                .ret_type,
                .@&quot;try&quot;,
                .try_ptr,
                .@&quot;defer&quot;,
                .defer_err_code,
                .save_err_ret_index,
                .for_len,
                .opt_eu_base_ptr_init,
                .coerce_ptr_elem_ty,
                .struct_init_empty,
                .struct_init_empty_result,
                .struct_init_empty_ref_result,
                .struct_init_anon,
                .struct_init,
                .struct_init_ref,
                .validate_struct_init_ty,
                .validate_struct_init_result_ty,
                .validate_ptr_struct_init,
                .struct_init_field_type,
                .struct_init_field_ptr,
                .array_init_anon,
                .array_init,
                .array_init_ref,
                .validate_array_init_ty,
                .validate_array_init_result_ty,
                .validate_array_init_ref_ty,
                .validate_ptr_array_init,
                .array_init_elem_type,
                .array_init_elem_ptr,
                .validate_ref_ty,
                .validate_const,
                .restore_err_ret_index_unconditional,
                .restore_err_ret_index_fn_entry,
                =&gt; <span class="tok-null">false</span>,

                .@&quot;break&quot;,
                .break_inline,
                .condbr,
                .condbr_inline,
                .compile_error,
                .ret_node,
                .ret_load,
                .ret_implicit,
                .ret_err_value,
                .@&quot;unreachable&quot;,
                .repeat,
                .repeat_inline,
                .panic,
                .trap,
                .check_comptime_control_flow,
                .switch_continue,
                =&gt; <span class="tok-null">true</span>,
            };
        }

        <span class="tok-comment">/// AstGen uses this to find out if `Ref.void_value` should be used in place</span>
        <span class="tok-comment">/// of the result of a given instruction. This allows Sema to forego adding</span>
        <span class="tok-comment">/// the instruction to the map after analysis.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlwaysVoid</span>(tag: <a href="std.zig.Zir.Inst.Tag.html">Tag</a>, data: <a href="std.zig.Zir.Inst.Data.html">Data</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {
                .dbg_stmt,
                .dbg_var_ptr,
                .dbg_var_val,
                .ensure_result_used,
                .ensure_result_non_error,
                .ensure_err_union_payload_void,
                .set_eval_branch_quota,
                .atomic_store,
                .store_node,
                .store_to_inferred_ptr,
                .validate_deref,
                .validate_destructure,
                .@&quot;export&quot;,
                .set_runtime_safety,
                .memcpy,
                .memset,
                .check_comptime_control_flow,
                .@&quot;defer&quot;,
                .defer_err_code,
                .save_err_ret_index,
                .restore_err_ret_index_unconditional,
                .restore_err_ret_index_fn_entry,
                .validate_struct_init_ty,
                .validate_struct_init_result_ty,
                .validate_ptr_struct_init,
                .validate_array_init_ty,
                .validate_array_init_result_ty,
                .validate_ptr_array_init,
                .validate_ref_ty,
                .validate_const,
                =&gt; <span class="tok-null">true</span>,

                .param,
                .param_comptime,
                .param_anytype,
                .param_anytype_comptime,
                .add,
                .addwrap,
                .add_sat,
                .add_unsafe,
                .alloc,
                .alloc_mut,
                .alloc_comptime_mut,
                .alloc_inferred,
                .alloc_inferred_mut,
                .alloc_inferred_comptime,
                .alloc_inferred_comptime_mut,
                .resolve_inferred_alloc,
                .make_ptr_const,
                .array_cat,
                .array_mul,
                .array_type,
                .array_type_sentinel,
                .vector_type,
                .elem_type,
                .indexable_ptr_elem_type,
                .vec_arr_elem_type,
                .indexable_ptr_len,
                .anyframe_type,
                .as_node,
                .as_shift_operand,
                .bit_and,
                .bitcast,
                .bit_or,
                .block,
                .block_comptime,
                .block_inline,
                .declaration,
                .suspend_block,
                .loop,
                .bool_br_and,
                .bool_br_or,
                .bool_not,
                .call,
                .field_call,
                .cmp_lt,
                .cmp_lte,
                .cmp_eq,
                .cmp_gte,
                .cmp_gt,
                .cmp_neq,
                .error_set_decl,
                .decl_ref,
                .decl_val,
                .load,
                .div,
                .elem_ptr,
                .elem_val,
                .elem_ptr_node,
                .elem_val_node,
                .elem_val_imm,
                .field_ptr,
                .field_val,
                .field_ptr_named,
                .field_val_named,
                .func,
                .func_inferred,
                .func_fancy,
                .has_decl,
                .int,
                .int_big,
                .float,
                .float128,
                .int_type,
                .is_non_null,
                .is_non_null_ptr,
                .is_non_err,
                .is_non_err_ptr,
                .ret_is_non_err,
                .mod_rem,
                .mul,
                .mulwrap,
                .mul_sat,
                .ref,
                .shl,
                .shl_sat,
                .shr,
                .str,
                .sub,
                .subwrap,
                .sub_sat,
                .negate,
                .negate_wrap,
                .typeof,
                .typeof_builtin,
                .xor,
                .optional_type,
                .optional_payload_safe,
                .optional_payload_unsafe,
                .optional_payload_safe_ptr,
                .optional_payload_unsafe_ptr,
                .err_union_payload_unsafe,
                .err_union_payload_unsafe_ptr,
                .err_union_code,
                .err_union_code_ptr,
                .ptr_type,
                .enum_literal,
                .decl_literal,
                .decl_literal_no_coerce,
                .merge_error_sets,
                .error_union_type,
                .bit_not,
                .error_value,
                .slice_start,
                .slice_end,
                .slice_sentinel,
                .slice_length,
                .slice_sentinel_ty,
                .import,
                .typeof_log2_int_type,
                .switch_block,
                .switch_block_ref,
                .switch_block_err_union,
                .union_init,
                .field_type_ref,
                .enum_from_int,
                .int_from_enum,
                .type_info,
                .size_of,
                .bit_size_of,
                .int_from_ptr,
                .align_of,
                .int_from_bool,
                .embed_file,
                .error_name,
                .sqrt,
                .sin,
                .cos,
                .tan,
                .exp,
                .exp2,
                .log,
                .log2,
                .log10,
                .abs,
                .floor,
                .ceil,
                .trunc,
                .round,
                .tag_name,
                .type_name,
                .frame_type,
                .frame_size,
                .int_from_float,
                .float_from_int,
                .ptr_from_int,
                .float_cast,
                .int_cast,
                .ptr_cast,
                .truncate,
                .has_field,
                .clz,
                .ctz,
                .pop_count,
                .byte_swap,
                .bit_reverse,
                .div_exact,
                .div_floor,
                .div_trunc,
                .mod,
                .rem,
                .shl_exact,
                .shr_exact,
                .bit_offset_of,
                .offset_of,
                .splat,
                .reduce,
                .shuffle,
                .atomic_load,
                .atomic_rmw,
                .mul_add,
                .builtin_call,
                .max,
                .min,
                .c_import,
                .@&quot;resume&quot;,
                .@&quot;await&quot;,
                .ret_err_value_code,
                .@&quot;break&quot;,
                .break_inline,
                .condbr,
                .condbr_inline,
                .switch_continue,
                .compile_error,
                .ret_node,
                .ret_load,
                .ret_implicit,
                .ret_err_value,
                .ret_ptr,
                .ret_type,
                .@&quot;unreachable&quot;,
                .repeat,
                .repeat_inline,
                .panic,
                .trap,
                .for_len,
                .@&quot;try&quot;,
                .try_ptr,
                .opt_eu_base_ptr_init,
                .coerce_ptr_elem_ty,
                .struct_init_empty,
                .struct_init_empty_result,
                .struct_init_empty_ref_result,
                .struct_init_anon,
                .struct_init,
                .struct_init_ref,
                .struct_init_field_type,
                .struct_init_field_ptr,
                .array_init_anon,
                .array_init,
                .array_init_ref,
                .validate_array_init_ref_ty,
                .array_init_elem_type,
                .array_init_elem_ptr,
                =&gt; <span class="tok-null">false</span>,

                .extended =&gt; <span class="tok-kw">switch</span> (data.extended.opcode) {
                    .branch_hint,
                    .breakpoint,
                    .disable_instrumentation,
                    .disable_intrinsics,
                    =&gt; <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                },
            };
        }

        <span class="tok-comment">/// Used by debug safety-checking code.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> data_tags = list: {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2000</span>);
            <span class="tok-kw">break</span> :list <a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.directEnumArray">directEnumArray</a>(<a href="std.zig.Zir.Inst.Tag.html">Tag</a>, <a href="std.zig.Zir.Inst.Data.html">Data</a>.<a href="std.zig.Zir.Inst.Data.FieldEnum.html">FieldEnum</a>, <span class="tok-number">0</span>, .{
                .add = .pl_node,
                .addwrap = .pl_node,
                .add_sat = .pl_node,
                .add_unsafe = .pl_node,
                .sub = .pl_node,
                .subwrap = .pl_node,
                .sub_sat = .pl_node,
                .mul = .pl_node,
                .mulwrap = .pl_node,
                .mul_sat = .pl_node,

                .param = .pl_tok,
                .param_comptime = .pl_tok,
                .param_anytype = .str_tok,
                .param_anytype_comptime = .str_tok,
                .array_cat = .pl_node,
                .array_mul = .pl_node,
                .array_type = .pl_node,
                .array_type_sentinel = .pl_node,
                .vector_type = .pl_node,
                .elem_type = .un_node,
                .indexable_ptr_elem_type = .un_node,
                .vec_arr_elem_type = .un_node,
                .indexable_ptr_len = .un_node,
                .anyframe_type = .un_node,
                .as_node = .pl_node,
                .as_shift_operand = .pl_node,
                .bit_and = .pl_node,
                .bitcast = .pl_node,
                .bit_not = .un_node,
                .bit_or = .pl_node,
                .block = .pl_node,
                .block_comptime = .pl_node,
                .block_inline = .pl_node,
                .declaration = .declaration,
                .suspend_block = .pl_node,
                .bool_not = .un_node,
                .bool_br_and = .pl_node,
                .bool_br_or = .pl_node,
                .@&quot;break&quot; = .@&quot;break&quot;,
                .break_inline = .@&quot;break&quot;,
                .switch_continue = .@&quot;break&quot;,
                .check_comptime_control_flow = .un_node,
                .for_len = .pl_node,
                .call = .pl_node,
                .field_call = .pl_node,
                .cmp_lt = .pl_node,
                .cmp_lte = .pl_node,
                .cmp_eq = .pl_node,
                .cmp_gte = .pl_node,
                .cmp_gt = .pl_node,
                .cmp_neq = .pl_node,
                .condbr = .pl_node,
                .condbr_inline = .pl_node,
                .@&quot;try&quot; = .pl_node,
                .try_ptr = .pl_node,
                .error_set_decl = .pl_node,
                .dbg_stmt = .dbg_stmt,
                .dbg_var_ptr = .str_op,
                .dbg_var_val = .str_op,
                .decl_ref = .str_tok,
                .decl_val = .str_tok,
                .load = .un_node,
                .div = .pl_node,
                .elem_ptr = .pl_node,
                .elem_ptr_node = .pl_node,
                .elem_val = .pl_node,
                .elem_val_node = .pl_node,
                .elem_val_imm = .elem_val_imm,
                .ensure_result_used = .un_node,
                .ensure_result_non_error = .un_node,
                .ensure_err_union_payload_void = .un_node,
                .error_union_type = .pl_node,
                .error_value = .str_tok,
                .@&quot;export&quot; = .pl_node,
                .field_ptr = .pl_node,
                .field_val = .pl_node,
                .field_ptr_named = .pl_node,
                .field_val_named = .pl_node,
                .func = .pl_node,
                .func_inferred = .pl_node,
                .func_fancy = .pl_node,
                .import = .pl_tok,
                .int = .int,
                .int_big = .str,
                .float = .float,
                .float128 = .pl_node,
                .int_type = .int_type,
                .is_non_null = .un_node,
                .is_non_null_ptr = .un_node,
                .is_non_err = .un_node,
                .is_non_err_ptr = .un_node,
                .ret_is_non_err = .un_node,
                .loop = .pl_node,
                .repeat = .node,
                .repeat_inline = .node,
                .merge_error_sets = .pl_node,
                .mod_rem = .pl_node,
                .ref = .un_tok,
                .ret_node = .un_node,
                .ret_load = .un_node,
                .ret_implicit = .un_tok,
                .ret_err_value = .str_tok,
                .ret_err_value_code = .str_tok,
                .ret_ptr = .node,
                .ret_type = .node,
                .ptr_type = .ptr_type,
                .slice_start = .pl_node,
                .slice_end = .pl_node,
                .slice_sentinel = .pl_node,
                .slice_length = .pl_node,
                .slice_sentinel_ty = .un_node,
                .store_node = .pl_node,
                .store_to_inferred_ptr = .pl_node,
                .str = .str,
                .negate = .un_node,
                .negate_wrap = .un_node,
                .typeof = .un_node,
                .typeof_log2_int_type = .un_node,
                .@&quot;unreachable&quot; = .@&quot;unreachable&quot;,
                .xor = .pl_node,
                .optional_type = .un_node,
                .optional_payload_safe = .un_node,
                .optional_payload_unsafe = .un_node,
                .optional_payload_safe_ptr = .un_node,
                .optional_payload_unsafe_ptr = .un_node,
                .err_union_payload_unsafe = .un_node,
                .err_union_payload_unsafe_ptr = .un_node,
                .err_union_code = .un_node,
                .err_union_code_ptr = .un_node,
                .enum_literal = .str_tok,
                .decl_literal = .pl_node,
                .decl_literal_no_coerce = .pl_node,
                .switch_block = .pl_node,
                .switch_block_ref = .pl_node,
                .switch_block_err_union = .pl_node,
                .validate_deref = .un_node,
                .validate_destructure = .pl_node,
                .field_type_ref = .pl_node,
                .union_init = .pl_node,
                .type_info = .un_node,
                .size_of = .un_node,
                .bit_size_of = .un_node,
                .opt_eu_base_ptr_init = .un_node,
                .coerce_ptr_elem_ty = .pl_node,
                .validate_ref_ty = .un_tok,
                .validate_const = .un_node,

                .int_from_ptr = .un_node,
                .compile_error = .un_node,
                .set_eval_branch_quota = .un_node,
                .int_from_enum = .un_node,
                .align_of = .un_node,
                .int_from_bool = .un_node,
                .embed_file = .un_node,
                .error_name = .un_node,
                .panic = .un_node,
                .trap = .node,
                .set_runtime_safety = .un_node,
                .sqrt = .un_node,
                .sin = .un_node,
                .cos = .un_node,
                .tan = .un_node,
                .exp = .un_node,
                .exp2 = .un_node,
                .log = .un_node,
                .log2 = .un_node,
                .log10 = .un_node,
                .abs = .un_node,
                .floor = .un_node,
                .ceil = .un_node,
                .trunc = .un_node,
                .round = .un_node,
                .tag_name = .un_node,
                .type_name = .un_node,
                .frame_type = .un_node,
                .frame_size = .un_node,

                .int_from_float = .pl_node,
                .float_from_int = .pl_node,
                .ptr_from_int = .pl_node,
                .enum_from_int = .pl_node,
                .float_cast = .pl_node,
                .int_cast = .pl_node,
                .ptr_cast = .pl_node,
                .truncate = .pl_node,
                .typeof_builtin = .pl_node,

                .has_decl = .pl_node,
                .has_field = .pl_node,

                .clz = .un_node,
                .ctz = .un_node,
                .pop_count = .un_node,
                .byte_swap = .un_node,
                .bit_reverse = .un_node,

                .div_exact = .pl_node,
                .div_floor = .pl_node,
                .div_trunc = .pl_node,
                .mod = .pl_node,
                .rem = .pl_node,

                .shl = .pl_node,
                .shl_exact = .pl_node,
                .shl_sat = .pl_node,
                .shr = .pl_node,
                .shr_exact = .pl_node,

                .bit_offset_of = .pl_node,
                .offset_of = .pl_node,
                .splat = .pl_node,
                .reduce = .pl_node,
                .shuffle = .pl_node,
                .atomic_load = .pl_node,
                .atomic_rmw = .pl_node,
                .atomic_store = .pl_node,
                .mul_add = .pl_node,
                .builtin_call = .pl_node,
                .max = .pl_node,
                .memcpy = .pl_node,
                .memset = .pl_node,
                .min = .pl_node,
                .c_import = .pl_node,

                .alloc = .un_node,
                .alloc_mut = .un_node,
                .alloc_comptime_mut = .un_node,
                .alloc_inferred = .node,
                .alloc_inferred_mut = .node,
                .alloc_inferred_comptime = .node,
                .alloc_inferred_comptime_mut = .node,
                .resolve_inferred_alloc = .un_node,
                .make_ptr_const = .un_node,

                .@&quot;resume&quot; = .un_node,
                .@&quot;await&quot; = .un_node,

                .@&quot;defer&quot; = .@&quot;defer&quot;,
                .defer_err_code = .defer_err_code,

                .save_err_ret_index = .save_err_ret_index,
                .restore_err_ret_index_unconditional = .un_node,
                .restore_err_ret_index_fn_entry = .un_node,

                .struct_init_empty = .un_node,
                .struct_init_empty_result = .un_node,
                .struct_init_empty_ref_result = .un_node,
                .struct_init_anon = .pl_node,
                .struct_init = .pl_node,
                .struct_init_ref = .pl_node,
                .validate_struct_init_ty = .un_node,
                .validate_struct_init_result_ty = .un_node,
                .validate_ptr_struct_init = .pl_node,
                .struct_init_field_type = .pl_node,
                .struct_init_field_ptr = .pl_node,
                .array_init_anon = .pl_node,
                .array_init = .pl_node,
                .array_init_ref = .pl_node,
                .validate_array_init_ty = .pl_node,
                .validate_array_init_result_ty = .pl_node,
                .validate_array_init_ref_ty = .pl_node,
                .validate_ptr_array_init = .pl_node,
                .array_init_elem_type = .bin,
                .array_init_elem_ptr = .pl_node,

                .extended = .extended,
            });
        };<span class="tok-comment">

        // Uncomment to view how many tag slots are available.
        //comptime {
        //    @compileLog(&quot;ZIR tags left: &quot;, 256 - @typeInfo(Tag).@&quot;enum&quot;.fields.len);
        //}
    </span>};

    <span class="tok-comment">/// Rarer instructions are here; ones that do not fit in the 8-bit `Tag` enum.</span>
    <span class="tok-comment">/// `noreturn` instructions may not go here; they must be part of the main `Tag` enum.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Extended = <span class="tok-kw">enum</span>(<span class="tok-type">u16</span>) {
        <span class="tok-comment">/// A struct type definition. Contains references to ZIR instructions for</span>
        <span class="tok-comment">/// the field types, defaults, and alignments.</span>
        <span class="tok-comment">/// `operand` is payload index to `StructDecl`.</span>
        <span class="tok-comment">/// `small` is `StructDecl.Small`.</span>
        struct_decl,
        <span class="tok-comment">/// An enum type definition. Contains references to ZIR instructions for</span>
        <span class="tok-comment">/// the field value expressions and optional type tag expression.</span>
        <span class="tok-comment">/// `operand` is payload index to `EnumDecl`.</span>
        <span class="tok-comment">/// `small` is `EnumDecl.Small`.</span>
        enum_decl,
        <span class="tok-comment">/// A union type definition. Contains references to ZIR instructions for</span>
        <span class="tok-comment">/// the field types and optional type tag expression.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnionDecl`.</span>
        <span class="tok-comment">/// `small` is `UnionDecl.Small`.</span>
        union_decl,
        <span class="tok-comment">/// An opaque type definition. Contains references to decls and captures.</span>
        <span class="tok-comment">/// `operand` is payload index to `OpaqueDecl`.</span>
        <span class="tok-comment">/// `small` is `OpaqueDecl.Small`.</span>
        opaque_decl,
        <span class="tok-comment">/// A tuple type. Note that tuples are not namespace/container types.</span>
        <span class="tok-comment">/// `operand` is payload index to `TupleDecl`.</span>
        <span class="tok-comment">/// `small` is `fields_len: u16`.</span>
        tuple_decl,
        <span class="tok-comment">/// Implements the `@This` builtin.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        this,
        <span class="tok-comment">/// Implements the `@returnAddress` builtin.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        ret_addr,
        <span class="tok-comment">/// Implements the `@src` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `LineColumn`.</span>
        builtin_src,
        <span class="tok-comment">/// Implements the `@errorReturnTrace` builtin.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        error_return_trace,
        <span class="tok-comment">/// Implements the `@frame` builtin.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        frame,
        <span class="tok-comment">/// Implements the `@frameAddress` builtin.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        frame_address,
        <span class="tok-comment">/// Same as `alloc` from `Tag` but may contain an alignment instruction.</span>
        <span class="tok-comment">/// `operand` is payload index to `AllocExtended`.</span>
        <span class="tok-comment">/// `small`:</span>
        <span class="tok-comment">///  * 0b000X - has type</span>
        <span class="tok-comment">///  * 0b00X0 - has alignment</span>
        <span class="tok-comment">///  * 0b0X00 - 1=const, 0=var</span>
        <span class="tok-comment">///  * 0bX000 - is comptime</span>
        alloc,
        <span class="tok-comment">/// The `@extern` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        builtin_extern,
        <span class="tok-comment">/// Inline assembly.</span>
        <span class="tok-comment">/// `small`:</span>
        <span class="tok-comment">///  * 0b00000000_000XXXXX - `outputs_len`.</span>
        <span class="tok-comment">///  * 0b000000XX_XXX00000 - `inputs_len`.</span>
        <span class="tok-comment">///  * 0b0XXXXX00_00000000 - `clobbers_len`.</span>
        <span class="tok-comment">///  * 0bX0000000_00000000 - is volatile</span>
        <span class="tok-comment">/// `operand` is payload index to `Asm`.</span>
        @&quot;asm&quot;,
        <span class="tok-comment">/// Same as `asm` except the assembly template is not a string literal but a comptime</span>
        <span class="tok-comment">/// expression.</span>
        <span class="tok-comment">/// The `asm_source` field of the Asm is not a null-terminated string</span>
        <span class="tok-comment">/// but instead a Ref.</span>
        asm_expr,
        <span class="tok-comment">/// Log compile time variables and emit an error message.</span>
        <span class="tok-comment">/// `operand` is payload index to `NodeMultiOp`.</span>
        <span class="tok-comment">/// `small` is `operands_len`.</span>
        <span class="tok-comment">/// The AST node is the compile log builtin call.</span>
        compile_log,
        <span class="tok-comment">/// The builtin `@TypeOf` which returns the type after Peer Type Resolution</span>
        <span class="tok-comment">/// of one or more params.</span>
        <span class="tok-comment">/// `operand` is payload index to `TypeOfPeer`.</span>
        <span class="tok-comment">/// `small` is `operands_len`.</span>
        <span class="tok-comment">/// The AST node is the builtin call.</span>
        typeof_peer,
        <span class="tok-comment">/// Implements the `@min` builtin for more than 2 args.</span>
        <span class="tok-comment">/// `operand` is payload index to `NodeMultiOp`.</span>
        <span class="tok-comment">/// `small` is `operands_len`.</span>
        <span class="tok-comment">/// The AST node is the builtin call.</span>
        min_multi,
        <span class="tok-comment">/// Implements the `@max` builtin for more than 2 args.</span>
        <span class="tok-comment">/// `operand` is payload index to `NodeMultiOp`.</span>
        <span class="tok-comment">/// `small` is `operands_len`.</span>
        <span class="tok-comment">/// The AST node is the builtin call.</span>
        max_multi,
        <span class="tok-comment">/// Implements the `@addWithOverflow` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        <span class="tok-comment">/// `small` is unused.</span>
        add_with_overflow,
        <span class="tok-comment">/// Implements the `@subWithOverflow` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        <span class="tok-comment">/// `small` is unused.</span>
        sub_with_overflow,
        <span class="tok-comment">/// Implements the `@mulWithOverflow` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        <span class="tok-comment">/// `small` is unused.</span>
        mul_with_overflow,
        <span class="tok-comment">/// Implements the `@shlWithOverflow` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        <span class="tok-comment">/// `small` is unused.</span>
        shl_with_overflow,
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        c_undef,
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        c_include,
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        c_define,
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        wasm_memory_size,
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        wasm_memory_grow,
        <span class="tok-comment">/// The `@prefetch` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        prefetch,
        <span class="tok-comment">/// Implement builtin `@setFloatMode`.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        set_float_mode,
        <span class="tok-comment">/// Implements the `@errorCast` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`. `lhs` is dest type, `rhs` is operand.</span>
        error_cast,
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        await_nosuspend,
        <span class="tok-comment">/// Implements `@breakpoint`.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        breakpoint,
        <span class="tok-comment">/// Implement builtin `@disableInstrumentation`. `operand` is `src_node: i32`.</span>
        disable_instrumentation,
        <span class="tok-comment">/// Implement builtin `@disableIntrinsics`. `operand` is `src_node: i32`.</span>
        disable_intrinsics,
        <span class="tok-comment">/// Implements the `@select` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `Select`.</span>
        select,
        <span class="tok-comment">/// Implement builtin `@errToInt`.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        int_from_error,
        <span class="tok-comment">/// Implement builtin `@errorFromInt`.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        error_from_int,
        <span class="tok-comment">/// Implement builtin `@Type`.</span>
        <span class="tok-comment">/// `operand` is payload index to `Reify`.</span>
        <span class="tok-comment">/// `small` contains `NameStrategy`.</span>
        reify,
        <span class="tok-comment">/// Implements the `@asyncCall` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `AsyncCall`.</span>
        builtin_async_call,
        <span class="tok-comment">/// Implements the `@cmpxchgStrong` and `@cmpxchgWeak` builtins.</span>
        <span class="tok-comment">/// `small` 0=&gt;weak 1=&gt;strong</span>
        <span class="tok-comment">/// `operand` is payload index to `Cmpxchg`.</span>
        cmpxchg,
        <span class="tok-comment">/// Implement builtin `@cVaArg`.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        c_va_arg,
        <span class="tok-comment">/// Implement builtin `@cVaCopy`.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        c_va_copy,
        <span class="tok-comment">/// Implement builtin `@cVaEnd`.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        c_va_end,
        <span class="tok-comment">/// Implement builtin `@cVaStart`.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        c_va_start,
        <span class="tok-comment">/// Implements the following builtins:</span>
        <span class="tok-comment">/// `@ptrCast`, `@alignCast`, `@addrSpaceCast`, `@constCast`, `@volatileCast`.</span>
        <span class="tok-comment">/// Represents an arbitrary nesting of the above builtins. Such a nesting is treated as a</span>
        <span class="tok-comment">/// single operation which can modify multiple components of a pointer type.</span>
        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span>
        <span class="tok-comment">/// `small` contains `FullPtrCastFlags`.</span>
        <span class="tok-comment">/// AST node is the root of the nested casts.</span>
        <span class="tok-comment">/// `lhs` is dest type, `rhs` is operand.</span>
        ptr_cast_full,
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        <span class="tok-comment">/// `small` contains `FullPtrCastFlags`.</span>
        <span class="tok-comment">/// Guaranteed to only have flags where no explicit destination type is</span>
        <span class="tok-comment">/// required (const_cast and volatile_cast).</span>
        <span class="tok-comment">/// AST node is the root of the nested casts.</span>
        ptr_cast_no_dest,
        <span class="tok-comment">/// Implements the `@workItemId` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        work_item_id,
        <span class="tok-comment">/// Implements the `@workGroupSize` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        work_group_size,
        <span class="tok-comment">/// Implements the `@workGroupId` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        work_group_id,
        <span class="tok-comment">/// Implements the `@inComptime` builtin.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        in_comptime,
        <span class="tok-comment">/// Restores the error return index to its last saved state in a given</span>
        <span class="tok-comment">/// block. If the block is `.none`, restores to the state from the point</span>
        <span class="tok-comment">/// of function entry. If the operand is not `.none`, the restore is</span>
        <span class="tok-comment">/// conditional on the operand value not being an error.</span>
        <span class="tok-comment">/// `operand` is payload index to `RestoreErrRetIndex`.</span>
        <span class="tok-comment">/// `small` is undefined.</span>
        restore_err_ret_index,
        <span class="tok-comment">/// Retrieves a value from the current type declaration scope's closure.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        <span class="tok-comment">/// `small` is closure index.</span>
        closure_get,
        <span class="tok-comment">/// Used as a placeholder instruction which is just a dummy index for Sema to replace</span>
        <span class="tok-comment">/// with a specific value. For instance, this is used for the capture of an `errdefer`.</span>
        <span class="tok-comment">/// This should never appear in a body.</span>
        value_placeholder,
        <span class="tok-comment">/// Implements the `@fieldParentPtr` builtin.</span>
        <span class="tok-comment">/// `operand` is payload index to `FieldParentPtr`.</span>
        <span class="tok-comment">/// `small` contains `FullPtrCastFlags`.</span>
        <span class="tok-comment">/// Guaranteed to not have the `ptr_cast` flag.</span>
        <span class="tok-comment">/// Uses the `pl_node` union field with payload `FieldParentPtr`.</span>
        field_parent_ptr,
        <span class="tok-comment">/// Get a type or value from `std.builtin`.</span>
        <span class="tok-comment">/// `operand` is `src_node: i32`.</span>
        <span class="tok-comment">/// `small` is an `Inst.BuiltinValue`.</span>
        builtin_value,
        <span class="tok-comment">/// Provide a `@branchHint` for the current block.</span>
        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span>
        <span class="tok-comment">/// `small` is unused.</span>
        branch_hint,
        <span class="tok-comment">/// Compute the result type for in-place arithmetic, e.g. `+=`.</span>
        <span class="tok-comment">/// `operand` is `Zir.Inst.Ref` of the loaded LHS (*not* its type).</span>
        <span class="tok-comment">/// `small` is an `Inst.InplaceOp`.</span>
        inplace_arith_result_ty,
        <span class="tok-comment">/// Marks a statement that can be stepped to but produces no code.</span>
        <span class="tok-comment">/// `operand` and `small` are ignored.</span>
        dbg_empty_stmt,
        <span class="tok-comment">/// At this point, AstGen encountered a fatal error which terminated ZIR lowering for this body.</span>
        <span class="tok-comment">/// A file-level error has been reported. Sema should terminate semantic analysis.</span>
        <span class="tok-comment">/// `operand` and `small` are ignored.</span>
        <span class="tok-comment">/// This instruction is always `noreturn`, however, it is not considered as such by ZIR-level queries. This allows AstGen to assume that</span>
        <span class="tok-comment">/// any code may have gone here, avoiding false-positive &quot;unreachable code&quot; errors.</span>
        astgen_error,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstData = <span class="tok-kw">struct</span> {
            opcode: <a href="std.zig.Zir.Inst.Extended.html">Extended</a>,
            small: <span class="tok-type">u16</span>,
            operand: <span class="tok-type">u32</span>,
        };
    };

    <span class="tok-comment">/// The position of a ZIR instruction within the `Zir` instructions array.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        <span class="tok-comment">/// ZIR is structured so that the outermost &quot;main&quot; struct of any file</span>
        <span class="tok-comment">/// is always at index 0.</span>
        main_struct_inst = <span class="tok-number">0</span>,
        ref_start_index = <a href="std.zig.Zir.Inst.Index.html#std.zig.Zir.Inst.Index.static_len">static_len</a>,
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> static_len = <span class="tok-number">93</span>;

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toRef</span>(i: <a href="std.zig.Zir.Inst.Index.html">Index</a>) <a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Ref.html">Ref</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.Inst.Index.html">Index</a>.<a href="#">ref_start_index</a>) + <span class="tok-builtin">@intFromEnum</span>(i));
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOptional</span>(i: <a href="std.zig.Zir.Inst.Index.html">Index</a>) <a href="std.zig.Zir.Inst.OptionalIndex.html">OptionalIndex</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(i));
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> OptionalIndex = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        <span class="tok-comment">/// ZIR is structured so that the outermost &quot;main&quot; struct of any file</span>
        <span class="tok-comment">/// is always at index 0.</span>
        main_struct_inst = <span class="tok-number">0</span>,
        ref_start_index = <a href="std.zig.Zir.Inst.Index.html">Index</a>.<a href="std.zig.Zir.Inst.Index.html#std.zig.Zir.Inst.Index.static_len">static_len</a>,
        none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(oi: <a href="std.zig.Zir.Inst.OptionalIndex.html">OptionalIndex</a>) ?<a href="std.zig.Zir.Inst.Index.html">Index</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (oi == .none) <span class="tok-null">null</span> <span class="tok-kw">else</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(oi));
        }
    };

    <span class="tok-comment">/// A reference to ZIR instruction, or to an InternPool index, or neither.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If the integer tag value is &lt; InternPool.static_len, then it</span>
    <span class="tok-comment">/// corresponds to an InternPool index. Otherwise, this refers to a ZIR</span>
    <span class="tok-comment">/// instruction.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The tag type is specified so that it is safe to bitcast between `[]u32`</span>
    <span class="tok-comment">/// and `[]Ref`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Ref = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        u0_type,
        i0_type,
        u1_type,
        u8_type,
        i8_type,
        u16_type,
        i16_type,
        u29_type,
        u32_type,
        i32_type,
        u64_type,
        i64_type,
        u80_type,
        u128_type,
        i128_type,
        usize_type,
        isize_type,
        c_char_type,
        c_short_type,
        c_ushort_type,
        c_int_type,
        c_uint_type,
        c_long_type,
        c_ulong_type,
        c_longlong_type,
        c_ulonglong_type,
        c_longdouble_type,
        f16_type,
        f32_type,
        f64_type,
        f80_type,
        f128_type,
        anyopaque_type,
        bool_type,
        void_type,
        type_type,
        anyerror_type,
        comptime_int_type,
        comptime_float_type,
        noreturn_type,
        anyframe_type,
        null_type,
        undefined_type,
        enum_literal_type,
        manyptr_u8_type,
        manyptr_const_u8_type,
        manyptr_const_u8_sentinel_0_type,
        single_const_pointer_to_comptime_int_type,
        slice_const_u8_type,
        slice_const_u8_sentinel_0_type,
        vector_16_i8_type,
        vector_32_i8_type,
        vector_16_u8_type,
        vector_32_u8_type,
        vector_8_i16_type,
        vector_16_i16_type,
        vector_8_u16_type,
        vector_16_u16_type,
        vector_4_i32_type,
        vector_8_i32_type,
        vector_4_u32_type,
        vector_8_u32_type,
        vector_2_i64_type,
        vector_4_i64_type,
        vector_2_u64_type,
        vector_4_u64_type,
        vector_4_f16_type,
        vector_8_f16_type,
        vector_2_f32_type,
        vector_4_f32_type,
        vector_8_f32_type,
        vector_2_f64_type,
        vector_4_f64_type,
        optional_noreturn_type,
        anyerror_void_error_union_type,
        adhoc_inferred_error_set_type,
        generic_poison_type,
        empty_tuple_type,
        undef,
        zero,
        zero_usize,
        zero_u8,
        one,
        one_usize,
        one_u8,
        four_u8,
        negative_one,
        void_value,
        unreachable_value,
        null_value,
        bool_true,
        bool_false,
        empty_tuple,

        <span class="tok-comment">/// This Ref does not correspond to any ZIR instruction or constant</span>
        <span class="tok-comment">/// value and may instead be used as a sentinel to indicate null.</span>
        none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),

        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toIndex</span>(inst: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>) ?<a href="std.zig.Zir.Inst.Index.html">Index</a> {
            <a href="std.debug.html#std.debug.assert">assert</a>(inst != .none);
            <span class="tok-kw">const</span> ref_int = <span class="tok-builtin">@intFromEnum</span>(inst);
            <span class="tok-kw">if</span> (ref_int &gt;= <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.Inst.Index.html">Index</a>.<a href="#">ref_start_index</a>)) {
                <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(ref_int - <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.Zir.Inst.Index.html">Index</a>.<a href="#">ref_start_index</a>));
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toIndexAllowNone</span>(inst: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>) ?<a href="std.zig.Zir.Inst.Index.html">Index</a> {
            <span class="tok-kw">if</span> (inst == .none) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> <a href="std.zig.Zir.Inst.Ref.html#std.zig.Zir.Inst.Ref.toIndex">toIndex</a>(inst);
        }
    };

    <span class="tok-comment">/// All instructions have an 8-byte payload, which is contained within</span>
    <span class="tok-comment">/// this union. `Tag` determines which union field is active, as well as</span>
    <span class="tok-comment">/// how to interpret the data within.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">union</span> {
        <span class="tok-comment">/// Used for `Tag.extended`. The extended opcode determines the meaning</span>
        <span class="tok-comment">/// of the `small` and `operand` fields.</span>
        extended: <a href="std.zig.Zir.Inst.Extended.html">Extended</a>.<a href="std.zig.Zir.Inst.Extended.InstData.html">InstData</a>,
        <span class="tok-comment">/// Used for unary operators, with an AST node source location.</span>
        un_node: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset from Decl AST node index.</span>
            src_node: <span class="tok-type">i32</span>,
            <span class="tok-comment">/// The meaning of this operand depends on the corresponding `Tag`.</span>
            operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        },
        <span class="tok-comment">/// Used for unary operators, with a token source location.</span>
        un_tok: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset from Decl AST token index.</span>
            src_tok: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            <span class="tok-comment">/// The meaning of this operand depends on the corresponding `Tag`.</span>
            operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        },
        pl_node: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset from Decl AST node index.</span>
            <span class="tok-comment">/// `Tag` determines which kind of AST node this points to.</span>
            src_node: <span class="tok-type">i32</span>,
            <span class="tok-comment">/// index into extra.</span>
            <span class="tok-comment">/// `Tag` determines what lives there.</span>
            payload_index: <span class="tok-type">u32</span>,
        },
        pl_tok: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset from Decl AST token index.</span>
            src_tok: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            <span class="tok-comment">/// index into extra.</span>
            <span class="tok-comment">/// `Tag` determines what lives there.</span>
            payload_index: <span class="tok-type">u32</span>,
        },
        bin: <a href="std.zig.Zir.Inst.Bin.html">Bin</a>,
        <span class="tok-comment">/// For strings which may contain null bytes.</span>
        str: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset into `string_bytes`.</span>
            start: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            <span class="tok-comment">/// Number of bytes in the string.</span>
            len: <span class="tok-type">u32</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <span class="tok-builtin">@This</span>(), code: <a href="std.zig.Zir.html">Zir</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
                <span class="tok-kw">return</span> code.string_bytes[<span class="tok-builtin">@intFromEnum</span>(self.start)..][<span class="tok-number">0</span>..self.len];
            }
        },
        str_tok: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset into `string_bytes`. Null-terminated.</span>
            start: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            <span class="tok-comment">/// Offset from Decl AST token index.</span>
            src_tok: <span class="tok-type">u32</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <span class="tok-builtin">@This</span>(), code: <a href="std.zig.Zir.html">Zir</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
                <span class="tok-kw">return</span> code.nullTerminatedString(self.start);
            }
        },
        <span class="tok-comment">/// Offset from Decl AST token index.</span>
        tok: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Offset from Decl AST node index.</span>
        node: <span class="tok-type">i32</span>,
        int: <span class="tok-type">u64</span>,
        float: <span class="tok-type">f64</span>,
        ptr_type: <span class="tok-kw">struct</span> {
            flags: <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
                is_allowzero: <span class="tok-type">bool</span>,
                is_mutable: <span class="tok-type">bool</span>,
                is_volatile: <span class="tok-type">bool</span>,
                has_sentinel: <span class="tok-type">bool</span>,
                has_align: <span class="tok-type">bool</span>,
                has_addrspace: <span class="tok-type">bool</span>,
                has_bit_range: <span class="tok-type">bool</span>,
                _: <span class="tok-type">u1</span> = <span class="tok-null">undefined</span>,
            },
            size: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Pointer.html">Pointer</a>.<a href="std.builtin.Type.Pointer.Size.html">Size</a>,
            <span class="tok-comment">/// Index into extra. See `PtrType`.</span>
            payload_index: <span class="tok-type">u32</span>,
        },
        int_type: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset from Decl AST node index.</span>
            <span class="tok-comment">/// `Tag` determines which kind of AST node this points to.</span>
            src_node: <span class="tok-type">i32</span>,
            signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a>,
            bit_count: <span class="tok-type">u16</span>,
        },
        @&quot;unreachable&quot;: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset from Decl AST node index.</span>
            <span class="tok-comment">/// `Tag` determines which kind of AST node this points to.</span>
            src_node: <span class="tok-type">i32</span>,
        },
        @&quot;break&quot;: <span class="tok-kw">struct</span> {
            operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            <span class="tok-comment">/// Index of a `Break` payload.</span>
            payload_index: <span class="tok-type">u32</span>,
        },
        dbg_stmt: <a href="std.zig.Zir.Inst.LineColumn.html">LineColumn</a>,
        <span class="tok-comment">/// Used for unary operators which reference an inst,</span>
        <span class="tok-comment">/// with an AST node source location.</span>
        inst_node: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset from Decl AST node index.</span>
            src_node: <span class="tok-type">i32</span>,
            <span class="tok-comment">/// The meaning of this operand depends on the corresponding `Tag`.</span>
            inst: <a href="std.zig.Zir.Inst.Index.html">Index</a>,
        },
        str_op: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Offset into `string_bytes`. Null-terminated.</span>
            str: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStr</span>(self: <span class="tok-builtin">@This</span>(), zir: <a href="std.zig.Zir.html">Zir</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
                <span class="tok-kw">return</span> zir.nullTerminatedString(self.str);
            }
        },
        @&quot;defer&quot;: <span class="tok-kw">struct</span> {
            index: <span class="tok-type">u32</span>,
            len: <span class="tok-type">u32</span>,
        },
        defer_err_code: <span class="tok-kw">struct</span> {
            err_code: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            payload_index: <span class="tok-type">u32</span>,
        },
        save_err_ret_index: <span class="tok-kw">struct</span> {
            operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,<span class="tok-comment"> // If error type (or .none), save new trace index
        </span>},
        elem_val_imm: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The indexable value being accessed.</span>
            operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            <span class="tok-comment">/// The index being accessed.</span>
            idx: <span class="tok-type">u32</span>,
        },
        declaration: <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// This node provides a new absolute baseline node for all instructions within this struct.</span>
            src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            <span class="tok-comment">/// index into extra to a `Declaration` payload.</span>
            payload_index: <span class="tok-type">u32</span>,
        },<span class="tok-comment">

        // Make sure we don't accidentally add a field to make this union
        // bigger than expected. Note that in Debug builds, Zig is allowed
        // to insert a secret field for safety checks.
        </span><span class="tok-kw">comptime</span> {
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> != .Debug <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> != .ReleaseSafe) {
                <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.zig.Zir.Inst.Data.html">Data</a>) == <span class="tok-number">8</span>);
            }
        }

        <span class="tok-comment">/// TODO this has to be kept in sync with `Data` which we want to be an untagged</span>
        <span class="tok-comment">/// union. There is some kind of language awkwardness here and it has to do with</span>
        <span class="tok-comment">/// deserializing an untagged union (in this case `Data`) from a file, and trying</span>
        <span class="tok-comment">/// to preserve the hidden safety field.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldEnum = <span class="tok-kw">enum</span> {
            extended,
            un_node,
            un_tok,
            pl_node,
            pl_tok,
            bin,
            str,
            str_tok,
            tok,
            node,
            int,
            float,
            ptr_type,
            int_type,
            @&quot;unreachable&quot;,
            @&quot;break&quot;,
            dbg_stmt,
            inst_node,
            str_op,
            @&quot;defer&quot;,
            defer_err_code,
            save_err_ret_index,
            elem_val_imm,
            declaration,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Break = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> no_src_node = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">i32</span>);

        operand_src_node: <span class="tok-type">i32</span>,
        block_inst: <a href="std.zig.Zir.Inst.Index.html">Index</a>,
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. Output for every outputs_len</span>
    <span class="tok-comment">/// 1. Input for every inputs_len</span>
    <span class="tok-comment">/// 2. clobber: NullTerminatedString // index into string_bytes (null terminated) for every clobbers_len.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Asm = <span class="tok-kw">struct</span> {
        src_node: <span class="tok-type">i32</span>,<span class="tok-comment">
        // null-terminated string index
        </span>asm_source: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
        <span class="tok-comment">/// 1 bit for each outputs_len: whether it uses `-&gt; T` or not.</span>
        <span class="tok-comment">///   0b0 - operand is a pointer to where to store the output.</span>
        <span class="tok-comment">///   0b1 - operand is a type; asm expression has the output as the result.</span>
        <span class="tok-comment">/// 0b0X is the first output, 0bX0 is the second, etc.</span>
        output_type_bits: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Output = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// index into string_bytes (null terminated)</span>
            name: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            <span class="tok-comment">/// index into string_bytes (null terminated)</span>
            constraint: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            <span class="tok-comment">/// How to interpret this is determined by `output_type_bits`.</span>
            operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Input = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// index into string_bytes (null terminated)</span>
            name: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            <span class="tok-comment">/// index into string_bytes (null terminated)</span>
            constraint: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        };
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// if (ret_ty.body_len == 1) {</span>
    <span class="tok-comment">///   0. return_type: Ref</span>
    <span class="tok-comment">/// }</span>
    <span class="tok-comment">/// if (ret_ty.body_len &gt; 1) {</span>
    <span class="tok-comment">///   1. return_type: Index // for each ret_ty.body_len</span>
    <span class="tok-comment">/// }</span>
    <span class="tok-comment">/// 2. body: Index // for each body_len</span>
    <span class="tok-comment">/// 3. src_locs: SrcLocs // if body_len != 0</span>
    <span class="tok-comment">/// 4. proto_hash: std.zig.SrcHash // if body_len != 0; hash of function prototype</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Func = <span class="tok-kw">struct</span> {
        ret_ty: <a href="std.zig.Zir.Inst.Func.RetTy.html">RetTy</a>,
        <span class="tok-comment">/// Points to the block that contains the param instructions for this function.</span>
        <span class="tok-comment">/// If this is a `declaration`, it refers to the declaration's value body.</span>
        param_block: <a href="std.zig.Zir.Inst.Index.html">Index</a>,
        body_len: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> RetTy = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
            <span class="tok-comment">/// 0 means `void`.</span>
            <span class="tok-comment">/// 1 means the type is a simple `Ref`.</span>
            <span class="tok-comment">/// Otherwise, the length of a trailing body.</span>
            body_len: <span class="tok-type">u31</span>,
            <span class="tok-comment">/// Whether the return type is generic, i.e. refers to one or more previous parameters.</span>
            is_generic: <span class="tok-type">bool</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SrcLocs = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Line index in the source file relative to the parent decl.</span>
            lbrace_line: <span class="tok-type">u32</span>,
            <span class="tok-comment">/// Line index in the source file relative to the parent decl.</span>
            rbrace_line: <span class="tok-type">u32</span>,
            <span class="tok-comment">/// lbrace_column is least significant bits u16</span>
            <span class="tok-comment">/// rbrace_column is most significant bits u16</span>
            columns: <span class="tok-type">u32</span>,
        };
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// if (has_cc_ref and !has_cc_body) {</span>
    <span class="tok-comment">///   0. cc: Ref,</span>
    <span class="tok-comment">/// }</span>
    <span class="tok-comment">/// if (has_cc_body) {</span>
    <span class="tok-comment">///   1. cc_body_len: u32</span>
    <span class="tok-comment">///   2. cc_body: u32 // for each cc_body_len</span>
    <span class="tok-comment">/// }</span>
    <span class="tok-comment">/// if (has_ret_ty_ref and !has_ret_ty_body) {</span>
    <span class="tok-comment">///   3. ret_ty: Ref,</span>
    <span class="tok-comment">/// }</span>
    <span class="tok-comment">/// if (has_ret_ty_body) {</span>
    <span class="tok-comment">///   4. ret_ty_body_len: u32</span>
    <span class="tok-comment">///   5. ret_ty_body: u32 // for each ret_ty_body_len</span>
    <span class="tok-comment">/// }</span>
    <span class="tok-comment">/// 6. noalias_bits: u32 // if has_any_noalias</span>
    <span class="tok-comment">///    - each bit starting with LSB corresponds to parameter indexes</span>
    <span class="tok-comment">/// 7. body: Index // for each body_len</span>
    <span class="tok-comment">/// 8. src_locs: Func.SrcLocs // if body_len != 0</span>
    <span class="tok-comment">/// 9. proto_hash: std.zig.SrcHash // if body_len != 0; hash of function prototype</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FuncFancy = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Points to the block that contains the param instructions for this function.</span>
        <span class="tok-comment">/// If this is a `declaration`, it refers to the declaration's value body.</span>
        param_block: <a href="std.zig.Zir.Inst.Index.html">Index</a>,
        body_len: <span class="tok-type">u32</span>,
        bits: <a href="std.zig.Zir.Inst.FuncFancy.Bits.html">Bits</a>,

        <span class="tok-comment">/// If both has_cc_ref and has_cc_body are false, it means auto calling convention.</span>
        <span class="tok-comment">/// If both has_ret_ty_ref and has_ret_ty_body are false, it means void return type.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bits = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
            is_var_args: <span class="tok-type">bool</span>,
            is_inferred_error: <span class="tok-type">bool</span>,
            is_noinline: <span class="tok-type">bool</span>,
            has_cc_ref: <span class="tok-type">bool</span>,
            has_cc_body: <span class="tok-type">bool</span>,
            has_ret_ty_ref: <span class="tok-type">bool</span>,
            has_ret_ty_body: <span class="tok-type">bool</span>,
            has_any_noalias: <span class="tok-type">bool</span>,
            ret_ty_is_generic: <span class="tok-type">bool</span>,
            _: <span class="tok-type">u23</span> = <span class="tok-null">undefined</span>,
        };
    };

    <span class="tok-comment">/// This data is stored inside extra, with trailing operands according to `operands_len`.</span>
    <span class="tok-comment">/// Each operand is a `Ref`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MultiOp = <span class="tok-kw">struct</span> {
        operands_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-comment">/// Trailing: operand: Ref, // for each `operands_len` (stored in `small`).</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NodeMultiOp = <span class="tok-kw">struct</span> {
        src_node: <span class="tok-type">i32</span>,
    };

    <span class="tok-comment">/// This data is stored inside extra, with trailing operands according to `body_len`.</span>
    <span class="tok-comment">/// Each operand is an `Index`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Block = <span class="tok-kw">struct</span> {
        body_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// * inst: Index // for each `body_len`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BlockComptime = <span class="tok-kw">struct</span> {
        reason: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.SimpleComptimeReason.html">SimpleComptimeReason</a>,
        body_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// * inst: Index // for each `body_len`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BoolBr = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        body_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. name: NullTerminatedString      // if `flags.id.hasName()`</span>
    <span class="tok-comment">/// 1. lib_name: NullTerminatedString  // if `flags.id.hasLibName()`</span>
    <span class="tok-comment">/// 2. type_body_len: u32              // if `flags.id.hasTypeBody()`</span>
    <span class="tok-comment">/// 3. align_body_len: u32             // if `flags.id.hasSpecialBodies()`</span>
    <span class="tok-comment">/// 4. linksection_body_len: u32       // if `flags.id.hasSpecialBodies()`</span>
    <span class="tok-comment">/// 5. addrspace_body_len: u32         // if `flags.id.hasSpecialBodies()`</span>
    <span class="tok-comment">/// 6. value_body_len: u32             // if `flags.id.hasValueBody()`</span>
    <span class="tok-comment">/// 7. type_body_inst: Zir.Inst.Index</span>
    <span class="tok-comment">///    - for each `type_body_len`</span>
    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span>
    <span class="tok-comment">/// 8. align_body_inst: Zir.Inst.Index</span>
    <span class="tok-comment">///    - for each `align_body_len`</span>
    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span>
    <span class="tok-comment">/// 9. linksection_body_inst: Zir.Inst.Index</span>
    <span class="tok-comment">///    - for each `linksection_body_len`</span>
    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span>
    <span class="tok-comment">/// 10. addrspace_body_inst: Zir.Inst.Index</span>
    <span class="tok-comment">///    - for each `addrspace_body_len`</span>
    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span>
    <span class="tok-comment">/// 11. value_body_inst: Zir.Inst.Index</span>
    <span class="tok-comment">///    - for each `value_body_len`</span>
    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span>
    <span class="tok-comment">///    - within this body, the `declaration` instruction refers to the resolved type from the type body</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Declaration = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // These fields should be concatenated and reinterpreted as a `std.zig.SrcHash`.
        </span>src_hash_0: <span class="tok-type">u32</span>,
        src_hash_1: <span class="tok-type">u32</span>,
        src_hash_2: <span class="tok-type">u32</span>,
        src_hash_3: <span class="tok-type">u32</span>,<span class="tok-comment">
        // These fields should be concatenated and reinterpreted as a `Flags`.
        </span>flags_0: <span class="tok-type">u32</span>,
        flags_1: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unwrapped = <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> {
                unnamed_test,
                @&quot;test&quot;,
                decltest,
                @&quot;comptime&quot;,
                @&quot;usingnamespace&quot;,
                @&quot;const&quot;,
                @&quot;var&quot;,
            };

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Linkage = <span class="tok-kw">enum</span> {
                normal,
                @&quot;extern&quot;,
                @&quot;export&quot;,
            };

            src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,

            src_line: <span class="tok-type">u32</span>,
            src_column: <span class="tok-type">u32</span>,

            kind: <a href="std.zig.Zir.Inst.Declaration.Unwrapped.Kind.html">Kind</a>,
            <span class="tok-comment">/// Always `.empty` for `kind` of `unnamed_test`, `.@&quot;comptime&quot;`, `.@&quot;usingnamespace&quot;`.</span>
            name: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            <span class="tok-comment">/// Always `false` for `kind` of `unnamed_test`, `.@&quot;test&quot;`, `.decltest`, `.@&quot;comptime&quot;`.</span>
            is_pub: <span class="tok-type">bool</span>,
            <span class="tok-comment">/// Always `false` for `kind != .@&quot;var&quot;`.</span>
            is_threadlocal: <span class="tok-type">bool</span>,
            <span class="tok-comment">/// Always `.normal` for `kind != .@&quot;const&quot; and kind != .@&quot;var&quot;`.</span>
            linkage: <a href="std.zig.Zir.Inst.Declaration.Unwrapped.Linkage.html">Linkage</a>,
            <span class="tok-comment">/// Always `.empty` for `linkage != .@&quot;extern&quot;`.</span>
            lib_name: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,

            <span class="tok-comment">/// Always populated for `linkage == .@&quot;extern&quot;.</span>
            type_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
            align_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
            linksection_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
            addrspace_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
            <span class="tok-comment">/// Always populated for `linkage != .@&quot;extern&quot;.</span>
            value_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Flags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u64</span>) {
            src_line: <span class="tok-type">u30</span>,
            src_column: <span class="tok-type">u29</span>,
            id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Id = <span class="tok-kw">enum</span>(<span class="tok-type">u5</span>) {
                unnamed_test,
                @&quot;test&quot;,
                decltest,
                @&quot;comptime&quot;,

                @&quot;usingnamespace&quot;,
                pub_usingnamespace,

                const_simple,
                const_typed,
                @&quot;const&quot;,
                pub_const_simple,
                pub_const_typed,
                pub_const,

                extern_const_simple,
                extern_const,
                pub_extern_const_simple,
                pub_extern_const,

                export_const,
                pub_export_const,

                var_simple,
                @&quot;var&quot;,
                var_threadlocal,
                pub_var_simple,
                pub_var,
                pub_var_threadlocal,

                extern_var,
                extern_var_threadlocal,
                pub_extern_var,
                pub_extern_var_threadlocal,

                export_var,
                export_var_threadlocal,
                pub_export_var,
                pub_export_var_threadlocal,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasName</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <span class="tok-type">bool</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .unnamed_test,
                        .@&quot;comptime&quot;,
                        .@&quot;usingnamespace&quot;,
                        .pub_usingnamespace,
                        =&gt; <span class="tok-null">false</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasLibName</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <span class="tok-type">bool</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .extern_const,
                        .pub_extern_const,
                        .extern_var,
                        .extern_var_threadlocal,
                        .pub_extern_var,
                        .pub_extern_var_threadlocal,
                        =&gt; <span class="tok-null">true</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasTypeBody</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <span class="tok-type">bool</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .unnamed_test,
                        .@&quot;test&quot;,
                        .decltest,
                        .@&quot;comptime&quot;,
                        .@&quot;usingnamespace&quot;,
                        .pub_usingnamespace,
                        =&gt; <span class="tok-null">false</span>,<span class="tok-comment"> // these constructs are untyped
                        </span>.const_simple,
                        .pub_const_simple,
                        .var_simple,
                        .pub_var_simple,
                        =&gt; <span class="tok-null">false</span>,<span class="tok-comment"> // these reprs omit type bodies
                        </span><span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasValueBody</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <span class="tok-type">bool</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .extern_const_simple,
                        .extern_const,
                        .pub_extern_const_simple,
                        .pub_extern_const,
                        .extern_var,
                        .extern_var_threadlocal,
                        .pub_extern_var,
                        .pub_extern_var_threadlocal,
                        =&gt; <span class="tok-null">false</span>,<span class="tok-comment"> // externs do not have values
                        </span><span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasSpecialBodies</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <span class="tok-type">bool</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .unnamed_test,
                        .@&quot;test&quot;,
                        .decltest,
                        .@&quot;comptime&quot;,
                        .@&quot;usingnamespace&quot;,
                        .pub_usingnamespace,
                        =&gt; <span class="tok-null">false</span>,<span class="tok-comment"> // these constructs are untyped
                        </span>.const_simple,
                        .const_typed,
                        .pub_const_simple,
                        .pub_const_typed,
                        .extern_const_simple,
                        .pub_extern_const_simple,
                        .var_simple,
                        .pub_var_simple,
                        =&gt; <span class="tok-null">false</span>,<span class="tok-comment"> // these reprs omit special bodies
                        </span><span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkage</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.html">Unwrapped</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.Linkage.html">Linkage</a> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .extern_const_simple,
                        .extern_const,
                        .pub_extern_const_simple,
                        .pub_extern_const,
                        .extern_var,
                        .extern_var_threadlocal,
                        .pub_extern_var,
                        .pub_extern_var_threadlocal,
                        =&gt; .@&quot;extern&quot;,
                        .export_const,
                        .pub_export_const,
                        .export_var,
                        .export_var_threadlocal,
                        .pub_export_var,
                        .pub_export_var_threadlocal,
                        =&gt; .@&quot;export&quot;,
                        <span class="tok-kw">else</span> =&gt; .normal,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kind</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.html">Unwrapped</a>.<a href="std.zig.Zir.Inst.Declaration.Unwrapped.Kind.html">Kind</a> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .unnamed_test =&gt; .unnamed_test,
                        .@&quot;test&quot; =&gt; .@&quot;test&quot;,
                        .decltest =&gt; .decltest,
                        .@&quot;comptime&quot; =&gt; .@&quot;comptime&quot;,
                        .@&quot;usingnamespace&quot;, .pub_usingnamespace =&gt; .@&quot;usingnamespace&quot;,
                        .const_simple,
                        .const_typed,
                        .@&quot;const&quot;,
                        .pub_const_simple,
                        .pub_const_typed,
                        .pub_const,
                        .extern_const_simple,
                        .extern_const,
                        .pub_extern_const_simple,
                        .pub_extern_const,
                        .export_const,
                        .pub_export_const,
                        =&gt; .@&quot;const&quot;,
                        .var_simple,
                        .@&quot;var&quot;,
                        .var_threadlocal,
                        .pub_var_simple,
                        .pub_var,
                        .pub_var_threadlocal,
                        .extern_var,
                        .extern_var_threadlocal,
                        .pub_extern_var,
                        .pub_extern_var_threadlocal,
                        .export_var,
                        .export_var_threadlocal,
                        .pub_export_var,
                        .pub_export_var_threadlocal,
                        =&gt; .@&quot;var&quot;,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isPub</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <span class="tok-type">bool</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .pub_usingnamespace,
                        .pub_const_simple,
                        .pub_const_typed,
                        .pub_const,
                        .pub_extern_const_simple,
                        .pub_extern_const,
                        .pub_export_const,
                        .pub_var_simple,
                        .pub_var,
                        .pub_var_threadlocal,
                        .pub_extern_var,
                        .pub_extern_var_threadlocal,
                        .pub_export_var,
                        .pub_export_var_threadlocal,
                        =&gt; <span class="tok-null">true</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isThreadlocal</span>(id: <a href="std.zig.Zir.Inst.Declaration.Flags.Id.html">Id</a>) <span class="tok-type">bool</span> {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (id) {
                        .var_threadlocal,
                        .pub_var_threadlocal,
                        .extern_var_threadlocal,
                        .pub_extern_var_threadlocal,
                        .export_var_threadlocal,
                        .pub_export_var_threadlocal,
                        =&gt; <span class="tok-null">true</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                    };
                }
            };
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Name = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
            @&quot;comptime&quot; = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
            @&quot;usingnamespace&quot; = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>) - <span class="tok-number">1</span>,
            unnamed_test = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>) - <span class="tok-number">2</span>,
            <span class="tok-comment">/// Other values are `NullTerminatedString` values, i.e. index into</span>
            <span class="tok-comment">/// `string_bytes`. If the byte referenced is 0, the decl is a named</span>
            <span class="tok-comment">/// test, and the actual name begins at the following byte.</span>
            _,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNamedTest</span>(name: <a href="std.zig.Zir.Inst.Declaration.Name.html">Name</a>, zir: <a href="std.zig.Zir.html">Zir</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (name) {
                    .@&quot;comptime&quot;, .@&quot;usingnamespace&quot;, .unnamed_test =&gt; <span class="tok-null">false</span>,
                    _ =&gt; zir.string_bytes[<span class="tok-builtin">@intFromEnum</span>(name)] == <span class="tok-number">0</span>,
                };
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toString</span>(name: <a href="std.zig.Zir.Inst.Declaration.Name.html">Name</a>, zir: <a href="std.zig.Zir.html">Zir</a>) ?<a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a> {
                <span class="tok-kw">switch</span> (name) {
                    .@&quot;comptime&quot;, .@&quot;usingnamespace&quot;, .unnamed_test =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
                    _ =&gt; {},
                }
                <span class="tok-kw">const</span> idx: <span class="tok-type">u32</span> = <span class="tok-builtin">@intFromEnum</span>(name);
                <span class="tok-kw">if</span> (zir.string_bytes[idx] == <span class="tok-number">0</span>) {<span class="tok-comment">
                    // Named test
                    </span><span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(idx + <span class="tok-number">1</span>);
                }
                <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(idx);
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bodies = <span class="tok-kw">struct</span> {
            type_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Index.html">Index</a>,
            align_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Index.html">Index</a>,
            linksection_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Index.html">Index</a>,
            addrspace_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Index.html">Index</a>,
            value_body: ?[]<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Index.html">Index</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getBodies</span>(declaration: <a href="std.zig.Zir.Inst.Declaration.html">Declaration</a>, extra_end: <span class="tok-type">u32</span>, zir: <a href="std.zig.Zir.html">Zir</a>) <a href="std.zig.Zir.Inst.Declaration.Bodies.html">Bodies</a> {
            <span class="tok-kw">var</span> extra_index: <span class="tok-type">u32</span> = extra_end;
            <span class="tok-kw">const</span> value_body_len = declaration.value_body_len;
            <span class="tok-kw">const</span> type_body_len: <span class="tok-type">u32</span> = len: {
                <span class="tok-kw">if</span> (!declaration.flags().kind.hasTypeBody()) <span class="tok-kw">break</span> :len <span class="tok-number">0</span>;
                <span class="tok-kw">const</span> len = zir.extra[extra_index];
                extra_index += <span class="tok-number">1</span>;
                <span class="tok-kw">break</span> :len len;
            };
            <span class="tok-kw">const</span> align_body_len, <span class="tok-kw">const</span> linksection_body_len, <span class="tok-kw">const</span> addrspace_body_len = lens: {
                <span class="tok-kw">if</span> (!declaration.flags.kind.hasSpecialBodies()) {
                    <span class="tok-kw">break</span> :lens .{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> };
                }
                <span class="tok-kw">const</span> lens = zir.extra[extra_index..][<span class="tok-number">0</span>..<span class="tok-number">3</span>].*;
                extra_index += <span class="tok-number">3</span>;
                <span class="tok-kw">break</span> :lens lens;
            };
            <span class="tok-kw">return</span> .{
                .type_body = <span class="tok-kw">if</span> (type_body_len == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> b: {
                    <span class="tok-kw">const</span> b = zir.bodySlice(extra_index, type_body_len);
                    extra_index += type_body_len;
                    <span class="tok-kw">break</span> :b b;
                },
                .align_body = <span class="tok-kw">if</span> (align_body_len == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> b: {
                    <span class="tok-kw">const</span> b = zir.bodySlice(extra_index, align_body_len);
                    extra_index += align_body_len;
                    <span class="tok-kw">break</span> :b b;
                },
                .linksection_body = <span class="tok-kw">if</span> (linksection_body_len == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> b: {
                    <span class="tok-kw">const</span> b = zir.bodySlice(extra_index, linksection_body_len);
                    extra_index += linksection_body_len;
                    <span class="tok-kw">break</span> :b b;
                },
                .addrspace_body = <span class="tok-kw">if</span> (addrspace_body_len == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> b: {
                    <span class="tok-kw">const</span> b = zir.bodySlice(extra_index, addrspace_body_len);
                    extra_index += addrspace_body_len;
                    <span class="tok-kw">break</span> :b b;
                },
                .value_body = <span class="tok-kw">if</span> (value_body_len == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> b: {
                    <span class="tok-kw">const</span> b = zir.bodySlice(extra_index, value_body_len);
                    extra_index += value_body_len;
                    <span class="tok-kw">break</span> :b b;
                },
            };
        }
    };

    <span class="tok-comment">/// Stored inside extra, with trailing arguments according to `args_len`.</span>
    <span class="tok-comment">/// Implicit 0. arg_0_start: u32, // always same as `args_len`</span>
    <span class="tok-comment">/// 1. arg_end: u32, // for each `args_len`</span>
    <span class="tok-comment">/// arg_N_start is the same as arg_N-1_end</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Call = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // Note: Flags *must* come first so that unusedResultExpr
        // can find it when it goes to modify them.
        </span>flags: <a href="std.zig.Zir.Inst.Call.Flags.html">Flags</a>,
        callee: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Flags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// std.builtin.CallModifier in packed form</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PackedModifier = <span class="tok-type">u3</span>;
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PackedArgsLen = <span class="tok-type">u27</span>;

            packed_modifier: <a href="std.zig.Zir.Inst.Call.Flags.html#std.zig.Zir.Inst.Call.Flags.PackedModifier">PackedModifier</a>,
            ensure_result_used: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            pop_error_return_trace: <span class="tok-type">bool</span>,
            args_len: <a href="std.zig.Zir.Inst.Call.Flags.html#std.zig.Zir.Inst.Call.Flags.PackedArgsLen">PackedArgsLen</a>,

            <span class="tok-kw">comptime</span> {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.zig.Zir.Inst.Call.Flags.html">Flags</a>) != <span class="tok-number">4</span> <span class="tok-kw">or</span> <span class="tok-builtin">@bitSizeOf</span>(<a href="std.zig.Zir.Inst.Call.Flags.html">Flags</a>) != <span class="tok-number">32</span>)
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Layout of Call.Flags needs to be updated!&quot;</span>);
                <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.CallModifier.html">CallModifier</a>) != <span class="tok-builtin">@bitSizeOf</span>(<a href="std.zig.Zir.Inst.Call.Flags.html#std.zig.Zir.Inst.Call.Flags.PackedModifier">PackedModifier</a>))
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Call.Flags.PackedModifier needs to be updated!&quot;</span>);
            }
        };
    };

    <span class="tok-comment">/// Stored inside extra, with trailing arguments according to `args_len`.</span>
    <span class="tok-comment">/// Implicit 0. arg_0_start: u32, // always same as `args_len`</span>
    <span class="tok-comment">/// 1. arg_end: u32, // for each `args_len`</span>
    <span class="tok-comment">/// arg_N_start is the same as arg_N-1_end</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldCall = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // Note: Flags *must* come first so that unusedResultExpr
        // can find it when it goes to modify them.
        </span>flags: <a href="std.zig.Zir.Inst.Call.html">Call</a>.<a href="std.zig.Zir.Inst.Call.Flags.html">Flags</a>,
        obj_ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Offset into `string_bytes`.</span>
        field_name_start: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    };

    <span class="tok-comment">/// There is a body of instructions at `extra[body_index..][0..body_len]`.</span>
    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. operand: Ref // for each `operands_len`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> TypeOfPeer = <span class="tok-kw">struct</span> {
        src_node: <span class="tok-type">i32</span>,
        body_len: <span class="tok-type">u32</span>,
        body_index: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BuiltinCall = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // Note: Flags *must* come first so that unusedResultExpr
        // can find it when it goes to modify them.
        </span>flags: <a href="std.zig.Zir.Inst.BuiltinCall.Flags.html">Flags</a>,
        modifier: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        callee: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        args: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Flags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            is_nosuspend: <span class="tok-type">bool</span>,
            ensure_result_used: <span class="tok-type">bool</span>,
            _: <span class="tok-type">u30</span> = <span class="tok-null">undefined</span>,

            <span class="tok-kw">comptime</span> {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.zig.Zir.Inst.BuiltinCall.Flags.html">Flags</a>) != <span class="tok-number">4</span> <span class="tok-kw">or</span> <span class="tok-builtin">@bitSizeOf</span>(<a href="std.zig.Zir.Inst.BuiltinCall.Flags.html">Flags</a>) != <span class="tok-number">32</span>)
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Layout of BuiltinCall.Flags needs to be updated!&quot;</span>);
            }
        };
    };

    <span class="tok-comment">/// This data is stored inside extra, with two sets of trailing `Ref`:</span>
    <span class="tok-comment">/// * 0. the then body, according to `then_body_len`.</span>
    <span class="tok-comment">/// * 1. the else body, according to `else_body_len`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CondBr = <span class="tok-kw">struct</span> {
        condition: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        then_body_len: <span class="tok-type">u32</span>,
        else_body_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-comment">/// This data is stored inside extra, trailed by:</span>
    <span class="tok-comment">/// * 0. body: Index //  for each `body_len`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Try = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The error union to unwrap.</span>
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        body_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-comment">/// Stored in extra. Depending on the flags in Data, there will be up to 5</span>
    <span class="tok-comment">/// trailing Ref fields:</span>
    <span class="tok-comment">/// 0. sentinel: Ref // if `has_sentinel` flag is set</span>
    <span class="tok-comment">/// 1. align: Ref // if `has_align` flag is set</span>
    <span class="tok-comment">/// 2. address_space: Ref // if `has_addrspace` flag is set</span>
    <span class="tok-comment">/// 3. bit_start: Ref // if `has_bit_range` flag is set</span>
    <span class="tok-comment">/// 4. host_size: Ref // if `has_bit_range` flag is set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtrType = <span class="tok-kw">struct</span> {
        elem_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        src_node: <span class="tok-type">i32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayTypeSentinel = <span class="tok-kw">struct</span> {
        len: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        sentinel: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        elem_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceStart = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        start: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceEnd = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        start: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        end: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceSentinel = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        start: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        end: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        sentinel: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceLength = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        start: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        len: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        sentinel: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        start_src_node_offset: <span class="tok-type">i32</span>,
    };

    <span class="tok-comment">/// The meaning of these operands depends on the corresponding `Tag`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bin = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        rhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BinNode = <span class="tok-kw">struct</span> {
        node: <span class="tok-type">i32</span>,
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        rhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnNode = <span class="tok-kw">struct</span> {
        node: <span class="tok-type">i32</span>,
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ElemPtrImm = <span class="tok-kw">struct</span> {
        ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        index: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reify = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// This node is absolute, because `reify` instructions are tracked across updates, and</span>
        <span class="tok-comment">/// this simplifies the logic for getting source locations for types.</span>
        node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        src_line: <span class="tok-type">u32</span>,
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. multi_cases_len: u32 // if `has_multi_cases`</span>
    <span class="tok-comment">/// 1. err_capture_inst: u32 // if `any_uses_err_capture`</span>
    <span class="tok-comment">/// 2. non_err_body {</span>
    <span class="tok-comment">///        info: ProngInfo,</span>
    <span class="tok-comment">///        inst: Index // for every `info.body_len`</span>
    <span class="tok-comment">///     }</span>
    <span class="tok-comment">/// 3. else_body { // if `has_else`</span>
    <span class="tok-comment">///        info: ProngInfo,</span>
    <span class="tok-comment">///        inst: Index // for every `info.body_len`</span>
    <span class="tok-comment">///     }</span>
    <span class="tok-comment">/// 4. scalar_cases: { // for every `scalar_cases_len`</span>
    <span class="tok-comment">///        item: Ref,</span>
    <span class="tok-comment">///        info: ProngInfo,</span>
    <span class="tok-comment">///        inst: Index // for every `info.body_len`</span>
    <span class="tok-comment">///     }</span>
    <span class="tok-comment">/// 5. multi_cases: { // for every `multi_cases_len`</span>
    <span class="tok-comment">///        items_len: u32,</span>
    <span class="tok-comment">///        ranges_len: u32,</span>
    <span class="tok-comment">///        info: ProngInfo,</span>
    <span class="tok-comment">///        item: Ref // for every `items_len`</span>
    <span class="tok-comment">///        ranges: { // for every `ranges_len`</span>
    <span class="tok-comment">///            item_first: Ref,</span>
    <span class="tok-comment">///            item_last: Ref,</span>
    <span class="tok-comment">///        }</span>
    <span class="tok-comment">///        inst: Index // for every `info.body_len`</span>
    <span class="tok-comment">///    }</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// When analyzing a case body, the switch instruction itself refers to the</span>
    <span class="tok-comment">/// captured error, or to the success value in `non_err_body`. Whether this</span>
    <span class="tok-comment">/// is captured by reference or by value depends on whether the `byref` bit</span>
    <span class="tok-comment">/// is set for the corresponding body. `err_capture_inst` refers to the error</span>
    <span class="tok-comment">/// capture outside of the `switch`, i.e. `err` in</span>
    <span class="tok-comment">/// `x catch |err| switch (err) { ... }`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SwitchBlockErrUnion = <span class="tok-kw">struct</span> {
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        bits: <a href="std.zig.Zir.Inst.SwitchBlockErrUnion.Bits.html">Bits</a>,
        main_src_node_offset: <span class="tok-type">i32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bits = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
            <span class="tok-comment">/// If true, one or more prongs have multiple items.</span>
            has_multi_cases: <span class="tok-type">bool</span>,
            <span class="tok-comment">/// If true, there is an else prong. This is mutually exclusive with `has_under`.</span>
            has_else: <span class="tok-type">bool</span>,
            any_uses_err_capture: <span class="tok-type">bool</span>,
            payload_is_ref: <span class="tok-type">bool</span>,
            scalar_cases_len: <a href="std.zig.Zir.Inst.SwitchBlockErrUnion.Bits.html#std.zig.Zir.Inst.SwitchBlockErrUnion.Bits.ScalarCasesLen">ScalarCasesLen</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ScalarCasesLen = <span class="tok-type">u28</span>;
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MultiProng = <span class="tok-kw">struct</span> {
            items: []<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Index.html">Index</a>,
        };
    };

    <span class="tok-comment">/// 0. multi_cases_len: u32 // If has_multi_cases is set.</span>
    <span class="tok-comment">/// 1. tag_capture_inst: u32 // If any_has_tag_capture is set. Index of instruction prongs use to refer to the inline tag capture.</span>
    <span class="tok-comment">/// 2. else_body { // If has_else or has_under is set.</span>
    <span class="tok-comment">///        info: ProngInfo,</span>
    <span class="tok-comment">///        body member Index for every info.body_len</span>
    <span class="tok-comment">///     }</span>
    <span class="tok-comment">/// 3. scalar_cases: { // for every scalar_cases_len</span>
    <span class="tok-comment">///        item: Ref,</span>
    <span class="tok-comment">///        info: ProngInfo,</span>
    <span class="tok-comment">///        body member Index for every info.body_len</span>
    <span class="tok-comment">///     }</span>
    <span class="tok-comment">/// 4. multi_cases: { // for every multi_cases_len</span>
    <span class="tok-comment">///        items_len: u32,</span>
    <span class="tok-comment">///        ranges_len: u32,</span>
    <span class="tok-comment">///        info: ProngInfo,</span>
    <span class="tok-comment">///        item: Ref // for every items_len</span>
    <span class="tok-comment">///        ranges: { // for every ranges_len</span>
    <span class="tok-comment">///            item_first: Ref,</span>
    <span class="tok-comment">///            item_last: Ref,</span>
    <span class="tok-comment">///        }</span>
    <span class="tok-comment">///        body member Index for every info.body_len</span>
    <span class="tok-comment">///    }</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// When analyzing a case body, the switch instruction itself refers to the</span>
    <span class="tok-comment">/// captured payload. Whether this is captured by reference or by value</span>
    <span class="tok-comment">/// depends on whether the `byref` bit is set for the corresponding body.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SwitchBlock = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The operand passed to the `switch` expression. If this is a</span>
        <span class="tok-comment">/// `switch_block`, this is the operand value; if `switch_block_ref` it</span>
        <span class="tok-comment">/// is a pointer to the operand. `switch_block_ref` is always used if</span>
        <span class="tok-comment">/// any prong has a byref capture.</span>
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        bits: <a href="std.zig.Zir.Inst.SwitchBlock.Bits.html">Bits</a>,

        <span class="tok-comment">/// These are stored in trailing data in `extra` for each prong.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ProngInfo = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
            body_len: <span class="tok-type">u28</span>,
            capture: <a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.html">ProngInfo</a>.<a href="std.zig.Zir.Inst.SwitchBlock.ProngInfo.Capture.html">Capture</a>,
            is_inline: <span class="tok-type">bool</span>,
            has_tag_capture: <span class="tok-type">bool</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Capture = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
                none,
                by_val,
                by_ref,
            };
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bits = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
            <span class="tok-comment">/// If true, one or more prongs have multiple items.</span>
            has_multi_cases: <span class="tok-type">bool</span>,
            <span class="tok-comment">/// If true, there is an else prong. This is mutually exclusive with `has_under`.</span>
            has_else: <span class="tok-type">bool</span>,
            <span class="tok-comment">/// If true, there is an underscore prong. This is mutually exclusive with `has_else`.</span>
            has_under: <span class="tok-type">bool</span>,
            <span class="tok-comment">/// If true, at least one prong has an inline tag capture.</span>
            any_has_tag_capture: <span class="tok-type">bool</span>,
            <span class="tok-comment">/// If true, at least one prong has a capture which may not</span>
            <span class="tok-comment">/// be comptime-known via `inline`.</span>
            any_non_inline_capture: <span class="tok-type">bool</span>,
            has_continue: <span class="tok-type">bool</span>,
            scalar_cases_len: <a href="std.zig.Zir.Inst.SwitchBlock.Bits.html#std.zig.Zir.Inst.SwitchBlock.Bits.ScalarCasesLen">ScalarCasesLen</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ScalarCasesLen = <span class="tok-type">u26</span>;

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">specialProng</span>(bits: <a href="std.zig.Zir.Inst.SwitchBlock.Bits.html">Bits</a>) <a href="std.zig.Zir.SpecialProng.html">SpecialProng</a> {
                <span class="tok-kw">const</span> has_else: <span class="tok-type">u2</span> = <span class="tok-builtin">@intFromBool</span>(bits.has_else);
                <span class="tok-kw">const</span> has_under: <span class="tok-type">u2</span> = <span class="tok-builtin">@intFromBool</span>(bits.has_under);
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> ((has_else &lt;&lt; <span class="tok-number">1</span>) | has_under) {
                    <span class="tok-number">0b00</span> =&gt; .none,
                    <span class="tok-number">0b01</span> =&gt; .under,
                    <span class="tok-number">0b10</span> =&gt; .@&quot;else&quot;,
                    <span class="tok-number">0b11</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MultiProng = <span class="tok-kw">struct</span> {
            items: []<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
            body: []<span class="tok-kw">const</span> <a href="std.zig.Zir.Inst.Index.html">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayInitRefTy = <span class="tok-kw">struct</span> {
        ptr_ty: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        elem_count: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Field = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Offset into `string_bytes`.</span>
        field_name_start: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldNamed = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        field_name: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> As = <span class="tok-kw">struct</span> {
        dest_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. captures_len: u32 // if has_captures_len</span>
    <span class="tok-comment">/// 1. fields_len: u32, // if has_fields_len</span>
    <span class="tok-comment">/// 2. decls_len: u32, // if has_decls_len</span>
    <span class="tok-comment">/// 3. capture: Capture // for every captures_len</span>
    <span class="tok-comment">/// 4. capture_name: NullTerminatedString // for every captures_len</span>
    <span class="tok-comment">/// 5. backing_int_body_len: u32, // if has_backing_int</span>
    <span class="tok-comment">/// 6. backing_int_ref: Ref, // if has_backing_int and backing_int_body_len is 0</span>
    <span class="tok-comment">/// 7. backing_int_body_inst: Inst, // if has_backing_int and backing_int_body_len is &gt; 0</span>
    <span class="tok-comment">/// 8. decl: Index, // for every decls_len; points to a `declaration` instruction</span>
    <span class="tok-comment">/// 9. flags: u32 // for every 8 fields</span>
    <span class="tok-comment">///    - sets of 4 bits:</span>
    <span class="tok-comment">///      0b000X: whether corresponding field has an align expression</span>
    <span class="tok-comment">///      0b00X0: whether corresponding field has a default expression</span>
    <span class="tok-comment">///      0b0X00: whether corresponding field is comptime</span>
    <span class="tok-comment">///      0bX000: whether corresponding field has a type expression</span>
    <span class="tok-comment">/// 10. fields: { // for every fields_len</span>
    <span class="tok-comment">///        field_name: u32,</span>
    <span class="tok-comment">///        field_type: Ref, // if corresponding bit is not set. none means anytype.</span>
    <span class="tok-comment">///        field_type_body_len: u32, // if corresponding bit is set</span>
    <span class="tok-comment">///        align_body_len: u32, // if corresponding bit is set</span>
    <span class="tok-comment">///        init_body_len: u32, // if corresponding bit is set</span>
    <span class="tok-comment">///    }</span>
    <span class="tok-comment">/// 11. bodies: { // for every fields_len</span>
    <span class="tok-comment">///        field_type_body_inst: Inst, // for each field_type_body_len</span>
    <span class="tok-comment">///        align_body_inst: Inst, // for each align_body_len</span>
    <span class="tok-comment">///        init_body_inst: Inst, // for each init_body_len</span>
    <span class="tok-comment">///    }</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructDecl = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // These fields should be concatenated and reinterpreted as a `std.zig.SrcHash`.
        // This hash contains the source of all fields, and any specified attributes (`extern`, backing type, etc).
        </span>fields_hash_0: <span class="tok-type">u32</span>,
        fields_hash_1: <span class="tok-type">u32</span>,
        fields_hash_2: <span class="tok-type">u32</span>,
        fields_hash_3: <span class="tok-type">u32</span>,
        src_line: <span class="tok-type">u32</span>,
        <span class="tok-comment">/// This node provides a new absolute baseline node for all instructions within this struct.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            has_captures_len: <span class="tok-type">bool</span>,
            has_fields_len: <span class="tok-type">bool</span>,
            has_decls_len: <span class="tok-type">bool</span>,
            has_backing_int: <span class="tok-type">bool</span>,
            known_non_opv: <span class="tok-type">bool</span>,
            known_comptime_only: <span class="tok-type">bool</span>,
            name_strategy: <a href="std.zig.Zir.Inst.NameStrategy.html">NameStrategy</a>,
            layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a>,
            any_default_inits: <span class="tok-type">bool</span>,
            any_comptime_fields: <span class="tok-type">bool</span>,
            any_aligned_fields: <span class="tok-type">bool</span>,
            _: <span class="tok-type">u3</span> = <span class="tok-null">undefined</span>,
        };
    };

    <span class="tok-comment">/// Represents a single value being captured in a type declaration's closure.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Capture = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        tag: <span class="tok-kw">enum</span>(<span class="tok-type">u3</span>) {
            <span class="tok-comment">/// `data` is a `u16` index into the parent closure.</span>
            nested,
            <span class="tok-comment">/// `data` is a `Zir.Inst.Index` to an instruction whose value is being captured.</span>
            instruction,
            <span class="tok-comment">/// `data` is a `Zir.Inst.Index` to an instruction representing an alloc whose contents is being captured.</span>
            instruction_load,
            <span class="tok-comment">/// `data` is a `NullTerminatedString` to a decl name.</span>
            decl_val,
            <span class="tok-comment">/// `data` is a `NullTerminatedString` to a decl name.</span>
            decl_ref,
        },
        data: <span class="tok-type">u29</span>,
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unwrapped = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            nested: <span class="tok-type">u16</span>,
            instruction: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
            instruction_load: <a href="std.zig.Zir.html">Zir</a>.<a href="std.zig.Zir.Inst.html">Inst</a>.<a href="std.zig.Zir.Inst.Index.html">Index</a>,
            decl_val: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            decl_ref: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
        };
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wrap</span>(cap: <a href="std.zig.Zir.Inst.Capture.Unwrapped.html">Unwrapped</a>) <a href="std.zig.Zir.Inst.Capture.html">Capture</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (cap) {
                .nested =&gt; |idx| .{
                    .tag = .nested,
                    .data = idx,
                },
                .instruction =&gt; |inst| .{
                    .tag = .instruction,
                    .data = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(inst)),
                },
                .instruction_load =&gt; |inst| .{
                    .tag = .instruction_load,
                    .data = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(inst)),
                },
                .decl_val =&gt; |str| .{
                    .tag = .decl_val,
                    .data = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(str)),
                },
                .decl_ref =&gt; |str| .{
                    .tag = .decl_ref,
                    .data = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(str)),
                },
            };
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(cap: <a href="std.zig.Zir.Inst.Capture.html">Capture</a>) <a href="std.zig.Zir.Inst.Capture.Unwrapped.html">Unwrapped</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (cap.tag) {
                .nested =&gt; .{ .nested = <span class="tok-builtin">@intCast</span>(cap.data) },
                .instruction =&gt; .{ .instruction = <span class="tok-builtin">@enumFromInt</span>(cap.data) },
                .instruction_load =&gt; .{ .instruction_load = <span class="tok-builtin">@enumFromInt</span>(cap.data) },
                .decl_val =&gt; .{ .decl_val = <span class="tok-builtin">@enumFromInt</span>(cap.data) },
                .decl_ref =&gt; .{ .decl_ref = <span class="tok-builtin">@enumFromInt</span>(cap.data) },
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NameStrategy = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
        <span class="tok-comment">/// Use the same name as the parent declaration name.</span>
        <span class="tok-comment">/// e.g. `const Foo = struct {...};`.</span>
        parent,
        <span class="tok-comment">/// Use the name of the currently executing comptime function call,</span>
        <span class="tok-comment">/// with the current parameters. e.g. `ArrayList(i32)`.</span>
        func,
        <span class="tok-comment">/// Create an anonymous name for this declaration.</span>
        <span class="tok-comment">/// Like this: &quot;ParentDeclName_struct_69&quot;</span>
        anon,
        <span class="tok-comment">/// Use the name specified in the next `dbg_var_{val,ptr}` instruction.</span>
        dbg_var,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FullPtrCastFlags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u5</span>) {
        ptr_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        align_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        addrspace_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        const_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        volatile_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">needResultTypeBuiltinName</span>(flags: <a href="std.zig.Zir.Inst.FullPtrCastFlags.html">FullPtrCastFlags</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">if</span> (flags.ptr_cast) <span class="tok-kw">return</span> <span class="tok-str">&quot;@ptrCast&quot;</span>;
            <span class="tok-kw">if</span> (flags.align_cast) <span class="tok-kw">return</span> <span class="tok-str">&quot;@alignCast&quot;</span>;
            <span class="tok-kw">if</span> (flags.addrspace_cast) <span class="tok-kw">return</span> <span class="tok-str">&quot;@addrSpaceCast&quot;</span>;
            <span class="tok-kw">unreachable</span>;
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BuiltinValue = <span class="tok-kw">enum</span>(<span class="tok-type">u16</span>) {<span class="tok-comment">
        // Types
        </span>atomic_order,
        atomic_rmw_op,
        calling_convention,
        address_space,
        float_mode,
        reduce_op,
        call_modifier,
        prefetch_options,
        export_options,
        extern_options,
        type_info,
        branch_hint,<span class="tok-comment">
        // Values
        </span>calling_convention_c,
        calling_convention_inline,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InplaceOp = <span class="tok-kw">enum</span>(<span class="tok-type">u16</span>) {
        add_eq,
        sub_eq,
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. tag_type: Ref, // if has_tag_type</span>
    <span class="tok-comment">/// 1. captures_len: u32, // if has_captures_len</span>
    <span class="tok-comment">/// 2. body_len: u32, // if has_body_len</span>
    <span class="tok-comment">/// 3. fields_len: u32, // if has_fields_len</span>
    <span class="tok-comment">/// 4. decls_len: u32, // if has_decls_len</span>
    <span class="tok-comment">/// 5. capture: Capture // for every captures_len</span>
    <span class="tok-comment">/// 6. capture_name: NullTerminatedString // for every captures_len</span>
    <span class="tok-comment">/// 7. decl: Index, // for every decls_len; points to a `declaration` instruction</span>
    <span class="tok-comment">/// 8. inst: Index // for every body_len</span>
    <span class="tok-comment">/// 9. has_bits: u32 // for every 32 fields</span>
    <span class="tok-comment">///    - the bit is whether corresponding field has an value expression</span>
    <span class="tok-comment">/// 10. fields: { // for every fields_len</span>
    <span class="tok-comment">///        field_name: u32,</span>
    <span class="tok-comment">///        value: Ref, // if corresponding bit is set</span>
    <span class="tok-comment">///    }</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnumDecl = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // These fields should be concatenated and reinterpreted as a `std.zig.SrcHash`.
        // This hash contains the source of all fields, and the backing type if specified.
        </span>fields_hash_0: <span class="tok-type">u32</span>,
        fields_hash_1: <span class="tok-type">u32</span>,
        fields_hash_2: <span class="tok-type">u32</span>,
        fields_hash_3: <span class="tok-type">u32</span>,
        src_line: <span class="tok-type">u32</span>,
        <span class="tok-comment">/// This node provides a new absolute baseline node for all instructions within this struct.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            has_tag_type: <span class="tok-type">bool</span>,
            has_captures_len: <span class="tok-type">bool</span>,
            has_body_len: <span class="tok-type">bool</span>,
            has_fields_len: <span class="tok-type">bool</span>,
            has_decls_len: <span class="tok-type">bool</span>,
            name_strategy: <a href="std.zig.Zir.Inst.NameStrategy.html">NameStrategy</a>,
            nonexhaustive: <span class="tok-type">bool</span>,
            _: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,
        };
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. tag_type: Ref, // if has_tag_type</span>
    <span class="tok-comment">/// 1. captures_len: u32 // if has_captures_len</span>
    <span class="tok-comment">/// 2. body_len: u32, // if has_body_len</span>
    <span class="tok-comment">/// 3. fields_len: u32, // if has_fields_len</span>
    <span class="tok-comment">/// 4. decls_len: u32, // if has_decls_len</span>
    <span class="tok-comment">/// 5. capture: Capture // for every captures_len</span>
    <span class="tok-comment">/// 6. capture_name: NullTerminatedString // for every captures_len</span>
    <span class="tok-comment">/// 7. decl: Index, // for every decls_len; points to a `declaration` instruction</span>
    <span class="tok-comment">/// 8. inst: Index // for every body_len</span>
    <span class="tok-comment">/// 9. has_bits: u32 // for every 8 fields</span>
    <span class="tok-comment">///    - sets of 4 bits:</span>
    <span class="tok-comment">///      0b000X: whether corresponding field has a type expression</span>
    <span class="tok-comment">///      0b00X0: whether corresponding field has a align expression</span>
    <span class="tok-comment">///      0b0X00: whether corresponding field has a tag value expression</span>
    <span class="tok-comment">///      0bX000: unused</span>
    <span class="tok-comment">/// 10. fields: { // for every fields_len</span>
    <span class="tok-comment">///        field_name: NullTerminatedString, // null terminated string index</span>
    <span class="tok-comment">///        field_type: Ref, // if corresponding bit is set</span>
    <span class="tok-comment">///        align: Ref, // if corresponding bit is set</span>
    <span class="tok-comment">///        tag_value: Ref, // if corresponding bit is set</span>
    <span class="tok-comment">///    }</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnionDecl = <span class="tok-kw">struct</span> {<span class="tok-comment">
        // These fields should be concatenated and reinterpreted as a `std.zig.SrcHash`.
        // This hash contains the source of all fields, and any specified attributes (`extern` etc).
        </span>fields_hash_0: <span class="tok-type">u32</span>,
        fields_hash_1: <span class="tok-type">u32</span>,
        fields_hash_2: <span class="tok-type">u32</span>,
        fields_hash_3: <span class="tok-type">u32</span>,
        src_line: <span class="tok-type">u32</span>,
        <span class="tok-comment">/// This node provides a new absolute baseline node for all instructions within this struct.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            has_tag_type: <span class="tok-type">bool</span>,
            has_captures_len: <span class="tok-type">bool</span>,
            has_body_len: <span class="tok-type">bool</span>,
            has_fields_len: <span class="tok-type">bool</span>,
            has_decls_len: <span class="tok-type">bool</span>,
            name_strategy: <a href="std.zig.Zir.Inst.NameStrategy.html">NameStrategy</a>,
            layout: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.ContainerLayout.html">ContainerLayout</a>,
            <span class="tok-comment">/// has_tag_type | auto_enum_tag | result</span>
            <span class="tok-comment">/// -------------------------------------</span>
            <span class="tok-comment">///    false     | false         |  union { }</span>
            <span class="tok-comment">///    false     | true          |  union(enum) { }</span>
            <span class="tok-comment">///    true      | true          |  union(enum(T)) { }</span>
            <span class="tok-comment">///    true      | false         |  union(T) { }</span>
            auto_enum_tag: <span class="tok-type">bool</span>,
            any_aligned_fields: <span class="tok-type">bool</span>,
            _: <span class="tok-type">u5</span> = <span class="tok-null">undefined</span>,
        };
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. captures_len: u32, // if has_captures_len</span>
    <span class="tok-comment">/// 1. decls_len: u32, // if has_decls_len</span>
    <span class="tok-comment">/// 2. capture: Capture, // for every captures_len</span>
    <span class="tok-comment">/// 3. capture_name: NullTerminatedString // for every captures_len</span>
    <span class="tok-comment">/// 4. decl: Index, // for every decls_len; points to a `declaration` instruction</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpaqueDecl = <span class="tok-kw">struct</span> {
        src_line: <span class="tok-type">u32</span>,
        <span class="tok-comment">/// This node provides a new absolute baseline node for all instructions within this struct.</span>
        src_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            has_captures_len: <span class="tok-type">bool</span>,
            has_decls_len: <span class="tok-type">bool</span>,
            name_strategy: <a href="std.zig.Zir.Inst.NameStrategy.html">NameStrategy</a>,
            _: <span class="tok-type">u12</span> = <span class="tok-null">undefined</span>,
        };
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 1. fields: { // for every `fields_len` (stored in `extended.small`)</span>
    <span class="tok-comment">///        type: Inst.Ref,</span>
    <span class="tok-comment">///        init: Inst.Ref, // `.none` for non-`comptime` fields</span>
    <span class="tok-comment">///    }</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> TupleDecl = <span class="tok-kw">struct</span> {
        src_node: <span class="tok-type">i32</span>,<span class="tok-comment"> // relative
    </span>};

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. field_name: NullTerminatedString // for every fields_len</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorSetDecl = <span class="tok-kw">struct</span> {
        fields_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-comment">/// A f128 value, broken up into 4 u32 parts.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Float128 = <span class="tok-kw">struct</span> {
        piece0: <span class="tok-type">u32</span>,
        piece1: <span class="tok-type">u32</span>,
        piece2: <span class="tok-type">u32</span>,
        piece3: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.zig.Zir.Inst.Float128.html">Float128</a>) <span class="tok-type">f128</span> {
            <span class="tok-kw">const</span> int_bits = <span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, self.piece0) |
                (<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, self.piece1) &lt;&lt; <span class="tok-number">32</span>) |
                (<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, self.piece2) &lt;&lt; <span class="tok-number">64</span>) |
                (<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, self.piece3) &lt;&lt; <span class="tok-number">96</span>);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">f128</span>, <span class="tok-builtin">@bitCast</span>(int_bits));
        }
    };

    <span class="tok-comment">/// Trailing is an item per field.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructInit = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// If this is an anonymous initialization (the operand is poison), this instruction becomes the owner of a type.</span>
        <span class="tok-comment">/// To resolve source locations, we need an absolute source node.</span>
        abs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Likewise, we need an absolute line number.</span>
        abs_line: <span class="tok-type">u32</span>,
        fields_len: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// The `struct_init_field_type` ZIR instruction for this field init.</span>
            field_type: <a href="std.zig.Zir.Inst.Index.html">Index</a>,
            <span class="tok-comment">/// The field init expression to be used as the field value. This value will be coerced</span>
            <span class="tok-comment">/// to the field type if not already.</span>
            init: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        };
    };

    <span class="tok-comment">/// Trailing is an Item per field.</span>
    <span class="tok-comment">/// TODO make this instead array of inits followed by array of names because</span>
    <span class="tok-comment">/// it will be simpler Sema code and better for CPU cache.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructInitAnon = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// This is an anonymous initialization, meaning this instruction becomes the owner of a type.</span>
        <span class="tok-comment">/// To resolve source locations, we need an absolute source node.</span>
        abs_node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Likewise, we need an absolute line number.</span>
        abs_line: <span class="tok-type">u32</span>,
        fields_len: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// Null-terminated string table index.</span>
            field_name: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            <span class="tok-comment">/// The field init expression to be used as the field value.</span>
            init: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldType = <span class="tok-kw">struct</span> {
        container_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// Offset into `string_bytes`, null terminated.</span>
        name_start: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldTypeRef = <span class="tok-kw">struct</span> {
        container_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        field_name: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cmpxchg = <span class="tok-kw">struct</span> {
        node: <span class="tok-type">i32</span>,
        ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        expected_value: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        new_value: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        success_order: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        failure_order: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicRmw = <span class="tok-kw">struct</span> {
        ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        operation: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        ordering: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnionInit = <span class="tok-kw">struct</span> {
        union_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        field_name: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        init: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicStore = <span class="tok-kw">struct</span> {
        ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        ordering: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicLoad = <span class="tok-kw">struct</span> {
        elem_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        ordering: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MulAdd = <span class="tok-kw">struct</span> {
        mulend1: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        mulend2: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        addend: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldParentPtr = <span class="tok-kw">struct</span> {
        src_node: <span class="tok-type">i32</span>,
        parent_ptr_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        field_name: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        field_ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Shuffle = <span class="tok-kw">struct</span> {
        elem_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        a: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        b: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        mask: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Select = <span class="tok-kw">struct</span> {
        node: <span class="tok-type">i32</span>,
        elem_type: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        pred: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        a: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        b: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AsyncCall = <span class="tok-kw">struct</span> {
        node: <span class="tok-type">i32</span>,
        frame_buffer: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        result_ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        fn_ptr: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        args: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-comment">/// Trailing: inst: Index // for every body_len</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Param = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Null-terminated string index.</span>
        name: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
        <span class="tok-type">type</span>: <a href="std.zig.Zir.Inst.Param.Type.html">Type</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Type = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
            <span class="tok-comment">/// The body contains the type of the parameter.</span>
            body_len: <span class="tok-type">u31</span>,
            <span class="tok-comment">/// Whether the type is generic, i.e. refers to one or more previous parameters.</span>
            is_generic: <span class="tok-type">bool</span>,
        };
    };

    <span class="tok-comment">/// Trailing:</span>
    <span class="tok-comment">/// 0. type_inst: Ref,  // if small 0b000X is set</span>
    <span class="tok-comment">/// 1. align_inst: Ref, // if small 0b00X0 is set</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocExtended = <span class="tok-kw">struct</span> {
        src_node: <span class="tok-type">i32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            has_type: <span class="tok-type">bool</span>,
            has_align: <span class="tok-type">bool</span>,
            is_const: <span class="tok-type">bool</span>,
            is_comptime: <span class="tok-type">bool</span>,
            _: <span class="tok-type">u12</span> = <span class="tok-null">undefined</span>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Export = <span class="tok-kw">struct</span> {
        exported: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        options: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-comment">/// Trailing: `CompileErrors.Item` for each `items_len`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompileErrors = <span class="tok-kw">struct</span> {
        items_len: <span class="tok-type">u32</span>,

        <span class="tok-comment">/// Trailing: `note_payload_index: u32` for each `notes_len`.</span>
        <span class="tok-comment">/// It's a payload index of another `Item`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// null terminated string index</span>
            msg: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            node: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            <span class="tok-comment">/// If node is 0 then this will be populated.</span>
            token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            <span class="tok-comment">/// Can be used in combination with `token`.</span>
            byte_offset: <span class="tok-type">u32</span>,
            <span class="tok-comment">/// 0 or a payload index of a `Block`, each is a payload</span>
            <span class="tok-comment">/// index of another `Item`.</span>
            notes: <span class="tok-type">u32</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">notesLen</span>(item: <a href="std.zig.Zir.Inst.CompileErrors.Item.html">Item</a>, zir: <a href="std.zig.Zir.html">Zir</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">if</span> (item.notes == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
                <span class="tok-kw">const</span> block = zir.extraData(<a href="std.zig.Zir.Inst.Block.html">Block</a>, item.notes);
                <span class="tok-kw">return</span> block.data.body_len;
            }
        };
    };

    <span class="tok-comment">/// Trailing: for each `imports_len` there is an Item</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Imports = <span class="tok-kw">struct</span> {
        imports_len: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// null terminated string index</span>
            name: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
            <span class="tok-comment">/// points to the import name</span>
            token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LineColumn = <span class="tok-kw">struct</span> {
        line: <span class="tok-type">u32</span>,
        column: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayInit = <span class="tok-kw">struct</span> {
        ty: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        init_count: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Src = <span class="tok-kw">struct</span> {
        node: <span class="tok-type">i32</span>,
        line: <span class="tok-type">u32</span>,
        column: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeferErrCode = <span class="tok-kw">struct</span> {
        remapped_err_code: <a href="std.zig.Zir.Inst.Index.html">Index</a>,
        index: <span class="tok-type">u32</span>,
        len: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValidateDestructure = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The value being destructured.</span>
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// The `destructure_assign` node.</span>
        destructure_node: <span class="tok-type">i32</span>,
        <span class="tok-comment">/// The expected field count.</span>
        expect_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayMul = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The result type of the array multiplication operation, or `.none` if none was available.</span>
        res_ty: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// The LHS of the array multiplication.</span>
        lhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// The RHS of the array multiplication.</span>
        rhs: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> RestoreErrRetIndex = <span class="tok-kw">struct</span> {
        src_node: <span class="tok-type">i32</span>,
        <span class="tok-comment">/// If `.none`, restore the trace to its state upon function entry.</span>
        block: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// If `.none`, restore unconditionally.</span>
        operand: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Import = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// The result type of the import, or `.none` if none was available.</span>
        res_ty: <a href="std.zig.Zir.Inst.Ref.html">Ref</a>,
        <span class="tok-comment">/// The import path.</span>
        path: <a href="std.zig.Zir.NullTerminatedString.html">NullTerminatedString</a>,
    };
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
