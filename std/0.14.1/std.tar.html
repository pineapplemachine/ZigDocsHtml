<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.tar.html" class="active">tar</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.tar" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.tar</span><a href="#src.zig-std.tar">[src]</a></h1><div class="tldDocs"><p>Tar archive is single ordinary file which can contain many files (or
directories, symlinks, ...). It's build by series of blocks each size of 512
bytes. First block of each entry is header which defines type, name, size
permissions and other attributes. Header is followed by series of blocks of
file content, if any that entry has content. Content is padded to the block
size, so next header always starts at block boundary.</p>
<p>This simple format is extended by GNU and POSIX pax extensions to support
file names longer than 256 bytes and additional attributes.</p>
<p>This is not comprehensive tar parser. Here we are only file types needed to
support Zig package manager; normal file, directory, symbolic link. And
subset of attributes: name, size, permissions.</p>
<p>GNU tar reference: <a href="https://www.gnu.org/software/tar/manual/html_node/Standard.html">https://www.gnu.org/software/tar/manual/html_node/Standard.html</a>
pax reference: <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13">https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13</a></p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.tar.Diagnostics.html">std.tar.Diagnostics</a></li><li><a href="std.tar.PipeOptions.html">std.tar.PipeOptions</a></li><li><a href="std.tar.IteratorOptions.html">std.tar.IteratorOptions</a></li><li><a href="std.tar.FileKind.html">std.tar.FileKind</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.tar.Iterator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.tar.Iterator">[src]</a></h2><div class="tldDocs"><p>Iterator over entries in the tar file represented by reader.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ReaderType: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.tar.Iterator.File.html">std.tar.Iterator.File</a></li></ul></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>reader: ReaderType</code></pre></div><div><pre><code>diagnostics: ?*<a href="std.tar.Diagnostics.html">Diagnostics</a> = <span class="tok-null">null</span></code></pre></div><div><pre><code>header_buffer: [<a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span></code></pre></div><div><pre><code>file_name_buffer: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>link_name_buffer: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>padding: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>unread_file_bytes: <span class="tok-type">u64</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.tar.Iterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.tar.Iterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>) !?<a href="std.tar.Iterator.File.html">File</a></code></pre></div><div class="tldDocs"><p>Iterates through the tar archive as if it is a series of files.
Internally, the tar format often uses entries (header with optional
content) to add meta data that describes the next file. These
entries should not normally be visible to the outside. As such, this
loop iterates through one or more entries until it collects a all
file attributes.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.tar.html#std.tar.Iterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.tar.Iterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>) !?<a href="std.tar.Iterator.File.html">File</a> {
    <span class="tok-kw">if</span> (self.unread_file_bytes &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
        // If file content was not consumed by caller
        </span><span class="tok-kw">try</span> self.reader.skipBytes(self.unread_file_bytes, .{});
        self.unread_file_bytes = <span class="tok-number">0</span>;
    }
    <span class="tok-kw">var</span> file: <a href="std.tar.Iterator.File.html">File</a> = self.newFile();

    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.readHeader()) |header| {
        <span class="tok-kw">const</span> kind = header.kind();
        <span class="tok-kw">const</span> size: <span class="tok-type">u64</span> = <span class="tok-kw">try</span> header.size();
        self.padding = <a href="std.tar.html#std.tar.Iterator.blockPadding">blockPadding</a>(size);

        <span class="tok-kw">switch</span> (kind) {<span class="tok-comment">
            // File types to return upstream
            </span>.directory, .normal, .symbolic_link =&gt; {
                file.kind = <span class="tok-kw">switch</span> (kind) {
                    .directory =&gt; .directory,
                    .normal =&gt; .file,
                    .symbolic_link =&gt; .sym_link,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
                file.mode = <span class="tok-kw">try</span> header.mode();<span class="tok-comment">

                // set file attributes if not already set by prefix/extended headers
                </span><span class="tok-kw">if</span> (file.size == <span class="tok-number">0</span>) {
                    file.size = size;
                }
                <span class="tok-kw">if</span> (file.link_name.len == <span class="tok-number">0</span>) {
                    file.link_name = <span class="tok-kw">try</span> header.linkName(self.link_name_buffer);
                }
                <span class="tok-kw">if</span> (file.name.len == <span class="tok-number">0</span>) {
                    file.name = <span class="tok-kw">try</span> header.fullName(self.file_name_buffer);
                }

                self.padding = <a href="std.tar.html#std.tar.Iterator.blockPadding">blockPadding</a>(file.size);
                self.unread_file_bytes = file.size;
                <span class="tok-kw">return</span> file;
            },<span class="tok-comment">
            // Prefix header types
            </span>.gnu_long_name =&gt; {
                file.name = <span class="tok-kw">try</span> self.readString(<span class="tok-builtin">@intCast</span>(size), self.file_name_buffer);
            },
            .gnu_long_link =&gt; {
                file.link_name = <span class="tok-kw">try</span> self.readString(<span class="tok-builtin">@intCast</span>(size), self.link_name_buffer);
            },
            .extended_header =&gt; {<span class="tok-comment">
                // Use just attributes from last extended header.
                </span>file = self.newFile();

                <span class="tok-kw">var</span> rdr = <a href="std.tar.html#std.tar.paxIterator">paxIterator</a>(self.reader, <span class="tok-builtin">@intCast</span>(size));
                <span class="tok-kw">while</span> (<span class="tok-kw">try</span> rdr.next()) |attr| {
                    <span class="tok-kw">switch</span> (attr.kind) {
                        .path =&gt; {
                            file.name = <span class="tok-kw">try</span> attr.value(self.file_name_buffer);
                        },
                        .linkpath =&gt; {
                            file.link_name = <span class="tok-kw">try</span> attr.value(self.link_name_buffer);
                        },
                        .size =&gt; {
                            <span class="tok-kw">var</span> buf: [<a href="std.tar.html#std.tar.pax_max_size_attr_len">pax_max_size_attr_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                            file.size = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, <span class="tok-kw">try</span> attr.value(&amp;buf), <span class="tok-number">10</span>);
                        },
                    }
                }
            },<span class="tok-comment">
            // Ignored header type
            </span>.global_extended_header =&gt; {
                self.reader.skipBytes(size, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeadersTooBig;
            },<span class="tok-comment">
            // All other are unsupported header types
            </span><span class="tok-kw">else</span> =&gt; {
                <span class="tok-kw">const</span> d = self.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarUnsupportedHeader;
                <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unsupported_file_type = .{
                    .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, header.name()),
                    .file_type = kind,
                } });
                <span class="tok-kw">if</span> (kind == .gnu_sparse) {
                    <span class="tok-kw">try</span> self.skipGnuSparseExtendedHeaders(header);
                }
                self.reader.skipBytes(size, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeadersTooBig;
            },
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.tar.Iterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> ReaderType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        reader: ReaderType,
        diagnostics: ?*<a href="std.tar.Diagnostics.html">Diagnostics</a> = <span class="tok-null">null</span>,<span class="tok-comment">

        // buffers for heeader and file attributes
        </span>header_buffer: [<a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,
        file_name_buffer: []<span class="tok-type">u8</span>,
        link_name_buffer: []<span class="tok-type">u8</span>,<span class="tok-comment">

        // bytes of padding to the end of the block
        </span>padding: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,<span class="tok-comment">
        // not consumed bytes of file from last next iteration
        </span>unread_file_bytes: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {
            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,<span class="tok-comment"> // name of file, symlink or directory
            </span>link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,<span class="tok-comment"> // target name of symlink
            </span>size: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,<span class="tok-comment"> // size of the file in bytes
            </span>mode: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
            kind: <a href="std.tar.FileKind.html">FileKind</a> = .file,

            unread_bytes: *<span class="tok-type">u64</span>,
            parent_reader: ReaderType,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(<a href="std.tar.Iterator.File.html">File</a>, ReaderType.Error, <a href="std.tar.Iterator.File.html">File</a>.<a href="std.tar.Iterator.File.html#std.tar.Iterator.File.read">read</a>);

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(self: <a href="std.tar.Iterator.File.html">File</a>) <a href="std.tar.Iterator.File.html#std.tar.Iterator.File.Reader">Reader</a> {
                <span class="tok-kw">return</span> .{ .context = self };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: <a href="std.tar.Iterator.File.html">File</a>, dest: []<span class="tok-type">u8</span>) ReaderType.Error!<span class="tok-type">usize</span> {
                <span class="tok-kw">const</span> buf = dest[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(dest.len, self.unread_bytes.*)];
                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.parent_reader.read(buf);
                self.unread_bytes.* -= n;
                <span class="tok-kw">return</span> n;
            }<span class="tok-comment">

            // Writes file content to writer.
            </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(self: <a href="std.tar.Iterator.File.html">File</a>, out_writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
                <span class="tok-kw">var</span> buffer: [<span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

                <span class="tok-kw">while</span> (self.unread_bytes.* &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> buf = buffer[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(buffer.len, self.unread_bytes.*)];
                    <span class="tok-kw">try</span> self.parent_reader.readNoEof(buf);
                    <span class="tok-kw">try</span> out_writer.writeAll(buf);
                    self.unread_bytes.* -= buf.len;
                }
            }
        };

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">fn</span> <span class="tok-fn">readHeader</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>) !?<a href="std.tar.Header.html">Header</a> {
            <span class="tok-kw">if</span> (self.padding &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> self.reader.skipBytes(self.padding, .{});
            }
            <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.reader.readAll(&amp;self.header_buffer);
            <span class="tok-kw">if</span> (n == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (n &lt; <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;
            <span class="tok-kw">const</span> header = <a href="std.tar.Header.html">Header</a>{ .bytes = self.header_buffer[<span class="tok-number">0</span>..<a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>] };
            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> header.checkChksum() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> header;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">readString</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>, size: <span class="tok-type">usize</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">if</span> (size &gt; buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarInsufficientBuffer;
            <span class="tok-kw">const</span> buf = buffer[<span class="tok-number">0</span>..size];
            <span class="tok-kw">try</span> self.reader.readNoEof(buf);
            <span class="tok-kw">return</span> <a href="std.tar.html#std.tar.nullStr">nullStr</a>(buf);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">newFile</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>) <a href="std.tar.Iterator.File.html">File</a> {
            <span class="tok-kw">return</span> .{
                .name = self.file_name_buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],
                .link_name = self.link_name_buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],
                .parent_reader = self.reader,
                .unread_bytes = &amp;self.unread_file_bytes,
            };
        }<span class="tok-comment">

        // Number of padding bytes in the last file block.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">blockPadding</span>(size: <span class="tok-type">u64</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> block_rounded = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">u64</span>, size, <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>);<span class="tok-comment"> // size rounded to te block boundary
            </span><span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(block_rounded - size);
        }

        <span class="tok-comment">/// Iterates through the tar archive as if it is a series of files.</span>
        <span class="tok-comment">/// Internally, the tar format often uses entries (header with optional</span>
        <span class="tok-comment">/// content) to add meta data that describes the next file. These</span>
        <span class="tok-comment">/// entries should not normally be visible to the outside. As such, this</span>
        <span class="tok-comment">/// loop iterates through one or more entries until it collects a all</span>
        <span class="tok-comment">/// file attributes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>) !?<a href="std.tar.Iterator.File.html">File</a> {
            <span class="tok-kw">if</span> (self.unread_file_bytes &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
                // If file content was not consumed by caller
                </span><span class="tok-kw">try</span> self.reader.skipBytes(self.unread_file_bytes, .{});
                self.unread_file_bytes = <span class="tok-number">0</span>;
            }
            <span class="tok-kw">var</span> file: <a href="std.tar.Iterator.File.html">File</a> = self.newFile();

            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.readHeader()) |header| {
                <span class="tok-kw">const</span> kind = header.kind();
                <span class="tok-kw">const</span> size: <span class="tok-type">u64</span> = <span class="tok-kw">try</span> header.size();
                self.padding = <a href="std.tar.html#std.tar.Iterator.blockPadding">blockPadding</a>(size);

                <span class="tok-kw">switch</span> (kind) {<span class="tok-comment">
                    // File types to return upstream
                    </span>.directory, .normal, .symbolic_link =&gt; {
                        file.kind = <span class="tok-kw">switch</span> (kind) {
                            .directory =&gt; .directory,
                            .normal =&gt; .file,
                            .symbolic_link =&gt; .sym_link,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        };
                        file.mode = <span class="tok-kw">try</span> header.mode();<span class="tok-comment">

                        // set file attributes if not already set by prefix/extended headers
                        </span><span class="tok-kw">if</span> (file.size == <span class="tok-number">0</span>) {
                            file.size = size;
                        }
                        <span class="tok-kw">if</span> (file.link_name.len == <span class="tok-number">0</span>) {
                            file.link_name = <span class="tok-kw">try</span> header.linkName(self.link_name_buffer);
                        }
                        <span class="tok-kw">if</span> (file.name.len == <span class="tok-number">0</span>) {
                            file.name = <span class="tok-kw">try</span> header.fullName(self.file_name_buffer);
                        }

                        self.padding = <a href="std.tar.html#std.tar.Iterator.blockPadding">blockPadding</a>(file.size);
                        self.unread_file_bytes = file.size;
                        <span class="tok-kw">return</span> file;
                    },<span class="tok-comment">
                    // Prefix header types
                    </span>.gnu_long_name =&gt; {
                        file.name = <span class="tok-kw">try</span> self.readString(<span class="tok-builtin">@intCast</span>(size), self.file_name_buffer);
                    },
                    .gnu_long_link =&gt; {
                        file.link_name = <span class="tok-kw">try</span> self.readString(<span class="tok-builtin">@intCast</span>(size), self.link_name_buffer);
                    },
                    .extended_header =&gt; {<span class="tok-comment">
                        // Use just attributes from last extended header.
                        </span>file = self.newFile();

                        <span class="tok-kw">var</span> rdr = <a href="std.tar.html#std.tar.paxIterator">paxIterator</a>(self.reader, <span class="tok-builtin">@intCast</span>(size));
                        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> rdr.next()) |attr| {
                            <span class="tok-kw">switch</span> (attr.kind) {
                                .path =&gt; {
                                    file.name = <span class="tok-kw">try</span> attr.value(self.file_name_buffer);
                                },
                                .linkpath =&gt; {
                                    file.link_name = <span class="tok-kw">try</span> attr.value(self.link_name_buffer);
                                },
                                .size =&gt; {
                                    <span class="tok-kw">var</span> buf: [<a href="std.tar.html#std.tar.pax_max_size_attr_len">pax_max_size_attr_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                                    file.size = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, <span class="tok-kw">try</span> attr.value(&amp;buf), <span class="tok-number">10</span>);
                                },
                            }
                        }
                    },<span class="tok-comment">
                    // Ignored header type
                    </span>.global_extended_header =&gt; {
                        self.reader.skipBytes(size, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeadersTooBig;
                    },<span class="tok-comment">
                    // All other are unsupported header types
                    </span><span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">const</span> d = self.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarUnsupportedHeader;
                        <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unsupported_file_type = .{
                            .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, header.name()),
                            .file_type = kind,
                        } });
                        <span class="tok-kw">if</span> (kind == .gnu_sparse) {
                            <span class="tok-kw">try</span> self.skipGnuSparseExtendedHeaders(header);
                        }
                        self.reader.skipBytes(size, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeadersTooBig;
                    },
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">skipGnuSparseExtendedHeaders</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>, header: <a href="std.tar.Header.html">Header</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> is_extended = header.bytes[<span class="tok-number">482</span>] &gt; <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (is_extended) {
                <span class="tok-kw">var</span> buf: [<a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.reader.readAll(&amp;buf);
                <span class="tok-kw">if</span> (n &lt; <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;
                is_extended = buf[<span class="tok-number">504</span>] &gt; <span class="tok-number">0</span>;
            }
        }
    };
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.tar.writer.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.tar.writer.writer">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(underlying_writer: <span class="tok-kw">anytype</span>) <a href="std.tar.writer.html#std.tar.writer.Writer">Writer</a>(<span class="tok-builtin">@TypeOf</span>(underlying_writer))</code></pre></div><div class="tldDocs"><p>Creates tar Writer which will write tar content to the <code>underlying_writer</code>.
Use setRoot to nest all following entries under single root. If file don't
fit into posix header (name+prefix: 100+155 bytes) gnu extented header will
be used for long names. Options enables setting file premission mode and
mtime. Default is to use current time for mtime and 0o664 for file mode.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.tar.writer.writer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(underlying_writer: <span class="tok-kw">anytype</span>) <a href="std.tar.writer.html#std.tar.writer.Writer">Writer</a>(<span class="tok-builtin">@TypeOf</span>(underlying_writer)) {
    <span class="tok-kw">return</span> .{ .underlying_writer = underlying_writer };
}</code></pre></details></div></div><div class="decl"><h2 id="std.tar.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.tar.iterator">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(reader: <span class="tok-kw">anytype</span>, options: <a href="std.tar.IteratorOptions.html">IteratorOptions</a>) <a href="std.tar.html#std.tar.Iterator">Iterator</a>(<span class="tok-builtin">@TypeOf</span>(reader))</code></pre></div><div class="tldDocs"><p>Iterates over files in tar archive.
<code>next</code> returns each file in tar archive.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.tar.IteratorOptions.html">IteratorOptions</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> iterator {<span class="tok-comment">
    // Example tar file is created from this tree structure:
    // $ tree example
    //    example
    //    ├── a
    //    │   └── file
    //    ├── b
    //    │   └── symlink -&gt; ../a/file
    //    └── empty
    // $ cat example/a/file
    //   content
    // $ tar -cf example.tar example
    // $ tar -tvf example.tar
    //    example/
    //    example/b/
    //    example/b/symlink -&gt; ../a/file
    //    example/a/
    //    example/a/file
    //    example/empty/

    </span><span class="tok-kw">const</span> data = <span class="tok-builtin">@embedFile</span>(<span class="tok-str">&quot;tar/testdata/example.tar&quot;</span>);
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);<span class="tok-comment">

    // User provided buffers to the iterator
    </span><span class="tok-kw">var</span> file_name_buffer: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> link_name_buffer: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // Create iterator
    </span><span class="tok-kw">var</span> iter = <a href="std.tar.html#std.tar.iterator">iterator</a>(fbs.reader(), .{
        .file_name_buffer = &amp;file_name_buffer,
        .link_name_buffer = &amp;link_name_buffer,
    });<span class="tok-comment">
    // Iterate over files in example.tar
    </span><span class="tok-kw">var</span> file_no: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |file| : (file_no += <span class="tok-number">1</span>) {
        <span class="tok-kw">switch</span> (file.kind) {
            .directory =&gt; {
                <span class="tok-kw">switch</span> (file_no) {
                    <span class="tok-number">0</span> =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/&quot;</span>, file.name),
                    <span class="tok-number">1</span> =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/b/&quot;</span>, file.name),
                    <span class="tok-number">3</span> =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/a/&quot;</span>, file.name),
                    <span class="tok-number">5</span> =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/empty/&quot;</span>, file.name),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            },
            .file =&gt; {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/a/file&quot;</span>, file.name);<span class="tok-comment">
                // Read file content
                </span><span class="tok-kw">var</span> buf: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> file.reader().readAll(&amp;buf);
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content\n&quot;</span>, buf[<span class="tok-number">0</span>..n]);
            },
            .sym_link =&gt; {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/b/symlink&quot;</span>, file.name);
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;../a/file&quot;</span>, file.link_name);
            },
        }
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.tar.iterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(reader: <span class="tok-kw">anytype</span>, options: <a href="std.tar.IteratorOptions.html">IteratorOptions</a>) <a href="std.tar.html#std.tar.Iterator">Iterator</a>(<span class="tok-builtin">@TypeOf</span>(reader)) {
    <span class="tok-kw">return</span> .{
        .reader = reader,
        .diagnostics = options.diagnostics,
        .file_name_buffer = options.file_name_buffer,
        .link_name_buffer = options.link_name_buffer,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.tar.pipeToFileSystem" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pipeToFileSystem</span><a href="#src.zig-std.tar.pipeToFileSystem">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipeToFileSystem</span>(dir: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, reader: <span class="tok-kw">anytype</span>, options: <a href="std.tar.PipeOptions.html">PipeOptions</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Saves tar file content to the file systems.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>options: <a href="std.tar.PipeOptions.html">PipeOptions</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> pipeToFileSystem {<span class="tok-comment">
    // Example tar file is created from this tree structure:
    // $ tree example
    //    example
    //    ├── a
    //    │   └── file
    //    ├── b
    //    │   └── symlink -&gt; ../a/file
    //    └── empty
    // $ cat example/a/file
    //   content
    // $ tar -cf example.tar example
    // $ tar -tvf example.tar
    //    example/
    //    example/b/
    //    example/b/symlink -&gt; ../a/file
    //    example/a/
    //    example/a/file
    //    example/empty/

    </span><span class="tok-kw">const</span> data = <span class="tok-builtin">@embedFile</span>(<span class="tok-str">&quot;tar/testdata/example.tar&quot;</span>);
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
    <span class="tok-kw">const</span> reader = fbs.reader();

    <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{ .no_follow = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> tmp.cleanup();
    <span class="tok-kw">const</span> dir = tmp.dir;<span class="tok-comment">

    // Save tar from `reader` to the file system `dir`
    </span><a href="std.tar.html#std.tar.pipeToFileSystem">pipeToFileSystem</a>(dir, reader, .{
        .mode_mode = .ignore,
        .strip_components = <span class="tok-number">1</span>,
        .exclude_empty_directories = <span class="tok-null">true</span>,
    }) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // Skip on platform which don't support symlinks
        </span><span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.UnableToCreateSymLink) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
        <span class="tok-kw">return</span> err;
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.FileNotFound, dir.statFile(<span class="tok-str">&quot;empty&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> dir.statFile(<span class="tok-str">&quot;a/file&quot;</span>)).kind == .file);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> dir.statFile(<span class="tok-str">&quot;b/symlink&quot;</span>)).kind == .file);<span class="tok-comment"> // statFile follows symlink

    </span><span class="tok-kw">var</span> buf: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(
        <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;../a/file&quot;</span>,
        <a href="std.tar.html#std.tar.normalizePath">normalizePath</a>(<span class="tok-kw">try</span> dir.readLink(<span class="tok-str">&quot;b/symlink&quot;</span>, &amp;buf)),
    );
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.tar.pipeToFileSystem">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipeToFileSystem</span>(dir: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, reader: <span class="tok-kw">anytype</span>, options: <a href="std.tar.PipeOptions.html">PipeOptions</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> file_name_buffer: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> link_name_buffer: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> iter = <a href="std.tar.html#std.tar.iterator">iterator</a>(reader, .{
        .file_name_buffer = &amp;file_name_buffer,
        .link_name_buffer = &amp;link_name_buffer,
        .diagnostics = options.diagnostics,
    });

    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |file| {
        <span class="tok-kw">const</span> file_name = <a href="std.tar.html#std.tar.stripComponents">stripComponents</a>(file.name, options.strip_components);
        <span class="tok-kw">if</span> (file_name.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> file.kind != .directory) {
            <span class="tok-kw">const</span> d = options.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarComponentsOutsideStrippedPrefix;
            <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .components_outside_stripped_prefix = .{
                .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, file.name),
            } });
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">if</span> (options.diagnostics) |d| {
            <span class="tok-kw">try</span> d.findRoot(file_name);
        }

        <span class="tok-kw">switch</span> (file.kind) {
            .directory =&gt; {
                <span class="tok-kw">if</span> (file_name.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !options.exclude_empty_directories) {
                    <span class="tok-kw">try</span> dir.makePath(file_name);
                }
            },
            .file =&gt; {
                <span class="tok-kw">if</span> (<a href="std.tar.html#std.tar.createDirAndFile">createDirAndFile</a>(dir, file_name, <a href="std.tar.html#std.tar.fileMode">fileMode</a>(file.mode, options))) |fs_file| {
                    <span class="tok-kw">defer</span> fs_file.close();
                    <span class="tok-kw">try</span> file.writeAll(fs_file);
                } <span class="tok-kw">else</span> |err| {
                    <span class="tok-kw">const</span> d = options.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                    <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unable_to_create_file = .{
                        .code = err,
                        .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, file_name),
                    } });
                }
            },
            .sym_link =&gt; {
                <span class="tok-kw">const</span> link_name = file.link_name;
                <a href="std.tar.html#std.tar.createDirAndSymlink">createDirAndSymlink</a>(dir, link_name, file_name) <span class="tok-kw">catch</span> |err| {
                    <span class="tok-kw">const</span> d = options.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToCreateSymLink;
                    <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unable_to_create_sym_link = .{
                        .code = err,
                        .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, file_name),
                        .link_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, link_name),
                    } });
                };
            },
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.tar">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Tar archive is single ordinary file which can contain many files (or</span>
<span class="tok-comment">//! directories, symlinks, ...). It's build by series of blocks each size of 512</span>
<span class="tok-comment">//! bytes. First block of each entry is header which defines type, name, size</span>
<span class="tok-comment">//! permissions and other attributes. Header is followed by series of blocks of</span>
<span class="tok-comment">//! file content, if any that entry has content. Content is padded to the block</span>
<span class="tok-comment">//! size, so next header always starts at block boundary.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! This simple format is extended by GNU and POSIX pax extensions to support</span>
<span class="tok-comment">//! file names longer than 256 bytes and additional attributes.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! This is not comprehensive tar parser. Here we are only file types needed to</span>
<span class="tok-comment">//! support Zig package manager; normal file, directory, symbolic link. And</span>
<span class="tok-comment">//! subset of attributes: name, size, permissions.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! GNU tar reference: https://www.gnu.org/software/tar/manual/html_node/Standard.html</span>
<span class="tok-comment">//! pax reference: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> writer = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;tar/writer.zig&quot;</span>).writer;

<span class="tok-comment">/// Provide this to receive detailed error messages.</span>
<span class="tok-comment">/// When this is provided, some errors which would otherwise be returned</span>
<span class="tok-comment">/// immediately will instead be added to this structure. The API user must check</span>
<span class="tok-comment">/// the errors in diagnostics to know whether the operation succeeded or failed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostics = <span class="tok-kw">struct</span> {
    allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    errors: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.tar.Diagnostics.Error.html">Error</a>) = .empty,

    entries: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    root_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        unable_to_create_sym_link: <span class="tok-kw">struct</span> {
            code: <span class="tok-type">anyerror</span>,
            file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        },
        unable_to_create_file: <span class="tok-kw">struct</span> {
            code: <span class="tok-type">anyerror</span>,
            file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        },
        unsupported_file_type: <span class="tok-kw">struct</span> {
            file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            file_type: <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.Kind.html">Kind</a>,
        },
        components_outside_stripped_prefix: <span class="tok-kw">struct</span> {
            file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        },
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">findRoot</span>(d: *<a href="std.tar.Diagnostics.html">Diagnostics</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (path.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        d.entries += <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> root_dir = <a href="std.tar.Diagnostics.html#std.tar.Diagnostics.rootDir">rootDir</a>(path);
        <span class="tok-kw">if</span> (d.entries == <span class="tok-number">1</span>) {
            d.root_dir = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, root_dir);
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">if</span> (d.root_dir.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, root_dir, d.root_dir))
            <span class="tok-kw">return</span>;
        d.allocator.free(d.root_dir);
        d.root_dir = <span class="tok-str">&quot;&quot;</span>;
    }<span class="tok-comment">

    // Returns root dir of the path, assumes non empty path.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">rootDir</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> start_index: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (path[<span class="tok-number">0</span>] == <span class="tok-str">'/'</span>) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> end_index: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (path[path.len - <span class="tok-number">1</span>] == <span class="tok-str">'/'</span>) path.len - <span class="tok-number">1</span> <span class="tok-kw">else</span> path.len;
        <span class="tok-kw">const</span> buf = path[start_index..end_index];
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(<span class="tok-type">u8</span>, buf, <span class="tok-number">0</span>, <span class="tok-str">'/'</span>)) |idx| {
            <span class="tok-kw">return</span> buf[<span class="tok-number">0</span>..idx];
        }
        <span class="tok-kw">return</span> buf;
    }

    <span class="tok-kw">test</span> rootDir {
        <span class="tok-kw">const</span> expectEqualStrings = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>;
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;a&quot;</span>, <a href="std.tar.Diagnostics.html#std.tar.Diagnostics.rootDir">rootDir</a>(<span class="tok-str">&quot;a&quot;</span>));
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;b&quot;</span>, <a href="std.tar.Diagnostics.html#std.tar.Diagnostics.rootDir">rootDir</a>(<span class="tok-str">&quot;b&quot;</span>));
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;c&quot;</span>, <a href="std.tar.Diagnostics.html#std.tar.Diagnostics.rootDir">rootDir</a>(<span class="tok-str">&quot;/c&quot;</span>));
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;d&quot;</span>, <a href="std.tar.Diagnostics.html#std.tar.Diagnostics.rootDir">rootDir</a>(<span class="tok-str">&quot;/d/&quot;</span>));
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;a&quot;</span>, <a href="std.tar.Diagnostics.html#std.tar.Diagnostics.rootDir">rootDir</a>(<span class="tok-str">&quot;a/b&quot;</span>));
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;a&quot;</span>, <a href="std.tar.Diagnostics.html#std.tar.Diagnostics.rootDir">rootDir</a>(<span class="tok-str">&quot;a/b/c&quot;</span>));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(d: *<a href="std.tar.Diagnostics.html">Diagnostics</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">for</span> (d.errors.items) |item| {
            <span class="tok-kw">switch</span> (item) {
                .unable_to_create_sym_link =&gt; |info| {
                    d.allocator.free(info.file_name);
                    d.allocator.free(info.link_name);
                },
                .unable_to_create_file =&gt; |info| {
                    d.allocator.free(info.file_name);
                },
                .unsupported_file_type =&gt; |info| {
                    d.allocator.free(info.file_name);
                },
                .components_outside_stripped_prefix =&gt; |info| {
                    d.allocator.free(info.file_name);
                },
            }
        }
        d.errors.deinit(d.allocator);
        d.allocator.free(d.root_dir);
        d.* = <span class="tok-null">undefined</span>;
    }
};

<span class="tok-comment">/// pipeToFileSystem options</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PipeOptions = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Number of directory levels to skip when extracting files.</span>
    strip_components: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
    <span class="tok-comment">/// How to handle the &quot;mode&quot; property of files from within the tar file.</span>
    mode_mode: <a href="std.tar.PipeOptions.ModeMode.html">ModeMode</a> = .executable_bit_only,
    <span class="tok-comment">/// Prevents creation of empty directories.</span>
    exclude_empty_directories: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    <span class="tok-comment">/// Collects error messages during unpacking</span>
    diagnostics: ?*<a href="std.tar.Diagnostics.html">Diagnostics</a> = <span class="tok-null">null</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ModeMode = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// The mode from the tar file is completely ignored. Files are created</span>
        <span class="tok-comment">/// with the default mode when creating files.</span>
        ignore,
        <span class="tok-comment">/// The mode from the tar file is inspected for the owner executable bit</span>
        <span class="tok-comment">/// only. This bit is copied to the group and other executable bits.</span>
        <span class="tok-comment">/// Other bits of the mode are left as the default when creating files.</span>
        executable_bit_only,
    };
};

<span class="tok-kw">const</span> Header = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> SIZE = <span class="tok-number">512</span>;
    <span class="tok-kw">const</span> MAX_NAME_SIZE = <span class="tok-number">100</span> + <span class="tok-number">1</span> + <span class="tok-number">155</span>;<span class="tok-comment"> // name(100) + separator(1) + prefix(155)
    </span><span class="tok-kw">const</span> LINK_NAME_SIZE = <span class="tok-number">100</span>;

    bytes: *<span class="tok-kw">const</span> [<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>]<span class="tok-type">u8</span>,

    <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        normal_alias = <span class="tok-number">0</span>,
        normal = <span class="tok-str">'0'</span>,
        hard_link = <span class="tok-str">'1'</span>,
        symbolic_link = <span class="tok-str">'2'</span>,
        character_special = <span class="tok-str">'3'</span>,
        block_special = <span class="tok-str">'4'</span>,
        directory = <span class="tok-str">'5'</span>,
        fifo = <span class="tok-str">'6'</span>,
        contiguous = <span class="tok-str">'7'</span>,
        global_extended_header = <span class="tok-str">'g'</span>,
        extended_header = <span class="tok-str">'x'</span>,<span class="tok-comment">
        // Types 'L' and 'K' are used by the GNU format for a meta file
        // used to store the path or link name for the next file.
        </span>gnu_long_name = <span class="tok-str">'L'</span>,
        gnu_long_link = <span class="tok-str">'K'</span>,
        gnu_sparse = <span class="tok-str">'S'</span>,
        solaris_extended_header = <span class="tok-str">'X'</span>,
        _,
    };

    <span class="tok-comment">/// Includes prefix concatenated, if any.</span>
    <span class="tok-comment">/// TODO: check against &quot;../&quot; and other nefarious things</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullName</span>(header: <a href="std.tar.Header.html">Header</a>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> n = <a href="std.tar.Header.html#std.tar.Header.name">name</a>(header);
        <span class="tok-kw">const</span> p = <a href="std.tar.Header.html#std.tar.Header.prefix">prefix</a>(header);
        <span class="tok-kw">if</span> (buffer.len &lt; n.len + p.len + <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarInsufficientBuffer;
        <span class="tok-kw">if</span> (!<a href="std.tar.Header.html#std.tar.Header.is_ustar">is_ustar</a>(header) <span class="tok-kw">or</span> p.len == <span class="tok-number">0</span>) {
            <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..n.len], n);
            <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..n.len];
        }
        <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..p.len], p);
        buffer[p.len] = <span class="tok-str">'/'</span>;
        <span class="tok-builtin">@memcpy</span>(buffer[p.len + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..n.len], n);
        <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span> .. p.len + <span class="tok-number">1</span> + n.len];
    }

    <span class="tok-comment">/// When kind is symbolic_link linked-to name (target_path) is specified in</span>
    <span class="tok-comment">/// the linkname field.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkName</span>(header: <a href="std.tar.Header.html">Header</a>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> link_name = header.str(<span class="tok-number">157</span>, <span class="tok-number">100</span>);
        <span class="tok-kw">if</span> (link_name.len == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
        }
        <span class="tok-kw">if</span> (buffer.len &lt; link_name.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarInsufficientBuffer;
        <span class="tok-kw">const</span> buf = buffer[<span class="tok-number">0</span>..link_name.len];
        <span class="tok-builtin">@memcpy</span>(buf, link_name);
        <span class="tok-kw">return</span> buf;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name</span>(header: <a href="std.tar.Header.html">Header</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> header.str(<span class="tok-number">0</span>, <span class="tok-number">100</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mode</span>(header: <a href="std.tar.Header.html">Header</a>) !<span class="tok-type">u32</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-kw">try</span> header.octal(<span class="tok-number">100</span>, <span class="tok-number">8</span>));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">size</span>(header: <a href="std.tar.Header.html">Header</a>) !<span class="tok-type">u64</span> {
        <span class="tok-kw">const</span> start = <span class="tok-number">124</span>;
        <span class="tok-kw">const</span> len = <span class="tok-number">12</span>;
        <span class="tok-kw">const</span> raw = header.bytes[start..][<span class="tok-number">0</span>..len];<span class="tok-comment">
        //  If the leading byte is 0xff (255), all the bytes of the field
        //  (including the leading byte) are concatenated in big-endian order,
        //  with the result being a negative number expressed in two’s
        //  complement form.
        </span><span class="tok-kw">if</span> (raw[<span class="tok-number">0</span>] == <span class="tok-number">0xff</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarNumericValueNegative;<span class="tok-comment">
        // If the leading byte is 0x80 (128), the non-leading bytes of the
        // field are concatenated in big-endian order.
        </span><span class="tok-kw">if</span> (raw[<span class="tok-number">0</span>] == <span class="tok-number">0x80</span>) {
            <span class="tok-kw">if</span> (raw[<span class="tok-number">1</span>] != <span class="tok-number">0</span> <span class="tok-kw">or</span> raw[<span class="tok-number">2</span>] != <span class="tok-number">0</span> <span class="tok-kw">or</span> raw[<span class="tok-number">3</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarNumericValueTooBig;
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u64</span>, raw[<span class="tok-number">4</span>..<span class="tok-number">12</span>], .big);
        }
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> header.octal(start, len);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chksum</span>(header: <a href="std.tar.Header.html">Header</a>) !<span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> header.octal(<span class="tok-number">148</span>, <span class="tok-number">8</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">is_ustar</span>(header: <a href="std.tar.Header.html">Header</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> magic = header.bytes[<span class="tok-number">257</span>..][<span class="tok-number">0</span>..<span class="tok-number">6</span>];
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, magic[<span class="tok-number">0</span>..<span class="tok-number">5</span>], <span class="tok-str">&quot;ustar&quot;</span>) <span class="tok-kw">and</span> (magic[<span class="tok-number">5</span>] == <span class="tok-number">0</span> <span class="tok-kw">or</span> magic[<span class="tok-number">5</span>] == <span class="tok-str">' '</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefix</span>(header: <a href="std.tar.Header.html">Header</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> header.str(<span class="tok-number">345</span>, <span class="tok-number">155</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kind</span>(header: <a href="std.tar.Header.html">Header</a>) <a href="std.tar.Header.Kind.html">Kind</a> {
        <span class="tok-kw">const</span> result: <a href="std.tar.Header.Kind.html">Kind</a> = <span class="tok-builtin">@enumFromInt</span>(header.bytes[<span class="tok-number">156</span>]);
        <span class="tok-kw">if</span> (result == .normal_alias) <span class="tok-kw">return</span> .normal;
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">str</span>(header: <a href="std.tar.Header.html">Header</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <a href="std.tar.html#std.tar.nullStr">nullStr</a>(header.bytes[start .. start + len]);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">octal</span>(header: <a href="std.tar.Header.html">Header</a>, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">u64</span> {
        <span class="tok-kw">const</span> raw = header.bytes[start..][<span class="tok-number">0</span>..len];<span class="tok-comment">
        // Zero-filled octal number in ASCII. Each numeric field of width w
        // contains w minus 1 digits, and a null
        </span><span class="tok-kw">const</span> ltrimmed = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trimLeft">trimLeft</a>(<span class="tok-type">u8</span>, raw, <span class="tok-str">&quot;0 &quot;</span>);
        <span class="tok-kw">const</span> rtrimmed = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trimRight">trimRight</a>(<span class="tok-type">u8</span>, ltrimmed, <span class="tok-str">&quot; \x00&quot;</span>);
        <span class="tok-kw">if</span> (rtrimmed.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, rtrimmed, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeader;
    }

    <span class="tok-kw">const</span> Chksums = <span class="tok-kw">struct</span> {
        unsigned: <span class="tok-type">u64</span>,
        signed: <span class="tok-type">i64</span>,
    };<span class="tok-comment">

    // Sum of all bytes in the header block. The chksum field is treated as if
    // it were filled with spaces (ASCII 32).
    </span><span class="tok-kw">fn</span> <span class="tok-fn">computeChksum</span>(header: <a href="std.tar.Header.html">Header</a>) <a href="std.tar.Header.Chksums.html">Chksums</a> {
        <span class="tok-kw">var</span> cs: <a href="std.tar.Header.Chksums.html">Chksums</a> = .{ .signed = <span class="tok-number">0</span>, .unsigned = <span class="tok-number">0</span> };
        <span class="tok-kw">for</span> (header.bytes, <span class="tok-number">0</span>..) |v, i| {
            <span class="tok-kw">const</span> b = <span class="tok-kw">if</span> (<span class="tok-number">148</span> &lt;= i <span class="tok-kw">and</span> i &lt; <span class="tok-number">156</span>) <span class="tok-number">32</span> <span class="tok-kw">else</span> v;<span class="tok-comment"> // Treating chksum bytes as spaces.
            </span>cs.unsigned += b;
            cs.signed += <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-builtin">@bitCast</span>(b));
        }
        <span class="tok-kw">return</span> cs;
    }<span class="tok-comment">

    // Checks calculated chksum with value of chksum field.
    // Returns error or valid chksum value.
    // Zero value indicates empty block.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkChksum</span>(header: <a href="std.tar.Header.html">Header</a>) !<span class="tok-type">u64</span> {
        <span class="tok-kw">const</span> field = <span class="tok-kw">try</span> header.chksum();
        <span class="tok-kw">const</span> cs = header.computeChksum();
        <span class="tok-kw">if</span> (field == <span class="tok-number">0</span> <span class="tok-kw">and</span> cs.unsigned == <span class="tok-number">256</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (field != cs.unsigned <span class="tok-kw">and</span> field != cs.signed) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeaderChksum;
        <span class="tok-kw">return</span> field;
    }
};<span class="tok-comment">

// Breaks string on first null character.
</span><span class="tok-kw">fn</span> <span class="tok-fn">nullStr</span>(str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">for</span> (str, <span class="tok-number">0</span>..) |c, i| {
        <span class="tok-kw">if</span> (c == <span class="tok-number">0</span>) <span class="tok-kw">return</span> str[<span class="tok-number">0</span>..i];
    }
    <span class="tok-kw">return</span> str;
}

<span class="tok-comment">/// Options for iterator.</span>
<span class="tok-comment">/// Buffers should be provided by the caller.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IteratorOptions = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Use a buffer with length `std.fs.max_path_bytes` to match file system capabilities.</span>
    file_name_buffer: []<span class="tok-type">u8</span>,
    <span class="tok-comment">/// Use a buffer with length `std.fs.max_path_bytes` to match file system capabilities.</span>
    link_name_buffer: []<span class="tok-type">u8</span>,
    <span class="tok-comment">/// Collects error messages during unpacking</span>
    diagnostics: ?*<a href="std.tar.Diagnostics.html">Diagnostics</a> = <span class="tok-null">null</span>,
};

<span class="tok-comment">/// Iterates over files in tar archive.</span>
<span class="tok-comment">/// `next` returns each file in tar archive.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(reader: <span class="tok-kw">anytype</span>, options: <a href="std.tar.IteratorOptions.html">IteratorOptions</a>) <a href="std.tar.html#std.tar.Iterator">Iterator</a>(<span class="tok-builtin">@TypeOf</span>(reader)) {
    <span class="tok-kw">return</span> .{
        .reader = reader,
        .diagnostics = options.diagnostics,
        .file_name_buffer = options.file_name_buffer,
        .link_name_buffer = options.link_name_buffer,
    };
}

<span class="tok-comment">/// Type of the file returned by iterator `next` method.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FileKind = <span class="tok-kw">enum</span> {
    directory,
    sym_link,
    file,
};

<span class="tok-comment">/// Iterator over entries in the tar file represented by reader.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> ReaderType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        reader: ReaderType,
        diagnostics: ?*<a href="std.tar.Diagnostics.html">Diagnostics</a> = <span class="tok-null">null</span>,<span class="tok-comment">

        // buffers for heeader and file attributes
        </span>header_buffer: [<a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,
        file_name_buffer: []<span class="tok-type">u8</span>,
        link_name_buffer: []<span class="tok-type">u8</span>,<span class="tok-comment">

        // bytes of padding to the end of the block
        </span>padding: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,<span class="tok-comment">
        // not consumed bytes of file from last next iteration
        </span>unread_file_bytes: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {
            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,<span class="tok-comment"> // name of file, symlink or directory
            </span>link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,<span class="tok-comment"> // target name of symlink
            </span>size: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,<span class="tok-comment"> // size of the file in bytes
            </span>mode: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
            kind: <a href="std.tar.FileKind.html">FileKind</a> = .file,

            unread_bytes: *<span class="tok-type">u64</span>,
            parent_reader: ReaderType,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(<a href="std.tar.Iterator.File.html">File</a>, ReaderType.Error, <a href="std.tar.Iterator.File.html">File</a>.<a href="std.tar.Iterator.File.html#std.tar.Iterator.File.read">read</a>);

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(self: <a href="std.tar.Iterator.File.html">File</a>) <a href="std.tar.Iterator.File.html#std.tar.Iterator.File.Reader">Reader</a> {
                <span class="tok-kw">return</span> .{ .context = self };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: <a href="std.tar.Iterator.File.html">File</a>, dest: []<span class="tok-type">u8</span>) ReaderType.Error!<span class="tok-type">usize</span> {
                <span class="tok-kw">const</span> buf = dest[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(dest.len, self.unread_bytes.*)];
                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.parent_reader.read(buf);
                self.unread_bytes.* -= n;
                <span class="tok-kw">return</span> n;
            }<span class="tok-comment">

            // Writes file content to writer.
            </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(self: <a href="std.tar.Iterator.File.html">File</a>, out_writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
                <span class="tok-kw">var</span> buffer: [<span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

                <span class="tok-kw">while</span> (self.unread_bytes.* &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> buf = buffer[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(buffer.len, self.unread_bytes.*)];
                    <span class="tok-kw">try</span> self.parent_reader.readNoEof(buf);
                    <span class="tok-kw">try</span> out_writer.writeAll(buf);
                    self.unread_bytes.* -= buf.len;
                }
            }
        };

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">fn</span> <span class="tok-fn">readHeader</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>) !?<a href="std.tar.Header.html">Header</a> {
            <span class="tok-kw">if</span> (self.padding &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> self.reader.skipBytes(self.padding, .{});
            }
            <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.reader.readAll(&amp;self.header_buffer);
            <span class="tok-kw">if</span> (n == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (n &lt; <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;
            <span class="tok-kw">const</span> header = <a href="std.tar.Header.html">Header</a>{ .bytes = self.header_buffer[<span class="tok-number">0</span>..<a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>] };
            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> header.checkChksum() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> header;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">readString</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>, size: <span class="tok-type">usize</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">if</span> (size &gt; buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarInsufficientBuffer;
            <span class="tok-kw">const</span> buf = buffer[<span class="tok-number">0</span>..size];
            <span class="tok-kw">try</span> self.reader.readNoEof(buf);
            <span class="tok-kw">return</span> <a href="std.tar.html#std.tar.nullStr">nullStr</a>(buf);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">newFile</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>) <a href="std.tar.Iterator.File.html">File</a> {
            <span class="tok-kw">return</span> .{
                .name = self.file_name_buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],
                .link_name = self.link_name_buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],
                .parent_reader = self.reader,
                .unread_bytes = &amp;self.unread_file_bytes,
            };
        }<span class="tok-comment">

        // Number of padding bytes in the last file block.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">blockPadding</span>(size: <span class="tok-type">u64</span>) <span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> block_rounded = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">u64</span>, size, <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>);<span class="tok-comment"> // size rounded to te block boundary
            </span><span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(block_rounded - size);
        }

        <span class="tok-comment">/// Iterates through the tar archive as if it is a series of files.</span>
        <span class="tok-comment">/// Internally, the tar format often uses entries (header with optional</span>
        <span class="tok-comment">/// content) to add meta data that describes the next file. These</span>
        <span class="tok-comment">/// entries should not normally be visible to the outside. As such, this</span>
        <span class="tok-comment">/// loop iterates through one or more entries until it collects a all</span>
        <span class="tok-comment">/// file attributes.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>) !?<a href="std.tar.Iterator.File.html">File</a> {
            <span class="tok-kw">if</span> (self.unread_file_bytes &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
                // If file content was not consumed by caller
                </span><span class="tok-kw">try</span> self.reader.skipBytes(self.unread_file_bytes, .{});
                self.unread_file_bytes = <span class="tok-number">0</span>;
            }
            <span class="tok-kw">var</span> file: <a href="std.tar.Iterator.File.html">File</a> = self.newFile();

            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.readHeader()) |header| {
                <span class="tok-kw">const</span> kind = header.kind();
                <span class="tok-kw">const</span> size: <span class="tok-type">u64</span> = <span class="tok-kw">try</span> header.size();
                self.padding = <a href="std.tar.html#std.tar.Iterator.blockPadding">blockPadding</a>(size);

                <span class="tok-kw">switch</span> (kind) {<span class="tok-comment">
                    // File types to return upstream
                    </span>.directory, .normal, .symbolic_link =&gt; {
                        file.kind = <span class="tok-kw">switch</span> (kind) {
                            .directory =&gt; .directory,
                            .normal =&gt; .file,
                            .symbolic_link =&gt; .sym_link,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        };
                        file.mode = <span class="tok-kw">try</span> header.mode();<span class="tok-comment">

                        // set file attributes if not already set by prefix/extended headers
                        </span><span class="tok-kw">if</span> (file.size == <span class="tok-number">0</span>) {
                            file.size = size;
                        }
                        <span class="tok-kw">if</span> (file.link_name.len == <span class="tok-number">0</span>) {
                            file.link_name = <span class="tok-kw">try</span> header.linkName(self.link_name_buffer);
                        }
                        <span class="tok-kw">if</span> (file.name.len == <span class="tok-number">0</span>) {
                            file.name = <span class="tok-kw">try</span> header.fullName(self.file_name_buffer);
                        }

                        self.padding = <a href="std.tar.html#std.tar.Iterator.blockPadding">blockPadding</a>(file.size);
                        self.unread_file_bytes = file.size;
                        <span class="tok-kw">return</span> file;
                    },<span class="tok-comment">
                    // Prefix header types
                    </span>.gnu_long_name =&gt; {
                        file.name = <span class="tok-kw">try</span> self.readString(<span class="tok-builtin">@intCast</span>(size), self.file_name_buffer);
                    },
                    .gnu_long_link =&gt; {
                        file.link_name = <span class="tok-kw">try</span> self.readString(<span class="tok-builtin">@intCast</span>(size), self.link_name_buffer);
                    },
                    .extended_header =&gt; {<span class="tok-comment">
                        // Use just attributes from last extended header.
                        </span>file = self.newFile();

                        <span class="tok-kw">var</span> rdr = <a href="std.tar.html#std.tar.paxIterator">paxIterator</a>(self.reader, <span class="tok-builtin">@intCast</span>(size));
                        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> rdr.next()) |attr| {
                            <span class="tok-kw">switch</span> (attr.kind) {
                                .path =&gt; {
                                    file.name = <span class="tok-kw">try</span> attr.value(self.file_name_buffer);
                                },
                                .linkpath =&gt; {
                                    file.link_name = <span class="tok-kw">try</span> attr.value(self.link_name_buffer);
                                },
                                .size =&gt; {
                                    <span class="tok-kw">var</span> buf: [<a href="std.tar.html#std.tar.pax_max_size_attr_len">pax_max_size_attr_len</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                                    file.size = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, <span class="tok-kw">try</span> attr.value(&amp;buf), <span class="tok-number">10</span>);
                                },
                            }
                        }
                    },<span class="tok-comment">
                    // Ignored header type
                    </span>.global_extended_header =&gt; {
                        self.reader.skipBytes(size, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeadersTooBig;
                    },<span class="tok-comment">
                    // All other are unsupported header types
                    </span><span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">const</span> d = self.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarUnsupportedHeader;
                        <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unsupported_file_type = .{
                            .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, header.name()),
                            .file_type = kind,
                        } });
                        <span class="tok-kw">if</span> (kind == .gnu_sparse) {
                            <span class="tok-kw">try</span> self.skipGnuSparseExtendedHeaders(header);
                        }
                        self.reader.skipBytes(size, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeadersTooBig;
                    },
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">skipGnuSparseExtendedHeaders</span>(self: *<a href="std.tar.html#std.tar.Iterator">Self</a>, header: <a href="std.tar.Header.html">Header</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> is_extended = header.bytes[<span class="tok-number">482</span>] &gt; <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (is_extended) {
                <span class="tok-kw">var</span> buf: [<a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.reader.readAll(&amp;buf);
                <span class="tok-kw">if</span> (n &lt; <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;
                is_extended = buf[<span class="tok-number">504</span>] &gt; <span class="tok-number">0</span>;
            }
        }
    };
}

<span class="tok-comment">/// Pax attributes iterator.</span>
<span class="tok-comment">/// Size is length of pax extended header in reader.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">paxIterator</span>(reader: <span class="tok-kw">anytype</span>, size: <span class="tok-type">usize</span>) <a href="std.tar.html#std.tar.PaxIterator">PaxIterator</a>(<span class="tok-builtin">@TypeOf</span>(reader)) {
    <span class="tok-kw">return</span> <a href="std.tar.html#std.tar.PaxIterator">PaxIterator</a>(<span class="tok-builtin">@TypeOf</span>(reader)){
        .reader = reader,
        .size = size,
    };
}

<span class="tok-kw">const</span> PaxAttributeKind = <span class="tok-kw">enum</span> {
    path,
    linkpath,
    size,
};<span class="tok-comment">

// maxInt(u64) has 20 chars, base 10 in practice we got 24 chars
</span><span class="tok-kw">const</span> pax_max_size_attr_len = <span class="tok-number">64</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">PaxIterator</span>(<span class="tok-kw">comptime</span> ReaderType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        size: <span class="tok-type">usize</span>,<span class="tok-comment"> // cumulative size of all pax attributes
        </span>reader: ReaderType,<span class="tok-comment">
        // scratch buffer used for reading attribute length and keyword
        </span>scratch: [<span class="tok-number">128</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">const</span> Attribute = <span class="tok-kw">struct</span> {
            kind: <a href="std.tar.PaxAttributeKind.html">PaxAttributeKind</a>,
            len: <span class="tok-type">usize</span>,<span class="tok-comment"> // length of the attribute value
            </span>reader: ReaderType,<span class="tok-comment"> // reader positioned at value start

            // Copies pax attribute value into destination buffer.
            // Must be called with destination buffer of size at least Attribute.len.
            </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">value</span>(self: <a href="std.tar.PaxIterator.Attribute.html">Attribute</a>, dst: []<span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
                <span class="tok-kw">if</span> (self.len &gt; dst.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarInsufficientBuffer;<span class="tok-comment">
                // assert(self.len &lt;= dst.len);
                </span><span class="tok-kw">const</span> buf = dst[<span class="tok-number">0</span>..self.len];
                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.reader.readAll(buf);
                <span class="tok-kw">if</span> (n &lt; self.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;
                <span class="tok-kw">try</span> <a href="std.tar.html#std.tar.PaxIterator.validateAttributeEnding">validateAttributeEnding</a>(self.reader);
                <span class="tok-kw">if</span> (<a href="std.tar.html#std.tar.PaxIterator.hasNull">hasNull</a>(buf)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PaxNullInValue;
                <span class="tok-kw">return</span> buf;
            }
        };<span class="tok-comment">

        // Iterates over pax attributes. Returns known only known attributes.
        // Caller has to call value in Attribute, to advance reader across value.
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.tar.html#std.tar.PaxIterator">Self</a>) !?<a href="std.tar.PaxIterator.Attribute.html">Attribute</a> {<span class="tok-comment">
            // Pax extended header consists of one or more attributes, each constructed as follows:
            // &quot;%d %s=%s\n&quot;, &lt;length&gt;, &lt;keyword&gt;, &lt;value&gt;
            </span><span class="tok-kw">while</span> (self.size &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> length_buf = <span class="tok-kw">try</span> self.readUntil(<span class="tok-str">' '</span>);
                <span class="tok-kw">const</span> length = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">usize</span>, length_buf, <span class="tok-number">10</span>);<span class="tok-comment"> // record length in bytes

                </span><span class="tok-kw">const</span> keyword = <span class="tok-kw">try</span> self.readUntil(<span class="tok-str">'='</span>);
                <span class="tok-kw">if</span> (<a href="std.tar.html#std.tar.PaxIterator.hasNull">hasNull</a>(keyword)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PaxNullInKeyword;<span class="tok-comment">

                // calculate value_len
                </span><span class="tok-kw">const</span> value_start = length_buf.len + keyword.len + <span class="tok-number">2</span>;<span class="tok-comment"> // 2 separators
                </span><span class="tok-kw">if</span> (length &lt; value_start + <span class="tok-number">1</span> <span class="tok-kw">or</span> self.size &lt; length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;
                <span class="tok-kw">const</span> value_len = length - value_start - <span class="tok-number">1</span>;<span class="tok-comment"> // \n separator at end
                </span>self.size -= length;

                <span class="tok-kw">const</span> kind: <a href="std.tar.PaxAttributeKind.html">PaxAttributeKind</a> = <span class="tok-kw">if</span> (<a href="std.tar.html#std.tar.PaxIterator.eql">eql</a>(keyword, <span class="tok-str">&quot;path&quot;</span>))
                    .path
                <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.tar.html#std.tar.PaxIterator.eql">eql</a>(keyword, <span class="tok-str">&quot;linkpath&quot;</span>))
                    .linkpath
                <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.tar.html#std.tar.PaxIterator.eql">eql</a>(keyword, <span class="tok-str">&quot;size&quot;</span>))
                    .size
                <span class="tok-kw">else</span> {
                    <span class="tok-kw">try</span> self.reader.skipBytes(value_len, .{});
                    <span class="tok-kw">try</span> <a href="std.tar.html#std.tar.PaxIterator.validateAttributeEnding">validateAttributeEnding</a>(self.reader);
                    <span class="tok-kw">continue</span>;
                };
                <span class="tok-kw">if</span> (kind == .size <span class="tok-kw">and</span> value_len &gt; <a href="std.tar.html#std.tar.pax_max_size_attr_len">pax_max_size_attr_len</a>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PaxSizeAttrOverflow;
                }
                <span class="tok-kw">return</span> <a href="std.tar.PaxIterator.Attribute.html">Attribute</a>{
                    .kind = kind,
                    .len = value_len,
                    .reader = self.reader,
                };
            }

            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">readUntil</span>(self: *<a href="std.tar.html#std.tar.PaxIterator">Self</a>, delimiter: <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(&amp;self.scratch);
            <span class="tok-kw">try</span> self.reader.streamUntilDelimiter(fbs.writer(), delimiter, <span class="tok-null">null</span>);
            <span class="tok-kw">return</span> fbs.getWritten();
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, b);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">hasNull</span>(str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, str, <span class="tok-number">0</span>)) != <span class="tok-null">null</span>;
        }<span class="tok-comment">

        // Checks that each record ends with new line.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">validateAttributeEnding</span>(reader: ReaderType) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> reader.readByte() != <span class="tok-str">'\n'</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PaxInvalidAttributeEnd;
        }
    };
}

<span class="tok-comment">/// Saves tar file content to the file systems.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipeToFileSystem</span>(dir: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, reader: <span class="tok-kw">anytype</span>, options: <a href="std.tar.PipeOptions.html">PipeOptions</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> file_name_buffer: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> link_name_buffer: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> iter = <a href="std.tar.html#std.tar.iterator">iterator</a>(reader, .{
        .file_name_buffer = &amp;file_name_buffer,
        .link_name_buffer = &amp;link_name_buffer,
        .diagnostics = options.diagnostics,
    });

    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |file| {
        <span class="tok-kw">const</span> file_name = <a href="std.tar.html#std.tar.stripComponents">stripComponents</a>(file.name, options.strip_components);
        <span class="tok-kw">if</span> (file_name.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> file.kind != .directory) {
            <span class="tok-kw">const</span> d = options.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarComponentsOutsideStrippedPrefix;
            <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .components_outside_stripped_prefix = .{
                .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, file.name),
            } });
            <span class="tok-kw">continue</span>;
        }
        <span class="tok-kw">if</span> (options.diagnostics) |d| {
            <span class="tok-kw">try</span> d.findRoot(file_name);
        }

        <span class="tok-kw">switch</span> (file.kind) {
            .directory =&gt; {
                <span class="tok-kw">if</span> (file_name.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !options.exclude_empty_directories) {
                    <span class="tok-kw">try</span> dir.makePath(file_name);
                }
            },
            .file =&gt; {
                <span class="tok-kw">if</span> (<a href="std.tar.html#std.tar.createDirAndFile">createDirAndFile</a>(dir, file_name, <a href="std.tar.html#std.tar.fileMode">fileMode</a>(file.mode, options))) |fs_file| {
                    <span class="tok-kw">defer</span> fs_file.close();
                    <span class="tok-kw">try</span> file.writeAll(fs_file);
                } <span class="tok-kw">else</span> |err| {
                    <span class="tok-kw">const</span> d = options.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                    <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unable_to_create_file = .{
                        .code = err,
                        .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, file_name),
                    } });
                }
            },
            .sym_link =&gt; {
                <span class="tok-kw">const</span> link_name = file.link_name;
                <a href="std.tar.html#std.tar.createDirAndSymlink">createDirAndSymlink</a>(dir, link_name, file_name) <span class="tok-kw">catch</span> |err| {
                    <span class="tok-kw">const</span> d = options.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToCreateSymLink;
                    <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unable_to_create_sym_link = .{
                        .code = err,
                        .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, file_name),
                        .link_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, link_name),
                    } });
                };
            },
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">createDirAndFile</span>(dir: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.mode_t">Mode</a>) !<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">const</span> fs_file = dir.createFile(file_name, .{ .exclusive = <span class="tok-null">true</span>, .mode = mode }) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.FileNotFound) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(file_name)) |dir_name| {
                <span class="tok-kw">try</span> dir.makePath(dir_name);
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> dir.createFile(file_name, .{ .exclusive = <span class="tok-null">true</span>, .mode = mode });
            }
        }
        <span class="tok-kw">return</span> err;
    };
    <span class="tok-kw">return</span> fs_file;
}<span class="tok-comment">

// Creates a symbolic link at path `file_name` which points to `link_name`.
</span><span class="tok-kw">fn</span> <span class="tok-fn">createDirAndSymlink</span>(dir: <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    dir.symLink(link_name, file_name, .{}) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.FileNotFound) {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(file_name)) |dir_name| {
                <span class="tok-kw">try</span> dir.makePath(dir_name);
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> dir.symLink(link_name, file_name, .{});
            }
        }
        <span class="tok-kw">return</span> err;
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">stripComponents</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, count: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> c = count;
    <span class="tok-kw">while</span> (c &gt; <span class="tok-number">0</span>) : (c -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(<span class="tok-type">u8</span>, path, i, <span class="tok-str">'/'</span>)) |pos| {
            i = pos + <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            i = path.len;
            <span class="tok-kw">break</span>;
        }
    }
    <span class="tok-kw">return</span> path[i..];
}

<span class="tok-kw">test</span> stripComponents {
    <span class="tok-kw">const</span> expectEqualStrings = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>;
    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;a/b/c&quot;</span>, <a href="std.tar.html#std.tar.stripComponents">stripComponents</a>(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">0</span>));
    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;b/c&quot;</span>, <a href="std.tar.html#std.tar.stripComponents">stripComponents</a>(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;c&quot;</span>, <a href="std.tar.html#std.tar.stripComponents">stripComponents</a>(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">2</span>));
    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;&quot;</span>, <a href="std.tar.html#std.tar.stripComponents">stripComponents</a>(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">3</span>));
    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;&quot;</span>, <a href="std.tar.html#std.tar.stripComponents">stripComponents</a>(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">4</span>));
}

<span class="tok-kw">test</span> PaxIterator {
    <span class="tok-kw">const</span> Attr = <span class="tok-kw">struct</span> {
        kind: <a href="std.tar.PaxAttributeKind.html">PaxAttributeKind</a>,
        value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,
        err: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">const</span> cases = [_]<span class="tok-kw">struct</span> {
        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        attrs: []<span class="tok-kw">const</span> Attr,
        err: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>,
    }{
        .{<span class="tok-comment"> // valid but unknown keys
            </span>.data =
            <span class="tok-str">\\30 mtime=1350244992.023960108</span>
            <span class="tok-str">\\6 k=1</span>
            <span class="tok-str">\\13 key1=val1</span>
            <span class="tok-str">\\10 a=name</span>
            <span class="tok-str">\\9 a=name</span>
            <span class="tok-str">\\</span>
            ,
            .attrs = &amp;[_]Attr{},
        },
        .{<span class="tok-comment"> // mix of known and unknown keys
            </span>.data =
            <span class="tok-str">\\6 k=1</span>
            <span class="tok-str">\\13 path=name</span>
            <span class="tok-str">\\17 linkpath=link</span>
            <span class="tok-str">\\13 key1=val1</span>
            <span class="tok-str">\\12 size=123</span>
            <span class="tok-str">\\13 key2=val2</span>
            <span class="tok-str">\\</span>
            ,
            .attrs = &amp;[_]Attr{
                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },
                .{ .kind = .linkpath, .value = <span class="tok-str">&quot;link&quot;</span> },
                .{ .kind = .size, .value = <span class="tok-str">&quot;123&quot;</span> },
            },
        },
        .{<span class="tok-comment"> // too short size of the second key-value pair
            </span>.data =
            <span class="tok-str">\\13 path=name</span>
            <span class="tok-str">\\10 linkpath=value</span>
            <span class="tok-str">\\</span>
            ,
            .attrs = &amp;[_]Attr{
                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },
            },
            .err = <span class="tok-kw">error</span>.UnexpectedEndOfStream,
        },
        .{<span class="tok-comment"> // too long size of the second key-value pair
            </span>.data =
            <span class="tok-str">\\13 path=name</span>
            <span class="tok-str">\\6 k=1</span>
            <span class="tok-str">\\19 linkpath=value</span>
            <span class="tok-str">\\</span>
            ,
            .attrs = &amp;[_]Attr{
                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },
            },
            .err = <span class="tok-kw">error</span>.UnexpectedEndOfStream,
        },

        .{<span class="tok-comment"> // too long size of the second key-value pair
            </span>.data =
            <span class="tok-str">\\13 path=name</span>
            <span class="tok-str">\\19 linkpath=value</span>
            <span class="tok-str">\\6 k=1</span>
            <span class="tok-str">\\</span>
            ,
            .attrs = &amp;[_]Attr{
                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },
                .{ .kind = .linkpath, .err = <span class="tok-kw">error</span>.PaxInvalidAttributeEnd },
            },
        },
        .{<span class="tok-comment"> // null in keyword is not valid
            </span>.data = <span class="tok-str">&quot;13 path=name\n&quot;</span> ++ <span class="tok-str">&quot;7 k\x00b=1\n&quot;</span>,
            .attrs = &amp;[_]Attr{
                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },
            },
            .err = <span class="tok-kw">error</span>.PaxNullInKeyword,
        },
        .{<span class="tok-comment"> // null in value is not valid
            </span>.data = <span class="tok-str">&quot;23 path=name\x00with null\n&quot;</span>,
            .attrs = &amp;[_]Attr{
                .{ .kind = .path, .err = <span class="tok-kw">error</span>.PaxNullInValue },
            },
        },
        .{<span class="tok-comment"> // 1000 characters path
            </span>.data = <span class="tok-str">&quot;1011 path=&quot;</span> ++ <span class="tok-str">&quot;0123456789&quot;</span> ** <span class="tok-number">100</span> ++ <span class="tok-str">&quot;\n&quot;</span>,
            .attrs = &amp;[_]Attr{
                .{ .kind = .path, .value = <span class="tok-str">&quot;0123456789&quot;</span> ** <span class="tok-number">100</span> },
            },
        },
    };
    <span class="tok-kw">var</span> buffer: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    outer: <span class="tok-kw">for</span> (cases) |case| {
        <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(case.data);
        <span class="tok-kw">var</span> iter = <a href="std.tar.html#std.tar.paxIterator">paxIterator</a>(stream.reader(), case.data.len);

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (iter.next() <span class="tok-kw">catch</span> |err| {
            <span class="tok-kw">if</span> (case.err) |e| {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(e, err);
                <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">return</span> err;
        }) |attr| : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> exp = case.attrs[i];
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(exp.kind, attr.kind);
            <span class="tok-kw">const</span> value = attr.value(&amp;buffer) <span class="tok-kw">catch</span> |err| {
                <span class="tok-kw">if</span> (exp.err) |e| {
                    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(e, err);
                    <span class="tok-kw">break</span> :outer;
                }
                <span class="tok-kw">return</span> err;
            };
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(exp.value, value);
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(case.attrs.len, i);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(case.err == <span class="tok-null">null</span>);
    }
}

<span class="tok-kw">test</span> {
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;tar/test.zig&quot;</span>);
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;tar/writer.zig&quot;</span>);
    _ = <a href="std.tar.Diagnostics.html">Diagnostics</a>;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;header parse size&quot;</span> {
    <span class="tok-kw">const</span> cases = [_]<span class="tok-kw">struct</span> {
        in: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        want: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,
        err: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>,
    }{<span class="tok-comment">
        // Test base-256 (binary) encoded values.
        </span>.{ .in = <span class="tok-str">&quot;&quot;</span>, .want = <span class="tok-number">0</span> },
        .{ .in = <span class="tok-str">&quot;\x80&quot;</span>, .want = <span class="tok-number">0</span> },
        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&quot;</span>, .want = <span class="tok-number">1</span> },
        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02&quot;</span>, .want = <span class="tok-number">0x0102</span> },
        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08&quot;</span>, .want = <span class="tok-number">0x0102030405060708</span> },
        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09&quot;</span>, .err = <span class="tok-kw">error</span>.TarNumericValueTooBig },
        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x00\x07\x76\xa2\x22\xeb\x8a\x72\x61&quot;</span>, .want = <span class="tok-number">537795476381659745</span> },
        .{ .in = <span class="tok-str">&quot;\x80\x80\x80\x00\x01\x02\x03\x04\x05\x06\x07\x08&quot;</span>, .err = <span class="tok-kw">error</span>.TarNumericValueTooBig },<span class="tok-comment">

        // // Test base-8 (octal) encoded values.
        </span>.{ .in = <span class="tok-str">&quot;00000000227\x00&quot;</span>, .want = <span class="tok-number">0o227</span> },
        .{ .in = <span class="tok-str">&quot;  000000227\x00&quot;</span>, .want = <span class="tok-number">0o227</span> },
        .{ .in = <span class="tok-str">&quot;00000000228\x00&quot;</span>, .err = <span class="tok-kw">error</span>.TarHeader },
        .{ .in = <span class="tok-str">&quot;11111111111\x00&quot;</span>, .want = <span class="tok-number">0o11111111111</span> },
    };

    <span class="tok-kw">for</span> (cases) |case| {
        <span class="tok-kw">var</span> bytes = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>;
        <span class="tok-builtin">@memcpy</span>(bytes[<span class="tok-number">124</span> .. <span class="tok-number">124</span> + case.in.len], case.in);
        <span class="tok-kw">var</span> header = <a href="std.tar.Header.html">Header</a>{ .bytes = &amp;bytes };
        <span class="tok-kw">if</span> (case.err) |err| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(err, header.size());
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(case.want, <span class="tok-kw">try</span> header.size());
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;header parse mode&quot;</span> {
    <span class="tok-kw">const</span> cases = [_]<span class="tok-kw">struct</span> {
        in: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        want: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,
        err: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>,
    }{
        .{ .in = <span class="tok-str">&quot;0000644\x00&quot;</span>, .want = <span class="tok-number">0o644</span> },
        .{ .in = <span class="tok-str">&quot;0000777\x00&quot;</span>, .want = <span class="tok-number">0o777</span> },
        .{ .in = <span class="tok-str">&quot;7777777\x00&quot;</span>, .want = <span class="tok-number">0o7777777</span> },
        .{ .in = <span class="tok-str">&quot;7777778\x00&quot;</span>, .err = <span class="tok-kw">error</span>.TarHeader },
        .{ .in = <span class="tok-str">&quot;77777777&quot;</span>, .want = <span class="tok-number">0o77777777</span> },
        .{ .in = <span class="tok-str">&quot;777777777777&quot;</span>, .want = <span class="tok-number">0o77777777</span> },
    };
    <span class="tok-kw">for</span> (cases) |case| {
        <span class="tok-kw">var</span> bytes = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <a href="std.tar.Header.html">Header</a>.<a href="std.tar.Header.html#std.tar.Header.SIZE">SIZE</a>;
        <span class="tok-builtin">@memcpy</span>(bytes[<span class="tok-number">100</span> .. <span class="tok-number">100</span> + case.in.len], case.in);
        <span class="tok-kw">var</span> header = <a href="std.tar.Header.html">Header</a>{ .bytes = &amp;bytes };
        <span class="tok-kw">if</span> (case.err) |err| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(err, header.mode());
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(case.want, <span class="tok-kw">try</span> header.mode());
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;create file and symlink&quot;</span> {
    <span class="tok-kw">var</span> root = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> root.cleanup();

    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> <a href="std.tar.html#std.tar.createDirAndFile">createDirAndFile</a>(root.dir, <span class="tok-str">&quot;file1&quot;</span>, <a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>);
    file.close();
    file = <span class="tok-kw">try</span> <a href="std.tar.html#std.tar.createDirAndFile">createDirAndFile</a>(root.dir, <span class="tok-str">&quot;a/b/c/file2&quot;</span>, <a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>);
    file.close();

    <a href="std.tar.html#std.tar.createDirAndSymlink">createDirAndSymlink</a>(root.dir, <span class="tok-str">&quot;a/b/c/file2&quot;</span>, <span class="tok-str">&quot;symlink1&quot;</span>) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // On Windows when developer mode is not enabled
        </span><span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.AccessDenied) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
        <span class="tok-kw">return</span> err;
    };
    <span class="tok-kw">try</span> <a href="std.tar.html#std.tar.createDirAndSymlink">createDirAndSymlink</a>(root.dir, <span class="tok-str">&quot;../../../file1&quot;</span>, <span class="tok-str">&quot;d/e/f/symlink2&quot;</span>);<span class="tok-comment">

    // Danglink symlnik, file created later
    </span><span class="tok-kw">try</span> <a href="std.tar.html#std.tar.createDirAndSymlink">createDirAndSymlink</a>(root.dir, <span class="tok-str">&quot;../../../g/h/i/file4&quot;</span>, <span class="tok-str">&quot;j/k/l/symlink3&quot;</span>);
    file = <span class="tok-kw">try</span> <a href="std.tar.html#std.tar.createDirAndFile">createDirAndFile</a>(root.dir, <span class="tok-str">&quot;g/h/i/file4&quot;</span>, <a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>);
    file.close();
}

<span class="tok-kw">test</span> iterator {<span class="tok-comment">
    // Example tar file is created from this tree structure:
    // $ tree example
    //    example
    //    ├── a
    //    │   └── file
    //    ├── b
    //    │   └── symlink -&gt; ../a/file
    //    └── empty
    // $ cat example/a/file
    //   content
    // $ tar -cf example.tar example
    // $ tar -tvf example.tar
    //    example/
    //    example/b/
    //    example/b/symlink -&gt; ../a/file
    //    example/a/
    //    example/a/file
    //    example/empty/

    </span><span class="tok-kw">const</span> data = <span class="tok-builtin">@embedFile</span>(<span class="tok-str">&quot;tar/testdata/example.tar&quot;</span>);
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);<span class="tok-comment">

    // User provided buffers to the iterator
    </span><span class="tok-kw">var</span> file_name_buffer: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> link_name_buffer: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // Create iterator
    </span><span class="tok-kw">var</span> iter = <a href="std.tar.html#std.tar.iterator">iterator</a>(fbs.reader(), .{
        .file_name_buffer = &amp;file_name_buffer,
        .link_name_buffer = &amp;link_name_buffer,
    });<span class="tok-comment">
    // Iterate over files in example.tar
    </span><span class="tok-kw">var</span> file_no: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |file| : (file_no += <span class="tok-number">1</span>) {
        <span class="tok-kw">switch</span> (file.kind) {
            .directory =&gt; {
                <span class="tok-kw">switch</span> (file_no) {
                    <span class="tok-number">0</span> =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/&quot;</span>, file.name),
                    <span class="tok-number">1</span> =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/b/&quot;</span>, file.name),
                    <span class="tok-number">3</span> =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/a/&quot;</span>, file.name),
                    <span class="tok-number">5</span> =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/empty/&quot;</span>, file.name),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            },
            .file =&gt; {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/a/file&quot;</span>, file.name);<span class="tok-comment">
                // Read file content
                </span><span class="tok-kw">var</span> buf: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> file.reader().readAll(&amp;buf);
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content\n&quot;</span>, buf[<span class="tok-number">0</span>..n]);
            },
            .sym_link =&gt; {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/b/symlink&quot;</span>, file.name);
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;../a/file&quot;</span>, file.link_name);
            },
        }
    }
}

<span class="tok-kw">test</span> pipeToFileSystem {<span class="tok-comment">
    // Example tar file is created from this tree structure:
    // $ tree example
    //    example
    //    ├── a
    //    │   └── file
    //    ├── b
    //    │   └── symlink -&gt; ../a/file
    //    └── empty
    // $ cat example/a/file
    //   content
    // $ tar -cf example.tar example
    // $ tar -tvf example.tar
    //    example/
    //    example/b/
    //    example/b/symlink -&gt; ../a/file
    //    example/a/
    //    example/a/file
    //    example/empty/

    </span><span class="tok-kw">const</span> data = <span class="tok-builtin">@embedFile</span>(<span class="tok-str">&quot;tar/testdata/example.tar&quot;</span>);
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
    <span class="tok-kw">const</span> reader = fbs.reader();

    <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{ .no_follow = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> tmp.cleanup();
    <span class="tok-kw">const</span> dir = tmp.dir;<span class="tok-comment">

    // Save tar from `reader` to the file system `dir`
    </span><a href="std.tar.html#std.tar.pipeToFileSystem">pipeToFileSystem</a>(dir, reader, .{
        .mode_mode = .ignore,
        .strip_components = <span class="tok-number">1</span>,
        .exclude_empty_directories = <span class="tok-null">true</span>,
    }) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // Skip on platform which don't support symlinks
        </span><span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.UnableToCreateSymLink) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
        <span class="tok-kw">return</span> err;
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.FileNotFound, dir.statFile(<span class="tok-str">&quot;empty&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> dir.statFile(<span class="tok-str">&quot;a/file&quot;</span>)).kind == .file);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> dir.statFile(<span class="tok-str">&quot;b/symlink&quot;</span>)).kind == .file);<span class="tok-comment"> // statFile follows symlink

    </span><span class="tok-kw">var</span> buf: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(
        <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;../a/file&quot;</span>,
        <a href="std.tar.html#std.tar.normalizePath">normalizePath</a>(<span class="tok-kw">try</span> dir.readLink(<span class="tok-str">&quot;b/symlink&quot;</span>, &amp;buf)),
    );
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pipeToFileSystem root_dir&quot;</span> {
    <span class="tok-kw">const</span> data = <span class="tok-builtin">@embedFile</span>(<span class="tok-str">&quot;tar/testdata/example.tar&quot;</span>);
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
    <span class="tok-kw">const</span> reader = fbs.reader();<span class="tok-comment">

    // with strip_components = 1
    </span>{
        <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{ .no_follow = <span class="tok-null">true</span> });
        <span class="tok-kw">defer</span> tmp.cleanup();
        <span class="tok-kw">var</span> diagnostics: <a href="std.tar.Diagnostics.html">Diagnostics</a> = .{ .allocator = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a> };
        <span class="tok-kw">defer</span> diagnostics.deinit();

        <a href="std.tar.html#std.tar.pipeToFileSystem">pipeToFileSystem</a>(tmp.dir, reader, .{
            .strip_components = <span class="tok-number">1</span>,
            .diagnostics = &amp;diagnostics,
        }) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // Skip on platform which don't support symlinks
            </span><span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.UnableToCreateSymLink) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
            <span class="tok-kw">return</span> err;
        };<span class="tok-comment">

        // there is no root_dir
        </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, diagnostics.root_dir.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">5</span>, diagnostics.entries);
    }<span class="tok-comment">

    // with strip_components = 0
    </span>{
        fbs.reset();
        <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{ .no_follow = <span class="tok-null">true</span> });
        <span class="tok-kw">defer</span> tmp.cleanup();
        <span class="tok-kw">var</span> diagnostics: <a href="std.tar.Diagnostics.html">Diagnostics</a> = .{ .allocator = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a> };
        <span class="tok-kw">defer</span> diagnostics.deinit();

        <a href="std.tar.html#std.tar.pipeToFileSystem">pipeToFileSystem</a>(tmp.dir, reader, .{
            .strip_components = <span class="tok-number">0</span>,
            .diagnostics = &amp;diagnostics,
        }) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // Skip on platform which don't support symlinks
            </span><span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.UnableToCreateSymLink) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
            <span class="tok-kw">return</span> err;
        };<span class="tok-comment">

        // root_dir found
        </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example&quot;</span>, diagnostics.root_dir);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, diagnostics.entries);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;findRoot without explicit root dir&quot;</span> {
    <span class="tok-kw">const</span> data = <span class="tok-builtin">@embedFile</span>(<span class="tok-str">&quot;tar/testdata/19820.tar&quot;</span>);
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
    <span class="tok-kw">const</span> reader = fbs.reader();

    <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">var</span> diagnostics: <a href="std.tar.Diagnostics.html">Diagnostics</a> = .{ .allocator = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a> };
    <span class="tok-kw">defer</span> diagnostics.deinit();
    <span class="tok-kw">try</span> <a href="std.tar.html#std.tar.pipeToFileSystem">pipeToFileSystem</a>(tmp.dir, reader, .{ .diagnostics = &amp;diagnostics });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;root&quot;</span>, diagnostics.root_dir);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pipeToFileSystem strip_components&quot;</span> {
    <span class="tok-kw">const</span> data = <span class="tok-builtin">@embedFile</span>(<span class="tok-str">&quot;tar/testdata/example.tar&quot;</span>);
    <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
    <span class="tok-kw">const</span> reader = fbs.reader();

    <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{ .no_follow = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> tmp.cleanup();
    <span class="tok-kw">var</span> diagnostics: <a href="std.tar.Diagnostics.html">Diagnostics</a> = .{ .allocator = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a> };
    <span class="tok-kw">defer</span> diagnostics.deinit();

    <a href="std.tar.html#std.tar.pipeToFileSystem">pipeToFileSystem</a>(tmp.dir, reader, .{
        .strip_components = <span class="tok-number">3</span>,
        .diagnostics = &amp;diagnostics,
    }) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // Skip on platform which don't support symlinks
        </span><span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.UnableToCreateSymLink) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
        <span class="tok-kw">return</span> err;
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, diagnostics.errors.items.len);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/b/symlink&quot;</span>, diagnostics.errors.items[<span class="tok-number">0</span>].components_outside_stripped_prefix.file_name);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;example/a/file&quot;</span>, diagnostics.errors.items[<span class="tok-number">1</span>].components_outside_stripped_prefix.file_name);
}

<span class="tok-kw">fn</span> <span class="tok-fn">normalizePath</span>(bytes: []<span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> canonical_sep = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep_posix">sep_posix</a>;
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a> == canonical_sep) <span class="tok-kw">return</span> bytes;
    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.replaceScalar">replaceScalar</a>(<span class="tok-type">u8</span>, bytes, <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>, canonical_sep);
    <span class="tok-kw">return</span> bytes;
}

<span class="tok-kw">const</span> default_mode = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>;<span class="tok-comment">

// File system mode based on tar header mode and mode_mode options.
</span><span class="tok-kw">fn</span> <span class="tok-fn">fileMode</span>(mode: <span class="tok-type">u32</span>, options: <a href="std.tar.PipeOptions.html">PipeOptions</a>) <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.mode_t">Mode</a> {
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.has_executable_bit">has_executable_bit</a> <span class="tok-kw">or</span> options.mode_mode == .ignore)
        <span class="tok-kw">return</span> <a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>;

    <span class="tok-kw">const</span> S = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>;<span class="tok-comment">

    // The mode from the tar file is inspected for the owner executable bit.
    </span><span class="tok-kw">if</span> (mode &amp; S.IXUSR == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>;<span class="tok-comment">

    // This bit is copied to the group and other executable bits.
    // Other bits of the mode are left as the default when creating files.
    </span><span class="tok-kw">return</span> <a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a> | S.IXUSR | S.IXGRP | S.IXOTH;
}

<span class="tok-kw">test</span> fileMode {
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.has_executable_bit">has_executable_bit</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>, <a href="std.tar.html#std.tar.fileMode">fileMode</a>(<span class="tok-number">0o744</span>, <a href="std.tar.PipeOptions.html">PipeOptions</a>{ .mode_mode = .ignore }));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0o777</span>, <a href="std.tar.html#std.tar.fileMode">fileMode</a>(<span class="tok-number">0o744</span>, <a href="std.tar.PipeOptions.html">PipeOptions</a>{}));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0o666</span>, <a href="std.tar.html#std.tar.fileMode">fileMode</a>(<span class="tok-number">0o644</span>, <a href="std.tar.PipeOptions.html">PipeOptions</a>{}));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0o666</span>, <a href="std.tar.html#std.tar.fileMode">fileMode</a>(<span class="tok-number">0o655</span>, <a href="std.tar.PipeOptions.html">PipeOptions</a>{}));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;executable bit&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.has_executable_bit">has_executable_bit</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> S = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>;
    <span class="tok-kw">const</span> data = <span class="tok-builtin">@embedFile</span>(<span class="tok-str">&quot;tar/testdata/example.tar&quot;</span>);

    <span class="tok-kw">for</span> ([_]<a href="std.tar.PipeOptions.html">PipeOptions</a>.<a href="std.tar.PipeOptions.ModeMode.html">ModeMode</a>{ .ignore, .executable_bit_only }) |opt| {
        <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
        <span class="tok-kw">const</span> reader = fbs.reader();

        <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{ .no_follow = <span class="tok-null">true</span> });<span class="tok-comment">
        //defer tmp.cleanup();

        </span><a href="std.tar.html#std.tar.pipeToFileSystem">pipeToFileSystem</a>(tmp.dir, reader, .{
            .strip_components = <span class="tok-number">1</span>,
            .exclude_empty_directories = <span class="tok-null">true</span>,
            .mode_mode = opt,
        }) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
            // Skip on platform which don't support symlinks
            </span><span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.UnableToCreateSymLink) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
            <span class="tok-kw">return</span> err;
        };

        <span class="tok-kw">const</span> fs = <span class="tok-kw">try</span> tmp.dir.statFile(<span class="tok-str">&quot;a/file&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fs.kind == .file);

        <span class="tok-kw">if</span> (opt == .executable_bit_only) {<span class="tok-comment">
            // Executable bit is set for user, group and others
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fs.mode &amp; S.IXUSR &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fs.mode &amp; S.IXGRP &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fs.mode &amp; S.IXOTH &gt; <span class="tok-number">0</span>);
        }
        <span class="tok-kw">if</span> (opt == .ignore) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fs.mode &amp; S.IXUSR == <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fs.mode &amp; S.IXGRP == <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fs.mode &amp; S.IXOTH == <span class="tok-number">0</span>);
        }
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
