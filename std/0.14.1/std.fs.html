<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.fs.html" class="active">fs</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.fs" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.fs</span><a href="#src.zig-std.fs">[src]</a></h1><div class="tldDocs"><p>File System.</p>
</div><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.fs.path.html">std.fs.path</a></li><li><a href="std.fs.wasi.html">std.fs.wasi</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.fs.AtomicFile.html">std.fs.AtomicFile</a></li><li><a href="std.fs.Dir.html">std.fs.Dir</a></li><li><a href="std.fs.File.html">std.fs.File</a></li></ul></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.fs.has_executable_bit" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">has_executable_bit</span><a href="#src.zig-std.fs.has_executable_bit">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.has_executable_bit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> has_executable_bit = <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
    .windows, .wasi =&gt; <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.MAX_PATH_BYTES" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">MAX_PATH_BYTES</span><a href="#src.zig-std.fs.MAX_PATH_BYTES">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.MAX_PATH_BYTES">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_PATH_BYTES = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; renamed to max_path_bytes&quot;</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.fs.max_path_bytes" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">max_path_bytes</span><a href="#src.zig-std.fs.max_path_bytes">[src]</a></h2><div class="tldDocs"><p>The maximum length of a file path that the operating system will accept.</p>
<p>Paths, including those returned from file system operations, may be longer
than this length, but such paths cannot be successfully passed back in
other file system operations. However, all path components returned by file
system operations are assumed to fit into a <code>u8</code> array of this length.</p>
<p>The byte count includes room for a null sentinel byte.</p>
<ul>
<li>On Windows, <code>[]u8</code> file paths are encoded as
<a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</li>
<li>On WASI, <code>[]u8</code> file paths are encoded as valid UTF-8.</li>
<li>On other platforms, <code>[]u8</code> file paths are opaque sequences of bytes with
no particular encoding.</li>
</ul>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.max_path_bytes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_path_bytes = <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .haiku, .solaris, .illumos, .plan9, .emscripten, .wasi =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>,<span class="tok-comment">
    // Each WTF-16LE code unit may be expanded to 3 WTF-8 bytes.
    // If it would require 4 WTF-8 bytes, then there would be a surrogate
    // pair in the WTF-16LE, and we (over)account 3 bytes for it that way.
    // +1 for the null byte at the end, which can be encoded in 1 byte.
    </span>.windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a> * <span class="tok-number">3</span> + <span class="tok-number">1</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>, <span class="tok-str">&quot;PATH_MAX&quot;</span>))
        <a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>.<a href="#">PATH_MAX</a>
    <span class="tok-kw">else</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;PATH_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(<a href="std.fs.html#std.fs.native_os">native_os</a>)),
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.max_name_bytes" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">max_name_bytes</span><a href="#src.zig-std.fs.max_name_bytes">[src]</a></h2><div class="tldDocs"><p>This represents the maximum size of a <code>[]u8</code> file name component that
the platform's common file systems support. File name components returned by file system
operations are likely to fit into a <code>u8</code> array of this length, but
(depending on the platform) this assumption may not hold for every configuration.
The byte count does not include a null sentinel byte.
On Windows, <code>[]u8</code> file name components are encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, file name components are encoded as valid UTF-8.
On other platforms, <code>[]u8</code> components are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.max_name_bytes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_name_bytes = <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .solaris, .illumos =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a>,<span class="tok-comment">
    // Haiku's NAME_MAX includes the null terminator, so subtract one.
    </span>.haiku =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a> - <span class="tok-number">1</span>,<span class="tok-comment">
    // Each WTF-16LE character may be expanded to 3 WTF-8 bytes.
    // If it would require 4 WTF-8 bytes, then there would be a surrogate
    // pair in the WTF-16LE, and we (over)account 3 bytes for it that way.
    </span>.windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.NAME_MAX">NAME_MAX</a> * <span class="tok-number">3</span>,<span class="tok-comment">
    // For WASI, the MAX_NAME will depend on the host OS, so it needs to be
    // as large as the largest max_name_bytes (Windows) in order to work on any host OS.
    // TODO determine if this is a reasonable approach
    </span>.wasi =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.NAME_MAX">NAME_MAX</a> * <span class="tok-number">3</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>, <span class="tok-str">&quot;NAME_MAX&quot;</span>))
        <a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>.<a href="#">NAME_MAX</a>
    <span class="tok-kw">else</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;NAME_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(<a href="std.fs.html#std.fs.native_os">native_os</a>)),
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.max_name_bytes" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">max_name_bytes</span><a href="#src.zig-std.fs.max_name_bytes">[src]</a></h2><div class="tldDocs"><p>This represents the maximum size of a <code>[]u8</code> file name component that
the platform's common file systems support. File name components returned by file system
operations are likely to fit into a <code>u8</code> array of this length, but
(depending on the platform) this assumption may not hold for every configuration.
The byte count does not include a null sentinel byte.
On Windows, <code>[]u8</code> file name components are encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, file name components are encoded as valid UTF-8.
On other platforms, <code>[]u8</code> components are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.max_name_bytes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_name_bytes = <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .solaris, .illumos =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a>,<span class="tok-comment">
    // Haiku's NAME_MAX includes the null terminator, so subtract one.
    </span>.haiku =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a> - <span class="tok-number">1</span>,<span class="tok-comment">
    // Each WTF-16LE character may be expanded to 3 WTF-8 bytes.
    // If it would require 4 WTF-8 bytes, then there would be a surrogate
    // pair in the WTF-16LE, and we (over)account 3 bytes for it that way.
    </span>.windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.NAME_MAX">NAME_MAX</a> * <span class="tok-number">3</span>,<span class="tok-comment">
    // For WASI, the MAX_NAME will depend on the host OS, so it needs to be
    // as large as the largest max_name_bytes (Windows) in order to work on any host OS.
    // TODO determine if this is a reasonable approach
    </span>.wasi =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.NAME_MAX">NAME_MAX</a> * <span class="tok-number">3</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>, <span class="tok-str">&quot;NAME_MAX&quot;</span>))
        <a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>.<a href="#">NAME_MAX</a>
    <span class="tok-kw">else</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;NAME_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(<a href="std.fs.html#std.fs.native_os">native_os</a>)),
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.base64_alphabet" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">base64_alphabet</span><a href="#src.zig-std.fs.base64_alphabet">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.base64_alphabet">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_alphabet = <span class="tok-str">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;</span>.*</code></pre></details></div></div><div class="decl"><h2 id="std.fs.base64_encoder" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">base64_encoder</span><a href="#src.zig-std.fs.base64_encoder">[src]</a></h2><div class="tldDocs"><p>Base64 encoder, replacing the standard <code>+/</code> with <code>-_</code> so that it can be used in a file name on any filesystem.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.base64_encoder">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_encoder = <a href="std.base64.html">base64</a>.<a href="std.base64.Base64Encoder.html">Base64Encoder</a>.<a href="std.base64.Base64Encoder.html#std.base64.Base64Encoder.init">init</a>(<a href="std.fs.html#std.fs.base64_alphabet">base64_alphabet</a>, <span class="tok-null">null</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.fs.base64_decoder" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">base64_decoder</span><a href="#src.zig-std.fs.base64_decoder">[src]</a></h2><div class="tldDocs"><p>Base64 decoder, replacing the standard <code>+/</code> with <code>-_</code> so that it can be used in a file name on any filesystem.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.base64_decoder">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_decoder = <a href="std.base64.html">base64</a>.<a href="std.base64.Base64Decoder.html">Base64Decoder</a>.<a href="std.base64.Base64Decoder.html#std.base64.Base64Decoder.init">init</a>(<a href="std.fs.html#std.fs.base64_alphabet">base64_alphabet</a>, <span class="tok-null">null</span>)</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.fs.get_app_data_dir.GetAppDataDirError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetAppDataDirError</span><a href="#src.zig-std.fs.get_app_data_dir.GetAppDataDirError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AppDataDirUnavailable</dt></div><div><dt>OutOfMemory</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.get_app_data_dir.GetAppDataDirError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetAppDataDirError = <span class="tok-kw">error</span>{
    OutOfMemory,
    AppDataDirUnavailable,
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.OpenSelfExeError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">OpenSelfExeError</span><a href="#src.zig-std.fs.OpenSelfExeError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AntivirusInterference <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a></dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Path contains characters that are disallowed by the underlying filesystem.</p>
</dd></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileSystem <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a></dt></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InputOutput <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a></dt></div><div><dt>InvalidUtf8 <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>NotLink <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a></dt></div><div><dt>NotSupported <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a></dt></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a></dt></div><div><dt>PipeBusy <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SharingViolation <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnknownName <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a></dt></div><div><dt>UnrecognizedVolume <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a></dt><dd><p>On Windows, the volume does not contain a recognized file system. File
system drivers might not be loaded, or the volume may be corrupt.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.OpenSelfExeError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenSelfExeError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.OpenError">OpenError</a> || <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FlockError">FlockError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.SelfExePathError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SelfExePathError</span><a href="#src.zig-std.fs.SelfExePathError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>AntivirusInterference</dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName</dt></div><div><dt>DeviceBusy</dt></div><div><dt>FileNotFound</dt></div><div><dt>FileSystem</dt></div><div><dt>FileTooBig</dt></div><div><dt>InputOutput</dt></div><div><dt>IsDir</dt></div><div><dt>NameTooLong</dt></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotDir</dt></div><div><dt>NotLink</dt></div><div><dt>NotSupported</dt></div><div><dt>PathAlreadyExists</dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a></dt></div><div><dt>PipeBusy</dt></div><div><dt>ProcessFdQuotaExceeded</dt></div><div><dt>SharingViolation</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemFdQuotaExceeded</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>UnknownName <a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a></dt></div><div><dt>UnrecognizedVolume</dt><dd><p>On Windows, the volume does not contain a recognized file system. File
system drivers might not be loaded, or the volume may be corrupt.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.SelfExePathError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SelfExePathError = <span class="tok-kw">error</span>{
    FileNotFound,
    AccessDenied,
    NameTooLong,
    NotSupported,
    NotDir,
    SymLinkLoop,
    InputOutput,
    FileTooBig,
    IsDir,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    NoSpaceLeft,
    FileSystem,
    BadPathName,
    DeviceBusy,
    SharingViolation,
    PipeBusy,
    NotLink,
    PathAlreadyExists,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,

    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,

    <span class="tok-comment">/// On Windows, the volume does not contain a recognized file system. File</span>
    <span class="tok-comment">/// system drivers might not be loaded, or the volume may be corrupt.</span>
    UnrecognizedVolume,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.posix.realpath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpath</span><a href="#src.zig-std.posix.realpath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Return the canonicalized absolute pathname.</p>
<p>Expands all symbolic links and resolves references to <code>.</code>, <code>..</code>, and
extra <code>/</code> characters in <code>pathname</code>.</p>
<p>On Windows, <code>pathname</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</p>
<p>On other platforms, <code>pathname</code> is an opaque sequence of bytes with no particular encoding.</p>
<p>The return value is a slice of <code>out_buffer</code>, but not necessarily from the beginning.</p>
<p>See also <code><a href="std.posix.html#std.posix.realpathZ">realpathZ</a></code> and <code><a href="std.posix.html#std.posix.realpathW">realpathW</a></code>.</p>
<ul>
<li>On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</li>
<li>On other platforms, the result is an opaque sequence of bytes with no particular encoding.</li>
</ul>
<p>Calling this function is usually a bug.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.realpath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, pathname);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathW">realpathW</a>(pathname_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;WASI does not support os.realpath&quot;</span>);
    }
    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(pathname);
    <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(&amp;pathname_c, out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.realpathZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpathZ</span><a href="#src.zig-std.posix.realpathZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.realpath">realpath</a></code> except <code>pathname</code> is null-terminated.</p>
<p>Calling this function is usually a bug.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.realpathZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, pathname);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpathW">realpathW</a>(pathname_w.span(), out_buffer);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.realpath">realpath</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(pathname, <span class="tok-number">0</span>), out_buffer);
    }
    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> flags: <a href="std.posix.html#std.posix.O">O</a> = <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
            .linux =&gt; .{
                .NONBLOCK = <span class="tok-null">true</span>,
                .CLOEXEC = <span class="tok-null">true</span>,
                .PATH = <span class="tok-null">true</span>,
            },
            <span class="tok-kw">else</span> =&gt; .{
                .NONBLOCK = <span class="tok-null">true</span>,
                .CLOEXEC = <span class="tok-null">true</span>,
            },
        };
        <span class="tok-kw">const</span> fd = <a href="std.posix.html#std.posix.openZ">openZ</a>(pathname, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // not asking for write permissions
            </span><span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">defer</span> <a href="std.posix.html#std.posix.close">close</a>(fd);

        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.getFdPath">getFdPath</a>(fd, out_buffer);
    }
    <span class="tok-kw">const</span> result_path = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.realpath">realpath</a>(pathname, out_buffer) <span class="tok-kw">orelse</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.E">E</a>, <span class="tok-builtin">@enumFromInt</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._errno">_errno</a>().*))) {
        .SUCCESS =&gt; <span class="tok-kw">unreachable</span>,
        .INVAL =&gt; <span class="tok-kw">unreachable</span>,
        .BADF =&gt; <span class="tok-kw">unreachable</span>,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotSupported,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InputOutput,
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    };
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(result_path, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.realpathW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpathW</span><a href="#src.zig-std.posix.realpathW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.realpath">realpath</a></code> except <code>pathname</code> is WTF16LE-encoded.</p>
<p>The result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.</p>
<p>Calling this function is usually a bug.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.realpathW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.RealPathError">RealPathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> w = <a href="std.os.windows.html">windows</a>;

    <span class="tok-kw">const</span> dir = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().fd;
    <span class="tok-kw">const</span> access_mask = w.GENERIC_READ | w.SYNCHRONIZE;
    <span class="tok-kw">const</span> share_access = w.FILE_SHARE_READ | w.FILE_SHARE_WRITE | w.FILE_SHARE_DELETE;
    <span class="tok-kw">const</span> creation = w.FILE_OPEN;
    <span class="tok-kw">const</span> h_file = blk: {
        <span class="tok-kw">const</span> res = w.OpenFile(pathname, .{
            .dir = dir,
            .access_mask = access_mask,
            .share_access = share_access,
            .creation = creation,
            .filter = .any,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">break</span> :blk res;
    };
    <span class="tok-kw">defer</span> w.CloseHandle(h_file);

    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.getFdPath">getFdPath</a>(h_file, out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.get_app_data_dir.getAppDataDir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAppDataDir</span><a href="#src.zig-std.fs.get_app_data_dir.getAppDataDir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAppDataDir</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, appname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.get_app_data_dir.html#std.fs.get_app_data_dir.GetAppDataDirError">GetAppDataDirError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Caller owns returned memory.
TODO determine if we can remove the allocator requirement</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>appname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> getAppDataDir {
    <span class="tok-kw">if</span> (<a href="std.fs.get_app_data_dir.html#std.fs.get_app_data_dir.native_os">native_os</a> == .wasi) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment">

    // We can't actually validate the result
    </span><span class="tok-kw">const</span> dir = <a href="std.fs.get_app_data_dir.html#std.fs.get_app_data_dir.getAppDataDir">getAppDataDir</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;zig&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
    <span class="tok-kw">defer</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(dir);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.get_app_data_dir.getAppDataDir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAppDataDir</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, appname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.get_app_data_dir.html#std.fs.get_app_data_dir.GetAppDataDirError">GetAppDataDirError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">switch</span> (<a href="std.fs.get_app_data_dir.html#std.fs.get_app_data_dir.native_os">native_os</a>) {
        .windows =&gt; {
            <span class="tok-kw">const</span> local_app_data_dir = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.getEnvVarOwned">getEnvVarOwned</a>(allocator, <span class="tok-str">&quot;LOCALAPPDATA&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.OutOfMemory =&gt; |e| <span class="tok-kw">return</span> e,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AppDataDirUnavailable,
            };
            <span class="tok-kw">defer</span> allocator.free(local_app_data_dir);
            <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ local_app_data_dir, appname });
        },
        .macos =&gt; {
            <span class="tok-kw">const</span> home_dir = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(<span class="tok-str">&quot;HOME&quot;</span>) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // TODO look in /etc/passwd
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.AppDataDirUnavailable;
            };
            <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ home_dir, <span class="tok-str">&quot;Library&quot;</span>, <span class="tok-str">&quot;Application Support&quot;</span>, appname });
        },
        .linux, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; {
            <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(<span class="tok-str">&quot;XDG_DATA_HOME&quot;</span>)) |xdg| {
                <span class="tok-kw">if</span> (xdg.len &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ xdg, appname });
                }
            }

            <span class="tok-kw">const</span> home_dir = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(<span class="tok-str">&quot;HOME&quot;</span>) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // TODO look in /etc/passwd
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.AppDataDirUnavailable;
            };
            <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ home_dir, <span class="tok-str">&quot;.local&quot;</span>, <span class="tok-str">&quot;share&quot;</span>, appname });
        },
        .haiku =&gt; {
            <span class="tok-kw">var</span> dir_path_buf: [<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> rc = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.haiku.html#std.c.haiku.find_directory">find_directory</a>(.B_USER_SETTINGS_DIRECTORY, -<span class="tok-number">1</span>, <span class="tok-null">true</span>, &amp;dir_path_buf, dir_path_buf.len);
            <span class="tok-kw">const</span> settings_dir = <span class="tok-kw">try</span> allocator.dupeZ(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;dir_path_buf, <span class="tok-number">0</span>));
            <span class="tok-kw">defer</span> allocator.free(settings_dir);
            <span class="tok-kw">switch</span> (rc) {
                <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ settings_dir, appname }),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AppDataDirUnavailable,
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.atomicSymLink" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">atomicSymLink</span><a href="#src.zig-std.fs.atomicSymLink">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicSymLink</span>(_: <a href="std.mem.Allocator.html">Allocator</a>, existing_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deprecated. Use <code>cwd().atomicSymLink()</code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>_: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>existing_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.atomicSymLink">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicSymLink</span>(_: <a href="std.mem.Allocator.html">Allocator</a>, existing_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().atomicSymLink(existing_path, new_path, .{});
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.updateFileAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">updateFileAbsolute</span><a href="#src.zig-std.fs.updateFileAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFileAbsolute</span>( source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>, ) !<a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.PrevStatus.html">PrevStatus</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.updateFile">Dir.updateFile</a></code>, except asserts that both <code>source_path</code> and <code>dest_path</code>
are absolute. See <code><a href="std.fs.Dir.html#std.fs.Dir.updateFile">Dir.updateFile</a></code> for a function that operates on both
absolute and relative paths.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>args: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.updateFileAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFileAbsolute</span>(
    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>,
) !<a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.PrevStatus.html">PrevStatus</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(source_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dest_path));
    <span class="tok-kw">const</span> my_cwd = <a href="std.fs.html#std.fs.cwd">cwd</a>();
    <span class="tok-kw">return</span> <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.updateFile">updateFile</a>(my_cwd, source_path, my_cwd, dest_path, args);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.copyFileAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copyFileAbsolute</span><a href="#src.zig-std.fs.copyFileAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFileAbsolute</span>( source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.copyFile">Dir.copyFile</a></code>, except asserts that both <code>source_path</code> and <code>dest_path</code>
are absolute. See <code><a href="std.fs.Dir.html#std.fs.Dir.copyFile">Dir.copyFile</a></code> for a function that operates on both
absolute and relative paths.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>args: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.copyFileAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFileAbsolute</span>(
    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(source_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dest_path));
    <span class="tok-kw">const</span> my_cwd = <a href="std.fs.html#std.fs.cwd">cwd</a>();
    <span class="tok-kw">return</span> <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.copyFile">copyFile</a>(my_cwd, source_path, my_cwd, dest_path, args);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.makeDirAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeDirAbsolute</span><a href="#src.zig-std.fs.makeDirAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Create a new directory, based on an absolute path.
Asserts that the path is absolute. See <code><a href="std.fs.Dir.html#std.fs.Dir.makeDir">Dir.makeDir</a></code> for a function that operates
on both absolute and relative paths.
On Windows, <code>absolute_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>absolute_path</code> should be encoded as valid UTF-8.
On other platforms, <code>absolute_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.makeDirAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdir">mkdir</a>(absolute_path, <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.makeDirAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeDirAbsoluteZ</span><a href="#src.zig-std.fs.makeDirAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteZ</span>(absolute_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.makeDirAbsolute">makeDirAbsolute</a></code> except the parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.makeDirAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteZ</span>(absolute_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_z));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdirZ">mkdirZ</a>(absolute_path_z, <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.makeDirAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeDirAbsoluteW</span><a href="#src.zig-std.fs.makeDirAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.makeDirAbsolute">makeDirAbsolute</a></code> except the parameter is a null-terminated WTF-16 LE-encoded string.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.makeDirAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path_w));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdirW">mkdirW</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(absolute_path_w), <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.deleteDirAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteDirAbsolute</span><a href="#src.zig-std.fs.deleteDirAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsolute</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.deleteDir">Dir.deleteDir</a></code> except the path is absolute.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.deleteDirAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsolute</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dir_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rmdir">rmdir</a>(dir_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.deleteDirAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteDirAbsoluteZ</span><a href="#src.zig-std.fs.deleteDirAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.deleteDirAbsolute">deleteDirAbsolute</a></code> except the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.deleteDirAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(dir_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rmdirZ">rmdirZ</a>(dir_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.deleteDirAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteDirAbsoluteW</span><a href="#src.zig-std.fs.deleteDirAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteW</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.deleteDirAbsolute">deleteDirAbsolute</a></code> except the path parameter is WTF-16 and target OS is assumed Windows.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.deleteDirAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteW</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(dir_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rmdirW">rmdirW</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dir_path));
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.renameAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameAbsolute</span><a href="#src.zig-std.fs.renameAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsolute</span>(old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.rename">Dir.rename</a></code> except the paths are absolute.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.renameAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsolute</span>(old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(old_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(new_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rename">rename</a>(old_path, new_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.renameAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameAbsoluteZ</span><a href="#src.zig-std.fs.renameAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteZ</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.renameAbsolute">renameAbsolute</a></code> except the path parameters are null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.renameAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteZ</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(old_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(new_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameZ">renameZ</a>(old_path, new_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.renameAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameAbsoluteW</span><a href="#src.zig-std.fs.renameAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteW</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.renameAbsolute">renameAbsolute</a></code> except the path parameters are WTF-16 and target OS is assumed Windows.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.renameAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteW</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(old_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(new_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameW">renameW</a>(old_path, new_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.rename" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rename</span><a href="#src.zig-std.fs.rename">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.rename">Dir.rename</a></code>, except <code>new_sub_path</code> is relative to <code>new_dir</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.rename">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameat">renameat</a>(old_dir.fd, old_sub_path, new_dir.fd, new_sub_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.renameZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameZ</span><a href="#src.zig-std.fs.renameZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.rename">rename</a></code> except the parameters are null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.renameZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameatZ">renameatZ</a>(old_dir.fd, old_sub_path_z, new_dir.fd, new_sub_path_z);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.renameW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameW</span><a href="#src.zig-std.fs.renameW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.rename">rename</a></code> except the parameters are WTF16LE, NT prefixed.
This function is Windows-only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>old_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>new_dir: <a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.renameW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameatW">renameatW</a>(old_dir.fd, old_sub_path_w, new_dir.fd, new_sub_path_w, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.cwd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cwd</span><a href="#src.zig-std.fs.cwd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cwd</span>() <a href="std.fs.Dir.html">Dir</a></code></pre></div><div class="tldDocs"><p>Returns a handle to the current working directory. It is not opened with iteration capability.
Closing the returned <code><a href="std.fs.Dir.html">Dir</a></code> is checked illegal behavior. Iterating over the result is illegal behavior.
On POSIX targets, this function is comptime-callable.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.cwd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cwd</span>() <a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> .{ .fd = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.CurrentDirectory.Handle };
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .wasi) {
        <span class="tok-kw">return</span> .{ .fd = <a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">wasiCwd</a>() };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{ .fd = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a> };
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.defaultWasiCwd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">defaultWasiCwd</span><a href="#src.zig-std.fs.defaultWasiCwd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">defaultWasiCwd</span>() <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_t">fd_t</a></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.defaultWasiCwd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">defaultWasiCwd</span>() <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_t">fd_t</a> {<span class="tok-comment">
    // Expect the first preopen to be current working directory.
    </span><span class="tok-kw">return</span> <span class="tok-number">3</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.openDirAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openDirAbsolute</span><a href="#src.zig-std.fs.openDirAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a></code></pre></div><div class="tldDocs"><p>Opens a directory at the given path. The directory is a system resource that remains
open until <code>close</code> is called on the result.
See <code><a href="std.fs.html#std.fs.openDirAbsoluteZ">openDirAbsoluteZ</a></code> for a function that accepts a null-terminated path.</p>
<p>Asserts that the path parameter has no null bytes.
On Windows, <code>absolute_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>absolute_path</code> should be encoded as valid UTF-8.
On other platforms, <code>absolute_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.openDirAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openDir(absolute_path, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.openDirAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openDirAbsoluteZ</span><a href="#src.zig-std.fs.openDirAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.openDirAbsolute">openDirAbsolute</a></code> but the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.openDirAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openDirZ(absolute_path_c, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.openDirAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openDirAbsoluteW</span><a href="#src.zig-std.fs.openDirAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteW</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.openDirAbsolute">openDirAbsolute</a></code> but the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.openDirAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteW</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openDirW(absolute_path_c, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.openFileAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openFileAbsolute</span><a href="#src.zig-std.fs.openFileAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Opens a file for reading or writing, without attempting to create a new file, based on an absolute path.
Call <code><a href="std.fs.File.html#std.fs.File.close">File.close</a></code> to release the resource.
Asserts that the path is absolute. See <code><a href="std.fs.Dir.html#std.fs.Dir.openFile">Dir.openFile</a></code> for a function that
operates on both absolute and relative paths.
Asserts that the path parameter has no null bytes. See <code><a href="std.fs.html#std.fs.openFileAbsoluteZ">openFileAbsoluteZ</a></code> for a function
that accepts a null-terminated path.
On Windows, <code>absolute_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>absolute_path</code> should be encoded as valid UTF-8.
On other platforms, <code>absolute_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.openFileAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openFile(absolute_path, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.openFileAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openFileAbsoluteZ</span><a href="#src.zig-std.fs.openFileAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.openFileAbsolute">openFileAbsolute</a></code> but the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.openFileAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openFileZ(absolute_path_c, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.openFileAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openFileAbsoluteW</span><a href="#src.zig-std.fs.openFileAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteW</span>(absolute_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.openFileAbsolute">openFileAbsolute</a></code> but the path parameter is WTF-16-encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.openFileAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteW</span>(absolute_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsWTF16">isAbsoluteWindowsWTF16</a>(absolute_path_w));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openFileW(absolute_path_w, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.accessAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accessAbsolute</span><a href="#src.zig-std.fs.accessAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Test accessing <code><a href="std.fs.path.html">path</a></code>.
Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.
For example, instead of testing if a file exists and then opening it, just
open it and handle the error for file not found.
See <code><a href="std.fs.html#std.fs.accessAbsoluteZ">accessAbsoluteZ</a></code> for a function that accepts a null-terminated path.
On Windows, <code>absolute_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>absolute_path</code> should be encoded as valid UTF-8.
On other platforms, <code>absolute_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.accessAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().access(absolute_path, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.accessAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accessAbsoluteZ</span><a href="#src.zig-std.fs.accessAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteZ</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.accessAbsolute">accessAbsolute</a></code> but the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.accessAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteZ</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path));
    <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().accessZ(absolute_path, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.accessAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accessAbsoluteW</span><a href="#src.zig-std.fs.accessAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteW</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.accessAbsolute">accessAbsolute</a></code> but the path parameter is WTF-16 encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.accessAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteW</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path));
    <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().accessW(absolute_path, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.createFileAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createFileAbsolute</span><a href="#src.zig-std.fs.createFileAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Creates, opens, or overwrites a file with write access, based on an absolute path.
Call <code><a href="std.fs.File.html#std.fs.File.close">File.close</a></code> to release the resource.
Asserts that the path is absolute. See <code><a href="std.fs.Dir.html#std.fs.Dir.createFile">Dir.createFile</a></code> for a function that
operates on both absolute and relative paths.
Asserts that the path parameter has no null bytes. See <code>createFileAbsoluteC</code> for a function
that accepts a null-terminated path.
On Windows, <code>absolute_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>absolute_path</code> should be encoded as valid UTF-8.
On other platforms, <code>absolute_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.createFileAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().createFile(absolute_path, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.createFileAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createFileAbsoluteZ</span><a href="#src.zig-std.fs.createFileAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.createFileAbsolute">createFileAbsolute</a></code> but the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.createFileAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().createFileZ(absolute_path_c, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.createFileAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createFileAbsoluteW</span><a href="#src.zig-std.fs.createFileAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.createFileAbsolute">createFileAbsolute</a></code> but the path parameter is WTF-16 encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.createFileAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path_w));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().createFileW(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(absolute_path_w), flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.deleteFileAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteFileAbsolute</span><a href="#src.zig-std.fs.deleteFileAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Delete a file name and possibly the file it refers to, based on an absolute path.
Asserts that the path is absolute. See <code><a href="std.fs.Dir.html#std.fs.Dir.deleteFile">Dir.deleteFile</a></code> for a function that
operates on both absolute and relative paths.
Asserts that the path parameter has no null bytes.
On Windows, <code>absolute_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>absolute_path</code> should be encoded as valid UTF-8.
On other platforms, <code>absolute_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.deleteFileAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().deleteFile(absolute_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.deleteFileAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteFileAbsoluteZ</span><a href="#src.zig-std.fs.deleteFileAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.deleteFileAbsolute">deleteFileAbsolute</a></code> except the parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.deleteFileAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().deleteFileZ(absolute_path_c);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.deleteFileAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteFileAbsoluteW</span><a href="#src.zig-std.fs.deleteFileAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.deleteFileAbsolute">deleteFileAbsolute</a></code> except the parameter is WTF-16 encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.deleteFileAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path_w));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().deleteFileW(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(absolute_path_w));
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.deleteTreeAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deleteTreeAbsolute</span><a href="#src.zig-std.fs.deleteTreeAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Removes a symlink, file, or directory.
This is equivalent to <code><a href="std.fs.Dir.html#std.fs.Dir.deleteTree">Dir.deleteTree</a></code> with the base directory.
Asserts that the path is absolute. See <code><a href="std.fs.Dir.html#std.fs.Dir.deleteTree">Dir.deleteTree</a></code> for a function that
operates on both absolute and relative paths.
Asserts that the path parameter has no null bytes.
On Windows, <code>absolute_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>absolute_path</code> should be encoded as valid UTF-8.
On other platforms, <code>absolute_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.deleteTreeAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">const</span> dirname = <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(absolute_path) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>{
        <span class="tok-comment">/// Attempt to remove the root file system path.</span>
        <span class="tok-comment">/// This error is unreachable if `absolute_path` is relative.</span>
        CannotDeleteRootDirectory,
    }.CannotDeleteRootDirectory;

    <span class="tok-kw">var</span> dir = <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openDir(dirname, .{});
    <span class="tok-kw">defer</span> dir.close();

    <span class="tok-kw">return</span> dir.deleteTree(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(absolute_path));
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.readLinkAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readLinkAbsolute</span><a href="#src.zig-std.fs.readLinkAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsolute</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.Dir.html#std.fs.Dir.readLink">Dir.readLink</a></code>, except it asserts the path is absolute.
On Windows, <code>pathname</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>pathname</code> should be encoded as valid UTF-8.
On other platforms, <code>pathname</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.readLinkAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsolute</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(pathname));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlink">readlink</a>(pathname, buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.readlinkAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readlinkAbsoluteW</span><a href="#src.zig-std.fs.readlinkAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkAbsoluteW</span>(pathname_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code>readlinkW</code>, except the path parameter is null-terminated, WTF16
encoded.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.readlinkAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkAbsoluteW</span>(pathname_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(pathname_w));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkW">readlinkW</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(pathname_w), buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.readLinkAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readLinkAbsoluteZ</span><a href="#src.zig-std.fs.readLinkAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsoluteZ</span>(pathname_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Same as <code>readLink</code>, except the path parameter is null-terminated.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>pathname_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.readLinkAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsoluteZ</span>(pathname_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(pathname_c));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a>(pathname_c, buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.symLinkAbsolute" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symLinkAbsolute</span><a href="#src.zig-std.fs.symLinkAbsolute">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsolute</span>( target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a symbolic link named <code>sym_link_path</code> which contains the string <code>target_path</code>.
A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent
one; the latter case is known as a dangling link.
If <code>sym_link_path</code> exists, it will not be overwritten.
See also <code><a href="std.fs.html#std.fs.symLinkAbsoluteZ">symLinkAbsoluteZ</a></code> and <code><a href="std.fs.html#std.fs.symLinkAbsoluteW">symLinkAbsoluteW</a></code>.
On Windows, both paths should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, both paths should be encoded as valid UTF-8.
On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.symLinkAbsolute">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsolute</span>(
    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(target_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(sym_link_path));
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, target_path);
        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, sym_link_path);
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateSymbolicLink">CreateSymbolicLink</a>(<span class="tok-null">null</span>, sym_link_path_w.span(), target_path_w.span(), flags.is_directory);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.symlink">symlink</a>(target_path, sym_link_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.symLinkAbsoluteW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symLinkAbsoluteW</span><a href="#src.zig-std.fs.symLinkAbsoluteW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteW</span>( target_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, sym_link_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Windows-only. Same as <code><a href="std.fs.html#std.fs.symLinkAbsolute">symLinkAbsolute</a></code> except the parameters are null-terminated, WTF16 LE encoded.
Note that this function will by default try creating a symbolic link to a file. If you would
like to create a symbolic link to a directory, specify this with <code>SymLinkFlags{ .is_directory = true }</code>.
See also <code><a href="std.fs.html#std.fs.symLinkAbsolute">symLinkAbsolute</a></code>, <code><a href="std.fs.html#std.fs.symLinkAbsoluteZ">symLinkAbsoluteZ</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>sym_link_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.symLinkAbsoluteW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteW</span>(
    target_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    sym_link_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(target_path_w));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(sym_link_path_w));
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateSymbolicLink">CreateSymbolicLink</a>(<span class="tok-null">null</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(sym_link_path_w), <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(target_path_w), flags.is_directory);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.symLinkAbsoluteZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symLinkAbsoluteZ</span><a href="#src.zig-std.fs.symLinkAbsoluteZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteZ</span>( target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.fs.html#std.fs.symLinkAbsolute">symLinkAbsolute</a></code> except the parameters are null-terminated pointers.
See also <code><a href="std.fs.html#std.fs.symLinkAbsolute">symLinkAbsolute</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.symLinkAbsoluteZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteZ</span>(
    target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(target_path_c));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(sym_link_path_c));
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, target_path_c);
        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, sym_link_path_c);
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateSymbolicLink">CreateSymbolicLink</a>(<span class="tok-null">null</span>, sym_link_path_w.span(), target_path_w.span(), flags.is_directory);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.symlinkZ">symlinkZ</a>(target_path_c, sym_link_path_c);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.openSelfExe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openSelfExe</span><a href="#src.zig-std.fs.openSelfExe">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openSelfExe</span>(flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.html#std.fs.OpenSelfExeError">OpenSelfExeError</a>!<a href="std.fs.File.html">File</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.openSelfExe">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openSelfExe</span>(flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.html#std.fs.OpenSelfExeError">OpenSelfExeError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .linux) {
        <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.openFileAbsoluteZ">openFileAbsoluteZ</a>(<span class="tok-str">&quot;/proc/self/exe&quot;</span>, flags);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // If ImagePathName is a symlink, then it will contain the path of the symlink,
        // not the path that the symlink points to. However, because we are opening
        // the file, we can let the openFileW call follow the symlink for us.
        </span><span class="tok-kw">const</span> image_path_unicode_string = &amp;<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.ImagePathName;
        <span class="tok-kw">const</span> image_path_name = image_path_unicode_string.Buffer.?[<span class="tok-number">0</span> .. image_path_unicode_string.Length / <span class="tok-number">2</span> :<span class="tok-number">0</span>];
        <span class="tok-kw">const</span> prefixed_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.wToPrefixedFileW">wToPrefixedFileW</a>(<span class="tok-null">null</span>, image_path_name);
        <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openFileW(prefixed_path_w.span(), flags);
    }<span class="tok-comment">
    // Use of max_path_bytes here is valid as the resulting path is immediately
    // opened with no modification.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> self_exe_path = <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.selfExePath">selfExePath</a>(&amp;buf);
    buf[self_exe_path.len] = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.openFileAbsoluteZ">openFileAbsoluteZ</a>(buf[<span class="tok-number">0</span>..self_exe_path.len :<span class="tok-number">0</span>].ptr, flags);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.selfExePathAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">selfExePathAlloc</span><a href="#src.zig-std.fs.selfExePathAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p><code><a href="std.fs.html#std.fs.selfExePath">selfExePath</a></code> except allocates the result on the heap.
Caller owns returned memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.selfExePathAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // Use of max_path_bytes here is justified as, at least on one tested Linux
    // system, readlink will completely fail to return a result larger than
    // PATH_MAX even if given a sufficiently large buffer. This makes it
    // fundamentally impossible to get the selfExePath of a program running in
    // a very deeply nested directory chain in this way.
    // TODO(#4812): Investigate other systems and whether it is possible to get
    // this path by trying larger and larger buffers until one succeeds.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.selfExePath">selfExePath</a>(&amp;buf));
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.selfExePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">selfExePath</span><a href="#src.zig-std.fs.selfExePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePath</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Get the path to the current executable. Follows symlinks.
If you only need the directory, use selfExeDirPath.
If you only want an open file handle, use openSelfExe.
This function may return an error if the current executable
was deleted after spawning.
Returned value is a slice of out_buffer.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.</p>
<p>On Linux, depends on procfs being mounted. If the currently executing binary has
been deleted, the file path looks something like <code>/a/b/c/exe (deleted)</code>.
TODO make the return type of this a null terminated pointer</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.selfExePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePath</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.is_darwin">is_darwin</a>) {<span class="tok-comment">
        // Note that _NSGetExecutablePath() will return &quot;a path&quot; to
        // the executable not a &quot;real path&quot; to the executable.
        </span><span class="tok-kw">var</span> symlink_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> u32_len: <span class="tok-type">u32</span> = <a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a> + <span class="tok-number">1</span>;<span class="tok-comment"> // include the sentinel
        </span><span class="tok-kw">const</span> rc = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._NSGetExecutablePath">_NSGetExecutablePath</a>(&amp;symlink_path_buf, &amp;u32_len);
        <span class="tok-kw">if</span> (rc != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-kw">var</span> real_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> real_path = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(&amp;symlink_path_buf, &amp;real_path_buf) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];
        <span class="tok-builtin">@memcpy</span>(result, real_path);
        <span class="tok-kw">return</span> result;
    }
    <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a>(<span class="tok-str">&quot;/proc/self/exe&quot;</span>, out_buffer) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
            </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.UnsupportedReparsePointType =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        },
        .solaris, .illumos =&gt; <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a>(<span class="tok-str">&quot;/proc/self/path/a.out&quot;</span>, out_buffer) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
            </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.UnsupportedReparsePointType =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        },
        .freebsd, .dragonfly =&gt; {
            <span class="tok-kw">var</span> mib = [<span class="tok-number">4</span>]<span class="tok-type">c_int</span>{ <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CTL">CTL</a>.<a href="#">KERN</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">PROC</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">PROC_PATHNAME</a>, -<span class="tok-number">1</span> };
            <span class="tok-kw">var</span> out_len: <span class="tok-type">usize</span> = out_buffer.len;
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctl">sysctl</a>(&amp;mib, out_buffer.ptr, &amp;out_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>);<span class="tok-comment">
            // TODO could this slice from 0 to out_len instead?
            </span><span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(out_buffer, <span class="tok-number">0</span>);
        },
        .netbsd =&gt; {
            <span class="tok-kw">var</span> mib = [<span class="tok-number">4</span>]<span class="tok-type">c_int</span>{ <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CTL">CTL</a>.<a href="#">KERN</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">PROC_ARGS</a>, -<span class="tok-number">1</span>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">PROC_PATHNAME</a> };
            <span class="tok-kw">var</span> out_len: <span class="tok-type">usize</span> = out_buffer.len;
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctl">sysctl</a>(&amp;mib, out_buffer.ptr, &amp;out_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>);<span class="tok-comment">
            // TODO could this slice from 0 to out_len instead?
            </span><span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(out_buffer, <span class="tok-number">0</span>);
        },
        .openbsd, .haiku =&gt; {<span class="tok-comment">
            // OpenBSD doesn't support getting the path of a running process, so try to guess it
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>.<a href="#">len</a> == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;

            <span class="tok-kw">const</span> argv0 = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>[<span class="tok-number">0</span>]);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, argv0, <span class="tok-str">&quot;/&quot;</span>) != <span class="tok-null">null</span>) {<span class="tok-comment">
                // argv[0] is a path (relative or absolute): use realpath(3) directly
                </span><span class="tok-kw">var</span> real_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> real_path = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>[<span class="tok-number">0</span>], &amp;real_path_buf) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
                    </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
                    </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                };
                <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len)
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
                <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];
                <span class="tok-builtin">@memcpy</span>(result, real_path);
                <span class="tok-kw">return</span> result;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (argv0.len != <span class="tok-number">0</span>) {<span class="tok-comment">
                // argv[0] is not empty (and not a path): search it inside PATH
                </span><span class="tok-kw">const</span> PATH = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenvZ">getenvZ</a>(<span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
                <span class="tok-kw">var</span> path_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, PATH, <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.delimiter">delimiter</a>);
                <span class="tok-kw">while</span> (path_it.next()) |a_path| {
                    <span class="tok-kw">var</span> resolved_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a> - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">const</span> resolved_path = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrintZ">bufPrintZ</a>(&amp;resolved_path_buf, <span class="tok-str">&quot;{s}/{s}&quot;</span>, .{
                        a_path,
                        <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>[<span class="tok-number">0</span>],
                    }) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;

                    <span class="tok-kw">var</span> real_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(resolved_path, &amp;real_path_buf)) |real_path| {<span class="tok-comment">
                        // found a file, and hope it is the right file
                        </span><span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len)
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
                        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];
                        <span class="tok-builtin">@memcpy</span>(result, real_path);
                        <span class="tok-kw">return</span> result;
                    } <span class="tok-kw">else</span> |_| <span class="tok-kw">continue</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
        },
        .windows =&gt; {
            <span class="tok-kw">const</span> image_path_unicode_string = &amp;<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.ImagePathName;
            <span class="tok-kw">const</span> image_path_name = image_path_unicode_string.Buffer.?[<span class="tok-number">0</span> .. image_path_unicode_string.Length / <span class="tok-number">2</span> :<span class="tok-number">0</span>];<span class="tok-comment">

            // If ImagePathName is a symlink, then it will contain the path of the
            // symlink, not the path that the symlink points to. We want the path
            // that the symlink points to, though, so we need to get the realpath.
            </span><span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.wToPrefixedFileW">wToPrefixedFileW</a>(<span class="tok-null">null</span>, image_path_name);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().realpathW(pathname_w.span(), out_buffer) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.fs.selfExePath not supported for this target&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.selfExeDirPathAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">selfExeDirPathAlloc</span><a href="#src.zig-std.fs.selfExeDirPathAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p><code><a href="std.fs.html#std.fs.selfExeDirPath">selfExeDirPath</a></code> except allocates the result on the heap.
Caller owns returned memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.selfExeDirPathAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // Use of max_path_bytes here is justified as, at least on one tested Linux
    // system, readlink will completely fail to return a result larger than
    // PATH_MAX even if given a sufficiently large buffer. This makes it
    // fundamentally impossible to get the selfExeDirPath of a program running
    // in a very deeply nested directory chain in this way.
    // TODO(#4812): Investigate other systems and whether it is possible to get
    // this path by trying larger and larger buffers until one succeeds.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.selfExeDirPath">selfExeDirPath</a>(&amp;buf));
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.selfExeDirPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">selfExeDirPath</span><a href="#src.zig-std.fs.selfExeDirPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPath</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Get the directory path that contains the current executable.
Returned value is a slice of out_buffer.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.selfExeDirPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPath</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> self_exe_path = <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.selfExePath">selfExePath</a>(out_buffer);<span class="tok-comment">
    // Assume that the OS APIs return absolute paths, and therefore dirname
    // will not return null.
    </span><span class="tok-kw">return</span> <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(self_exe_path).?;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.realpathAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">realpathAlloc</span><a href="#src.zig-std.fs.realpathAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p><code><a href="std.posix.html#std.posix.realpath">realpath</a></code>, except caller must free the returned memory.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.
See also <code><a href="std.fs.Dir.html#std.fs.Dir.realpath">Dir.realpath</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.realpathAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // Use of max_path_bytes here is valid as the realpath function does not
    // have a variant that takes an arbitrary-size buffer.
    // TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008
    // NULL out parameter (GNU's canonicalize_file_name) to handle overelong
    // paths. musl supports passing NULL but restricts the output to PATH_MAX
    // anyway.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpath">realpath</a>(pathname, &amp;buf));
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.fs">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! File System.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> base64 = <a href="std.html">std</a>.<a href="std.base64.html">base64</a>;
<span class="tok-kw">const</span> crypto = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> native_os = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;

<span class="tok-kw">const</span> is_darwin = <a href="std.fs.html#std.fs.native_os">native_os</a>.<a href="#">isDarwin</a>();

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicFile = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/AtomicFile.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Dir = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/Dir.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/File.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> path = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/path.zig&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> has_executable_bit = <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
    .windows, .wasi =&gt; <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> wasi = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/wasi.zig&quot;</span>);<span class="tok-comment">

// TODO audit these APIs with respect to Dir and absolute paths

</span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpath = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpath">realpath</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpathZ = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpathZ">realpathZ</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> realpathW = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpathW">realpathW</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> getAppDataDir = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>).getAppDataDir;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetAppDataDirError = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>).GetAppDataDirError;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_PATH_BYTES = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; renamed to max_path_bytes&quot;</span>);

<span class="tok-comment">/// The maximum length of a file path that the operating system will accept.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Paths, including those returned from file system operations, may be longer</span>
<span class="tok-comment">/// than this length, but such paths cannot be successfully passed back in</span>
<span class="tok-comment">/// other file system operations. However, all path components returned by file</span>
<span class="tok-comment">/// system operations are assumed to fit into a `u8` array of this length.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The byte count includes room for a null sentinel byte.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// * On Windows, `[]u8` file paths are encoded as</span>
<span class="tok-comment">///   [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// * On WASI, `[]u8` file paths are encoded as valid UTF-8.</span>
<span class="tok-comment">/// * On other platforms, `[]u8` file paths are opaque sequences of bytes with</span>
<span class="tok-comment">///   no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_path_bytes = <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .haiku, .solaris, .illumos, .plan9, .emscripten, .wasi =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PATH_MAX">PATH_MAX</a>,<span class="tok-comment">
    // Each WTF-16LE code unit may be expanded to 3 WTF-8 bytes.
    // If it would require 4 WTF-8 bytes, then there would be a surrogate
    // pair in the WTF-16LE, and we (over)account 3 bytes for it that way.
    // +1 for the null byte at the end, which can be encoded in 1 byte.
    </span>.windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a> * <span class="tok-number">3</span> + <span class="tok-number">1</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>, <span class="tok-str">&quot;PATH_MAX&quot;</span>))
        <a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>.<a href="#">PATH_MAX</a>
    <span class="tok-kw">else</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;PATH_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(<a href="std.fs.html#std.fs.native_os">native_os</a>)),
};

<span class="tok-comment">/// This represents the maximum size of a `[]u8` file name component that</span>
<span class="tok-comment">/// the platform's common file systems support. File name components returned by file system</span>
<span class="tok-comment">/// operations are likely to fit into a `u8` array of this length, but</span>
<span class="tok-comment">/// (depending on the platform) this assumption may not hold for every configuration.</span>
<span class="tok-comment">/// The byte count does not include a null sentinel byte.</span>
<span class="tok-comment">/// On Windows, `[]u8` file name components are encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, file name components are encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `[]u8` components are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> max_name_bytes = <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .solaris, .illumos =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a>,<span class="tok-comment">
    // Haiku's NAME_MAX includes the null terminator, so subtract one.
    </span>.haiku =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.NAME_MAX">NAME_MAX</a> - <span class="tok-number">1</span>,<span class="tok-comment">
    // Each WTF-16LE character may be expanded to 3 WTF-8 bytes.
    // If it would require 4 WTF-8 bytes, then there would be a surrogate
    // pair in the WTF-16LE, and we (over)account 3 bytes for it that way.
    </span>.windows =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.NAME_MAX">NAME_MAX</a> * <span class="tok-number">3</span>,<span class="tok-comment">
    // For WASI, the MAX_NAME will depend on the host OS, so it needs to be
    // as large as the largest max_name_bytes (Windows) in order to work on any host OS.
    // TODO determine if this is a reasonable approach
    </span>.wasi =&gt; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.NAME_MAX">NAME_MAX</a> * <span class="tok-number">3</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>, <span class="tok-str">&quot;os&quot;</span>) <span class="tok-kw">and</span> <span class="tok-builtin">@hasDecl</span>(<a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>, <span class="tok-str">&quot;NAME_MAX&quot;</span>))
        <a href="std.fs.html#std.fs.root">root</a>.<a href="#">os</a>.<a href="#">NAME_MAX</a>
    <span class="tok-kw">else</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;NAME_MAX not implemented for &quot;</span> ++ <span class="tok-builtin">@tagName</span>(<a href="std.fs.html#std.fs.native_os">native_os</a>)),
};

<span class="tok-comment">/// Deprecated: use `max_name_bytes`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAX_NAME_BYTES = <a href="std.fs.html#std.fs.max_name_bytes">max_name_bytes</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_alphabet = <span class="tok-str">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;</span>.*;

<span class="tok-comment">/// Base64 encoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_encoder = <a href="std.base64.html">base64</a>.<a href="std.base64.Base64Encoder.html">Base64Encoder</a>.<a href="std.base64.Base64Encoder.html#std.base64.Base64Encoder.init">init</a>(<a href="std.fs.html#std.fs.base64_alphabet">base64_alphabet</a>, <span class="tok-null">null</span>);

<span class="tok-comment">/// Base64 decoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> base64_decoder = <a href="std.base64.html">base64</a>.<a href="std.base64.Base64Decoder.html">Base64Decoder</a>.<a href="std.base64.Base64Decoder.html#std.base64.Base64Decoder.init">init</a>(<a href="std.fs.html#std.fs.base64_alphabet">base64_alphabet</a>, <span class="tok-null">null</span>);

<span class="tok-comment">/// Deprecated. Use `cwd().atomicSymLink()` instead.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicSymLink</span>(_: <a href="std.mem.Allocator.html">Allocator</a>, existing_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().atomicSymLink(existing_path, new_path, .{});
}

<span class="tok-comment">/// Same as `Dir.updateFile`, except asserts that both `source_path` and `dest_path`</span>
<span class="tok-comment">/// are absolute. See `Dir.updateFile` for a function that operates on both</span>
<span class="tok-comment">/// absolute and relative paths.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFileAbsolute</span>(
    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>,
) !<a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.PrevStatus.html">PrevStatus</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(source_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dest_path));
    <span class="tok-kw">const</span> my_cwd = <a href="std.fs.html#std.fs.cwd">cwd</a>();
    <span class="tok-kw">return</span> <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.updateFile">updateFile</a>(my_cwd, source_path, my_cwd, dest_path, args);
}

<span class="tok-comment">/// Same as `Dir.copyFile`, except asserts that both `source_path` and `dest_path`</span>
<span class="tok-comment">/// are absolute. See `Dir.copyFile` for a function that operates on both</span>
<span class="tok-comment">/// absolute and relative paths.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFileAbsolute</span>(
    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.CopyFileOptions.html">CopyFileOptions</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(source_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dest_path));
    <span class="tok-kw">const</span> my_cwd = <a href="std.fs.html#std.fs.cwd">cwd</a>();
    <span class="tok-kw">return</span> <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.copyFile">copyFile</a>(my_cwd, source_path, my_cwd, dest_path, args);
}

<span class="tok-comment">/// Create a new directory, based on an absolute path.</span>
<span class="tok-comment">/// Asserts that the path is absolute. See `Dir.makeDir` for a function that operates</span>
<span class="tok-comment">/// on both absolute and relative paths.</span>
<span class="tok-comment">/// On Windows, `absolute_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `absolute_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `absolute_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdir">mkdir</a>(absolute_path, <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}

<span class="tok-comment">/// Same as `makeDirAbsolute` except the parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteZ</span>(absolute_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_z));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdirZ">mkdirZ</a>(absolute_path_z, <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}

<span class="tok-comment">/// Same as `makeDirAbsolute` except the parameter is a null-terminated WTF-16 LE-encoded string.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path_w));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mkdirW">mkdirW</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(absolute_path_w), <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.default_mode">default_mode</a>);
}

<span class="tok-comment">/// Same as `Dir.deleteDir` except the path is absolute.</span>
<span class="tok-comment">/// On Windows, `dir_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `dir_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `dir_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsolute</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dir_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rmdir">rmdir</a>(dir_path);
}

<span class="tok-comment">/// Same as `deleteDirAbsolute` except the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(dir_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rmdirZ">rmdirZ</a>(dir_path);
}

<span class="tok-comment">/// Same as `deleteDirAbsolute` except the path parameter is WTF-16 and target OS is assumed Windows.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirAbsoluteW</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(dir_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rmdirW">rmdirW</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dir_path));
}

<span class="tok-comment">/// Same as `Dir.rename` except the paths are absolute.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsolute</span>(old_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(old_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(new_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rename">rename</a>(old_path, new_path);
}

<span class="tok-comment">/// Same as `renameAbsolute` except the path parameters are null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteZ</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(old_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(new_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameZ">renameZ</a>(old_path, new_path);
}

<span class="tok-comment">/// Same as `renameAbsolute` except the path parameters are WTF-16 and target OS is assumed Windows.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameAbsoluteW</span>(old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(old_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(new_path));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameW">renameW</a>(old_path, new_path);
}

<span class="tok-comment">/// Same as `Dir.rename`, except `new_sub_path` is relative to `new_dir`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameat">renameat</a>(old_dir.fd, old_sub_path, new_dir.fd, new_sub_path);
}

<span class="tok-comment">/// Same as `rename` except the parameters are null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameatZ">renameatZ</a>(old_dir.fd, old_sub_path_z, new_dir.fd, new_sub_path_z);
}

<span class="tok-comment">/// Same as `rename` except the parameters are WTF16LE, NT prefixed.</span>
<span class="tok-comment">/// This function is Windows-only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(old_dir: <a href="std.fs.Dir.html">Dir</a>, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_dir: <a href="std.fs.Dir.html">Dir</a>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.renameatW">renameatW</a>(old_dir.fd, old_sub_path_w, new_dir.fd, new_sub_path_w, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>);
}

<span class="tok-comment">/// Returns a handle to the current working directory. It is not opened with iteration capability.</span>
<span class="tok-comment">/// Closing the returned `Dir` is checked illegal behavior. Iterating over the result is illegal behavior.</span>
<span class="tok-comment">/// On POSIX targets, this function is comptime-callable.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cwd</span>() <a href="std.fs.Dir.html">Dir</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .windows) {
        <span class="tok-kw">return</span> .{ .fd = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.CurrentDirectory.Handle };
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .wasi) {
        <span class="tok-kw">return</span> .{ .fd = <a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">wasiCwd</a>() };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> .{ .fd = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.AT">AT</a>.<a href="#">FDCWD</a> };
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">defaultWasiCwd</span>() <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.fd_t">fd_t</a> {<span class="tok-comment">
    // Expect the first preopen to be current working directory.
    </span><span class="tok-kw">return</span> <span class="tok-number">3</span>;
}

<span class="tok-comment">/// Opens a directory at the given path. The directory is a system resource that remains</span>
<span class="tok-comment">/// open until `close` is called on the result.</span>
<span class="tok-comment">/// See `openDirAbsoluteZ` for a function that accepts a null-terminated path.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-comment">/// On Windows, `absolute_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `absolute_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `absolute_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openDir(absolute_path, flags);
}

<span class="tok-comment">/// Same as `openDirAbsolute` but the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openDirZ(absolute_path_c, flags);
}
<span class="tok-comment">/// Same as `openDirAbsolute` but the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirAbsoluteW</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.OpenOptions.html">OpenOptions</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.Dir.html">Dir</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openDirW(absolute_path_c, flags);
}

<span class="tok-comment">/// Opens a file for reading or writing, without attempting to create a new file, based on an absolute path.</span>
<span class="tok-comment">/// Call `File.close` to release the resource.</span>
<span class="tok-comment">/// Asserts that the path is absolute. See `Dir.openFile` for a function that</span>
<span class="tok-comment">/// operates on both absolute and relative paths.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes. See `openFileAbsoluteZ` for a function</span>
<span class="tok-comment">/// that accepts a null-terminated path.</span>
<span class="tok-comment">/// On Windows, `absolute_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `absolute_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `absolute_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openFile(absolute_path, flags);
}

<span class="tok-comment">/// Same as `openFileAbsolute` but the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openFileZ(absolute_path_c, flags);
}

<span class="tok-comment">/// Same as `openFileAbsolute` but the path parameter is WTF-16-encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileAbsoluteW</span>(absolute_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsWTF16">isAbsoluteWindowsWTF16</a>(absolute_path_w));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openFileW(absolute_path_w, flags);
}

<span class="tok-comment">/// Test accessing `path`.</span>
<span class="tok-comment">/// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.</span>
<span class="tok-comment">/// For example, instead of testing if a file exists and then opening it, just</span>
<span class="tok-comment">/// open it and handle the error for file not found.</span>
<span class="tok-comment">/// See `accessAbsoluteZ` for a function that accepts a null-terminated path.</span>
<span class="tok-comment">/// On Windows, `absolute_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `absolute_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `absolute_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().access(absolute_path, flags);
}
<span class="tok-comment">/// Same as `accessAbsolute` but the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteZ</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path));
    <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().accessZ(absolute_path, flags);
}
<span class="tok-comment">/// Same as `accessAbsolute` but the path parameter is WTF-16 encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessAbsoluteW</span>(absolute_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.AccessError">AccessError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path));
    <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().accessW(absolute_path, flags);
}

<span class="tok-comment">/// Creates, opens, or overwrites a file with write access, based on an absolute path.</span>
<span class="tok-comment">/// Call `File.close` to release the resource.</span>
<span class="tok-comment">/// Asserts that the path is absolute. See `Dir.createFile` for a function that</span>
<span class="tok-comment">/// operates on both absolute and relative paths.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes. See `createFileAbsoluteC` for a function</span>
<span class="tok-comment">/// that accepts a null-terminated path.</span>
<span class="tok-comment">/// On Windows, `absolute_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `absolute_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `absolute_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().createFile(absolute_path, flags);
}

<span class="tok-comment">/// Same as `createFileAbsolute` but the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().createFileZ(absolute_path_c, flags);
}

<span class="tok-comment">/// Same as `createFileAbsolute` but the path parameter is WTF-16 encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.CreateFlags.html">CreateFlags</a>) <a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>!<a href="std.fs.File.html">File</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path_w));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().createFileW(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(absolute_path_w), flags);
}

<span class="tok-comment">/// Delete a file name and possibly the file it refers to, based on an absolute path.</span>
<span class="tok-comment">/// Asserts that the path is absolute. See `Dir.deleteFile` for a function that</span>
<span class="tok-comment">/// operates on both absolute and relative paths.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-comment">/// On Windows, `absolute_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `absolute_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `absolute_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().deleteFile(absolute_path);
}

<span class="tok-comment">/// Same as `deleteFileAbsolute` except the parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteZ</span>(absolute_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(absolute_path_c));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().deleteFileZ(absolute_path_c);
}

<span class="tok-comment">/// Same as `deleteFileAbsolute` except the parameter is WTF-16 encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileAbsoluteW</span>(absolute_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.UnlinkError">DeleteFileError</a>!<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(absolute_path_w));
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().deleteFileW(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(absolute_path_w));
}

<span class="tok-comment">/// Removes a symlink, file, or directory.</span>
<span class="tok-comment">/// This is equivalent to `Dir.deleteTree` with the base directory.</span>
<span class="tok-comment">/// Asserts that the path is absolute. See `Dir.deleteTree` for a function that</span>
<span class="tok-comment">/// operates on both absolute and relative paths.</span>
<span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span>
<span class="tok-comment">/// On Windows, `absolute_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `absolute_path` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `absolute_path` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeAbsolute</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(absolute_path));
    <span class="tok-kw">const</span> dirname = <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(absolute_path) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>{
        <span class="tok-comment">/// Attempt to remove the root file system path.</span>
        <span class="tok-comment">/// This error is unreachable if `absolute_path` is relative.</span>
        CannotDeleteRootDirectory,
    }.CannotDeleteRootDirectory;

    <span class="tok-kw">var</span> dir = <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openDir(dirname, .{});
    <span class="tok-kw">defer</span> dir.close();

    <span class="tok-kw">return</span> dir.deleteTree(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(absolute_path));
}

<span class="tok-comment">/// Same as `Dir.readLink`, except it asserts the path is absolute.</span>
<span class="tok-comment">/// On Windows, `pathname` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, `pathname` should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, `pathname` is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsolute</span>(pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(pathname));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlink">readlink</a>(pathname, buffer);
}

<span class="tok-comment">/// Windows-only. Same as `readlinkW`, except the path parameter is null-terminated, WTF16</span>
<span class="tok-comment">/// encoded.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readlinkAbsoluteW</span>(pathname_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(pathname_w));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkW">readlinkW</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(pathname_w), buffer);
}

<span class="tok-comment">/// Same as `readLink`, except the path parameter is null-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkAbsoluteZ</span>(pathname_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: *[<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(pathname_c));
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a>(pathname_c, buffer);
}

<span class="tok-comment">/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`.</span>
<span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span>
<span class="tok-comment">/// one; the latter case is known as a dangling link.</span>
<span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span>
<span class="tok-comment">/// See also `symLinkAbsoluteZ` and `symLinkAbsoluteW`.</span>
<span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span>
<span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsolute</span>(
    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(target_path));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(sym_link_path));
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, target_path);
        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.sliceToPrefixedFileW">sliceToPrefixedFileW</a>(<span class="tok-null">null</span>, sym_link_path);
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateSymbolicLink">CreateSymbolicLink</a>(<span class="tok-null">null</span>, sym_link_path_w.span(), target_path_w.span(), flags.is_directory);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.symlink">symlink</a>(target_path, sym_link_path);
}

<span class="tok-comment">/// Windows-only. Same as `symLinkAbsolute` except the parameters are null-terminated, WTF16 LE encoded.</span>
<span class="tok-comment">/// Note that this function will by default try creating a symbolic link to a file. If you would</span>
<span class="tok-comment">/// like to create a symbolic link to a directory, specify this with `SymLinkFlags{ .is_directory = true }`.</span>
<span class="tok-comment">/// See also `symLinkAbsolute`, `symLinkAbsoluteZ`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteW</span>(
    target_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    sym_link_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(target_path_w));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteWindowsW">isAbsoluteWindowsW</a>(sym_link_path_w));
    <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateSymbolicLink">CreateSymbolicLink</a>(<span class="tok-null">null</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(sym_link_path_w), <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(target_path_w), flags.is_directory);
}

<span class="tok-comment">/// Same as `symLinkAbsolute` except the parameters are null-terminated pointers.</span>
<span class="tok-comment">/// See also `symLinkAbsolute`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkAbsoluteZ</span>(
    target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.SymLinkFlags.html">SymLinkFlags</a>,
) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(target_path_c));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsoluteZ">isAbsoluteZ</a>(sym_link_path_c));
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, target_path_c);
        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.cStrToPrefixedFileW">cStrToPrefixedFileW</a>(<span class="tok-null">null</span>, sym_link_path_c);
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CreateSymbolicLink">CreateSymbolicLink</a>(<span class="tok-null">null</span>, sym_link_path_w.span(), target_path_w.span(), flags.is_directory);
    }
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.symlinkZ">symlinkZ</a>(target_path_c, sym_link_path_c);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenSelfExeError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.OpenError">OpenError</a> || <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FlockError">FlockError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openSelfExe</span>(flags: <a href="std.fs.File.html">File</a>.<a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <a href="std.fs.html#std.fs.OpenSelfExeError">OpenSelfExeError</a>!<a href="std.fs.File.html">File</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .linux) {
        <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.openFileAbsoluteZ">openFileAbsoluteZ</a>(<span class="tok-str">&quot;/proc/self/exe&quot;</span>, flags);
    }
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // If ImagePathName is a symlink, then it will contain the path of the symlink,
        // not the path that the symlink points to. However, because we are opening
        // the file, we can let the openFileW call follow the symlink for us.
        </span><span class="tok-kw">const</span> image_path_unicode_string = &amp;<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.ImagePathName;
        <span class="tok-kw">const</span> image_path_name = image_path_unicode_string.Buffer.?[<span class="tok-number">0</span> .. image_path_unicode_string.Length / <span class="tok-number">2</span> :<span class="tok-number">0</span>];
        <span class="tok-kw">const</span> prefixed_path_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.wToPrefixedFileW">wToPrefixedFileW</a>(<span class="tok-null">null</span>, image_path_name);
        <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.cwd">cwd</a>().openFileW(prefixed_path_w.span(), flags);
    }<span class="tok-comment">
    // Use of max_path_bytes here is valid as the resulting path is immediately
    // opened with no modification.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> self_exe_path = <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.selfExePath">selfExePath</a>(&amp;buf);
    buf[self_exe_path.len] = <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <a href="std.fs.html#std.fs.openFileAbsoluteZ">openFileAbsoluteZ</a>(buf[<span class="tok-number">0</span>..self_exe_path.len :<span class="tok-number">0</span>].ptr, flags);
}<span class="tok-comment">

// This is `posix.ReadLinkError || posix.RealPathError` with impossible errors excluded
</span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SelfExePathError = <span class="tok-kw">error</span>{
    FileNotFound,
    AccessDenied,
    NameTooLong,
    NotSupported,
    NotDir,
    SymLinkLoop,
    InputOutput,
    FileTooBig,
    IsDir,
    ProcessFdQuotaExceeded,
    SystemFdQuotaExceeded,
    NoDevice,
    SystemResources,
    NoSpaceLeft,
    FileSystem,
    BadPathName,
    DeviceBusy,
    SharingViolation,
    PipeBusy,
    NotLink,
    PathAlreadyExists,

    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,

    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,

    <span class="tok-comment">/// On Windows, the volume does not contain a recognized file system. File</span>
    <span class="tok-comment">/// system drivers might not be loaded, or the volume may be corrupt.</span>
    UnrecognizedVolume,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SysCtlError">SysCtlError</a>;

<span class="tok-comment">/// `selfExePath` except allocates the result on the heap.</span>
<span class="tok-comment">/// Caller owns returned memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // Use of max_path_bytes here is justified as, at least on one tested Linux
    // system, readlink will completely fail to return a result larger than
    // PATH_MAX even if given a sufficiently large buffer. This makes it
    // fundamentally impossible to get the selfExePath of a program running in
    // a very deeply nested directory chain in this way.
    // TODO(#4812): Investigate other systems and whether it is possible to get
    // this path by trying larger and larger buffers until one succeeds.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.selfExePath">selfExePath</a>(&amp;buf));
}

<span class="tok-comment">/// Get the path to the current executable. Follows symlinks.</span>
<span class="tok-comment">/// If you only need the directory, use selfExeDirPath.</span>
<span class="tok-comment">/// If you only want an open file handle, use openSelfExe.</span>
<span class="tok-comment">/// This function may return an error if the current executable</span>
<span class="tok-comment">/// was deleted after spawning.</span>
<span class="tok-comment">/// Returned value is a slice of out_buffer.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On Linux, depends on procfs being mounted. If the currently executing binary has</span>
<span class="tok-comment">/// been deleted, the file path looks something like `/a/b/c/exe (deleted)`.</span>
<span class="tok-comment">/// TODO make the return type of this a null terminated pointer</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExePath</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.is_darwin">is_darwin</a>) {<span class="tok-comment">
        // Note that _NSGetExecutablePath() will return &quot;a path&quot; to
        // the executable not a &quot;real path&quot; to the executable.
        </span><span class="tok-kw">var</span> symlink_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> u32_len: <span class="tok-type">u32</span> = <a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a> + <span class="tok-number">1</span>;<span class="tok-comment"> // include the sentinel
        </span><span class="tok-kw">const</span> rc = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin._NSGetExecutablePath">_NSGetExecutablePath</a>(&amp;symlink_path_buf, &amp;u32_len);
        <span class="tok-kw">if</span> (rc != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;

        <span class="tok-kw">var</span> real_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> real_path = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(&amp;symlink_path_buf, &amp;real_path_buf) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];
        <span class="tok-builtin">@memcpy</span>(result, real_path);
        <span class="tok-kw">return</span> result;
    }
    <span class="tok-kw">switch</span> (<a href="std.fs.html#std.fs.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a>(<span class="tok-str">&quot;/proc/self/exe&quot;</span>, out_buffer) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
            </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.UnsupportedReparsePointType =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        },
        .solaris, .illumos =&gt; <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readlinkZ">readlinkZ</a>(<span class="tok-str">&quot;/proc/self/path/a.out&quot;</span>, out_buffer) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // WASI-only
            </span><span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.UnsupportedReparsePointType =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        },
        .freebsd, .dragonfly =&gt; {
            <span class="tok-kw">var</span> mib = [<span class="tok-number">4</span>]<span class="tok-type">c_int</span>{ <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CTL">CTL</a>.<a href="#">KERN</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">PROC</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">PROC_PATHNAME</a>, -<span class="tok-number">1</span> };
            <span class="tok-kw">var</span> out_len: <span class="tok-type">usize</span> = out_buffer.len;
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctl">sysctl</a>(&amp;mib, out_buffer.ptr, &amp;out_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>);<span class="tok-comment">
            // TODO could this slice from 0 to out_len instead?
            </span><span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(out_buffer, <span class="tok-number">0</span>);
        },
        .netbsd =&gt; {
            <span class="tok-kw">var</span> mib = [<span class="tok-number">4</span>]<span class="tok-type">c_int</span>{ <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CTL">CTL</a>.<a href="#">KERN</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">PROC_ARGS</a>, -<span class="tok-number">1</span>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.KERN">KERN</a>.<a href="#">PROC_PATHNAME</a> };
            <span class="tok-kw">var</span> out_len: <span class="tok-type">usize</span> = out_buffer.len;
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctl">sysctl</a>(&amp;mib, out_buffer.ptr, &amp;out_len, <span class="tok-null">null</span>, <span class="tok-number">0</span>);<span class="tok-comment">
            // TODO could this slice from 0 to out_len instead?
            </span><span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(out_buffer, <span class="tok-number">0</span>);
        },
        .openbsd, .haiku =&gt; {<span class="tok-comment">
            // OpenBSD doesn't support getting the path of a running process, so try to guess it
            </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>.<a href="#">len</a> == <span class="tok-number">0</span>)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;

            <span class="tok-kw">const</span> argv0 = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>[<span class="tok-number">0</span>]);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, argv0, <span class="tok-str">&quot;/&quot;</span>) != <span class="tok-null">null</span>) {<span class="tok-comment">
                // argv[0] is a path (relative or absolute): use realpath(3) directly
                </span><span class="tok-kw">var</span> real_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> real_path = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>[<span class="tok-number">0</span>], &amp;real_path_buf) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
                    </span><span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Windows-only
                    </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
                };
                <span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len)
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
                <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];
                <span class="tok-builtin">@memcpy</span>(result, real_path);
                <span class="tok-kw">return</span> result;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (argv0.len != <span class="tok-number">0</span>) {<span class="tok-comment">
                // argv[0] is not empty (and not a path): search it inside PATH
                </span><span class="tok-kw">const</span> PATH = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenvZ">getenvZ</a>(<span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
                <span class="tok-kw">var</span> path_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, PATH, <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.delimiter">delimiter</a>);
                <span class="tok-kw">while</span> (path_it.next()) |a_path| {
                    <span class="tok-kw">var</span> resolved_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a> - <span class="tok-number">1</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">const</span> resolved_path = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrintZ">bufPrintZ</a>(&amp;resolved_path_buf, <span class="tok-str">&quot;{s}/{s}&quot;</span>, .{
                        a_path,
                        <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>[<span class="tok-number">0</span>],
                    }) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;

                    <span class="tok-kw">var</span> real_path_buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                    <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpathZ">realpathZ</a>(resolved_path, &amp;real_path_buf)) |real_path| {<span class="tok-comment">
                        // found a file, and hope it is the right file
                        </span><span class="tok-kw">if</span> (real_path.len &gt; out_buffer.len)
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
                        <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..real_path.len];
                        <span class="tok-builtin">@memcpy</span>(result, real_path);
                        <span class="tok-kw">return</span> result;
                    } <span class="tok-kw">else</span> |_| <span class="tok-kw">continue</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
        },
        .windows =&gt; {
            <span class="tok-kw">const</span> image_path_unicode_string = &amp;<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.ImagePathName;
            <span class="tok-kw">const</span> image_path_name = image_path_unicode_string.Buffer.?[<span class="tok-number">0</span> .. image_path_unicode_string.Length / <span class="tok-number">2</span> :<span class="tok-number">0</span>];<span class="tok-comment">

            // If ImagePathName is a symlink, then it will contain the path of the
            // symlink, not the path that the symlink points to. We want the path
            // that the symlink points to, though, so we need to get the realpath.
            </span><span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.wToPrefixedFileW">wToPrefixedFileW</a>(<span class="tok-null">null</span>, image_path_name);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().realpathW(pathname_w.span(), out_buffer) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.fs.selfExePath not supported for this target&quot;</span>),
    }
}

<span class="tok-comment">/// `selfExeDirPath` except allocates the result on the heap.</span>
<span class="tok-comment">/// Caller owns returned memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // Use of max_path_bytes here is justified as, at least on one tested Linux
    // system, readlink will completely fail to return a result larger than
    // PATH_MAX even if given a sufficiently large buffer. This makes it
    // fundamentally impossible to get the selfExeDirPath of a program running
    // in a very deeply nested directory chain in this way.
    // TODO(#4812): Investigate other systems and whether it is possible to get
    // this path by trying larger and larger buffers until one succeeds.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.selfExeDirPath">selfExeDirPath</a>(&amp;buf));
}

<span class="tok-comment">/// Get the directory path that contains the current executable.</span>
<span class="tok-comment">/// Returned value is a slice of out_buffer.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">selfExeDirPath</span>(out_buffer: []<span class="tok-type">u8</span>) <a href="std.fs.html#std.fs.SelfExePathError">SelfExePathError</a>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> self_exe_path = <span class="tok-kw">try</span> <a href="std.fs.html#std.fs.selfExePath">selfExePath</a>(out_buffer);<span class="tok-comment">
    // Assume that the OS APIs return absolute paths, and therefore dirname
    // will not return null.
    </span><span class="tok-kw">return</span> <a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(self_exe_path).?;
}

<span class="tok-comment">/// `realpath`, except caller must free the returned memory.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-comment">/// See also `Dir.realpath`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // Use of max_path_bytes here is valid as the realpath function does not
    // have a variant that takes an arbitrary-size buffer.
    // TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008
    // NULL out parameter (GNU's canonicalize_file_name) to handle overelong
    // paths. musl supports passing NULL but restricts the output to PATH_MAX
    // anyway.
    </span><span class="tok-kw">var</span> buf: [<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.realpath">realpath</a>(pathname, &amp;buf));
}

<span class="tok-kw">test</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.html#std.fs.native_os">native_os</a> != .wasi) {
        _ = &amp;<a href="std.fs.html#std.fs.makeDirAbsolute">makeDirAbsolute</a>;
        _ = &amp;<a href="std.fs.html#std.fs.makeDirAbsoluteZ">makeDirAbsoluteZ</a>;
        _ = &amp;<a href="std.fs.html#std.fs.copyFileAbsolute">copyFileAbsolute</a>;
        _ = &amp;<a href="std.fs.html#std.fs.updateFileAbsolute">updateFileAbsolute</a>;
    }
    _ = &amp;<a href="std.fs.AtomicFile.html">AtomicFile</a>;
    _ = &amp;<a href="std.fs.Dir.html">Dir</a>;
    _ = &amp;<a href="std.fs.File.html">File</a>;
    _ = &amp;<a href="std.fs.path.html">path</a>;
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/test.zig&quot;</span>);
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;fs/get_app_data_dir.zig&quot;</span>);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
