<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.Build.html" class="active">Build</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Build" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Build</span><a href="#src.zig-std.Build">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.Build.Fuzz.html">std.Build.Fuzz</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.Build.Cache.html">std.Build.Cache</a></li><li><a href="std.Build.Step.html">std.Build.Step</a></li><li><a href="std.Build.Module.html">std.Build.Module</a></li><li><a href="std.Build.Watch.html">std.Build.Watch</a></li><li><a href="std.Build.ReleaseMode.html">std.Build.ReleaseMode</a></li><li><a href="std.Build.Graph.html">std.Build.Graph</a></li><li><a href="std.Build.PkgConfigPkg.html">std.Build.PkgConfigPkg</a></li><li><a href="std.Build.DirList.html">std.Build.DirList</a></li><li><a href="std.Build.ExecutableOptions.html">std.Build.ExecutableOptions</a></li><li><a href="std.Build.ObjectOptions.html">std.Build.ObjectOptions</a></li><li><a href="std.Build.SharedLibraryOptions.html">std.Build.SharedLibraryOptions</a></li><li><a href="std.Build.StaticLibraryOptions.html">std.Build.StaticLibraryOptions</a></li><li><a href="std.Build.LibraryOptions.html">std.Build.LibraryOptions</a></li><li><a href="std.Build.TestOptions.html">std.Build.TestOptions</a></li><li><a href="std.Build.AssemblyOptions.html">std.Build.AssemblyOptions</a></li><li><a href="std.Build.StandardOptimizeOptionOptions.html">std.Build.StandardOptimizeOptionOptions</a></li><li><a href="std.Build.StandardTargetOptionsArgs.html">std.Build.StandardTargetOptionsArgs</a></li><li><a href="std.Build.Dependency.html">std.Build.Dependency</a></li><li><a href="std.Build.GeneratedFile.html">std.Build.GeneratedFile</a></li><li><a href="std.Build.LazyPath.html">std.Build.LazyPath</a></li><li><a href="std.Build.InstallDir.html">std.Build.InstallDir</a></li><li><a href="std.Build.ResolvedTarget.html">std.Build.ResolvedTarget</a></li><li><a href="std.Build.SystemIntegrationOptionConfig.html">std.Build.SystemIntegrationOptionConfig</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>graph: *<a href="std.Build.Graph.html">Graph</a></code></pre><div class="fieldDocs"><p>Shared state among all Build instances.</p>
</div></div><div><pre><code>install_tls: <a href="std.Build.TopLevelStep.html">TopLevelStep</a></code></pre></div><div><pre><code>uninstall_tls: <a href="std.Build.TopLevelStep.html">TopLevelStep</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>user_input_options: <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a></code></pre></div><div><pre><code>available_options_map: <a href="std.Build.html#std.Build.AvailableOptionsMap">AvailableOptionsMap</a></code></pre></div><div><pre><code>available_options_list: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.AvailableOption.html">AvailableOption</a>)</code></pre></div><div><pre><code>verbose: <span class="tok-type">bool</span></code></pre></div><div><pre><code>verbose_link: <span class="tok-type">bool</span></code></pre></div><div><pre><code>verbose_cc: <span class="tok-type">bool</span></code></pre></div><div><pre><code>verbose_air: <span class="tok-type">bool</span></code></pre></div><div><pre><code>verbose_llvm_ir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>verbose_llvm_bc: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>verbose_cimport: <span class="tok-type">bool</span></code></pre></div><div><pre><code>verbose_llvm_cpu_features: <span class="tok-type">bool</span></code></pre></div><div><pre><code>reference_trace: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>invalid_user_input: <span class="tok-type">bool</span></code></pre></div><div><pre><code>default_step: *<a href="std.Build.Step.html">Step</a></code></pre></div><div><pre><code>top_level_steps: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(*<a href="std.Build.TopLevelStep.html">TopLevelStep</a>)</code></pre></div><div><pre><code>install_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dest_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>lib_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>exe_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>h_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>install_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>sysroot: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>search_prefixes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>)</code></pre></div><div><pre><code>libc_file: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>build_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a></code></pre><div class="fieldDocs"><p>Path to the directory containing build.zig.</p>
</div></div><div><pre><code>cache_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a></code></pre></div><div><pre><code>pkg_config_pkg_list: ?(<a href="std.Build.html#std.Build.PkgConfigError">PkgConfigError</a>![]<span class="tok-kw">const</span> <a href="std.Build.PkgConfigPkg.html">PkgConfigPkg</a>) = <span class="tok-null">null</span></code></pre></div><div><pre><code>args: ?[]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span></code></pre></div><div><pre><code>debug_log_scopes: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{}</code></pre></div><div><pre><code>debug_compile_errors: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>debug_pkg_config: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div><div><pre><code>debug_stack_frames_count: <span class="tok-type">u8</span> = <span class="tok-number">8</span></code></pre><div class="fieldDocs"><p>Number of stack frames captured when a <code>StackTrace</code> is recorded for debug purposes,
in particular at <code><a href="std.Build.Step.html">Step</a></code> creation.
Set to 0 to disable stack collection.</p>
</div></div><div><pre><code>enable_darling: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Experimental. Use system Darling installation to run cross compiled macOS build artifacts.</p>
</div></div><div><pre><code>enable_qemu: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Use system QEMU installation to run cross compiled foreign architecture build artifacts.</p>
</div></div><div><pre><code>enable_rosetta: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Darwin. Use Rosetta to run x86_64 macOS build artifacts on arm64 macOS.</p>
</div></div><div><pre><code>enable_wasmtime: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Use system Wasmtime installation to run cross compiled wasm/wasi build artifacts.</p>
</div></div><div><pre><code>enable_wine: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre><div class="fieldDocs"><p>Use system Wine installation to run cross compiled Windows build artifacts.</p>
</div></div><div><pre><code>glibc_runtimes_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>After following the steps in <a href="https://github.com/ziglang/zig/wiki/Updating-libc#glibc">https://github.com/ziglang/zig/wiki/Updating-libc#glibc</a>,
this will be the directory $glibc-build-dir/install/glibcs
Given the example of the aarch64 target, this is the directory
that contains the path <code>aarch64-linux-gnu/lib/ld-linux-aarch64.so.1</code>.</p>
</div></div><div><pre><code>dep_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span></code></pre></div><div><pre><code>modules: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMap">StringArrayHashMap</a>(*<a href="std.Build.Module.html">Module</a>)</code></pre></div><div><pre><code>named_writefiles: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMap">StringArrayHashMap</a>(*<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a>)</code></pre></div><div><pre><code>named_lazy_paths: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMap">StringArrayHashMap</a>(<a href="std.Build.LazyPath.html">LazyPath</a>)</code></pre></div><div><pre><code>pkg_hash: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre><div class="fieldDocs"><p>The hash of this instance's package. <code>&quot;&quot;</code> means that this is the root package.</p>
</div></div><div><pre><code>available_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a></code></pre><div class="fieldDocs"><p>A mapping from dependency names to package hashes.</p>
</div></div><div><pre><code>release_mode: <a href="std.Build.ReleaseMode.html">ReleaseMode</a></code></pre></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.Build.RunError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RunError</span><a href="#src.zig-std.Build.RunError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>BadPathName <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt></div><div><dt>CurrentWorkingDirectoryUnlinked <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. <code>cwd</code> was provided, but the path did not exist when spawning the child process.</p>
</dd></div><div><dt>ExecNotSupported</dt></div><div><dt>ExitCodeFailure</dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileSystem <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InvalidBatchScriptArg <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. NUL (U+0000), LF (U+000A), CR (U+000D) are not allowed
within arguments when executing a <code>.bat</code>/<code>.cmd</code> script.</p>
<ul>
<li>NUL/LF signifiies end of arguments, so anything afterwards
would be lost after execution.</li>
<li>CR is stripped by <code>cmd.exe</code>, so any CR codepoints
would be lost after execution.</li>
</ul>
</dd></div><div><dt>InvalidExe <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InvalidHandle <a href="std.os.windows.html#std.os.windows.GetProcessMemoryInfoError">GetProcessMemoryInfoError</a></dt></div><div><dt>InvalidName <a href="std.os.windows.html#std.os.windows.CreateProcessError">CreateProcessError</a></dt></div><div><dt>InvalidProcessGroupId <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>InvalidUserId <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>InvalidUtf8 <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8 <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>Windows-only. <code>cwd</code> or <code>argv</code> was provided and it was invalid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NoDevice <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt><dd><p>POSIX-only. <code>StdIo.Ignore</code> was selected and opening <code>/dev/null</code> returned ENODEV.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>OutOfMemory <a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></dt></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.SetEidError">SetEidError</a></dt></div><div><dt>ProcessAlreadyExec <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.SetPgidError">SetPgidError</a></dt></div><div><dt>ProcessTerminated</dt></div><div><dt>ReadFailure</dt></div><div><dt>ResourceLimitReached <a href="std.posix.html#std.posix.SetIdError">SetIdError</a></dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WaitAbandoned <a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></dt></div><div><dt>WaitTimeOut <a href="std.os.windows.html#std.os.windows.WaitForSingleObjectError">WaitForSingleObjectError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.RunError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RunError = <span class="tok-kw">error</span>{
    ReadFailure,
    ExitCodeFailure,
    ProcessTerminated,
    ExecNotSupported,
} || <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a></code></pre></details></div></div><div class="decl"><h2 id="std.Build.PkgConfigError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PkgConfigError</span><a href="#src.zig-std.Build.PkgConfigError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>PkgConfigCrashed</dt></div><div><dt>PkgConfigFailed</dt></div><div><dt>PkgConfigInvalidOutput</dt></div><div><dt>PkgConfigNotInstalled</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.PkgConfigError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PkgConfigError = <span class="tok-kw">error</span>{
    PkgConfigCrashed,
    PkgConfigFailed,
    PkgConfigNotInstalled,
    PkgConfigInvalidOutput,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Build.create" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">create</span><a href="#src.zig-std.Build.create">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>( graph: *<a href="std.Build.Graph.html">Graph</a>, build_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>, cache_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>, available_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a>, ) <span class="tok-kw">error</span>{OutOfMemory}!*<a href="std.Build.html">Build</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>graph: *<a href="std.Build.Graph.html">Graph</a></code></pre></div><div><pre><code>build_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a></code></pre></div><div><pre><code>cache_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a></code></pre></div><div><pre><code>available_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.create">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(
    graph: *<a href="std.Build.Graph.html">Graph</a>,
    build_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
    cache_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
    available_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a>,
) <span class="tok-kw">error</span>{OutOfMemory}!*<a href="std.Build.html">Build</a> {
    <span class="tok-kw">const</span> arena = graph.arena;

    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> arena.create(<a href="std.Build.html">Build</a>);
    b.* = .{
        .graph = graph,
        .build_root = build_root,
        .cache_root = cache_root,
        .verbose = <span class="tok-null">false</span>,
        .verbose_link = <span class="tok-null">false</span>,
        .verbose_cc = <span class="tok-null">false</span>,
        .verbose_air = <span class="tok-null">false</span>,
        .verbose_llvm_ir = <span class="tok-null">null</span>,
        .verbose_llvm_bc = <span class="tok-null">null</span>,
        .verbose_cimport = <span class="tok-null">false</span>,
        .verbose_llvm_cpu_features = <span class="tok-null">false</span>,
        .invalid_user_input = <span class="tok-null">false</span>,
        .allocator = arena,
        .user_input_options = <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a>.<a href="#">init</a>(arena),
        .available_options_map = <a href="std.Build.html#std.Build.AvailableOptionsMap">AvailableOptionsMap</a>.<a href="#">init</a>(arena),
        .available_options_list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.AvailableOption.html">AvailableOption</a>).init(arena),
        .top_level_steps = .{},
        .default_step = <span class="tok-null">undefined</span>,
        .search_prefixes = .{},
        .install_prefix = <span class="tok-null">undefined</span>,
        .lib_dir = <span class="tok-null">undefined</span>,
        .exe_dir = <span class="tok-null">undefined</span>,
        .h_dir = <span class="tok-null">undefined</span>,
        .dest_dir = graph.env_map.get(<span class="tok-str">&quot;DESTDIR&quot;</span>),
        .install_tls = .{
            .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
                .id = <a href="std.Build.TopLevelStep.html">TopLevelStep</a>.<a href="std.Build.TopLevelStep.html#std.Build.TopLevelStep.base_id">base_id</a>,
                .name = <span class="tok-str">&quot;install&quot;</span>,
                .owner = b,
            }),
            .description = <span class="tok-str">&quot;Copy build artifacts to prefix path&quot;</span>,
        },
        .uninstall_tls = .{
            .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
                .id = <a href="std.Build.TopLevelStep.html">TopLevelStep</a>.<a href="std.Build.TopLevelStep.html#std.Build.TopLevelStep.base_id">base_id</a>,
                .name = <span class="tok-str">&quot;uninstall&quot;</span>,
                .owner = b,
                .makeFn = <a href="std.Build.html#std.Build.makeUninstall">makeUninstall</a>,
            }),
            .description = <span class="tok-str">&quot;Remove build artifacts from prefix path&quot;</span>,
        },
        .install_path = <span class="tok-null">undefined</span>,
        .args = <span class="tok-null">null</span>,
        .modules = .init(arena),
        .named_writefiles = .init(arena),
        .named_lazy_paths = .init(arena),
        .pkg_hash = <span class="tok-str">&quot;&quot;</span>,
        .available_deps = available_deps,
        .release_mode = .off,
    };
    <span class="tok-kw">try</span> b.top_level_steps.put(arena, b.install_tls.step.name, &amp;b.install_tls);
    <span class="tok-kw">try</span> b.top_level_steps.put(arena, b.uninstall_tls.step.name, &amp;b.uninstall_tls);
    b.default_step = &amp;b.install_tls.step;
    <span class="tok-kw">return</span> b;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.resolveInstallPrefix" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resolveInstallPrefix</span><a href="#src.zig-std.Build.resolveInstallPrefix">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveInstallPrefix</span>(b: *<a href="std.Build.html">Build</a>, install_prefix: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dir_list: <a href="std.Build.DirList.html">DirList</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>This function is intended to be called by lib/build_runner.zig, not a build.zig file.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>install_prefix: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dir_list: <a href="std.Build.DirList.html">DirList</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.resolveInstallPrefix">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveInstallPrefix</span>(b: *<a href="std.Build.html">Build</a>, install_prefix: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dir_list: <a href="std.Build.DirList.html">DirList</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (b.dest_dir) |dest_dir| {
        b.install_prefix = install_prefix <span class="tok-kw">orelse</span> <span class="tok-str">&quot;/usr&quot;</span>;
        b.install_path = b.pathJoin(&amp;.{ dest_dir, b.install_prefix });
    } <span class="tok-kw">else</span> {
        b.install_prefix = install_prefix <span class="tok-kw">orelse</span>
            (b.build_root.join(b.allocator, &amp;.{<span class="tok-str">&quot;zig-out&quot;</span>}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>));
        b.install_path = b.install_prefix;
    }

    <span class="tok-kw">var</span> lib_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ b.install_path, <span class="tok-str">&quot;lib&quot;</span> };
    <span class="tok-kw">var</span> exe_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ b.install_path, <span class="tok-str">&quot;bin&quot;</span> };
    <span class="tok-kw">var</span> h_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ b.install_path, <span class="tok-str">&quot;include&quot;</span> };

    <span class="tok-kw">if</span> (dir_list.lib_dir) |dir| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dir)) lib_list[<span class="tok-number">0</span>] = b.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;
        lib_list[<span class="tok-number">1</span>] = dir;
    }

    <span class="tok-kw">if</span> (dir_list.exe_dir) |dir| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dir)) exe_list[<span class="tok-number">0</span>] = b.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;
        exe_list[<span class="tok-number">1</span>] = dir;
    }

    <span class="tok-kw">if</span> (dir_list.include_dir) |dir| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dir)) h_list[<span class="tok-number">0</span>] = b.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;
        h_list[<span class="tok-number">1</span>] = dir;
    }

    b.lib_dir = b.pathJoin(&amp;lib_list);
    b.exe_dir = b.pathJoin(&amp;exe_list);
    b.h_dir = b.pathJoin(&amp;h_list);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addOptions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addOptions</span><a href="#src.zig-std.Build.addOptions">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptions</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Options.html">Options</a></code></pre></div><div class="tldDocs"><p>Create a set of key-value pairs that can be converted into a Zig source
file and then inserted into a Zig compilation's module table for importing.
In other words, this provides a way to expose build.zig values to Zig
source code with <code>@import</code>.
Related: <code><a href="std.Build.Module.html#std.Build.Module.addOptions">Module.addOptions</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addOptions">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptions</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Options.html">Options</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Options.html">Options</a>.<a href="std.Build.Step.Options.html#std.Build.Step.Options.create">create</a>(b);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addExecutable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addExecutable</span><a href="#src.zig-std.Build.addExecutable">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addExecutable</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.ExecutableOptions.html">ExecutableOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.ExecutableOptions.html">ExecutableOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addExecutable">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addExecutable</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.ExecutableOptions.html">ExecutableOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.target != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .root_source_file = options.root_source_file,
            .target = options.target <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be null&quot;</span>),
            .optimize = options.optimize,
            .link_libc = options.link_libc,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
            .code_model = options.code_model,
        }),
        .version = options.version,
        .kind = .exe,
        .linkage = options.linkage,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
        .win32_manifest = options.win32_manifest,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addObject" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addObject</span><a href="#src.zig-std.Build.addObject">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObject</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.ObjectOptions.html">ObjectOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.ObjectOptions.html">ObjectOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addObject">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObject</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.ObjectOptions.html">ObjectOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.target != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .root_source_file = options.root_source_file,
            .target = options.target <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be null&quot;</span>),
            .optimize = options.optimize,
            .link_libc = options.link_libc,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
            .code_model = options.code_model,
        }),
        .kind = .obj,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addSharedLibrary" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSharedLibrary</span><a href="#src.zig-std.Build.addSharedLibrary">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSharedLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.SharedLibraryOptions.html">SharedLibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="tldDocs"><p>Deprecated: use <code>b.addLibrary(.{ ..., .linkage = .dynamic })</code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.SharedLibraryOptions.html">SharedLibraryOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addSharedLibrary">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSharedLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.SharedLibraryOptions.html">SharedLibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.target != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .target = options.target <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be null&quot;</span>),
            .optimize = options.optimize,
            .root_source_file = options.root_source_file,
            .link_libc = options.link_libc,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
            .code_model = options.code_model,
        }),
        .kind = .lib,
        .linkage = .dynamic,
        .version = options.version,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
        .win32_manifest = options.win32_manifest,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addStaticLibrary" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addStaticLibrary</span><a href="#src.zig-std.Build.addStaticLibrary">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addStaticLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.StaticLibraryOptions.html">StaticLibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="tldDocs"><p>Deprecated: use <code>b.addLibrary(.{ ..., .linkage = .static })</code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.StaticLibraryOptions.html">StaticLibraryOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addStaticLibrary">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addStaticLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.StaticLibraryOptions.html">StaticLibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.target != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .target = options.target <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be null&quot;</span>),
            .optimize = options.optimize,
            .root_source_file = options.root_source_file,
            .link_libc = options.link_libc,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
            .code_model = options.code_model,
        }),
        .kind = .lib,
        .linkage = .static,
        .version = options.version,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addLibrary" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addLibrary</span><a href="#src.zig-std.Build.addLibrary">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.LibraryOptions.html">LibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.LibraryOptions.html">LibraryOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addLibrary">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.LibraryOptions.html">LibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module,
        .kind = .lib,
        .linkage = options.linkage,
        .version = options.version,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
        .win32_manifest = options.win32_manifest,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addTest" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addTest</span><a href="#src.zig-std.Build.addTest">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTest</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.TestOptions.html">TestOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="tldDocs"><p>Creates an executable containing unit tests.</p>
<p>Equivalent to running the command <code>zig test --test-no-exec ...</code>.</p>
<p><strong>This step does not run the unit tests</strong>. Typically, the result of this
function will be passed to <code><a href="std.Build.html#std.Build.addRunArtifact">addRunArtifact</a></code>, creating a <code><a href="std.Build.Step.Run.html">Step.Run</a></code>. These
two steps are separated because they are independently configured and
cached.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.TestOptions.html">TestOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addTest">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTest</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.TestOptions.html">TestOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.root_source_file != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `root_source_file` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .kind = .@&quot;test&quot;,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .root_source_file = options.root_source_file <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `root_source_file` cannot both be null&quot;</span>),
            .target = options.target <span class="tok-kw">orelse</span> b.graph.host,
            .optimize = options.optimize,
            .link_libc = options.link_libc,
            .link_libcpp = options.link_libcpp,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
        }),
        .max_rss = options.max_rss,
        .filters = <span class="tok-kw">if</span> (options.filter != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.filters.len &gt; <span class="tok-number">0</span>) filters: {
            <span class="tok-kw">const</span> filters = b.allocator.alloc([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-number">1</span> + options.filters.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            filters[<span class="tok-number">0</span>] = b.dupe(options.filter.?);
            <span class="tok-kw">for</span> (filters[<span class="tok-number">1</span>..], options.filters) |*dest, source| dest.* = b.dupe(source);
            <span class="tok-kw">break</span> :filters filters;
        } <span class="tok-kw">else</span> b.dupeStrings(<span class="tok-kw">if</span> (options.filter) |filter| &amp;.{filter} <span class="tok-kw">else</span> options.filters),
        .test_runner = options.test_runner,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addAssembly" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addAssembly</span><a href="#src.zig-std.Build.addAssembly">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssembly</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.AssemblyOptions.html">AssemblyOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div class="tldDocs"><p>Deprecated; prefer using <code><a href="std.Build.html#std.Build.addObject">addObject</a></code> where the <code>root_module</code> has an empty
<code>root_source_file</code> and contains an assembly file via <code><a href="std.Build.Module.html#std.Build.Module.addAssemblyFile">Module.addAssemblyFile</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.AssemblyOptions.html">AssemblyOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addAssembly">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssembly</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.AssemblyOptions.html">AssemblyOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">const</span> root_module = b.createModule(.{
        .target = options.target,
        .optimize = options.optimize,
    });
    root_module.addAssemblyFile(options.source_file);
    <span class="tok-kw">return</span> b.addObject(.{
        .name = options.name,
        .max_rss = options.max_rss,
        .zig_lib_dir = options.zig_lib_dir,
        .root_module = root_module,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addModule" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addModule</span><a href="#src.zig-std.Build.addModule">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addModule</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CreateOptions.html">CreateOptions</a>) *<a href="std.Build.Module.html">Module</a></code></pre></div><div class="tldDocs"><p>This function creates a module and adds it to the package's module set, making
it available to other packages which depend on this one.
<code><a href="std.Build.html#std.Build.createModule">createModule</a></code> can be used instead to create a private module.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CreateOptions.html">CreateOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addModule">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addModule</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CreateOptions.html">CreateOptions</a>) *<a href="std.Build.Module.html">Module</a> {
    <span class="tok-kw">const</span> module = <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.html#std.Build.Module.create">create</a>(b, options);
    b.modules.put(b.dupe(name), module) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">return</span> module;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.createModule" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createModule</span><a href="#src.zig-std.Build.createModule">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createModule</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CreateOptions.html">CreateOptions</a>) *<a href="std.Build.Module.html">Module</a></code></pre></div><div class="tldDocs"><p>This function creates a private module, to be used by the current package,
but not exposed to other packages depending on this one.
<code><a href="std.Build.html#std.Build.addModule">addModule</a></code> can be used instead to create a public module.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CreateOptions.html">CreateOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.createModule">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createModule</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CreateOptions.html">CreateOptions</a>) *<a href="std.Build.Module.html">Module</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.html#std.Build.Module.create">create</a>(b, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addSystemCommand" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSystemCommand</span><a href="#src.zig-std.Build.addSystemCommand">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemCommand</span>(b: *<a href="std.Build.html">Build</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a></code></pre></div><div class="tldDocs"><p>Initializes a <code><a href="std.Build.Step.Run.html">Step.Run</a></code> with argv, which must at least have the path to the
executable. More command line arguments can be added with <code>addArg</code>,
<code>addArgs</code>, and <code>addArtifactArg</code>.
Be careful using this function, as it introduces a system dependency.
To run an executable built with zig build, see <code>Step.Compile.run</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addSystemCommand">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemCommand</span>(b: *<a href="std.Build.html">Build</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(argv.len &gt;= <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> run_step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a>.<a href="std.Build.Step.Run.html#std.Build.Step.Run.create">create</a>(b, b.fmt(<span class="tok-str">&quot;run {s}&quot;</span>, .{argv[<span class="tok-number">0</span>]}));
    run_step.addArgs(argv);
    <span class="tok-kw">return</span> run_step;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addRunArtifact" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addRunArtifact</span><a href="#src.zig-std.Build.addRunArtifact">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRunArtifact</span>(b: *<a href="std.Build.html">Build</a>, exe: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a></code></pre></div><div class="tldDocs"><p>Creates a <code><a href="std.Build.Step.Run.html">Step.Run</a></code> with an executable built with <code><a href="std.Build.html#std.Build.addExecutable">addExecutable</a></code>.
Add command line arguments with methods of <code><a href="std.Build.Step.Run.html">Step.Run</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>exe: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addRunArtifact">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRunArtifact</span>(b: *<a href="std.Build.html">Build</a>, exe: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a> {<span class="tok-comment">
    // It doesn't have to be native. We catch that if you actually try to run it.
    // Consider that this is declarative; the run step may not be run unless a user
    // option is supplied.
    </span><span class="tok-kw">const</span> run_step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a>.<a href="std.Build.Step.Run.html#std.Build.Step.Run.create">create</a>(b, b.fmt(<span class="tok-str">&quot;run {s}&quot;</span>, .{exe.name}));
    run_step.producer = exe;
    <span class="tok-kw">if</span> (exe.kind == .@&quot;test&quot;) {
        <span class="tok-kw">if</span> (exe.exec_cmd_args) |exec_cmd_args| {
            <span class="tok-kw">for</span> (exec_cmd_args) |cmd_arg| {
                <span class="tok-kw">if</span> (cmd_arg) |arg| {
                    run_step.addArg(arg);
                } <span class="tok-kw">else</span> {
                    run_step.addArtifactArg(exe);
                }
            }
        } <span class="tok-kw">else</span> {
            run_step.addArtifactArg(exe);
        }

        <span class="tok-kw">const</span> test_server_mode = <span class="tok-kw">if</span> (exe.test_runner) |r| r.mode == .server <span class="tok-kw">else</span> <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (test_server_mode) run_step.enableTestRunnerMode();
    } <span class="tok-kw">else</span> {
        run_step.addArtifactArg(exe);
    }

    <span class="tok-kw">return</span> run_step;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addConfigHeader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addConfigHeader</span><a href="#src.zig-std.Build.addConfigHeader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addConfigHeader</span>( b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>.<a href="std.Build.Step.ConfigHeader.Options.html">Options</a>, values: <span class="tok-kw">anytype</span>, ) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a></code></pre></div><div class="tldDocs"><p>Using the <code>values</code> provided, produces a C header file, possibly based on a
template input file (e.g. config.h.in).
When an input template file is provided, this function will fail the build
when an option not found in the input file is provided in <code>values</code>, and
when an option found in the input file is missing from <code>values</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>.<a href="std.Build.Step.ConfigHeader.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addConfigHeader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addConfigHeader</span>(
    b: *<a href="std.Build.html">Build</a>,
    options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>.<a href="std.Build.Step.ConfigHeader.Options.html">Options</a>,
    values: <span class="tok-kw">anytype</span>,
) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a> {
    <span class="tok-kw">var</span> options_copy = options;
    <span class="tok-kw">if</span> (options_copy.first_ret_addr == <span class="tok-null">null</span>)
        options_copy.first_ret_addr = <span class="tok-builtin">@returnAddress</span>();

    <span class="tok-kw">const</span> config_header_step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>.<a href="std.Build.Step.ConfigHeader.html#std.Build.Step.ConfigHeader.create">create</a>(b, options_copy);
    config_header_step.addValues(values);
    <span class="tok-kw">return</span> config_header_step;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.dupe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dupe</span><a href="#src.zig-std.Build.dupe">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(b: *<a href="std.Build.html">Build</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Allocator.dupe without the need to handle out of memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.dupe">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(b: *<a href="std.Build.html">Build</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dupeInner">dupeInner</a>(b.allocator, bytes);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.dupeInner" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dupeInner</span><a href="#src.zig-std.Build.dupeInner">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeInner</span>(allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.dupeInner">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeInner</span>(allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, bytes) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.dupeStrings" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dupeStrings</span><a href="#src.zig-std.Build.dupeStrings">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeStrings</span>(b: *<a href="std.Build.html">Build</a>, strings: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) [][]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Duplicates an array of strings without the need to handle out of memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>strings: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.dupeStrings">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeStrings</span>(b: *<a href="std.Build.html">Build</a>, strings: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) [][]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> array = b.allocator.alloc([]<span class="tok-type">u8</span>, strings.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">for</span> (array, strings) |*dest, source| dest.* = b.dupe(source);
    <span class="tok-kw">return</span> array;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.dupePath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dupePath</span><a href="#src.zig-std.Build.dupePath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupePath</span>(b: *<a href="std.Build.html">Build</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Duplicates a path and converts all slashes to the OS's canonical path separator.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.dupePath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupePath</span>(b: *<a href="std.Build.html">Build</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dupePathInner">dupePathInner</a>(b.allocator, bytes);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addWriteFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addWriteFile</span><a href="#src.zig-std.Build.addWriteFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFile</span>(b: *<a href="std.Build.html">Build</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addWriteFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFile</span>(b: *<a href="std.Build.html">Build</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
    <span class="tok-kw">const</span> write_file_step = b.addWriteFiles();
    _ = write_file_step.add(file_path, data);
    <span class="tok-kw">return</span> write_file_step;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addNamedWriteFiles" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addNamedWriteFiles</span><a href="#src.zig-std.Build.addNamedWriteFiles">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNamedWriteFiles</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addNamedWriteFiles">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNamedWriteFiles</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
    <span class="tok-kw">const</span> wf = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a>.<a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.create">create</a>(b);
    b.named_writefiles.put(b.dupe(name), wf) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">return</span> wf;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addNamedLazyPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addNamedLazyPath</span><a href="#src.zig-std.Build.addNamedLazyPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNamedLazyPath</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lp: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>lp: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addNamedLazyPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNamedLazyPath</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lp: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    b.named_lazy_paths.put(b.dupe(name), lp.dupe(b)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addWriteFiles" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addWriteFiles</span><a href="#src.zig-std.Build.addWriteFiles">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFiles</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addWriteFiles">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFiles</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a>.<a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.create">create</a>(b);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addUpdateSourceFiles" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addUpdateSourceFiles</span><a href="#src.zig-std.Build.addUpdateSourceFiles">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUpdateSourceFiles</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.UpdateSourceFiles.html">UpdateSourceFiles</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addUpdateSourceFiles">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUpdateSourceFiles</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.UpdateSourceFiles.html">UpdateSourceFiles</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.UpdateSourceFiles.html">UpdateSourceFiles</a>.<a href="std.Build.Step.UpdateSourceFiles.html#std.Build.Step.UpdateSourceFiles.create">create</a>(b);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addRemoveDirTree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addRemoveDirTree</span><a href="#src.zig-std.Build.addRemoveDirTree">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRemoveDirTree</span>(b: *<a href="std.Build.html">Build</a>, dir_path: <a href="std.Build.LazyPath.html">LazyPath</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.RemoveDir.html">RemoveDir</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>dir_path: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addRemoveDirTree">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRemoveDirTree</span>(b: *<a href="std.Build.html">Build</a>, dir_path: <a href="std.Build.LazyPath.html">LazyPath</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.RemoveDir.html">RemoveDir</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.RemoveDir.html">RemoveDir</a>.<a href="std.Build.Step.RemoveDir.html#std.Build.Step.RemoveDir.create">create</a>(b, dir_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addFail" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFail</span><a href="#src.zig-std.Build.addFail">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFail</span>(b: *<a href="std.Build.html">Build</a>, error_msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fail.html">Fail</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>error_msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addFail">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFail</span>(b: *<a href="std.Build.html">Build</a>, error_msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fail.html">Fail</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fail.html">Fail</a>.<a href="std.Build.Step.Fail.html#std.Build.Step.Fail.create">create</a>(b, error_msg);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addFmt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFmt</span><a href="#src.zig-std.Build.addFmt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFmt</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a>.<a href="std.Build.Step.Fmt.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a>.<a href="std.Build.Step.Fmt.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addFmt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFmt</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a>.<a href="std.Build.Step.Fmt.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a>.<a href="std.Build.Step.Fmt.html#std.Build.Step.Fmt.create">create</a>(b, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addTranslateC" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addTranslateC</span><a href="#src.zig-std.Build.addTranslateC">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTranslateC</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a>.<a href="std.Build.Step.TranslateC.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a>.<a href="std.Build.Step.TranslateC.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addTranslateC">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTranslateC</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a>.<a href="std.Build.Step.TranslateC.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a>.<a href="std.Build.Step.TranslateC.html#std.Build.Step.TranslateC.create">create</a>(b, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.getInstallStep" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getInstallStep</span><a href="#src.zig-std.Build.getInstallStep">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallStep</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.getInstallStep">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallStep</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a> {
    <span class="tok-kw">return</span> &amp;b.install_tls.step;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.getUninstallStep" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getUninstallStep</span><a href="#src.zig-std.Build.getUninstallStep">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getUninstallStep</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.getUninstallStep">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getUninstallStep</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a> {
    <span class="tok-kw">return</span> &amp;b.uninstall_tls.step;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.option" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">option</span><a href="#src.zig-std.Build.option">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">option</span>(b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?T</code></pre></div><div class="tldDocs"><p>Creates a configuration option to be passed to the build.zig script.
When a user directly runs <code>zig build</code>, they can set these options with <code>-D</code> arguments.
When a project depends on a Zig package as a dependency, it programmatically sets
these options when calling the dependency's build.zig script as a function.
<code>null</code> is returned when an option is left to default.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>description_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.option">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">option</span>(b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?T {
    <span class="tok-kw">const</span> name = b.dupe(name_raw);
    <span class="tok-kw">const</span> description = b.dupe(description_raw);
    <span class="tok-kw">const</span> type_id = <span class="tok-kw">comptime</span> <a href="std.Build.html#std.Build.typeToEnum">typeToEnum</a>(T);
    <span class="tok-kw">const</span> enum_options = <span class="tok-kw">if</span> (type_id == .@&quot;enum&quot; <span class="tok-kw">or</span> type_id == .enum_list) blk: {
        <span class="tok-kw">const</span> EnumType = <span class="tok-kw">if</span> (type_id == .enum_list) <span class="tok-builtin">@typeInfo</span>(T).pointer.child <span class="tok-kw">else</span> T;
        <span class="tok-kw">const</span> fields = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(EnumType);
        <span class="tok-kw">var</span> options = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).initCapacity(b.allocator, fields.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {
            options.appendAssumeCapacity(field.name);
        }

        <span class="tok-kw">break</span> :blk options.toOwnedSlice() <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> available_option = <a href="std.Build.AvailableOption.html">AvailableOption</a>{
        .name = name,
        .type_id = type_id,
        .description = description,
        .enum_options = enum_options,
    };
    <span class="tok-kw">if</span> ((b.available_options_map.fetchPut(name, available_option) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>)) != <span class="tok-null">null</span>) {
        <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;Option '{s}' declared twice&quot;</span>, .{name});
    }
    b.available_options_list.append(available_option) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    <span class="tok-kw">const</span> option_ptr = b.user_input_options.getPtr(name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    option_ptr.used = <span class="tok-null">true</span>;
    <span class="tok-kw">switch</span> (type_id) {
        .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
            .scalar =&gt; |s| {
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;true&quot;</span>)) {
                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;false&quot;</span>)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                } <span class="tok-kw">else</span> {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a boolean, but received '{s}'&quot;</span>, .{ name, s });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
            .list, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a boolean, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
        },
        .int =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .list, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be an integer, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">const</span> n = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(T, s, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.Overflow =&gt; {
                        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;-D{s} value {s} cannot fit into type {s}.&quot;</span>, .{ name, s, <span class="tok-builtin">@typeName</span>(T) });
                        b.markInvalidUserInput();
                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be an integer of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });
                        b.markInvalidUserInput();
                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    },
                };
                <span class="tok-kw">return</span> n;
            },
        },
        .float =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .list, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a float, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">const</span> n = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.parse_float.html#std.fmt.parse_float.parseFloat">parseFloat</a>(T, s) <span class="tok-kw">catch</span> {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a float of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                };
                <span class="tok-kw">return</span> n;
            },
        },
        .@&quot;enum&quot; =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .list, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be an enum, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(T, s)) |enum_lit| {
                    <span class="tok-kw">return</span> enum_lit;
                } <span class="tok-kw">else</span> {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
        },
        .string =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .list, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a string, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| <span class="tok-kw">return</span> s,
        },
        .build_id =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .list, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be an enum, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.BuildId.html">BuildId</a>.<a href="std.zig.BuildId.html#std.zig.BuildId.parse">parse</a>(s)) |build_id| {
                    <span class="tok-kw">return</span> build_id;
                } <span class="tok-kw">else</span> |err| {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;unable to parse option '-D{s}': {s}&quot;</span>, .{ name, <span class="tok-builtin">@errorName</span>(err) });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
        },
        .list =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a list, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">return</span> b.allocator.dupe([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{s}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            .list =&gt; |lst| <span class="tok-kw">return</span> lst.items,
        },
        .enum_list =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a list, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">const</span> Child = <span class="tok-builtin">@typeInfo</span>(T).pointer.child;
                <span class="tok-kw">const</span> value = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(Child, s) <span class="tok-kw">orelse</span> {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(Child) });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                };
                <span class="tok-kw">return</span> b.allocator.dupe(Child, &amp;[_]Child{value}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            .list =&gt; |lst| {
                <span class="tok-kw">const</span> Child = <span class="tok-builtin">@typeInfo</span>(T).pointer.child;
                <span class="tok-kw">const</span> new_list = b.allocator.alloc(Child, lst.items.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                <span class="tok-kw">for</span> (new_list, lst.items) |*new_item, str| {
                    new_item.* = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(Child, str) <span class="tok-kw">orelse</span> {
                        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(Child) });
                        b.markInvalidUserInput();
                        b.allocator.free(new_list);
                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    };
                }
                <span class="tok-kw">return</span> new_list;
            },
        },
        .lazy_path =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .scalar =&gt; |s| <span class="tok-kw">return</span> .{ .cwd_relative = s },
            .lazy_path =&gt; |lp| <span class="tok-kw">return</span> lp,
            .flag, .map, .list, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a path, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
        },
        .lazy_path_list =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .scalar =&gt; |s| <span class="tok-kw">return</span> b.allocator.dupe(<a href="std.Build.LazyPath.html">LazyPath</a>, &amp;[_]<a href="std.Build.LazyPath.html">LazyPath</a>{.{ .cwd_relative = s }}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
            .lazy_path =&gt; |lp| <span class="tok-kw">return</span> b.allocator.dupe(<a href="std.Build.LazyPath.html">LazyPath</a>, &amp;[_]<a href="std.Build.LazyPath.html">LazyPath</a>{lp}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
            .list =&gt; |lst| {
                <span class="tok-kw">const</span> new_list = b.allocator.alloc(<a href="std.Build.LazyPath.html">LazyPath</a>, lst.items.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                <span class="tok-kw">for</span> (new_list, lst.items) |*new_item, str| {
                    new_item.* = .{ .cwd_relative = str };
                }
                <span class="tok-kw">return</span> new_list;
            },
            .lazy_path_list =&gt; |lp_list| <span class="tok-kw">return</span> lp_list.items,
            .flag, .map =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a path, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.step" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">step</span><a href="#src.zig-std.Build.step">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.step">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a> {
    <span class="tok-kw">const</span> step_info = b.allocator.create(<a href="std.Build.TopLevelStep.html">TopLevelStep</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    step_info.* = .{
        .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
            .id = <a href="std.Build.TopLevelStep.html">TopLevelStep</a>.<a href="std.Build.TopLevelStep.html#std.Build.TopLevelStep.base_id">base_id</a>,
            .name = name,
            .owner = b,
        }),
        .description = b.dupe(description),
    };
    <span class="tok-kw">const</span> gop = b.top_level_steps.getOrPut(b.allocator, name) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">if</span> (gop.found_existing) <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;A top-level step with name \&quot;{s}\&quot; already exists&quot;</span>, .{name});

    gop.key_ptr.* = step_info.step.name;
    gop.value_ptr.* = step_info;

    <span class="tok-kw">return</span> &amp;step_info.step;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.standardOptimizeOption" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">standardOptimizeOption</span><a href="#src.zig-std.Build.standardOptimizeOption">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardOptimizeOption</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.StandardOptimizeOptionOptions.html">StandardOptimizeOptionOptions</a>) <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.StandardOptimizeOptionOptions.html">StandardOptimizeOptionOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.standardOptimizeOption">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardOptimizeOption</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.StandardOptimizeOptionOptions.html">StandardOptimizeOptionOptions</a>) <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a> {
    <span class="tok-kw">if</span> (options.preferred_optimize_mode) |mode| {
        <span class="tok-kw">if</span> (b.option(<span class="tok-type">bool</span>, <span class="tok-str">&quot;release&quot;</span>, <span class="tok-str">&quot;optimize for end users&quot;</span>) <span class="tok-kw">orelse</span> (b.release_mode != .off)) {
            <span class="tok-kw">return</span> mode;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> .Debug;
        }
    }

    <span class="tok-kw">if</span> (b.option(
        <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a>,
        <span class="tok-str">&quot;optimize&quot;</span>,
        <span class="tok-str">&quot;Prioritize performance, safety, or binary size&quot;</span>,
    )) |mode| {
        <span class="tok-kw">return</span> mode;
    }

    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (b.release_mode) {
        .off =&gt; .Debug,
        .any =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;the project does not declare a preferred optimization mode. choose: --release=fast, --release=safe, or --release=small\n&quot;</span>, .{});
            <a href="std.process.html">process</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
        },
        .fast =&gt; .ReleaseFast,
        .safe =&gt; .ReleaseSafe,
        .small =&gt; .ReleaseSmall,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.standardTargetOptions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">standardTargetOptions</span><a href="#src.zig-std.Build.standardTargetOptions">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptions</span>(b: *<a href="std.Build.html">Build</a>, args: <a href="std.Build.StandardTargetOptionsArgs.html">StandardTargetOptionsArgs</a>) <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a></code></pre></div><div class="tldDocs"><p>Exposes standard <code>zig build</code> options for choosing a target and additionally
resolves the target query.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>args: <a href="std.Build.StandardTargetOptionsArgs.html">StandardTargetOptionsArgs</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.standardTargetOptions">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptions</span>(b: *<a href="std.Build.html">Build</a>, args: <a href="std.Build.StandardTargetOptionsArgs.html">StandardTargetOptionsArgs</a>) <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> {
    <span class="tok-kw">const</span> query = b.standardTargetOptionsQueryOnly(args);
    <span class="tok-kw">return</span> b.resolveTargetQuery(query);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.parseTargetQuery" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseTargetQuery</span><a href="#src.zig-std.Build.parseTargetQuery">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseTargetQuery</span>(options: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.ParseOptions.html">ParseOptions</a>) <span class="tok-kw">error</span>{ParseFailed}!<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a></code></pre></div><div class="tldDocs"><p>Obtain a target query from a string, reporting diagnostics to stderr if the
parsing failed.
Asserts that the <code>diagnostics</code> field of <code>options</code> is <code>null</code>. This use case
is handled instead by calling <code><a href="std.Target.Query.html#std.Target.Query.parse">std.Target.Query.parse</a></code> directly.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.ParseOptions.html">ParseOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.parseTargetQuery">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseTargetQuery</span>(options: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.ParseOptions.html">ParseOptions</a>) <span class="tok-kw">error</span>{ParseFailed}!<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(options.diagnostics == <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> diags: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.ParseOptions.html">ParseOptions</a>.<a href="std.Target.Query.ParseOptions.Diagnostics.html">Diagnostics</a> = .{};
    <span class="tok-kw">var</span> opts_copy = options;
    opts_copy.diagnostics = &amp;diags;
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.html#std.Target.Query.parse">parse</a>(opts_copy) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.UnknownCpuModel =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unknown CPU: '{s}'\navailable CPUs for architecture '{s}':\n&quot;</span>, .{
                diags.cpu_name.?, <span class="tok-builtin">@tagName</span>(diags.arch.?),
            });
            <span class="tok-kw">for</span> (diags.arch.?.allCpuModels()) |cpu| {
                <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot; {s}\n&quot;</span>, .{cpu.name});
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;
        },
        <span class="tok-kw">error</span>.UnknownCpuFeature =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(
                <span class="tok-str">\\unknown CPU feature: '{s}'</span>
                <span class="tok-str">\\available CPU features for architecture '{s}':</span>
                <span class="tok-str">\\</span>
            , .{
                diags.unknown_feature_name.?,
                <span class="tok-builtin">@tagName</span>(diags.arch.?),
            });
            <span class="tok-kw">for</span> (diags.arch.?.allFeaturesList()) |feature| {
                <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot; {s}: {s}\n&quot;</span>, .{ feature.name, feature.description });
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;
        },
        <span class="tok-kw">error</span>.UnknownOperatingSystem =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(
                <span class="tok-str">\\unknown OS: '{s}'</span>
                <span class="tok-str">\\available operating systems:</span>
                <span class="tok-str">\\</span>
            , .{diags.os_name.?});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>.<a href="std.Target.Os.Tag.html">Tag</a>)) |field| {
                <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot; {s}\n&quot;</span>, .{field.name});
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;
        },
        <span class="tok-kw">else</span> =&gt; |e| {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to parse target '{s}': {s}\n&quot;</span>, .{
                options.arch_os_abi, <span class="tok-builtin">@errorName</span>(e),
            });
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.standardTargetOptionsQueryOnly" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">standardTargetOptionsQueryOnly</span><a href="#src.zig-std.Build.standardTargetOptionsQueryOnly">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptionsQueryOnly</span>(b: *<a href="std.Build.html">Build</a>, args: <a href="std.Build.StandardTargetOptionsArgs.html">StandardTargetOptionsArgs</a>) <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a></code></pre></div><div class="tldDocs"><p>Exposes standard <code>zig build</code> options for choosing a target.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>args: <a href="std.Build.StandardTargetOptionsArgs.html">StandardTargetOptionsArgs</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.standardTargetOptionsQueryOnly">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptionsQueryOnly</span>(b: *<a href="std.Build.html">Build</a>, args: <a href="std.Build.StandardTargetOptionsArgs.html">StandardTargetOptionsArgs</a>) <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a> {
    <span class="tok-kw">const</span> maybe_triple = b.option(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;target&quot;</span>,
        <span class="tok-str">&quot;The CPU architecture, OS, and ABI to build for&quot;</span>,
    );
    <span class="tok-kw">const</span> mcpu = b.option(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;cpu&quot;</span>,
        <span class="tok-str">&quot;Target CPU features to add or subtract&quot;</span>,
    );
    <span class="tok-kw">const</span> ofmt = b.option(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;ofmt&quot;</span>,
        <span class="tok-str">&quot;Target object format&quot;</span>,
    );
    <span class="tok-kw">const</span> dynamic_linker = b.option(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;dynamic-linker&quot;</span>,
        <span class="tok-str">&quot;Path to interpreter on the target system&quot;</span>,
    );

    <span class="tok-kw">if</span> (maybe_triple == <span class="tok-null">null</span> <span class="tok-kw">and</span> mcpu == <span class="tok-null">null</span> <span class="tok-kw">and</span> ofmt == <span class="tok-null">null</span> <span class="tok-kw">and</span> dynamic_linker == <span class="tok-null">null</span>)
        <span class="tok-kw">return</span> args.default_target;

    <span class="tok-kw">const</span> triple = maybe_triple <span class="tok-kw">orelse</span> <span class="tok-str">&quot;native&quot;</span>;

    <span class="tok-kw">const</span> selected_target = <a href="std.Build.html#std.Build.parseTargetQuery">parseTargetQuery</a>(.{
        .arch_os_abi = triple,
        .cpu_features = mcpu,
        .object_format = ofmt,
        .dynamic_linker = dynamic_linker,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ParseFailed =&gt; {
            b.markInvalidUserInput();
            <span class="tok-kw">return</span> args.default_target;
        },
    };

    <span class="tok-kw">const</span> whitelist = args.whitelist <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> selected_target;<span class="tok-comment">

    // Make sure it's a match of one of the list.
    </span><span class="tok-kw">for</span> (whitelist) |q| {
        <span class="tok-kw">if</span> (q.eql(selected_target))
            <span class="tok-kw">return</span> selected_target;
    }

    <span class="tok-kw">for</span> (whitelist) |q| {
        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.info">info</a>(<span class="tok-str">&quot;allowed target: -Dtarget={s} -Dcpu={s}&quot;</span>, .{
            q.zigTriple(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
            q.serializeCpuAlloc(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
        });
    }
    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;chosen target '{s}' does not match one of the allowed targets&quot;</span>, .{
        selected_target.zigTriple(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
    });
    b.markInvalidUserInput();
    <span class="tok-kw">return</span> args.default_target;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addUserInputOption" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addUserInputOption</span><a href="#src.zig-std.Build.addUserInputOption">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputOption</span>(b: *<a href="std.Build.html">Build</a>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>value_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addUserInputOption">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputOption</span>(b: *<a href="std.Build.html">Build</a>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> name = b.dupe(name_raw);
    <span class="tok-kw">const</span> value = b.dupe(value_raw);
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> b.user_input_options.getOrPut(name);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.value_ptr.* = <a href="std.Build.UserInputOption.html">UserInputOption</a>{
            .name = name,
            .value = .{ .scalar = value },
            .used = <span class="tok-null">false</span>,
        };
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }<span class="tok-comment">

    // option already exists
    </span><span class="tok-kw">switch</span> (gop.value_ptr.value) {
        .scalar =&gt; |s| {<span class="tok-comment">
            // turn it into a list
            </span><span class="tok-kw">var</span> list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(b.allocator);
            <span class="tok-kw">try</span> list.append(s);
            <span class="tok-kw">try</span> list.append(value);
            <span class="tok-kw">try</span> b.user_input_options.put(name, .{
                .name = name,
                .value = .{ .list = list },
                .used = <span class="tok-null">false</span>,
            });
        },
        .list =&gt; |*list| {<span class="tok-comment">
            // append to the list
            </span><span class="tok-kw">try</span> list.append(value);
            <span class="tok-kw">try</span> b.user_input_options.put(name, .{
                .name = name,
                .value = .{ .list = list.* },
                .used = <span class="tok-null">false</span>,
            });
        },
        .flag =&gt; {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;option '-D{s}={s}' conflicts with flag '-D{s}'.&quot;</span>, .{ name, value, name });
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .map =&gt; |*map| {
            _ = map;
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;TODO maps as command line arguments is not implemented yet.&quot;</span>, .{});
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .lazy_path, .lazy_path_list =&gt; {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;the lazy path value type isn't added from the CLI, but somehow '{s}' is a .{}&quot;</span>, .{ name, <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.fmtId">fmtId</a>(<span class="tok-builtin">@tagName</span>(gop.value_ptr.value)) });
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addUserInputFlag" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addUserInputFlag</span><a href="#src.zig-std.Build.addUserInputFlag">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputFlag</span>(b: *<a href="std.Build.html">Build</a>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addUserInputFlag">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputFlag</span>(b: *<a href="std.Build.html">Build</a>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> name = b.dupe(name_raw);
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> b.user_input_options.getOrPut(name);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.value_ptr.* = .{
            .name = name,
            .value = .{ .flag = {} },
            .used = <span class="tok-null">false</span>,
        };
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }<span class="tok-comment">

    // option already exists
    </span><span class="tok-kw">switch</span> (gop.value_ptr.value) {
        .scalar =&gt; |s| {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Flag '-D{s}' conflicts with option '-D{s}={s}'.&quot;</span>, .{ name, name, s });
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .list, .map, .lazy_path_list =&gt; {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Flag '-D{s}' conflicts with multiple options of the same name.&quot;</span>, .{name});
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .lazy_path =&gt; |lp| {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Flag '-D{s}' conflicts with option '-D{s}={s}'.&quot;</span>, .{ name, name, lp.getDisplayName() });
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },

        .flag =&gt; {},
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.validateUserInputDidItFail" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">validateUserInputDidItFail</span><a href="#src.zig-std.Build.validateUserInputDidItFail">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validateUserInputDidItFail</span>(b: *<a href="std.Build.html">Build</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.validateUserInputDidItFail">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validateUserInputDidItFail</span>(b: *<a href="std.Build.html">Build</a>) <span class="tok-type">bool</span> {<span class="tok-comment">
    // Make sure all args are used.
    </span><span class="tok-kw">var</span> it = b.user_input_options.iterator();
    <span class="tok-kw">while</span> (it.next()) |entry| {
        <span class="tok-kw">if</span> (!entry.value_ptr.used) {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;invalid option: -D{s}&quot;</span>, .{entry.key_ptr.*});
            b.markInvalidUserInput();
        }
    }

    <span class="tok-kw">return</span> b.invalid_user_input;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.installArtifact" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installArtifact</span><a href="#src.zig-std.Build.installArtifact">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installArtifact</span>(b: *<a href="std.Build.html">Build</a>, artifact: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>This creates the install step and adds it to the dependencies of the
top-level install step, using all the default options.
See <code><a href="std.Build.html#std.Build.addInstallArtifact">addInstallArtifact</a></code> for a more flexible function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>artifact: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.installArtifact">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installArtifact</span>(b: *<a href="std.Build.html">Build</a>, artifact: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallArtifact(artifact, .{}).step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addInstallArtifact" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addInstallArtifact</span><a href="#src.zig-std.Build.addInstallArtifact">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallArtifact</span>( b: *<a href="std.Build.html">Build</a>, artifact: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a>.<a href="std.Build.Step.InstallArtifact.Options.html">Options</a>, ) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a></code></pre></div><div class="tldDocs"><p>This merely creates the step; it does not add it to the dependencies of the
top-level install step.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>artifact: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a>.<a href="std.Build.Step.InstallArtifact.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addInstallArtifact">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallArtifact</span>(
    b: *<a href="std.Build.html">Build</a>,
    artifact: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>,
    options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a>.<a href="std.Build.Step.InstallArtifact.Options.html">Options</a>,
) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a>.<a href="std.Build.Step.InstallArtifact.html#std.Build.Step.InstallArtifact.create">create</a>(b, artifact, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.installFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installFile</span><a href="#src.zig-std.Build.installFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p><code>dest_rel_path</code> is relative to prefix path</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.installFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallFileWithDir(b.path(src_path), .prefix, dest_rel_path).step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.installDirectory" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installDirectory</span><a href="#src.zig-std.Build.installDirectory">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installDirectory</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.Options.html">Options</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.installDirectory">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installDirectory</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.Options.html">Options</a>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallDirectory(options).step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.installBinFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installBinFile</span><a href="#src.zig-std.Build.installBinFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installBinFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p><code>dest_rel_path</code> is relative to bin path</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.installBinFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installBinFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallFileWithDir(b.path(src_path), .bin, dest_rel_path).step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.installLibFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">installLibFile</span><a href="#src.zig-std.Build.installLibFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installLibFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p><code>dest_rel_path</code> is relative to lib path</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.installLibFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installLibFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallFileWithDir(b.path(src_path), .lib, dest_rel_path).step);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addObjCopy" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addObjCopy</span><a href="#src.zig-std.Build.addObjCopy">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjCopy</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addObjCopy">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjCopy</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.html#std.Build.Step.ObjCopy.create">create</a>(b, source, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addInstallFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addInstallFile</span><a href="#src.zig-std.Build.addInstallFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a></code></pre></div><div class="tldDocs"><p><code>dest_rel_path</code> is relative to install prefix path</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addInstallFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> b.addInstallFileWithDir(source, .prefix, dest_rel_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addInstallBinFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addInstallBinFile</span><a href="#src.zig-std.Build.addInstallBinFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallBinFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a></code></pre></div><div class="tldDocs"><p><code>dest_rel_path</code> is relative to bin path</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addInstallBinFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallBinFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> b.addInstallFileWithDir(source, .bin, dest_rel_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addInstallLibFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addInstallLibFile</span><a href="#src.zig-std.Build.addInstallLibFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallLibFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a></code></pre></div><div class="tldDocs"><p><code>dest_rel_path</code> is relative to lib path</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addInstallLibFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallLibFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> b.addInstallFileWithDir(source, .lib, dest_rel_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addInstallHeaderFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addInstallHeaderFile</span><a href="#src.zig-std.Build.addInstallHeaderFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallHeaderFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a></code></pre></div><div class="tldDocs"><p><code>dest_rel_path</code> is relative to header path</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addInstallHeaderFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallHeaderFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> b.addInstallFileWithDir(source, .header, dest_rel_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addInstallFileWithDir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addInstallFileWithDir</span><a href="#src.zig-std.Build.addInstallFileWithDir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFileWithDir</span>( b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, install_dir: <a href="std.Build.InstallDir.html">InstallDir</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>install_dir: <a href="std.Build.InstallDir.html">InstallDir</a></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addInstallFileWithDir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFileWithDir</span>(
    b: *<a href="std.Build.html">Build</a>,
    source: <a href="std.Build.LazyPath.html">LazyPath</a>,
    install_dir: <a href="std.Build.InstallDir.html">InstallDir</a>,
    dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a>.<a href="std.Build.Step.InstallFile.html#std.Build.Step.InstallFile.create">create</a>(b, source, install_dir, dest_rel_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addInstallDirectory" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addInstallDirectory</span><a href="#src.zig-std.Build.addInstallDirectory">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallDirectory</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addInstallDirectory">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallDirectory</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.html#std.Build.Step.InstallDir.create">create</a>(b, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addCheckFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCheckFile</span><a href="#src.zig-std.Build.addCheckFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCheckFile</span>( b: *<a href="std.Build.html">Build</a>, file_source: <a href="std.Build.LazyPath.html">LazyPath</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a>.<a href="std.Build.Step.CheckFile.Options.html">Options</a>, ) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>file_source: <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a>.<a href="std.Build.Step.CheckFile.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addCheckFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCheckFile</span>(
    b: *<a href="std.Build.html">Build</a>,
    file_source: <a href="std.Build.LazyPath.html">LazyPath</a>,
    options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a>.<a href="std.Build.Step.CheckFile.Options.html">Options</a>,
) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a>.<a href="std.Build.Step.CheckFile.html#std.Build.Step.CheckFile.create">create</a>(b, file_source, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.truncateFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">truncateFile</span><a href="#src.zig-std.Build.truncateFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncateFile</span>(b: *<a href="std.Build.html">Build</a>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.truncateFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncateFile</span>(b: *<a href="std.Build.html">Build</a>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (b.verbose) {
        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.info">info</a>(<span class="tok-str">&quot;truncate {s}&quot;</span>, .{dest_path});
    }
    <span class="tok-kw">const</span> cwd = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>();
    <span class="tok-kw">var</span> src_file = cwd.createFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound =&gt; blk: {
            <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(dest_path)) |dirname| {
                <span class="tok-kw">try</span> cwd.makePath(dirname);
            }
            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> cwd.createFile(dest_path, .{});
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    src_file.close();
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.path" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">path</span><a href="#src.zig-std.Build.path">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">path</span>(b: *<a href="std.Build.html">Build</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>References a file or directory relative to the source root.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.path">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">path</span>(b: *<a href="std.Build.html">Build</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(sub_path)) {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;sub_path is expected to be relative to the build root, but was this absolute path: '{s}'. It is best avoid absolute paths, but if you must, it is supported by LazyPath.cwd_relative&quot;</span>, .{
            sub_path,
        });
    }
    <span class="tok-kw">return</span> .{ .src_path = .{
        .owner = b,
        .sub_path = sub_path,
    } };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.pathFromRoot" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pathFromRoot</span><a href="#src.zig-std.Build.pathFromRoot">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathFromRoot</span>(b: *<a href="std.Build.html">Build</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>This is low-level implementation details of the build system, not meant to
be called by users' build scripts. Even in the build system itself it is a
code smell to call this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.pathFromRoot">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathFromRoot</span>(b: *<a href="std.Build.html">Build</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> b.pathResolve(&amp;.{ b.build_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>, sub_path });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.pathJoin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pathJoin</span><a href="#src.zig-std.Build.pathJoin">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathJoin</span>(b: *<a href="std.Build.html">Build</a>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.pathJoin">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathJoin</span>(b: *<a href="std.Build.html">Build</a>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(b.allocator, paths) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.pathResolve" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pathResolve</span><a href="#src.zig-std.Build.pathResolve">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathResolve</span>(b: *<a href="std.Build.html">Build</a>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.pathResolve">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathResolve</span>(b: *<a href="std.Build.html">Build</a>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(b.allocator, paths) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.fmt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fmt</span><a href="#src.zig-std.Build.fmt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) []<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.fmt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(b.allocator, format, args) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.findProgram" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">findProgram</span><a href="#src.zig-std.Build.findProgram">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findProgram</span>(b: *<a href="std.Build.html">Build</a>, names: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{FileNotFound}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>names: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.findProgram">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findProgram</span>(b: *<a href="std.Build.html">Build</a>, names: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{FileNotFound}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {<span class="tok-comment">
    // TODO report error for ambiguous situations
    </span><span class="tok-kw">for</span> (b.search_prefixes.items) |search_prefix| {
        <span class="tok-kw">for</span> (names) |name| {
            <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(name)) {
                <span class="tok-kw">return</span> name;
            }
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.tryFindProgram">tryFindProgram</a>(b, b.pathJoin(&amp;.{ search_prefix, <span class="tok-str">&quot;bin&quot;</span>, name })) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        }
    }
    <span class="tok-kw">if</span> (b.graph.env_map.get(<span class="tok-str">&quot;PATH&quot;</span>)) |PATH| {
        <span class="tok-kw">for</span> (names) |name| {
            <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(name)) {
                <span class="tok-kw">return</span> name;
            }
            <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, PATH, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.delimiter">delimiter</a>);
            <span class="tok-kw">while</span> (it.next()) |p| {
                <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.tryFindProgram">tryFindProgram</a>(b, b.pathJoin(&amp;.{ p, name })) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            }
        }
    }
    <span class="tok-kw">for</span> (names) |name| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(name)) {
            <span class="tok-kw">return</span> name;
        }
        <span class="tok-kw">for</span> (paths) |p| {
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.tryFindProgram">tryFindProgram</a>(b, b.pathJoin(&amp;.{ p, name })) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.runAllowFail" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">runAllowFail</span><a href="#src.zig-std.Build.runAllowFail">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runAllowFail</span>( b: *<a href="std.Build.html">Build</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_code: *<span class="tok-type">u8</span>, stderr_behavior: <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.StdIo.html">StdIo</a>, ) <a href="std.Build.html#std.Build.RunError">RunError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>out_code: *<span class="tok-type">u8</span></code></pre></div><div><pre><code>stderr_behavior: <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.StdIo.html">StdIo</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.runAllowFail">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runAllowFail</span>(
    b: *<a href="std.Build.html">Build</a>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    out_code: *<span class="tok-type">u8</span>,
    stderr_behavior: <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.StdIo.html">StdIo</a>,
) <a href="std.Build.html#std.Build.RunError">RunError</a>![]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(argv.len != <span class="tok-number">0</span>);

    <span class="tok-kw">if</span> (!<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a>)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExecNotSupported;

    <span class="tok-kw">const</span> max_output_size = <span class="tok-number">400</span> * <span class="tok-number">1024</span>;
    <span class="tok-kw">var</span> child = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.html#std.process.Child.init">init</a>(argv, b.allocator);
    child.stdin_behavior = .Ignore;
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = stderr_behavior;
    child.env_map = &amp;b.graph.env_map;

    <span class="tok-kw">try</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.handleVerbose2">handleVerbose2</a>(b, <span class="tok-null">null</span>, child.env_map, argv);
    <span class="tok-kw">try</span> child.spawn();

    <span class="tok-kw">const</span> stdout = child.stdout.?.reader().readAllAlloc(b.allocator, max_output_size) <span class="tok-kw">catch</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadFailure;
    };
    <span class="tok-kw">errdefer</span> b.allocator.free(stdout);

    <span class="tok-kw">const</span> term = <span class="tok-kw">try</span> child.wait();
    <span class="tok-kw">switch</span> (term) {
        .Exited =&gt; |code| {
            <span class="tok-kw">if</span> (code != <span class="tok-number">0</span>) {
                out_code.* = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(code));
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExitCodeFailure;
            }
            <span class="tok-kw">return</span> stdout;
        },
        .Signal, .Stopped, .Unknown =&gt; |code| {
            out_code.* = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(code));
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessTerminated;
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.run" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">run</span><a href="#src.zig-std.Build.run">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(b: *<a href="std.Build.html">Build</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>This is a helper function to be called from build.zig scripts, <em>not</em> from
inside step make() functions. If any errors occur, it fails the build with
a helpful message.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.run">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(b: *<a href="std.Build.html">Build</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (!<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a>) {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to spawn the following command: cannot spawn child process\n{s}\n&quot;</span>, .{
            <span class="tok-kw">try</span> <a href="std.Build.html#std.Build.allocPrintCmd">allocPrintCmd</a>(b.allocator, <span class="tok-null">null</span>, argv),
        });
        <a href="std.process.html">process</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
    }

    <span class="tok-kw">var</span> code: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> b.runAllowFail(argv, &amp;code, .Inherit) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">const</span> printed_cmd = <a href="std.Build.html#std.Build.allocPrintCmd">allocPrintCmd</a>(b.allocator, <span class="tok-null">null</span>, argv) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to spawn the following command: {s}\n{s}\n&quot;</span>, .{
            <span class="tok-builtin">@errorName</span>(err), printed_cmd,
        });
        <a href="std.process.html">process</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.addSearchPrefix" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addSearchPrefix</span><a href="#src.zig-std.Build.addSearchPrefix">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSearchPrefix</span>(b: *<a href="std.Build.html">Build</a>, search_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>search_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.addSearchPrefix">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSearchPrefix</span>(b: *<a href="std.Build.html">Build</a>, search_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.search_prefixes.append(b.allocator, b.dupePath(search_prefix)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.getInstallPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getInstallPath</span><a href="#src.zig-std.Build.getInstallPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallPath</span>(b: *<a href="std.Build.html">Build</a>, dir: <a href="std.Build.InstallDir.html">InstallDir</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>dir: <a href="std.Build.InstallDir.html">InstallDir</a></code></pre></div><div><pre><code>dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.getInstallPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallPath</span>(b: *<a href="std.Build.html">Build</a>, dir: <a href="std.Build.InstallDir.html">InstallDir</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dest_rel_path));<span class="tok-comment"> // Install paths must be relative to the prefix
    </span><span class="tok-kw">const</span> base_dir = <span class="tok-kw">switch</span> (dir) {
        .prefix =&gt; b.install_path,
        .bin =&gt; b.exe_dir,
        .lib =&gt; b.lib_dir,
        .header =&gt; b.h_dir,
        .custom =&gt; |p| b.pathJoin(&amp;.{ b.install_path, p }),
    };
    <span class="tok-kw">return</span> b.pathResolve(&amp;.{ base_dir, dest_rel_path });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.lazyDependency" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lazyDependency</span><a href="#src.zig-std.Build.lazyDependency">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lazyDependency</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) ?*<a href="std.Build.Dependency.html">Dependency</a></code></pre></div><div class="tldDocs"><p>When this function is called, it means that the current build does, in
fact, require this dependency. If the dependency is already fetched, it
proceeds in the same manner as <code><a href="std.Build.html#std.Build.dependency">dependency</a></code>. However if the dependency was
not fetched, then when the build script is finished running, the build will
not proceed to the make phase. Instead, the parent process will
additionally fetch all the lazy dependencies that were actually required by
running the build script, rebuild the build script, and then run it again.
In other words, if this function returns <code>null</code> it means that the only
purpose of completing the configure phase is to find out all the other lazy
dependencies that are also required.
It is allowed to use this function for non-lazy dependencies, in which case
it will never return <code>null</code>. This allows toggling laziness via
build.zig.zon without changing build.zig logic.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.lazyDependency">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lazyDependency</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) ?*<a href="std.Build.Dependency.html">Dependency</a> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;
    <span class="tok-kw">const</span> pkg_hash = <a href="std.Build.html#std.Build.findPkgHashOrFatal">findPkgHashOrFatal</a>(b, name);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {
            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);
            <span class="tok-kw">const</span> available = !<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;available&quot;</span>) <span class="tok-kw">or</span> pkg.available;
            <span class="tok-kw">if</span> (!available) {
                <a href="std.Build.html#std.Build.markNeededLazyDep">markNeededLazyDep</a>(b, pkg_hash);
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dependencyInner">dependencyInner</a>(b, name, pkg.build_root, <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>)) pkg.build_zig <span class="tok-kw">else</span> <span class="tok-null">null</span>, pkg_hash, pkg.deps, args);
        }
    }

    <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // Bad @dependencies source
</span>}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.dependency" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dependency</span><a href="#src.zig-std.Build.dependency">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependency</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) *<a href="std.Build.Dependency.html">Dependency</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.dependency">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependency</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) *<a href="std.Build.Dependency.html">Dependency</a> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;
    <span class="tok-kw">const</span> pkg_hash = <a href="std.Build.html#std.Build.findPkgHashOrFatal">findPkgHashOrFatal</a>(b, name);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {
            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;available&quot;</span>)) {
                <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;dependency '{s}{s}' is marked as lazy in build.zig.zon which means it must use the lazyDependency function instead&quot;</span>, .{ b.dep_prefix, name });
            }
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dependencyInner">dependencyInner</a>(b, name, pkg.build_root, <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>)) pkg.build_zig <span class="tok-kw">else</span> <span class="tok-null">null</span>, pkg_hash, pkg.deps, args);
        }
    }

    <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // Bad @dependencies source
</span>}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.lazyImport" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lazyImport</span><a href="#src.zig-std.Build.lazyImport">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">lazyImport</span>( b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> asking_build_zig: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) ?<span class="tok-type">type</span></code></pre></div><div class="tldDocs"><p>In a build.zig file, this function is to <code>@import</code> what <code><a href="std.Build.html#std.Build.lazyDependency">lazyDependency</a></code> is to <code><a href="std.Build.html#std.Build.dependency">dependency</a></code>.
If the dependency is lazy and has not yet been fetched, it instructs the parent process to fetch
that dependency after the build script has finished running, then returns <code>null</code>.
If the dependency is lazy but has already been fetched, or if it is eager, it returns
the build.zig struct of that dependency, just like a regular <code>@import</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>asking_build_zig: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>The build.zig struct of the package importing the dependency.
When calling this function from the <code>build</code> function of a build.zig file's, you normally
pass <code>@This()</code>.</p>
</div></div><div><pre><code>dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.lazyImport">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">lazyImport</span>(
    b: *<a href="std.Build.html">Build</a>,
    <span class="tok-comment">/// The build.zig struct of the package importing the dependency.</span>
    <span class="tok-comment">/// When calling this function from the `build` function of a build.zig file's, you normally</span>
    <span class="tok-comment">/// pass `@This()`.</span>
    <span class="tok-kw">comptime</span> asking_build_zig: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) ?<span class="tok-type">type</span> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;
    <span class="tok-kw">const</span> pkg_hash = <a href="std.Build.html#std.Build.findImportPkgHashOrFatal">findImportPkgHashOrFatal</a>(b, asking_build_zig, dep_name);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {
            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);
            <span class="tok-kw">const</span> available = !<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;available&quot;</span>) <span class="tok-kw">or</span> pkg.available;
            <span class="tok-kw">if</span> (!available) {
                <a href="std.Build.html#std.Build.markNeededLazyDep">markNeededLazyDep</a>(b, pkg_hash);
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>))
                pkg.build_zig
            <span class="tok-kw">else</span>
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;dependency '&quot;</span> ++ dep_name ++ <span class="tok-str">&quot;' does not have a build.zig&quot;</span>);
        }
    }

    <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // Bad @dependencies source
</span>}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.dependencyFromBuildZig" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dependencyFromBuildZig</span><a href="#src.zig-std.Build.dependencyFromBuildZig">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependencyFromBuildZig</span>( b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> build_zig: <span class="tok-type">type</span>, args: <span class="tok-kw">anytype</span>, ) *<a href="std.Build.Dependency.html">Dependency</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>build_zig: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>The build.zig struct of the dependency, normally obtained by <code>@import</code> of the dependency.
If called from the build.zig file itself, use <code>@This</code> to obtain a reference to the struct.</p>
</div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.dependencyFromBuildZig">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependencyFromBuildZig</span>(
    b: *<a href="std.Build.html">Build</a>,
    <span class="tok-comment">/// The build.zig struct of the dependency, normally obtained by `@import` of the dependency.</span>
    <span class="tok-comment">/// If called from the build.zig file itself, use `@This` to obtain a reference to the struct.</span>
    <span class="tok-kw">comptime</span> build_zig: <span class="tok-type">type</span>,
    args: <span class="tok-kw">anytype</span>,
) *<a href="std.Build.Dependency.html">Dependency</a> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;

    find_dep: {
        <span class="tok-kw">const</span> pkg, <span class="tok-kw">const</span> pkg_hash = <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
            <span class="tok-kw">const</span> pkg_hash = decl.name;
            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, pkg_hash);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>) <span class="tok-kw">and</span> pkg.build_zig == build_zig) <span class="tok-kw">break</span> .{ pkg, pkg_hash };
        } <span class="tok-kw">else</span> <span class="tok-kw">break</span> :find_dep;
        <span class="tok-kw">const</span> dep_name = <span class="tok-kw">for</span> (b.available_deps) |dep| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, dep[<span class="tok-number">1</span>], pkg_hash)) <span class="tok-kw">break</span> dep[<span class="tok-number">1</span>];
        } <span class="tok-kw">else</span> <span class="tok-kw">break</span> :find_dep;
        <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dependencyInner">dependencyInner</a>(b, dep_name, pkg.build_root, pkg.build_zig, pkg_hash, pkg.deps, args);
    }

    <span class="tok-kw">const</span> full_path = b.pathFromRoot(<span class="tok-str">&quot;build.zig.zon&quot;</span>);
    <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;'{}' is not a build.zig struct of a dependency in '{s}'&quot;</span>, .{ build_zig, full_path });
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.runBuild" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">runBuild</span><a href="#src.zig-std.Build.runBuild">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runBuild</span>(b: *<a href="std.Build.html">Build</a>, build_zig: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.runBuild">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runBuild</span>(b: *<a href="std.Build.html">Build</a>, build_zig: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(build_zig.build)).@&quot;fn&quot;.return_type.?)) {
        .<span class="tok-type">void</span> =&gt; build_zig.build(b),
        .error_union =&gt; <span class="tok-kw">try</span> build_zig.build(b),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected return type of build to be 'void' or '!void'&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.dumpBadGetPathHelp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dumpBadGetPathHelp</span><a href="#src.zig-std.Build.dumpBadGetPathHelp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpBadGetPathHelp</span>( s: *<a href="std.Build.Step.html">Step</a>, stderr: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, src_builder: *<a href="std.Build.html">Build</a>, asking_step: ?*<a href="std.Build.Step.html">Step</a>, ) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>In this function the stderr mutex has already been locked.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>s: *<a href="std.Build.Step.html">Step</a></code></pre></div><div><pre><code>stderr: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>src_builder: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>asking_step: ?*<a href="std.Build.Step.html">Step</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.dumpBadGetPathHelp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpBadGetPathHelp</span>(
    s: *<a href="std.Build.Step.html">Step</a>,
    stderr: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,
    src_builder: *<a href="std.Build.html">Build</a>,
    asking_step: ?*<a href="std.Build.Step.html">Step</a>,
) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> w = stderr.writer();
    <span class="tok-kw">try</span> w.print(
        <span class="tok-str">\\getPath() was called on a GeneratedFile that wasn't built yet.</span>
        <span class="tok-str">\\  source package path: {s}</span>
        <span class="tok-str">\\  Is there a missing Step dependency on step '{s}'?</span>
        <span class="tok-str">\\</span>
    , .{
        src_builder.build_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>,
        s.name,
    });

    <span class="tok-kw">const</span> tty_config = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(stderr);
    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    The step was created by this stack trace:\n&quot;</span>);
    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};

    s.dump(stderr);
    <span class="tok-kw">if</span> (asking_step) |as| {
        tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
        <span class="tok-kw">try</span> stderr.writer().print(<span class="tok-str">&quot;    The step '{s}' that is missing a dependency on the above step was created by this stack trace:\n&quot;</span>, .{as.name});
        tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};

        as.dump(stderr);
    }
    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    Hope that helps. Proceeding to panic.\n&quot;</span>);
    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.makeTempPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">makeTempPath</span><a href="#src.zig-std.Build.makeTempPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeTempPath</span>(b: *<a href="std.Build.html">Build</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>This function is intended to be called in the <code>configure</code> phase only.
It returns an absolute directory path, which is potentially going to be a
source of API breakage in the future, so keep that in mind when using this
function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.makeTempPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeTempPath</span>(b: *<a href="std.Build.html">Build</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> rand_int = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">int</a>(<span class="tok-type">u64</span>);
    <span class="tok-kw">const</span> tmp_dir_sub_path = <span class="tok-str">&quot;tmp&quot;</span> ++ <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep_str">sep_str</a> ++ <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.hex">hex</a>(rand_int);
    <span class="tok-kw">const</span> result_path = b.cache_root.join(b.allocator, &amp;.{tmp_dir_sub_path}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    b.cache_root.handle.makePath(tmp_dir_sub_path) <span class="tok-kw">catch</span> |err| {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to make tmp path '{s}': {s}\n&quot;</span>, .{
            result_path, <span class="tok-builtin">@errorName</span>(err),
        });
    };
    <span class="tok-kw">return</span> result_path;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.hex64" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hex64</span><a href="#src.zig-std.Build.hex64">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hex64</span>(x: <span class="tok-type">u64</span>) [<span class="tok-number">16</span>]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Deprecated; use <code><a href="std.fmt.html#std.fmt.hex">std.fmt.hex</a></code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>x: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.hex64">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hex64</span>(x: <span class="tok-type">u64</span>) [<span class="tok-number">16</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.hex">hex</a>(x);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.resolveTargetQuery" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resolveTargetQuery</span><a href="#src.zig-std.Build.resolveTargetQuery">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveTargetQuery</span>(b: *<a href="std.Build.html">Build</a>, query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>) <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a></code></pre></div><div class="tldDocs"><p>Converts a target query into a fully resolved target that can be passed to
various parts of the API.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.resolveTargetQuery">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveTargetQuery</span>(b: *<a href="std.Build.html">Build</a>, query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>) <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> {
    <span class="tok-kw">if</span> (query.isNative()) {<span class="tok-comment">
        // Hot path. This is faster than querying the native CPU and OS again.
        </span><span class="tok-kw">return</span> b.graph.host;
    }
    <span class="tok-kw">return</span> .{
        .query = query,
        .result = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.system.html">system</a>.<a href="std.zig.system.html#std.zig.system.resolveTargetQuery">resolveTargetQuery</a>(query) <span class="tok-kw">catch</span>
            <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unable to resolve target query&quot;</span>),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.wantSharedLibSymLinks" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">wantSharedLibSymLinks</span><a href="#src.zig-std.Build.wantSharedLibSymLinks">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wantSharedLibSymLinks</span>(target: <a href="std.Target.html">Target</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>target: <a href="std.Target.html">Target</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.wantSharedLibSymLinks">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wantSharedLibSymLinks</span>(target: <a href="std.Target.html">Target</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> target.os.tag != .windows;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.systemIntegrationOption" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">systemIntegrationOption</span><a href="#src.zig-std.Build.systemIntegrationOption">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">systemIntegrationOption</span>( b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, config: <a href="std.Build.SystemIntegrationOptionConfig.html">SystemIntegrationOptionConfig</a>, ) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>b: *<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>config: <a href="std.Build.SystemIntegrationOptionConfig.html">SystemIntegrationOptionConfig</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.systemIntegrationOption">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">systemIntegrationOption</span>(
    b: *<a href="std.Build.html">Build</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    config: <a href="std.Build.SystemIntegrationOptionConfig.html">SystemIntegrationOptionConfig</a>,
) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> gop = b.graph.system_library_options.getOrPut(b.allocator, name) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">if</span> (gop.found_existing) <span class="tok-kw">switch</span> (gop.value_ptr.*) {
        .user_disabled =&gt; {
            gop.value_ptr.* = .declared_disabled;
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
        .user_enabled =&gt; {
            gop.value_ptr.* = .declared_enabled;
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .declared_disabled =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
        .declared_enabled =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
    } <span class="tok-kw">else</span> {
        gop.key_ptr.* = b.dupe(name);
        <span class="tok-kw">if</span> (config.default <span class="tok-kw">orelse</span> b.graph.system_package_mode) {
            gop.value_ptr.* = .declared_enabled;
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        } <span class="tok-kw">else</span> {
            gop.value_ptr.* = .declared_disabled;
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Build">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> io = <a href="std.html">std</a>.<a href="std.io.html">io</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> debug = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>;
<span class="tok-kw">const</span> panic = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>;
<span class="tok-kw">const</span> assert = <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> log = <a href="std.html">std</a>.<a href="std.log.html">log</a>;
<span class="tok-kw">const</span> ArrayList = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>;
<span class="tok-kw">const</span> StringHashMap = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> Target = <a href="std.html">std</a>.<a href="std.Target.html">Target</a>;
<span class="tok-kw">const</span> process = <a href="std.html">std</a>.<a href="std.process.html">process</a>;
<span class="tok-kw">const</span> EnvMap = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.EnvMap.html">EnvMap</a>;
<span class="tok-kw">const</span> File = <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>;
<span class="tok-kw">const</span> Sha256 = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.hash.html">hash</a>.<a href="std.crypto.sha2.html">sha2</a>.<a href="std.crypto.sha2.html#std.crypto.sha2.Sha256">Sha256</a>;
<span class="tok-kw">const</span> Build = <span class="tok-builtin">@This</span>();

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cache = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Cache.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Step = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Module = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Module.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Watch = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Watch.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fuzz = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Fuzz.zig&quot;</span>);

<span class="tok-comment">/// Shared state among all Build instances.</span>
graph: *<a href="std.Build.Graph.html">Graph</a>,
install_tls: <a href="std.Build.TopLevelStep.html">TopLevelStep</a>,
uninstall_tls: <a href="std.Build.TopLevelStep.html">TopLevelStep</a>,
allocator: <a href="std.mem.Allocator.html">Allocator</a>,
user_input_options: <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a>,
available_options_map: <a href="std.Build.html#std.Build.AvailableOptionsMap">AvailableOptionsMap</a>,
available_options_list: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.AvailableOption.html">AvailableOption</a>),
verbose: <span class="tok-type">bool</span>,
verbose_link: <span class="tok-type">bool</span>,
verbose_cc: <span class="tok-type">bool</span>,
verbose_air: <span class="tok-type">bool</span>,
verbose_llvm_ir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
verbose_llvm_bc: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
verbose_cimport: <span class="tok-type">bool</span>,
verbose_llvm_cpu_features: <span class="tok-type">bool</span>,
reference_trace: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>,
invalid_user_input: <span class="tok-type">bool</span>,
default_step: *<a href="std.Build.Step.html">Step</a>,
top_level_steps: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(*<a href="std.Build.TopLevelStep.html">TopLevelStep</a>),
install_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
dest_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
lib_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
exe_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
h_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
install_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
sysroot: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
search_prefixes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),
libc_file: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
<span class="tok-comment">/// Path to the directory containing build.zig.</span>
build_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
cache_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
pkg_config_pkg_list: ?(<a href="std.Build.html#std.Build.PkgConfigError">PkgConfigError</a>![]<span class="tok-kw">const</span> <a href="std.Build.PkgConfigPkg.html">PkgConfigPkg</a>) = <span class="tok-null">null</span>,
args: ?[]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
debug_log_scopes: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},
debug_compile_errors: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
debug_pkg_config: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// Number of stack frames captured when a `StackTrace` is recorded for debug purposes,</span>
<span class="tok-comment">/// in particular at `Step` creation.</span>
<span class="tok-comment">/// Set to 0 to disable stack collection.</span>
debug_stack_frames_count: <span class="tok-type">u8</span> = <span class="tok-number">8</span>,

<span class="tok-comment">/// Experimental. Use system Darling installation to run cross compiled macOS build artifacts.</span>
enable_darling: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// Use system QEMU installation to run cross compiled foreign architecture build artifacts.</span>
enable_qemu: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// Darwin. Use Rosetta to run x86_64 macOS build artifacts on arm64 macOS.</span>
enable_rosetta: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// Use system Wasmtime installation to run cross compiled wasm/wasi build artifacts.</span>
enable_wasmtime: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// Use system Wine installation to run cross compiled Windows build artifacts.</span>
enable_wine: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
<span class="tok-comment">/// After following the steps in https://github.com/ziglang/zig/wiki/Updating-libc#glibc,</span>
<span class="tok-comment">/// this will be the directory $glibc-build-dir/install/glibcs</span>
<span class="tok-comment">/// Given the example of the aarch64 target, this is the directory</span>
<span class="tok-comment">/// that contains the path `aarch64-linux-gnu/lib/ld-linux-aarch64.so.1`.</span>
glibc_runtimes_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

dep_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,

modules: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMap">StringArrayHashMap</a>(*<a href="std.Build.Module.html">Module</a>),

named_writefiles: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMap">StringArrayHashMap</a>(*<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a>),
named_lazy_paths: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMap">StringArrayHashMap</a>(<a href="std.Build.LazyPath.html">LazyPath</a>),
<span class="tok-comment">/// The hash of this instance's package. `&quot;&quot;` means that this is the root package.</span>
pkg_hash: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
<span class="tok-comment">/// A mapping from dependency names to package hashes.</span>
available_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a>,

release_mode: <a href="std.Build.ReleaseMode.html">ReleaseMode</a>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReleaseMode = <span class="tok-kw">enum</span> {
    off,
    any,
    fast,
    safe,
    small,
};

<span class="tok-comment">/// Shared state among all Build instances.</span>
<span class="tok-comment">/// Settings that are here rather than in Build are not configurable per-package.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Graph = <span class="tok-kw">struct</span> {
    arena: <a href="std.mem.Allocator.html">Allocator</a>,
    system_library_options: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(<a href="std.Build.SystemLibraryMode.html">SystemLibraryMode</a>) = .empty,
    system_package_mode: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    debug_compiler_runtime_libs: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    cache: <a href="std.Build.Cache.html">Cache</a>,
    zig_exe: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    env_map: <a href="std.process.EnvMap.html">EnvMap</a>,
    global_cache_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
    zig_lib_directory: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
    needed_lazy_dependencies: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.StringArrayHashMapUnmanaged">StringArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>) = .empty,
    <span class="tok-comment">/// Information about the native target. Computed before build() is invoked.</span>
    host: <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a>,
    incremental: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    random_seed: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
    dependency_cache: <a href="std.Build.html#std.Build.InitializedDepMap">InitializedDepMap</a> = .empty,
    allow_so_scripts: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
};

<span class="tok-kw">const</span> AvailableDeps = []<span class="tok-kw">const</span> <span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };

<span class="tok-kw">const</span> SystemLibraryMode = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// User asked for the library to be disabled.</span>
    <span class="tok-comment">/// The build runner has not confirmed whether the setting is recognized yet.</span>
    user_disabled,
    <span class="tok-comment">/// User asked for the library to be enabled.</span>
    <span class="tok-comment">/// The build runner has not confirmed whether the setting is recognized yet.</span>
    user_enabled,
    <span class="tok-comment">/// The build runner has confirmed that this setting is recognized.</span>
    <span class="tok-comment">/// System integration with this library has been resolved to off.</span>
    declared_disabled,
    <span class="tok-comment">/// The build runner has confirmed that this setting is recognized.</span>
    <span class="tok-comment">/// System integration with this library has been resolved to on.</span>
    declared_enabled,
};

<span class="tok-kw">const</span> InitializedDepMap = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.HashMapUnmanaged">HashMapUnmanaged</a>(<a href="std.Build.InitializedDepKey.html">InitializedDepKey</a>, *<a href="std.Build.Dependency.html">Dependency</a>, <a href="std.Build.InitializedDepContext.html">InitializedDepContext</a>, <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>);
<span class="tok-kw">const</span> InitializedDepKey = <span class="tok-kw">struct</span> {
    build_root_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    user_input_options: <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a>,
};

<span class="tok-kw">const</span> InitializedDepContext = <span class="tok-kw">struct</span> {
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: <span class="tok-builtin">@This</span>(), k: <a href="std.Build.InitializedDepKey.html">InitializedDepKey</a>) <span class="tok-type">u64</span> {
        <span class="tok-kw">var</span> hasher = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
        hasher.update(k.build_root_string);
        <a href="std.Build.html#std.Build.hashUserInputOptionsMap">hashUserInputOptionsMap</a>(ctx.allocator, k.user_input_options, &amp;hasher);
        <span class="tok-kw">return</span> hasher.final();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(_: <span class="tok-builtin">@This</span>(), lhs: <a href="std.Build.InitializedDepKey.html">InitializedDepKey</a>, rhs: <a href="std.Build.InitializedDepKey.html">InitializedDepKey</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs.build_root_string, rhs.build_root_string))
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;

        <span class="tok-kw">if</span> (lhs.user_input_options.count() != rhs.user_input_options.count())
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;

        <span class="tok-kw">var</span> it = lhs.user_input_options.iterator();
        <span class="tok-kw">while</span> (it.next()) |lhs_entry| {
            <span class="tok-kw">const</span> rhs_value = rhs.user_input_options.get(lhs_entry.key_ptr.*) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">if</span> (!<a href="std.Build.html#std.Build.userValuesAreSame">userValuesAreSame</a>(lhs_entry.value_ptr.*.value, rhs_value.value))
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }

        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RunError = <span class="tok-kw">error</span>{
    ReadFailure,
    ExitCodeFailure,
    ProcessTerminated,
    ExecNotSupported,
} || <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.html#std.process.Child.SpawnError">SpawnError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PkgConfigError = <span class="tok-kw">error</span>{
    PkgConfigCrashed,
    PkgConfigFailed,
    PkgConfigNotInstalled,
    PkgConfigInvalidOutput,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PkgConfigPkg = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    desc: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">const</span> UserInputOptionsMap = <a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<a href="std.Build.UserInputOption.html">UserInputOption</a>);
<span class="tok-kw">const</span> AvailableOptionsMap = <a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<a href="std.Build.AvailableOption.html">AvailableOption</a>);

<span class="tok-kw">const</span> AvailableOption = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    type_id: <a href="std.Build.TypeId.html">TypeId</a>,
    description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    <span class="tok-comment">/// If the `type_id` is `enum` or `enum_list` this provides the list of enum options</span>
    enum_options: ?[]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">const</span> UserInputOption = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    value: <a href="std.Build.UserValue.html">UserValue</a>,
    used: <span class="tok-type">bool</span>,
};

<span class="tok-kw">const</span> UserValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    flag: <span class="tok-type">void</span>,
    scalar: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    list: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),
    map: <a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(*<span class="tok-kw">const</span> <a href="std.Build.UserValue.html">UserValue</a>),
    lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>,
    lazy_path_list: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.LazyPath.html">LazyPath</a>),
};

<span class="tok-kw">const</span> TypeId = <span class="tok-kw">enum</span> {
    <span class="tok-type">bool</span>,
    int,
    float,
    @&quot;enum&quot;,
    enum_list,
    string,
    list,
    build_id,
    lazy_path,
    lazy_path_list,
};

<span class="tok-kw">const</span> TopLevelStep = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Id.html">Id</a> = .top_level;

    step: <a href="std.Build.Step.html">Step</a>,
    description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DirList = <span class="tok-kw">struct</span> {
    lib_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    exe_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    include_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(
    graph: *<a href="std.Build.Graph.html">Graph</a>,
    build_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
    cache_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
    available_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a>,
) <span class="tok-kw">error</span>{OutOfMemory}!*<a href="std.Build.html">Build</a> {
    <span class="tok-kw">const</span> arena = graph.arena;

    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> arena.create(<a href="std.Build.html">Build</a>);
    b.* = .{
        .graph = graph,
        .build_root = build_root,
        .cache_root = cache_root,
        .verbose = <span class="tok-null">false</span>,
        .verbose_link = <span class="tok-null">false</span>,
        .verbose_cc = <span class="tok-null">false</span>,
        .verbose_air = <span class="tok-null">false</span>,
        .verbose_llvm_ir = <span class="tok-null">null</span>,
        .verbose_llvm_bc = <span class="tok-null">null</span>,
        .verbose_cimport = <span class="tok-null">false</span>,
        .verbose_llvm_cpu_features = <span class="tok-null">false</span>,
        .invalid_user_input = <span class="tok-null">false</span>,
        .allocator = arena,
        .user_input_options = <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a>.<a href="#">init</a>(arena),
        .available_options_map = <a href="std.Build.html#std.Build.AvailableOptionsMap">AvailableOptionsMap</a>.<a href="#">init</a>(arena),
        .available_options_list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.AvailableOption.html">AvailableOption</a>).init(arena),
        .top_level_steps = .{},
        .default_step = <span class="tok-null">undefined</span>,
        .search_prefixes = .{},
        .install_prefix = <span class="tok-null">undefined</span>,
        .lib_dir = <span class="tok-null">undefined</span>,
        .exe_dir = <span class="tok-null">undefined</span>,
        .h_dir = <span class="tok-null">undefined</span>,
        .dest_dir = graph.env_map.get(<span class="tok-str">&quot;DESTDIR&quot;</span>),
        .install_tls = .{
            .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
                .id = <a href="std.Build.TopLevelStep.html">TopLevelStep</a>.<a href="std.Build.TopLevelStep.html#std.Build.TopLevelStep.base_id">base_id</a>,
                .name = <span class="tok-str">&quot;install&quot;</span>,
                .owner = b,
            }),
            .description = <span class="tok-str">&quot;Copy build artifacts to prefix path&quot;</span>,
        },
        .uninstall_tls = .{
            .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
                .id = <a href="std.Build.TopLevelStep.html">TopLevelStep</a>.<a href="std.Build.TopLevelStep.html#std.Build.TopLevelStep.base_id">base_id</a>,
                .name = <span class="tok-str">&quot;uninstall&quot;</span>,
                .owner = b,
                .makeFn = <a href="std.Build.html#std.Build.makeUninstall">makeUninstall</a>,
            }),
            .description = <span class="tok-str">&quot;Remove build artifacts from prefix path&quot;</span>,
        },
        .install_path = <span class="tok-null">undefined</span>,
        .args = <span class="tok-null">null</span>,
        .modules = .init(arena),
        .named_writefiles = .init(arena),
        .named_lazy_paths = .init(arena),
        .pkg_hash = <span class="tok-str">&quot;&quot;</span>,
        .available_deps = available_deps,
        .release_mode = .off,
    };
    <span class="tok-kw">try</span> b.top_level_steps.put(arena, b.install_tls.step.name, &amp;b.install_tls);
    <span class="tok-kw">try</span> b.top_level_steps.put(arena, b.uninstall_tls.step.name, &amp;b.uninstall_tls);
    b.default_step = &amp;b.install_tls.step;
    <span class="tok-kw">return</span> b;
}

<span class="tok-kw">fn</span> <span class="tok-fn">createChild</span>(
    parent: *<a href="std.Build.html">Build</a>,
    dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    build_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
    pkg_hash: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    pkg_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a>,
    user_input_options: <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a>,
) <span class="tok-kw">error</span>{OutOfMemory}!*<a href="std.Build.html">Build</a> {
    <span class="tok-kw">const</span> child = <span class="tok-kw">try</span> <a href="std.Build.html#std.Build.createChildOnly">createChildOnly</a>(parent, dep_name, build_root, pkg_hash, pkg_deps, user_input_options);
    <span class="tok-kw">try</span> <a href="std.Build.html#std.Build.determineAndApplyInstallPrefix">determineAndApplyInstallPrefix</a>(child);
    <span class="tok-kw">return</span> child;
}

<span class="tok-kw">fn</span> <span class="tok-fn">createChildOnly</span>(
    parent: *<a href="std.Build.html">Build</a>,
    dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    build_root: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>,
    pkg_hash: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    pkg_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a>,
    user_input_options: <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a>,
) <span class="tok-kw">error</span>{OutOfMemory}!*<a href="std.Build.html">Build</a> {
    <span class="tok-kw">const</span> allocator = parent.allocator;
    <span class="tok-kw">const</span> child = <span class="tok-kw">try</span> allocator.create(<a href="std.Build.html">Build</a>);
    child.* = .{
        .graph = parent.graph,
        .allocator = allocator,
        .install_tls = .{
            .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
                .id = <a href="std.Build.TopLevelStep.html">TopLevelStep</a>.<a href="std.Build.TopLevelStep.html#std.Build.TopLevelStep.base_id">base_id</a>,
                .name = <span class="tok-str">&quot;install&quot;</span>,
                .owner = child,
            }),
            .description = <span class="tok-str">&quot;Copy build artifacts to prefix path&quot;</span>,
        },
        .uninstall_tls = .{
            .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
                .id = <a href="std.Build.TopLevelStep.html">TopLevelStep</a>.<a href="std.Build.TopLevelStep.html#std.Build.TopLevelStep.base_id">base_id</a>,
                .name = <span class="tok-str">&quot;uninstall&quot;</span>,
                .owner = child,
                .makeFn = <a href="std.Build.html#std.Build.makeUninstall">makeUninstall</a>,
            }),
            .description = <span class="tok-str">&quot;Remove build artifacts from prefix path&quot;</span>,
        },
        .user_input_options = user_input_options,
        .available_options_map = <a href="std.Build.html#std.Build.AvailableOptionsMap">AvailableOptionsMap</a>.<a href="#">init</a>(allocator),
        .available_options_list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.AvailableOption.html">AvailableOption</a>).init(allocator),
        .verbose = parent.verbose,
        .verbose_link = parent.verbose_link,
        .verbose_cc = parent.verbose_cc,
        .verbose_air = parent.verbose_air,
        .verbose_llvm_ir = parent.verbose_llvm_ir,
        .verbose_llvm_bc = parent.verbose_llvm_bc,
        .verbose_cimport = parent.verbose_cimport,
        .verbose_llvm_cpu_features = parent.verbose_llvm_cpu_features,
        .reference_trace = parent.reference_trace,
        .invalid_user_input = <span class="tok-null">false</span>,
        .default_step = <span class="tok-null">undefined</span>,
        .top_level_steps = .{},
        .install_prefix = <span class="tok-null">undefined</span>,
        .dest_dir = parent.dest_dir,
        .lib_dir = parent.lib_dir,
        .exe_dir = parent.exe_dir,
        .h_dir = parent.h_dir,
        .install_path = parent.install_path,
        .sysroot = parent.sysroot,
        .search_prefixes = parent.search_prefixes,
        .libc_file = parent.libc_file,
        .build_root = build_root,
        .cache_root = parent.cache_root,
        .debug_log_scopes = parent.debug_log_scopes,
        .debug_compile_errors = parent.debug_compile_errors,
        .debug_pkg_config = parent.debug_pkg_config,
        .enable_darling = parent.enable_darling,
        .enable_qemu = parent.enable_qemu,
        .enable_rosetta = parent.enable_rosetta,
        .enable_wasmtime = parent.enable_wasmtime,
        .enable_wine = parent.enable_wine,
        .glibc_runtimes_dir = parent.glibc_runtimes_dir,
        .dep_prefix = parent.fmt(<span class="tok-str">&quot;{s}{s}.&quot;</span>, .{ parent.dep_prefix, dep_name }),
        .modules = .init(allocator),
        .named_writefiles = .init(allocator),
        .named_lazy_paths = .init(allocator),
        .pkg_hash = pkg_hash,
        .available_deps = pkg_deps,
        .release_mode = parent.release_mode,
    };
    <span class="tok-kw">try</span> child.top_level_steps.put(allocator, child.install_tls.step.name, &amp;child.install_tls);
    <span class="tok-kw">try</span> child.top_level_steps.put(allocator, child.uninstall_tls.step.name, &amp;child.uninstall_tls);
    child.default_step = &amp;child.install_tls.step;
    <span class="tok-kw">return</span> child;
}

<span class="tok-kw">fn</span> <span class="tok-fn">userInputOptionsFromArgs</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, args: <span class="tok-kw">anytype</span>) <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a> {
    <span class="tok-kw">var</span> user_input_options = <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a>.<a href="#">init</a>(allocator);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(args)).@&quot;struct&quot;.fields) |field| {
        <span class="tok-kw">const</span> v = <span class="tok-builtin">@field</span>(args, field.name);
        <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(v);
        <span class="tok-kw">switch</span> (T) {
            <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a> =&gt; {
                user_input_options.put(field.name, .{
                    .name = field.name,
                    .value = .{ .scalar = v.zigTriple(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },
                    .used = <span class="tok-null">false</span>,
                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                user_input_options.put(<span class="tok-str">&quot;cpu&quot;</span>, .{
                    .name = <span class="tok-str">&quot;cpu&quot;</span>,
                    .value = .{ .scalar = v.serializeCpuAlloc(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },
                    .used = <span class="tok-null">false</span>,
                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> =&gt; {
                user_input_options.put(field.name, .{
                    .name = field.name,
                    .value = .{ .scalar = v.query.zigTriple(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },
                    .used = <span class="tok-null">false</span>,
                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                user_input_options.put(<span class="tok-str">&quot;cpu&quot;</span>, .{
                    .name = <span class="tok-str">&quot;cpu&quot;</span>,
                    .value = .{ .scalar = v.query.serializeCpuAlloc(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },
                    .used = <span class="tok-null">false</span>,
                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            <a href="std.Build.LazyPath.html">LazyPath</a> =&gt; {
                user_input_options.put(field.name, .{
                    .name = field.name,
                    .value = .{ .lazy_path = v.dupeInner(allocator) },
                    .used = <span class="tok-null">false</span>,
                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            []<span class="tok-kw">const</span> <a href="std.Build.LazyPath.html">LazyPath</a> =&gt; {
                <span class="tok-kw">var</span> list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.LazyPath.html">LazyPath</a>).initCapacity(allocator, v.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                <span class="tok-kw">for</span> (v) |lp| list.appendAssumeCapacity(lp.dupeInner(allocator));
                user_input_options.put(field.name, .{
                    .name = field.name,
                    .value = .{ .lazy_path_list = list },
                    .used = <span class="tok-null">false</span>,
                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; {
                user_input_options.put(field.name, .{
                    .name = field.name,
                    .value = .{ .scalar = v },
                    .used = <span class="tok-null">false</span>,
                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; {
                <span class="tok-kw">var</span> list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).initCapacity(allocator, v.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                list.appendSliceAssumeCapacity(v);

                user_input_options.put(field.name, .{
                    .name = field.name,
                    .value = .{ .list = list },
                    .used = <span class="tok-null">false</span>,
                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
                .<span class="tok-type">bool</span> =&gt; {
                    user_input_options.put(field.name, .{
                        .name = field.name,
                        .value = .{ .scalar = <span class="tok-kw">if</span> (v) <span class="tok-str">&quot;true&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;false&quot;</span> },
                        .used = <span class="tok-null">false</span>,
                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                },
                .@&quot;enum&quot;, .enum_literal =&gt; {
                    user_input_options.put(field.name, .{
                        .name = field.name,
                        .value = .{ .scalar = <span class="tok-builtin">@tagName</span>(v) },
                        .used = <span class="tok-null">false</span>,
                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                },
                .<span class="tok-type">comptime_int</span>, .int =&gt; {
                    user_input_options.put(field.name, .{
                        .name = field.name,
                        .value = .{ .scalar = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{v}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },
                        .used = <span class="tok-null">false</span>,
                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                },
                .<span class="tok-type">comptime_float</span>, .float =&gt; {
                    user_input_options.put(field.name, .{
                        .name = field.name,
                        .value = .{ .scalar = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(allocator, <span class="tok-str">&quot;{e}&quot;</span>, .{v}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },
                        .used = <span class="tok-null">false</span>,
                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;option '&quot;</span> ++ field.name ++ <span class="tok-str">&quot;' has unsupported type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),
            },
        }
    }

    <span class="tok-kw">return</span> user_input_options;
}

<span class="tok-kw">const</span> OrderedUserValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    flag: <span class="tok-type">void</span>,
    scalar: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    list: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),
    map: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.OrderedUserValue.Pair.html">Pair</a>),
    lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>,
    lazy_path_list: <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.LazyPath.html">LazyPath</a>),

    <span class="tok-kw">const</span> Pair = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        value: <a href="std.Build.OrderedUserValue.html">OrderedUserValue</a>,
        <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(_: <span class="tok-type">void</span>, lhs: <a href="std.Build.OrderedUserValue.Pair.html">Pair</a>, rhs: <a href="std.Build.OrderedUserValue.Pair.html">Pair</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.lessThanIgnoreCase">lessThanIgnoreCase</a>(lhs.name, rhs.name);
        }
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(val: <a href="std.Build.OrderedUserValue.html">OrderedUserValue</a>, hasher: *<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>) <span class="tok-type">void</span> {
        hasher.update(&amp;<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.activeTag">activeTag</a>(val)));
        <span class="tok-kw">switch</span> (val) {
            .flag =&gt; {},
            .scalar =&gt; |scalar| hasher.update(scalar),<span class="tok-comment">
            // lists are already ordered
            </span>.list =&gt; |list| <span class="tok-kw">for</span> (list.items) |list_entry|
                hasher.update(list_entry),
            .map =&gt; |map| <span class="tok-kw">for</span> (map.items) |map_entry| {
                hasher.update(map_entry.name);
                map_entry.value.hash(hasher);
            },
            .lazy_path =&gt; |lp| <a href="std.Build.OrderedUserValue.html#std.Build.OrderedUserValue.hashLazyPath">hashLazyPath</a>(lp, hasher),
            .lazy_path_list =&gt; |lp_list| <span class="tok-kw">for</span> (lp_list.items) |lp| {
                <a href="std.Build.OrderedUserValue.html#std.Build.OrderedUserValue.hashLazyPath">hashLazyPath</a>(lp, hasher);
            },
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">hashLazyPath</span>(lp: <a href="std.Build.LazyPath.html">LazyPath</a>, hasher: *<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (lp) {
            .src_path =&gt; |sp| {
                hasher.update(sp.owner.pkg_hash);
                hasher.update(sp.sub_path);
            },
            .generated =&gt; |gen| {
                hasher.update(gen.file.step.owner.pkg_hash);
                hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;gen.up));
                hasher.update(gen.sub_path);
            },
            .cwd_relative =&gt; |rel_path| {
                hasher.update(rel_path);
            },
            .dependency =&gt; |dep| {
                hasher.update(dep.dependency.builder.pkg_hash);
                hasher.update(dep.sub_path);
            },
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">mapFromUnordered</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, unordered: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(*<span class="tok-kw">const</span> <a href="std.Build.UserValue.html">UserValue</a>)) <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.OrderedUserValue.Pair.html">Pair</a>) {
        <span class="tok-kw">var</span> ordered = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.OrderedUserValue.Pair.html">Pair</a>).init(allocator);
        <span class="tok-kw">var</span> it = unordered.iterator();
        <span class="tok-kw">while</span> (it.next()) |entry| {
            ordered.append(.{
                .name = entry.key_ptr.*,
                .value = <a href="std.Build.OrderedUserValue.html">OrderedUserValue</a>.<a href="std.Build.OrderedUserValue.html#std.Build.OrderedUserValue.fromUnordered">fromUnordered</a>(allocator, entry.value_ptr.*.*),
            }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
        }

        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortUnstable">sortUnstable</a>(<a href="std.Build.OrderedUserValue.Pair.html">Pair</a>, ordered.items, {}, <a href="std.Build.OrderedUserValue.Pair.html">Pair</a>.<a href="std.Build.OrderedUserValue.Pair.html#std.Build.OrderedUserValue.Pair.lessThan">lessThan</a>);
        <span class="tok-kw">return</span> ordered;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fromUnordered</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, unordered: <a href="std.Build.UserValue.html">UserValue</a>) <a href="std.Build.OrderedUserValue.html">OrderedUserValue</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (unordered) {
            .flag =&gt; .{ .flag = {} },
            .scalar =&gt; |scalar| .{ .scalar = scalar },
            .list =&gt; |list| .{ .list = list },
            .map =&gt; |map| .{ .map = <a href="std.Build.OrderedUserValue.html">OrderedUserValue</a>.<a href="std.Build.OrderedUserValue.html#std.Build.OrderedUserValue.mapFromUnordered">mapFromUnordered</a>(allocator, map) },
            .lazy_path =&gt; |lp| .{ .lazy_path = lp },
            .lazy_path_list =&gt; |list| .{ .lazy_path_list = list },
        };
    }
};

<span class="tok-kw">const</span> OrderedUserInputOption = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    value: <a href="std.Build.OrderedUserValue.html">OrderedUserValue</a>,
    used: <span class="tok-type">bool</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(opt: <a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a>, hasher: *<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>) <span class="tok-type">void</span> {
        hasher.update(opt.name);
        opt.value.hash(hasher);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fromUnordered</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, user_input_option: <a href="std.Build.UserInputOption.html">UserInputOption</a>) <a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a> {
        <span class="tok-kw">return</span> <a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a>{
            .name = user_input_option.name,
            .used = user_input_option.used,
            .value = <a href="std.Build.OrderedUserValue.html">OrderedUserValue</a>.<a href="std.Build.OrderedUserValue.html#std.Build.OrderedUserValue.fromUnordered">fromUnordered</a>(allocator, user_input_option.value),
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(_: <span class="tok-type">void</span>, lhs: <a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a>, rhs: <a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.lessThanIgnoreCase">lessThanIgnoreCase</a>(lhs.name, rhs.name);
    }
};<span class="tok-comment">

// The hash should be consistent with the same values given a different order.
// This function takes a user input map, orders it, then hashes the contents.
</span><span class="tok-kw">fn</span> <span class="tok-fn">hashUserInputOptionsMap</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, user_input_options: <a href="std.Build.html#std.Build.UserInputOptionsMap">UserInputOptionsMap</a>, hasher: *<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> ordered = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a>).init(allocator);
    <span class="tok-kw">var</span> it = user_input_options.iterator();
    <span class="tok-kw">while</span> (it.next()) |entry|
        ordered.append(<a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a>.<a href="std.Build.OrderedUserInputOption.html#std.Build.OrderedUserInputOption.fromUnordered">fromUnordered</a>(allocator, entry.value_ptr.*)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sortUnstable">sortUnstable</a>(<a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a>, ordered.items, {}, <a href="std.Build.OrderedUserInputOption.html">OrderedUserInputOption</a>.<a href="std.Build.OrderedUserInputOption.html#std.Build.OrderedUserInputOption.lessThan">lessThan</a>);<span class="tok-comment">

    // juice it
    </span><span class="tok-kw">for</span> (ordered.items) |user_option|
        user_option.hash(hasher);
}

<span class="tok-kw">fn</span> <span class="tok-fn">determineAndApplyInstallPrefix</span>(b: *<a href="std.Build.html">Build</a>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">void</span> {<span class="tok-comment">
    // Create an installation directory local to this package. This will be used when
    // dependant packages require a standard prefix, such as include directories for C headers.
    </span><span class="tok-kw">var</span> hash = b.graph.cache.hash;<span class="tok-comment">
    // Random bytes to make unique. Refresh this with new random bytes when
    // implementation is modified in a non-backwards-compatible way.
    </span>hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xd8cb0055</span>));
    hash.addBytes(b.dep_prefix);

    <span class="tok-kw">var</span> wyhash = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
    <a href="std.Build.html#std.Build.hashUserInputOptionsMap">hashUserInputOptionsMap</a>(b.allocator, b.user_input_options, &amp;wyhash);
    hash.add(wyhash.final());

    <span class="tok-kw">const</span> digest = hash.final();
    <span class="tok-kw">const</span> install_prefix = <span class="tok-kw">try</span> b.cache_root.join(b.allocator, &amp;.{ <span class="tok-str">&quot;i&quot;</span>, &amp;digest });
    b.resolveInstallPrefix(install_prefix, .{});
}

<span class="tok-comment">/// This function is intended to be called by lib/build_runner.zig, not a build.zig file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveInstallPrefix</span>(b: *<a href="std.Build.html">Build</a>, install_prefix: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dir_list: <a href="std.Build.DirList.html">DirList</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (b.dest_dir) |dest_dir| {
        b.install_prefix = install_prefix <span class="tok-kw">orelse</span> <span class="tok-str">&quot;/usr&quot;</span>;
        b.install_path = b.pathJoin(&amp;.{ dest_dir, b.install_prefix });
    } <span class="tok-kw">else</span> {
        b.install_prefix = install_prefix <span class="tok-kw">orelse</span>
            (b.build_root.join(b.allocator, &amp;.{<span class="tok-str">&quot;zig-out&quot;</span>}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>));
        b.install_path = b.install_prefix;
    }

    <span class="tok-kw">var</span> lib_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ b.install_path, <span class="tok-str">&quot;lib&quot;</span> };
    <span class="tok-kw">var</span> exe_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ b.install_path, <span class="tok-str">&quot;bin&quot;</span> };
    <span class="tok-kw">var</span> h_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ b.install_path, <span class="tok-str">&quot;include&quot;</span> };

    <span class="tok-kw">if</span> (dir_list.lib_dir) |dir| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dir)) lib_list[<span class="tok-number">0</span>] = b.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;
        lib_list[<span class="tok-number">1</span>] = dir;
    }

    <span class="tok-kw">if</span> (dir_list.exe_dir) |dir| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dir)) exe_list[<span class="tok-number">0</span>] = b.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;
        exe_list[<span class="tok-number">1</span>] = dir;
    }

    <span class="tok-kw">if</span> (dir_list.include_dir) |dir| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dir)) h_list[<span class="tok-number">0</span>] = b.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;
        h_list[<span class="tok-number">1</span>] = dir;
    }

    b.lib_dir = b.pathJoin(&amp;lib_list);
    b.exe_dir = b.pathJoin(&amp;exe_list);
    b.h_dir = b.pathJoin(&amp;h_list);
}

<span class="tok-comment">/// Create a set of key-value pairs that can be converted into a Zig source</span>
<span class="tok-comment">/// file and then inserted into a Zig compilation's module table for importing.</span>
<span class="tok-comment">/// In other words, this provides a way to expose build.zig values to Zig</span>
<span class="tok-comment">/// source code with `@import`.</span>
<span class="tok-comment">/// Related: `Module.addOptions`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptions</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Options.html">Options</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Options.html">Options</a>.<a href="std.Build.Step.Options.html#std.Build.Step.Options.create">create</a>(b);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExecutableOptions = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    version: ?<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> = <span class="tok-null">null</span>,
    linkage: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.LinkMode.html">LinkMode</a> = <span class="tok-null">null</span>,
    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Embed a `.manifest` file in the compilation if the object format supports it.</span>
    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sbscs/manifest-files-reference</span>
    <span class="tok-comment">/// Manifest files must have the extension `.manifest`.</span>
    <span class="tok-comment">/// Can be set regardless of target. The `.manifest` file will be ignored</span>
    <span class="tok-comment">/// if the target object format does not support embedded manifests.</span>
    win32_manifest: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Prefer populating this field (using e.g. `createModule`) instead of populating</span>
    <span class="tok-comment">/// the following fields (`root_source_file` etc). In a future release, those fields</span>
    <span class="tok-comment">/// will be removed, and this field will become non-optional.</span>
    root_module: ?*<a href="std.Build.Module.html">Module</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    root_source_file: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    target: ?<a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    optimize: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a> = .Debug,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    code_model: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.CodeModel.html">CodeModel</a> = .default,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    unwind_tables: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.UnwindTables.html">UnwindTables</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addExecutable</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.ExecutableOptions.html">ExecutableOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.target != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .root_source_file = options.root_source_file,
            .target = options.target <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be null&quot;</span>),
            .optimize = options.optimize,
            .link_libc = options.link_libc,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
            .code_model = options.code_model,
        }),
        .version = options.version,
        .kind = .exe,
        .linkage = options.linkage,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
        .win32_manifest = options.win32_manifest,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ObjectOptions = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Prefer populating this field (using e.g. `createModule`) instead of populating</span>
    <span class="tok-comment">/// the following fields (`root_source_file` etc). In a future release, those fields</span>
    <span class="tok-comment">/// will be removed, and this field will become non-optional.</span>
    root_module: ?*<a href="std.Build.Module.html">Module</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    root_source_file: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    target: ?<a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    optimize: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a> = .Debug,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    code_model: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.CodeModel.html">CodeModel</a> = .default,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    unwind_tables: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.UnwindTables.html">UnwindTables</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObject</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.ObjectOptions.html">ObjectOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.target != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .root_source_file = options.root_source_file,
            .target = options.target <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be null&quot;</span>),
            .optimize = options.optimize,
            .link_libc = options.link_libc,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
            .code_model = options.code_model,
        }),
        .kind = .obj,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SharedLibraryOptions = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    version: ?<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> = <span class="tok-null">null</span>,
    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Embed a `.manifest` file in the compilation if the object format supports it.</span>
    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sbscs/manifest-files-reference</span>
    <span class="tok-comment">/// Manifest files must have the extension `.manifest`.</span>
    <span class="tok-comment">/// Can be set regardless of target. The `.manifest` file will be ignored</span>
    <span class="tok-comment">/// if the target object format does not support embedded manifests.</span>
    win32_manifest: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Prefer populating this field (using e.g. `createModule`) instead of populating</span>
    <span class="tok-comment">/// the following fields (`root_source_file` etc). In a future release, those fields</span>
    <span class="tok-comment">/// will be removed, and this field will become non-optional.</span>
    root_module: ?*<a href="std.Build.Module.html">Module</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    root_source_file: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    target: ?<a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    optimize: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a> = .Debug,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    code_model: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.CodeModel.html">CodeModel</a> = .default,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    unwind_tables: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.UnwindTables.html">UnwindTables</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
};

<span class="tok-comment">/// Deprecated: use `b.addLibrary(.{ ..., .linkage = .dynamic })` instead.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSharedLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.SharedLibraryOptions.html">SharedLibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.target != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .target = options.target <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be null&quot;</span>),
            .optimize = options.optimize,
            .root_source_file = options.root_source_file,
            .link_libc = options.link_libc,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
            .code_model = options.code_model,
        }),
        .kind = .lib,
        .linkage = .dynamic,
        .version = options.version,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
        .win32_manifest = options.win32_manifest,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StaticLibraryOptions = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    version: ?<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> = <span class="tok-null">null</span>,
    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Prefer populating this field (using e.g. `createModule`) instead of populating</span>
    <span class="tok-comment">/// the following fields (`root_source_file` etc). In a future release, those fields</span>
    <span class="tok-comment">/// will be removed, and this field will become non-optional.</span>
    root_module: ?*<a href="std.Build.Module.html">Module</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    root_source_file: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    target: ?<a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    optimize: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a> = .Debug,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    code_model: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.CodeModel.html">CodeModel</a> = .default,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    unwind_tables: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.UnwindTables.html">UnwindTables</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
};

<span class="tok-comment">/// Deprecated: use `b.addLibrary(.{ ..., .linkage = .static })` instead.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addStaticLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.StaticLibraryOptions.html">StaticLibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.target != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .target = options.target <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `target` cannot both be null&quot;</span>),
            .optimize = options.optimize,
            .root_source_file = options.root_source_file,
            .link_libc = options.link_libc,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
            .code_model = options.code_model,
        }),
        .kind = .lib,
        .linkage = .static,
        .version = options.version,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> LibraryOptions = <span class="tok-kw">struct</span> {
    linkage: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.LinkMode.html">LinkMode</a> = .static,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    root_module: *<a href="std.Build.Module.html">Module</a>,
    version: ?<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> = <span class="tok-null">null</span>,
    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Embed a `.manifest` file in the compilation if the object format supports it.</span>
    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sbscs/manifest-files-reference</span>
    <span class="tok-comment">/// Manifest files must have the extension `.manifest`.</span>
    <span class="tok-comment">/// Can be set regardless of target. The `.manifest` file will be ignored</span>
    <span class="tok-comment">/// if the target object format does not support embedded manifests.</span>
    win32_manifest: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addLibrary</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.LibraryOptions.html">LibraryOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .root_module = options.root_module,
        .kind = .lib,
        .linkage = options.linkage,
        .version = options.version,
        .max_rss = options.max_rss,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
        .win32_manifest = options.win32_manifest,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TestOptions = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;test&quot;</span>,
    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    <span class="tok-comment">/// Deprecated; use `.filters = &amp;.{filter}` instead of `.filter = filter`.</span>
    filter: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    filters: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},
    test_runner: ?<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>.<a href="std.Build.Step.Compile.TestRunner.html">TestRunner</a> = <span class="tok-null">null</span>,
    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Prefer populating this field (using e.g. `createModule`) instead of populating</span>
    <span class="tok-comment">/// the following fields (`root_source_file` etc). In a future release, those fields</span>
    <span class="tok-comment">/// will be removed, and this field will become non-optional.</span>
    root_module: ?*<a href="std.Build.Module.html">Module</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    root_source_file: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    target: ?<a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    optimize: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a> = .Debug,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    version: ?<a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    link_libcpp: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    unwind_tables: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.UnwindTables.html">UnwindTables</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Deprecated; prefer populating `root_module`.</span>
    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
};

<span class="tok-comment">/// Creates an executable containing unit tests.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Equivalent to running the command `zig test --test-no-exec ...`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// **This step does not run the unit tests**. Typically, the result of this</span>
<span class="tok-comment">/// function will be passed to `addRunArtifact`, creating a `Step.Run`. These</span>
<span class="tok-comment">/// two steps are separated because they are independently configured and</span>
<span class="tok-comment">/// cached.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTest</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.TestOptions.html">TestOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">if</span> (options.root_module != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.root_source_file != <span class="tok-null">null</span>) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `root_source_file` cannot both be populated&quot;</span>);
    }
    <span class="tok-kw">return</span> .create(b, .{
        .name = options.name,
        .kind = .@&quot;test&quot;,
        .root_module = options.root_module <span class="tok-kw">orelse</span> b.createModule(.{
            .root_source_file = options.root_source_file <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;`root_module` and `root_source_file` cannot both be null&quot;</span>),
            .target = options.target <span class="tok-kw">orelse</span> b.graph.host,
            .optimize = options.optimize,
            .link_libc = options.link_libc,
            .link_libcpp = options.link_libcpp,
            .single_threaded = options.single_threaded,
            .pic = options.pic,
            .strip = options.strip,
            .unwind_tables = options.unwind_tables,
            .omit_frame_pointer = options.omit_frame_pointer,
            .sanitize_thread = options.sanitize_thread,
            .error_tracing = options.error_tracing,
        }),
        .max_rss = options.max_rss,
        .filters = <span class="tok-kw">if</span> (options.filter != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.filters.len &gt; <span class="tok-number">0</span>) filters: {
            <span class="tok-kw">const</span> filters = b.allocator.alloc([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-number">1</span> + options.filters.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            filters[<span class="tok-number">0</span>] = b.dupe(options.filter.?);
            <span class="tok-kw">for</span> (filters[<span class="tok-number">1</span>..], options.filters) |*dest, source| dest.* = b.dupe(source);
            <span class="tok-kw">break</span> :filters filters;
        } <span class="tok-kw">else</span> b.dupeStrings(<span class="tok-kw">if</span> (options.filter) |filter| &amp;.{filter} <span class="tok-kw">else</span> options.filters),
        .test_runner = options.test_runner,
        .use_llvm = options.use_llvm,
        .use_lld = options.use_lld,
        .zig_lib_dir = options.zig_lib_dir,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AssemblyOptions = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    source_file: <a href="std.Build.LazyPath.html">LazyPath</a>,
    <span class="tok-comment">/// To choose the same computer as the one building the package, pass the</span>
    <span class="tok-comment">/// `host` field of the package's `Build` instance.</span>
    target: <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a>,
    optimize: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a>,
    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    zig_lib_dir: ?<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,
};

<span class="tok-comment">/// Deprecated; prefer using `addObject` where the `root_module` has an empty</span>
<span class="tok-comment">/// `root_source_file` and contains an assembly file via `Module.addAssemblyFile`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssembly</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.AssemblyOptions.html">AssemblyOptions</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
    <span class="tok-kw">const</span> root_module = b.createModule(.{
        .target = options.target,
        .optimize = options.optimize,
    });
    root_module.addAssemblyFile(options.source_file);
    <span class="tok-kw">return</span> b.addObject(.{
        .name = options.name,
        .max_rss = options.max_rss,
        .zig_lib_dir = options.zig_lib_dir,
        .root_module = root_module,
    });
}

<span class="tok-comment">/// This function creates a module and adds it to the package's module set, making</span>
<span class="tok-comment">/// it available to other packages which depend on this one.</span>
<span class="tok-comment">/// `createModule` can be used instead to create a private module.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addModule</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CreateOptions.html">CreateOptions</a>) *<a href="std.Build.Module.html">Module</a> {
    <span class="tok-kw">const</span> module = <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.html#std.Build.Module.create">create</a>(b, options);
    b.modules.put(b.dupe(name), module) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">return</span> module;
}

<span class="tok-comment">/// This function creates a private module, to be used by the current package,</span>
<span class="tok-comment">/// but not exposed to other packages depending on this one.</span>
<span class="tok-comment">/// `addModule` can be used instead to create a public module.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createModule</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.CreateOptions.html">CreateOptions</a>) *<a href="std.Build.Module.html">Module</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Module.html">Module</a>.<a href="std.Build.Module.html#std.Build.Module.create">create</a>(b, options);
}

<span class="tok-comment">/// Initializes a `Step.Run` with argv, which must at least have the path to the</span>
<span class="tok-comment">/// executable. More command line arguments can be added with `addArg`,</span>
<span class="tok-comment">/// `addArgs`, and `addArtifactArg`.</span>
<span class="tok-comment">/// Be careful using this function, as it introduces a system dependency.</span>
<span class="tok-comment">/// To run an executable built with zig build, see `Step.Compile.run`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemCommand</span>(b: *<a href="std.Build.html">Build</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(argv.len &gt;= <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> run_step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a>.<a href="std.Build.Step.Run.html#std.Build.Step.Run.create">create</a>(b, b.fmt(<span class="tok-str">&quot;run {s}&quot;</span>, .{argv[<span class="tok-number">0</span>]}));
    run_step.addArgs(argv);
    <span class="tok-kw">return</span> run_step;
}

<span class="tok-comment">/// Creates a `Step.Run` with an executable built with `addExecutable`.</span>
<span class="tok-comment">/// Add command line arguments with methods of `Step.Run`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRunArtifact</span>(b: *<a href="std.Build.html">Build</a>, exe: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a> {<span class="tok-comment">
    // It doesn't have to be native. We catch that if you actually try to run it.
    // Consider that this is declarative; the run step may not be run unless a user
    // option is supplied.
    </span><span class="tok-kw">const</span> run_step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Run.html">Run</a>.<a href="std.Build.Step.Run.html#std.Build.Step.Run.create">create</a>(b, b.fmt(<span class="tok-str">&quot;run {s}&quot;</span>, .{exe.name}));
    run_step.producer = exe;
    <span class="tok-kw">if</span> (exe.kind == .@&quot;test&quot;) {
        <span class="tok-kw">if</span> (exe.exec_cmd_args) |exec_cmd_args| {
            <span class="tok-kw">for</span> (exec_cmd_args) |cmd_arg| {
                <span class="tok-kw">if</span> (cmd_arg) |arg| {
                    run_step.addArg(arg);
                } <span class="tok-kw">else</span> {
                    run_step.addArtifactArg(exe);
                }
            }
        } <span class="tok-kw">else</span> {
            run_step.addArtifactArg(exe);
        }

        <span class="tok-kw">const</span> test_server_mode = <span class="tok-kw">if</span> (exe.test_runner) |r| r.mode == .server <span class="tok-kw">else</span> <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (test_server_mode) run_step.enableTestRunnerMode();
    } <span class="tok-kw">else</span> {
        run_step.addArtifactArg(exe);
    }

    <span class="tok-kw">return</span> run_step;
}

<span class="tok-comment">/// Using the `values` provided, produces a C header file, possibly based on a</span>
<span class="tok-comment">/// template input file (e.g. config.h.in).</span>
<span class="tok-comment">/// When an input template file is provided, this function will fail the build</span>
<span class="tok-comment">/// when an option not found in the input file is provided in `values`, and</span>
<span class="tok-comment">/// when an option found in the input file is missing from `values`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addConfigHeader</span>(
    b: *<a href="std.Build.html">Build</a>,
    options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>.<a href="std.Build.Step.ConfigHeader.Options.html">Options</a>,
    values: <span class="tok-kw">anytype</span>,
) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a> {
    <span class="tok-kw">var</span> options_copy = options;
    <span class="tok-kw">if</span> (options_copy.first_ret_addr == <span class="tok-null">null</span>)
        options_copy.first_ret_addr = <span class="tok-builtin">@returnAddress</span>();

    <span class="tok-kw">const</span> config_header_step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ConfigHeader.html">ConfigHeader</a>.<a href="std.Build.Step.ConfigHeader.html#std.Build.Step.ConfigHeader.create">create</a>(b, options_copy);
    config_header_step.addValues(values);
    <span class="tok-kw">return</span> config_header_step;
}

<span class="tok-comment">/// Allocator.dupe without the need to handle out of memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(b: *<a href="std.Build.html">Build</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dupeInner">dupeInner</a>(b.allocator, bytes);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeInner</span>(allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, bytes) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-comment">/// Duplicates an array of strings without the need to handle out of memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeStrings</span>(b: *<a href="std.Build.html">Build</a>, strings: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) [][]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> array = b.allocator.alloc([]<span class="tok-type">u8</span>, strings.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">for</span> (array, strings) |*dest, source| dest.* = b.dupe(source);
    <span class="tok-kw">return</span> array;
}

<span class="tok-comment">/// Duplicates a path and converts all slashes to the OS's canonical path separator.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupePath</span>(b: *<a href="std.Build.html">Build</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dupePathInner">dupePathInner</a>(b.allocator, bytes);
}

<span class="tok-kw">fn</span> <span class="tok-fn">dupePathInner</span>(allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> the_copy = <a href="std.Build.html#std.Build.dupeInner">dupeInner</a>(allocator, bytes);
    <span class="tok-kw">for</span> (the_copy) |*byte| {
        <span class="tok-kw">switch</span> (byte.*) {
            <span class="tok-str">'/'</span>, <span class="tok-str">'\\'</span> =&gt; byte.* = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>,
            <span class="tok-kw">else</span> =&gt; {},
        }
    }
    <span class="tok-kw">return</span> the_copy;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFile</span>(b: *<a href="std.Build.html">Build</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
    <span class="tok-kw">const</span> write_file_step = b.addWriteFiles();
    _ = write_file_step.add(file_path, data);
    <span class="tok-kw">return</span> write_file_step;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNamedWriteFiles</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
    <span class="tok-kw">const</span> wf = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a>.<a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.create">create</a>(b);
    b.named_writefiles.put(b.dupe(name), wf) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">return</span> wf;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNamedLazyPath</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lp: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    b.named_lazy_paths.put(b.dupe(name), lp.dupe(b)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFiles</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a>.<a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.create">create</a>(b);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUpdateSourceFiles</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.UpdateSourceFiles.html">UpdateSourceFiles</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.UpdateSourceFiles.html">UpdateSourceFiles</a>.<a href="std.Build.Step.UpdateSourceFiles.html#std.Build.Step.UpdateSourceFiles.create">create</a>(b);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRemoveDirTree</span>(b: *<a href="std.Build.html">Build</a>, dir_path: <a href="std.Build.LazyPath.html">LazyPath</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.RemoveDir.html">RemoveDir</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.RemoveDir.html">RemoveDir</a>.<a href="std.Build.Step.RemoveDir.html#std.Build.Step.RemoveDir.create">create</a>(b, dir_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFail</span>(b: *<a href="std.Build.html">Build</a>, error_msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fail.html">Fail</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fail.html">Fail</a>.<a href="std.Build.Step.Fail.html#std.Build.Step.Fail.create">create</a>(b, error_msg);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFmt</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a>.<a href="std.Build.Step.Fmt.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Fmt.html">Fmt</a>.<a href="std.Build.Step.Fmt.html#std.Build.Step.Fmt.create">create</a>(b, options);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTranslateC</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a>.<a href="std.Build.Step.TranslateC.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.TranslateC.html">TranslateC</a>.<a href="std.Build.Step.TranslateC.html#std.Build.Step.TranslateC.create">create</a>(b, options);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallStep</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a> {
    <span class="tok-kw">return</span> &amp;b.install_tls.step;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getUninstallStep</span>(b: *<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.html">Step</a> {
    <span class="tok-kw">return</span> &amp;b.uninstall_tls.step;
}

<span class="tok-kw">fn</span> <span class="tok-fn">makeUninstall</span>(uninstall_step: *<a href="std.Build.Step.html">Step</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.MakeOptions.html">MakeOptions</a>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    _ = options;
    <span class="tok-kw">const</span> uninstall_tls: *<a href="std.Build.TopLevelStep.html">TopLevelStep</a> = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;step&quot;</span>, uninstall_step);
    <span class="tok-kw">const</span> b: *<a href="std.Build.html">Build</a> = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;uninstall_tls&quot;</span>, uninstall_tls);

    _ = b;
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO implement https://github.com/ziglang/zig/issues/14943&quot;</span>);
}

<span class="tok-comment">/// Creates a configuration option to be passed to the build.zig script.</span>
<span class="tok-comment">/// When a user directly runs `zig build`, they can set these options with `-D` arguments.</span>
<span class="tok-comment">/// When a project depends on a Zig package as a dependency, it programmatically sets</span>
<span class="tok-comment">/// these options when calling the dependency's build.zig script as a function.</span>
<span class="tok-comment">/// `null` is returned when an option is left to default.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">option</span>(b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?T {
    <span class="tok-kw">const</span> name = b.dupe(name_raw);
    <span class="tok-kw">const</span> description = b.dupe(description_raw);
    <span class="tok-kw">const</span> type_id = <span class="tok-kw">comptime</span> <a href="std.Build.html#std.Build.typeToEnum">typeToEnum</a>(T);
    <span class="tok-kw">const</span> enum_options = <span class="tok-kw">if</span> (type_id == .@&quot;enum&quot; <span class="tok-kw">or</span> type_id == .enum_list) blk: {
        <span class="tok-kw">const</span> EnumType = <span class="tok-kw">if</span> (type_id == .enum_list) <span class="tok-builtin">@typeInfo</span>(T).pointer.child <span class="tok-kw">else</span> T;
        <span class="tok-kw">const</span> fields = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(EnumType);
        <span class="tok-kw">var</span> options = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).initCapacity(b.allocator, fields.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {
            options.appendAssumeCapacity(field.name);
        }

        <span class="tok-kw">break</span> :blk options.toOwnedSlice() <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> available_option = <a href="std.Build.AvailableOption.html">AvailableOption</a>{
        .name = name,
        .type_id = type_id,
        .description = description,
        .enum_options = enum_options,
    };
    <span class="tok-kw">if</span> ((b.available_options_map.fetchPut(name, available_option) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>)) != <span class="tok-null">null</span>) {
        <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;Option '{s}' declared twice&quot;</span>, .{name});
    }
    b.available_options_list.append(available_option) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    <span class="tok-kw">const</span> option_ptr = b.user_input_options.getPtr(name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    option_ptr.used = <span class="tok-null">true</span>;
    <span class="tok-kw">switch</span> (type_id) {
        .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
            .scalar =&gt; |s| {
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;true&quot;</span>)) {
                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;false&quot;</span>)) {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                } <span class="tok-kw">else</span> {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a boolean, but received '{s}'&quot;</span>, .{ name, s });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
            .list, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a boolean, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
        },
        .int =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .list, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be an integer, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">const</span> n = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(T, s, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.Overflow =&gt; {
                        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;-D{s} value {s} cannot fit into type {s}.&quot;</span>, .{ name, s, <span class="tok-builtin">@typeName</span>(T) });
                        b.markInvalidUserInput();
                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be an integer of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });
                        b.markInvalidUserInput();
                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    },
                };
                <span class="tok-kw">return</span> n;
            },
        },
        .float =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .list, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a float, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">const</span> n = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.parse_float.html#std.fmt.parse_float.parseFloat">parseFloat</a>(T, s) <span class="tok-kw">catch</span> {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a float of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                };
                <span class="tok-kw">return</span> n;
            },
        },
        .@&quot;enum&quot; =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .list, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be an enum, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(T, s)) |enum_lit| {
                    <span class="tok-kw">return</span> enum_lit;
                } <span class="tok-kw">else</span> {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
        },
        .string =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .list, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a string, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| <span class="tok-kw">return</span> s,
        },
        .build_id =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .list, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be an enum, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.BuildId.html">BuildId</a>.<a href="std.zig.BuildId.html#std.zig.BuildId.parse">parse</a>(s)) |build_id| {
                    <span class="tok-kw">return</span> build_id;
                } <span class="tok-kw">else</span> |err| {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;unable to parse option '-D{s}': {s}&quot;</span>, .{ name, <span class="tok-builtin">@errorName</span>(err) });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                }
            },
        },
        .list =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a list, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">return</span> b.allocator.dupe([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{s}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            .list =&gt; |lst| <span class="tok-kw">return</span> lst.items,
        },
        .enum_list =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .flag, .map, .lazy_path, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a list, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
            .scalar =&gt; |s| {
                <span class="tok-kw">const</span> Child = <span class="tok-builtin">@typeInfo</span>(T).pointer.child;
                <span class="tok-kw">const</span> value = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(Child, s) <span class="tok-kw">orelse</span> {
                    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(Child) });
                    b.markInvalidUserInput();
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                };
                <span class="tok-kw">return</span> b.allocator.dupe(Child, &amp;[_]Child{value}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            .list =&gt; |lst| {
                <span class="tok-kw">const</span> Child = <span class="tok-builtin">@typeInfo</span>(T).pointer.child;
                <span class="tok-kw">const</span> new_list = b.allocator.alloc(Child, lst.items.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                <span class="tok-kw">for</span> (new_list, lst.items) |*new_item, str| {
                    new_item.* = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(Child, str) <span class="tok-kw">orelse</span> {
                        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(Child) });
                        b.markInvalidUserInput();
                        b.allocator.free(new_list);
                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    };
                }
                <span class="tok-kw">return</span> new_list;
            },
        },
        .lazy_path =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .scalar =&gt; |s| <span class="tok-kw">return</span> .{ .cwd_relative = s },
            .lazy_path =&gt; |lp| <span class="tok-kw">return</span> lp,
            .flag, .map, .list, .lazy_path_list =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a path, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
        },
        .lazy_path_list =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {
            .scalar =&gt; |s| <span class="tok-kw">return</span> b.allocator.dupe(<a href="std.Build.LazyPath.html">LazyPath</a>, &amp;[_]<a href="std.Build.LazyPath.html">LazyPath</a>{.{ .cwd_relative = s }}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
            .lazy_path =&gt; |lp| <span class="tok-kw">return</span> b.allocator.dupe(<a href="std.Build.LazyPath.html">LazyPath</a>, &amp;[_]<a href="std.Build.LazyPath.html">LazyPath</a>{lp}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
            .list =&gt; |lst| {
                <span class="tok-kw">const</span> new_list = b.allocator.alloc(<a href="std.Build.LazyPath.html">LazyPath</a>, lst.items.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
                <span class="tok-kw">for</span> (new_list, lst.items) |*new_item, str| {
                    new_item.* = .{ .cwd_relative = str };
                }
                <span class="tok-kw">return</span> new_list;
            },
            .lazy_path_list =&gt; |lp_list| <span class="tok-kw">return</span> lp_list.items,
            .flag, .map =&gt; {
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Expected -D{s} to be a path, but received a {s}.&quot;</span>, .{
                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),
                });
                b.markInvalidUserInput();
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            },
        },
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a> {
    <span class="tok-kw">const</span> step_info = b.allocator.create(<a href="std.Build.TopLevelStep.html">TopLevelStep</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    step_info.* = .{
        .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
            .id = <a href="std.Build.TopLevelStep.html">TopLevelStep</a>.<a href="std.Build.TopLevelStep.html#std.Build.TopLevelStep.base_id">base_id</a>,
            .name = name,
            .owner = b,
        }),
        .description = b.dupe(description),
    };
    <span class="tok-kw">const</span> gop = b.top_level_steps.getOrPut(b.allocator, name) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">if</span> (gop.found_existing) <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;A top-level step with name \&quot;{s}\&quot; already exists&quot;</span>, .{name});

    gop.key_ptr.* = step_info.step.name;
    gop.value_ptr.* = step_info;

    <span class="tok-kw">return</span> &amp;step_info.step;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StandardOptimizeOptionOptions = <span class="tok-kw">struct</span> {
    preferred_optimize_mode: ?<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardOptimizeOption</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.StandardOptimizeOptionOptions.html">StandardOptimizeOptionOptions</a>) <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a> {
    <span class="tok-kw">if</span> (options.preferred_optimize_mode) |mode| {
        <span class="tok-kw">if</span> (b.option(<span class="tok-type">bool</span>, <span class="tok-str">&quot;release&quot;</span>, <span class="tok-str">&quot;optimize for end users&quot;</span>) <span class="tok-kw">orelse</span> (b.release_mode != .off)) {
            <span class="tok-kw">return</span> mode;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> .Debug;
        }
    }

    <span class="tok-kw">if</span> (b.option(
        <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.OptimizeMode.html">OptimizeMode</a>,
        <span class="tok-str">&quot;optimize&quot;</span>,
        <span class="tok-str">&quot;Prioritize performance, safety, or binary size&quot;</span>,
    )) |mode| {
        <span class="tok-kw">return</span> mode;
    }

    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (b.release_mode) {
        .off =&gt; .Debug,
        .any =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;the project does not declare a preferred optimization mode. choose: --release=fast, --release=safe, or --release=small\n&quot;</span>, .{});
            <a href="std.process.html">process</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
        },
        .fast =&gt; .ReleaseFast,
        .safe =&gt; .ReleaseSafe,
        .small =&gt; .ReleaseSmall,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StandardTargetOptionsArgs = <span class="tok-kw">struct</span> {
    whitelist: ?[]<span class="tok-kw">const</span> <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a> = <span class="tok-null">null</span>,
    default_target: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a> = .{},
};

<span class="tok-comment">/// Exposes standard `zig build` options for choosing a target and additionally</span>
<span class="tok-comment">/// resolves the target query.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptions</span>(b: *<a href="std.Build.html">Build</a>, args: <a href="std.Build.StandardTargetOptionsArgs.html">StandardTargetOptionsArgs</a>) <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> {
    <span class="tok-kw">const</span> query = b.standardTargetOptionsQueryOnly(args);
    <span class="tok-kw">return</span> b.resolveTargetQuery(query);
}

<span class="tok-comment">/// Obtain a target query from a string, reporting diagnostics to stderr if the</span>
<span class="tok-comment">/// parsing failed.</span>
<span class="tok-comment">/// Asserts that the `diagnostics` field of `options` is `null`. This use case</span>
<span class="tok-comment">/// is handled instead by calling `std.Target.Query.parse` directly.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseTargetQuery</span>(options: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.ParseOptions.html">ParseOptions</a>) <span class="tok-kw">error</span>{ParseFailed}!<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(options.diagnostics == <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> diags: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.ParseOptions.html">ParseOptions</a>.<a href="std.Target.Query.ParseOptions.Diagnostics.html">Diagnostics</a> = .{};
    <span class="tok-kw">var</span> opts_copy = options;
    opts_copy.diagnostics = &amp;diags;
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>.<a href="std.Target.Query.html#std.Target.Query.parse">parse</a>(opts_copy) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.UnknownCpuModel =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unknown CPU: '{s}'\navailable CPUs for architecture '{s}':\n&quot;</span>, .{
                diags.cpu_name.?, <span class="tok-builtin">@tagName</span>(diags.arch.?),
            });
            <span class="tok-kw">for</span> (diags.arch.?.allCpuModels()) |cpu| {
                <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot; {s}\n&quot;</span>, .{cpu.name});
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;
        },
        <span class="tok-kw">error</span>.UnknownCpuFeature =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(
                <span class="tok-str">\\unknown CPU feature: '{s}'</span>
                <span class="tok-str">\\available CPU features for architecture '{s}':</span>
                <span class="tok-str">\\</span>
            , .{
                diags.unknown_feature_name.?,
                <span class="tok-builtin">@tagName</span>(diags.arch.?),
            });
            <span class="tok-kw">for</span> (diags.arch.?.allFeaturesList()) |feature| {
                <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot; {s}: {s}\n&quot;</span>, .{ feature.name, feature.description });
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;
        },
        <span class="tok-kw">error</span>.UnknownOperatingSystem =&gt; {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(
                <span class="tok-str">\\unknown OS: '{s}'</span>
                <span class="tok-str">\\available operating systems:</span>
                <span class="tok-str">\\</span>
            , .{diags.os_name.?});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>.<a href="std.Target.Os.Tag.html">Tag</a>)) |field| {
                <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot; {s}\n&quot;</span>, .{field.name});
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;
        },
        <span class="tok-kw">else</span> =&gt; |e| {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to parse target '{s}': {s}\n&quot;</span>, .{
                options.arch_os_abi, <span class="tok-builtin">@errorName</span>(e),
            });
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;
        },
    };
}

<span class="tok-comment">/// Exposes standard `zig build` options for choosing a target.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptionsQueryOnly</span>(b: *<a href="std.Build.html">Build</a>, args: <a href="std.Build.StandardTargetOptionsArgs.html">StandardTargetOptionsArgs</a>) <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a> {
    <span class="tok-kw">const</span> maybe_triple = b.option(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;target&quot;</span>,
        <span class="tok-str">&quot;The CPU architecture, OS, and ABI to build for&quot;</span>,
    );
    <span class="tok-kw">const</span> mcpu = b.option(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;cpu&quot;</span>,
        <span class="tok-str">&quot;Target CPU features to add or subtract&quot;</span>,
    );
    <span class="tok-kw">const</span> ofmt = b.option(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;ofmt&quot;</span>,
        <span class="tok-str">&quot;Target object format&quot;</span>,
    );
    <span class="tok-kw">const</span> dynamic_linker = b.option(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <span class="tok-str">&quot;dynamic-linker&quot;</span>,
        <span class="tok-str">&quot;Path to interpreter on the target system&quot;</span>,
    );

    <span class="tok-kw">if</span> (maybe_triple == <span class="tok-null">null</span> <span class="tok-kw">and</span> mcpu == <span class="tok-null">null</span> <span class="tok-kw">and</span> ofmt == <span class="tok-null">null</span> <span class="tok-kw">and</span> dynamic_linker == <span class="tok-null">null</span>)
        <span class="tok-kw">return</span> args.default_target;

    <span class="tok-kw">const</span> triple = maybe_triple <span class="tok-kw">orelse</span> <span class="tok-str">&quot;native&quot;</span>;

    <span class="tok-kw">const</span> selected_target = <a href="std.Build.html#std.Build.parseTargetQuery">parseTargetQuery</a>(.{
        .arch_os_abi = triple,
        .cpu_features = mcpu,
        .object_format = ofmt,
        .dynamic_linker = dynamic_linker,
    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.ParseFailed =&gt; {
            b.markInvalidUserInput();
            <span class="tok-kw">return</span> args.default_target;
        },
    };

    <span class="tok-kw">const</span> whitelist = args.whitelist <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> selected_target;<span class="tok-comment">

    // Make sure it's a match of one of the list.
    </span><span class="tok-kw">for</span> (whitelist) |q| {
        <span class="tok-kw">if</span> (q.eql(selected_target))
            <span class="tok-kw">return</span> selected_target;
    }

    <span class="tok-kw">for</span> (whitelist) |q| {
        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.info">info</a>(<span class="tok-str">&quot;allowed target: -Dtarget={s} -Dcpu={s}&quot;</span>, .{
            q.zigTriple(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
            q.serializeCpuAlloc(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
        });
    }
    <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;chosen target '{s}' does not match one of the allowed targets&quot;</span>, .{
        selected_target.zigTriple(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
    });
    b.markInvalidUserInput();
    <span class="tok-kw">return</span> args.default_target;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputOption</span>(b: *<a href="std.Build.html">Build</a>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> name = b.dupe(name_raw);
    <span class="tok-kw">const</span> value = b.dupe(value_raw);
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> b.user_input_options.getOrPut(name);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.value_ptr.* = <a href="std.Build.UserInputOption.html">UserInputOption</a>{
            .name = name,
            .value = .{ .scalar = value },
            .used = <span class="tok-null">false</span>,
        };
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }<span class="tok-comment">

    // option already exists
    </span><span class="tok-kw">switch</span> (gop.value_ptr.value) {
        .scalar =&gt; |s| {<span class="tok-comment">
            // turn it into a list
            </span><span class="tok-kw">var</span> list = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(b.allocator);
            <span class="tok-kw">try</span> list.append(s);
            <span class="tok-kw">try</span> list.append(value);
            <span class="tok-kw">try</span> b.user_input_options.put(name, .{
                .name = name,
                .value = .{ .list = list },
                .used = <span class="tok-null">false</span>,
            });
        },
        .list =&gt; |*list| {<span class="tok-comment">
            // append to the list
            </span><span class="tok-kw">try</span> list.append(value);
            <span class="tok-kw">try</span> b.user_input_options.put(name, .{
                .name = name,
                .value = .{ .list = list.* },
                .used = <span class="tok-null">false</span>,
            });
        },
        .flag =&gt; {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;option '-D{s}={s}' conflicts with flag '-D{s}'.&quot;</span>, .{ name, value, name });
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .map =&gt; |*map| {
            _ = map;
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;TODO maps as command line arguments is not implemented yet.&quot;</span>, .{});
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .lazy_path, .lazy_path_list =&gt; {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.warn">warn</a>(<span class="tok-str">&quot;the lazy path value type isn't added from the CLI, but somehow '{s}' is a .{}&quot;</span>, .{ name, <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.fmtId">fmtId</a>(<span class="tok-builtin">@tagName</span>(gop.value_ptr.value)) });
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputFlag</span>(b: *<a href="std.Build.html">Build</a>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> name = b.dupe(name_raw);
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> b.user_input_options.getOrPut(name);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.value_ptr.* = .{
            .name = name,
            .value = .{ .flag = {} },
            .used = <span class="tok-null">false</span>,
        };
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }<span class="tok-comment">

    // option already exists
    </span><span class="tok-kw">switch</span> (gop.value_ptr.value) {
        .scalar =&gt; |s| {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Flag '-D{s}' conflicts with option '-D{s}={s}'.&quot;</span>, .{ name, name, s });
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .list, .map, .lazy_path_list =&gt; {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Flag '-D{s}' conflicts with multiple options of the same name.&quot;</span>, .{name});
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .lazy_path =&gt; |lp| {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;Flag '-D{s}' conflicts with option '-D{s}={s}'.&quot;</span>, .{ name, name, lp.getDisplayName() });
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },

        .flag =&gt; {},
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeToEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.Build.TypeId.html">TypeId</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (T) {
        <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.BuildId.html">BuildId</a> =&gt; .build_id,
        <a href="std.Build.LazyPath.html">LazyPath</a> =&gt; .lazy_path,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            .int =&gt; .int,
            .float =&gt; .float,
            .<span class="tok-type">bool</span> =&gt; .<span class="tok-type">bool</span>,
            .@&quot;enum&quot; =&gt; .@&quot;enum&quot;,
            .pointer =&gt; |pointer| <span class="tok-kw">switch</span> (pointer.child) {
                <span class="tok-type">u8</span> =&gt; .string,
                []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; .list,
                <a href="std.Build.LazyPath.html">LazyPath</a> =&gt; .lazy_path_list,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(pointer.child)) {
                    .@&quot;enum&quot; =&gt; .enum_list,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),
                },
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),
        },
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">markInvalidUserInput</span>(b: *<a href="std.Build.html">Build</a>) <span class="tok-type">void</span> {
    b.invalid_user_input = <span class="tok-null">true</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validateUserInputDidItFail</span>(b: *<a href="std.Build.html">Build</a>) <span class="tok-type">bool</span> {<span class="tok-comment">
    // Make sure all args are used.
    </span><span class="tok-kw">var</span> it = b.user_input_options.iterator();
    <span class="tok-kw">while</span> (it.next()) |entry| {
        <span class="tok-kw">if</span> (!entry.value_ptr.used) {
            <a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(<span class="tok-str">&quot;invalid option: -D{s}&quot;</span>, .{entry.key_ptr.*});
            b.markInvalidUserInput();
        }
    }

    <span class="tok-kw">return</span> b.invalid_user_input;
}

<span class="tok-kw">fn</span> <span class="tok-fn">allocPrintCmd</span>(ally: <a href="std.mem.Allocator.html">Allocator</a>, opt_cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{OutOfMemory}![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> buf = <a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(ally);
    <span class="tok-kw">if</span> (opt_cwd) |cwd| <span class="tok-kw">try</span> buf.writer().print(<span class="tok-str">&quot;cd {s} &amp;&amp; &quot;</span>, .{cwd});
    <span class="tok-kw">for</span> (argv) |arg| {
        <span class="tok-kw">try</span> buf.writer().print(<span class="tok-str">&quot;{s} &quot;</span>, .{arg});
    }
    <span class="tok-kw">return</span> buf.toOwnedSlice();
}

<span class="tok-kw">fn</span> <span class="tok-fn">printCmd</span>(ally: <a href="std.mem.Allocator.html">Allocator</a>, cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> text = <a href="std.Build.html#std.Build.allocPrintCmd">allocPrintCmd</a>(ally, cwd, argv) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{s}\n&quot;</span>, .{text});
}

<span class="tok-comment">/// This creates the install step and adds it to the dependencies of the</span>
<span class="tok-comment">/// top-level install step, using all the default options.</span>
<span class="tok-comment">/// See `addInstallArtifact` for a more flexible function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installArtifact</span>(b: *<a href="std.Build.html">Build</a>, artifact: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallArtifact(artifact, .{}).step);
}

<span class="tok-comment">/// This merely creates the step; it does not add it to the dependencies of the</span>
<span class="tok-comment">/// top-level install step.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallArtifact</span>(
    b: *<a href="std.Build.html">Build</a>,
    artifact: *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a>,
    options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a>.<a href="std.Build.Step.InstallArtifact.Options.html">Options</a>,
) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a>.<a href="std.Build.Step.InstallArtifact.html#std.Build.Step.InstallArtifact.create">create</a>(b, artifact, options);
}

<span class="tok-comment">///`dest_rel_path` is relative to prefix path</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallFileWithDir(b.path(src_path), .prefix, dest_rel_path).step);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installDirectory</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.Options.html">Options</a>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallDirectory(options).step);
}

<span class="tok-comment">///`dest_rel_path` is relative to bin path</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installBinFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallFileWithDir(b.path(src_path), .bin, dest_rel_path).step);
}

<span class="tok-comment">///`dest_rel_path` is relative to lib path</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installLibFile</span>(b: *<a href="std.Build.html">Build</a>, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.getInstallStep().dependOn(&amp;b.addInstallFileWithDir(b.path(src_path), .lib, dest_rel_path).step);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjCopy</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.ObjCopy.html">ObjCopy</a>.<a href="std.Build.Step.ObjCopy.html#std.Build.Step.ObjCopy.create">create</a>(b, source, options);
}

<span class="tok-comment">/// `dest_rel_path` is relative to install prefix path</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> b.addInstallFileWithDir(source, .prefix, dest_rel_path);
}

<span class="tok-comment">/// `dest_rel_path` is relative to bin path</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallBinFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> b.addInstallFileWithDir(source, .bin, dest_rel_path);
}

<span class="tok-comment">/// `dest_rel_path` is relative to lib path</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallLibFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> b.addInstallFileWithDir(source, .lib, dest_rel_path);
}

<span class="tok-comment">/// `dest_rel_path` is relative to header path</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallHeaderFile</span>(b: *<a href="std.Build.html">Build</a>, source: <a href="std.Build.LazyPath.html">LazyPath</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> b.addInstallFileWithDir(source, .header, dest_rel_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFileWithDir</span>(
    b: *<a href="std.Build.html">Build</a>,
    source: <a href="std.Build.LazyPath.html">LazyPath</a>,
    install_dir: <a href="std.Build.InstallDir.html">InstallDir</a>,
    dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallFile.html">InstallFile</a>.<a href="std.Build.Step.InstallFile.html#std.Build.Step.InstallFile.create">create</a>(b, source, install_dir, dest_rel_path);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallDirectory</span>(b: *<a href="std.Build.html">Build</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.Options.html">Options</a>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallDir.html">InstallDir</a>.<a href="std.Build.Step.InstallDir.html#std.Build.Step.InstallDir.create">create</a>(b, options);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCheckFile</span>(
    b: *<a href="std.Build.html">Build</a>,
    file_source: <a href="std.Build.LazyPath.html">LazyPath</a>,
    options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a>.<a href="std.Build.Step.CheckFile.Options.html">Options</a>,
) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a> {
    <span class="tok-kw">return</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.CheckFile.html">CheckFile</a>.<a href="std.Build.Step.CheckFile.html#std.Build.Step.CheckFile.create">create</a>(b, file_source, options);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncateFile</span>(b: *<a href="std.Build.html">Build</a>, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>.<a href="std.posix.html#std.posix.MakeDirError">MakeError</a> || <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.StatFileError">StatFileError</a>)!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (b.verbose) {
        <a href="std.log.html">log</a>.<a href="std.log.html#std.log.info">info</a>(<span class="tok-str">&quot;truncate {s}&quot;</span>, .{dest_path});
    }
    <span class="tok-kw">const</span> cwd = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>();
    <span class="tok-kw">var</span> src_file = cwd.createFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound =&gt; blk: {
            <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(dest_path)) |dirname| {
                <span class="tok-kw">try</span> cwd.makePath(dirname);
            }
            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> cwd.createFile(dest_path, .{});
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
    src_file.close();
}

<span class="tok-comment">/// References a file or directory relative to the source root.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">path</span>(b: *<a href="std.Build.html">Build</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(sub_path)) {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;sub_path is expected to be relative to the build root, but was this absolute path: '{s}'. It is best avoid absolute paths, but if you must, it is supported by LazyPath.cwd_relative&quot;</span>, .{
            sub_path,
        });
    }
    <span class="tok-kw">return</span> .{ .src_path = .{
        .owner = b,
        .sub_path = sub_path,
    } };
}

<span class="tok-comment">/// This is low-level implementation details of the build system, not meant to</span>
<span class="tok-comment">/// be called by users' build scripts. Even in the build system itself it is a</span>
<span class="tok-comment">/// code smell to call this function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathFromRoot</span>(b: *<a href="std.Build.html">Build</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> b.pathResolve(&amp;.{ b.build_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>, sub_path });
}

<span class="tok-kw">fn</span> <span class="tok-fn">pathFromCwd</span>(b: *<a href="std.Build.html">Build</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> cwd = <a href="std.process.html">process</a>.<a href="std.process.html#std.process.getCwdAlloc">getCwdAlloc</a>(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">return</span> b.pathResolve(&amp;.{ cwd, sub_path });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathJoin</span>(b: *<a href="std.Build.html">Build</a>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(b.allocator, paths) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathResolve</span>(b: *<a href="std.Build.html">Build</a>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(b.allocator, paths) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(b.allocator, format, args) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">supportedWindowsProgramExtension</span>(ext: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.WindowsExtension.html">WindowsExtension</a>).@&quot;enum&quot;.fields) |field| {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(ext, <span class="tok-str">&quot;.&quot;</span> ++ field.name)) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">tryFindProgram</span>(b: *<a href="std.Build.html">Build</a>, full_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.realpathAlloc">realpathAlloc</a>(b.allocator, full_path)) |p| {
        <span class="tok-kw">return</span> p;
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">if</span> (b.graph.env_map.get(<span class="tok-str">&quot;PATHEXT&quot;</span>)) |PATHEXT| {
            <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, PATHEXT, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.delimiter">delimiter</a>);

            <span class="tok-kw">while</span> (it.next()) |ext| {
                <span class="tok-kw">if</span> (!<a href="std.Build.html#std.Build.supportedWindowsProgramExtension">supportedWindowsProgramExtension</a>(ext)) <span class="tok-kw">continue</span>;

                <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.realpathAlloc">realpathAlloc</a>(b.allocator, b.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ full_path, ext })) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                };
            }
        }
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findProgram</span>(b: *<a href="std.Build.html">Build</a>, names: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{FileNotFound}![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {<span class="tok-comment">
    // TODO report error for ambiguous situations
    </span><span class="tok-kw">for</span> (b.search_prefixes.items) |search_prefix| {
        <span class="tok-kw">for</span> (names) |name| {
            <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(name)) {
                <span class="tok-kw">return</span> name;
            }
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.tryFindProgram">tryFindProgram</a>(b, b.pathJoin(&amp;.{ search_prefix, <span class="tok-str">&quot;bin&quot;</span>, name })) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        }
    }
    <span class="tok-kw">if</span> (b.graph.env_map.get(<span class="tok-str">&quot;PATH&quot;</span>)) |PATH| {
        <span class="tok-kw">for</span> (names) |name| {
            <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(name)) {
                <span class="tok-kw">return</span> name;
            }
            <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, PATH, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.delimiter">delimiter</a>);
            <span class="tok-kw">while</span> (it.next()) |p| {
                <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.tryFindProgram">tryFindProgram</a>(b, b.pathJoin(&amp;.{ p, name })) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            }
        }
    }
    <span class="tok-kw">for</span> (names) |name| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(name)) {
            <span class="tok-kw">return</span> name;
        }
        <span class="tok-kw">for</span> (paths) |p| {
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.tryFindProgram">tryFindProgram</a>(b, b.pathJoin(&amp;.{ p, name })) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runAllowFail</span>(
    b: *<a href="std.Build.html">Build</a>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    out_code: *<span class="tok-type">u8</span>,
    stderr_behavior: <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.StdIo.html">StdIo</a>,
) <a href="std.Build.html#std.Build.RunError">RunError</a>![]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(argv.len != <span class="tok-number">0</span>);

    <span class="tok-kw">if</span> (!<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a>)
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExecNotSupported;

    <span class="tok-kw">const</span> max_output_size = <span class="tok-number">400</span> * <span class="tok-number">1024</span>;
    <span class="tok-kw">var</span> child = <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.Child.html">Child</a>.<a href="std.process.Child.html#std.process.Child.init">init</a>(argv, b.allocator);
    child.stdin_behavior = .Ignore;
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = stderr_behavior;
    child.env_map = &amp;b.graph.env_map;

    <span class="tok-kw">try</span> <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.handleVerbose2">handleVerbose2</a>(b, <span class="tok-null">null</span>, child.env_map, argv);
    <span class="tok-kw">try</span> child.spawn();

    <span class="tok-kw">const</span> stdout = child.stdout.?.reader().readAllAlloc(b.allocator, max_output_size) <span class="tok-kw">catch</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadFailure;
    };
    <span class="tok-kw">errdefer</span> b.allocator.free(stdout);

    <span class="tok-kw">const</span> term = <span class="tok-kw">try</span> child.wait();
    <span class="tok-kw">switch</span> (term) {
        .Exited =&gt; |code| {
            <span class="tok-kw">if</span> (code != <span class="tok-number">0</span>) {
                out_code.* = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(code));
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExitCodeFailure;
            }
            <span class="tok-kw">return</span> stdout;
        },
        .Signal, .Stopped, .Unknown =&gt; |code| {
            out_code.* = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(code));
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessTerminated;
        },
    }
}

<span class="tok-comment">/// This is a helper function to be called from build.zig scripts, *not* from</span>
<span class="tok-comment">/// inside step make() functions. If any errors occur, it fails the build with</span>
<span class="tok-comment">/// a helpful message.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(b: *<a href="std.Build.html">Build</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (!<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a>) {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to spawn the following command: cannot spawn child process\n{s}\n&quot;</span>, .{
            <span class="tok-kw">try</span> <a href="std.Build.html#std.Build.allocPrintCmd">allocPrintCmd</a>(b.allocator, <span class="tok-null">null</span>, argv),
        });
        <a href="std.process.html">process</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
    }

    <span class="tok-kw">var</span> code: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> b.runAllowFail(argv, &amp;code, .Inherit) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">const</span> printed_cmd = <a href="std.Build.html#std.Build.allocPrintCmd">allocPrintCmd</a>(b.allocator, <span class="tok-null">null</span>, argv) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to spawn the following command: {s}\n{s}\n&quot;</span>, .{
            <span class="tok-builtin">@errorName</span>(err), printed_cmd,
        });
        <a href="std.process.html">process</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSearchPrefix</span>(b: *<a href="std.Build.html">Build</a>, search_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.search_prefixes.append(b.allocator, b.dupePath(search_prefix)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallPath</span>(b: *<a href="std.Build.html">Build</a>, dir: <a href="std.Build.InstallDir.html">InstallDir</a>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(dest_rel_path));<span class="tok-comment"> // Install paths must be relative to the prefix
    </span><span class="tok-kw">const</span> base_dir = <span class="tok-kw">switch</span> (dir) {
        .prefix =&gt; b.install_path,
        .bin =&gt; b.exe_dir,
        .lib =&gt; b.lib_dir,
        .header =&gt; b.h_dir,
        .custom =&gt; |p| b.pathJoin(&amp;.{ b.install_path, p }),
    };
    <span class="tok-kw">return</span> b.pathResolve(&amp;.{ base_dir, dest_rel_path });
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Dependency = <span class="tok-kw">struct</span> {
    builder: *<a href="std.Build.html">Build</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">artifact</span>(d: *<a href="std.Build.Dependency.html">Dependency</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> {
        <span class="tok-kw">var</span> found: ?*<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Compile.html">Compile</a> = <span class="tok-null">null</span>;
        <span class="tok-kw">for</span> (d.builder.install_tls.step.dependencies.items) |dep_step| {
            <span class="tok-kw">const</span> inst = dep_step.cast(<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, inst.artifact.name, name)) {
                <span class="tok-kw">if</span> (found != <span class="tok-null">null</span>) <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;artifact name '{s}' is ambiguous&quot;</span>, .{name});
                found = inst.artifact;
            }
        }
        <span class="tok-kw">return</span> found <span class="tok-kw">orelse</span> {
            <span class="tok-kw">for</span> (d.builder.install_tls.step.dependencies.items) |dep_step| {
                <span class="tok-kw">const</span> inst = dep_step.cast(<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.InstallArtifact.html">InstallArtifact</a>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;
                <a href="std.log.html">log</a>.<a href="std.log.html#std.log.info">info</a>(<span class="tok-str">&quot;available artifact: '{s}'&quot;</span>, .{inst.artifact.name});
            }
            <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unable to find artifact '{s}'&quot;</span>, .{name});
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">module</span>(d: *<a href="std.Build.Dependency.html">Dependency</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Module.html">Module</a> {
        <span class="tok-kw">return</span> d.builder.modules.get(name) <span class="tok-kw">orelse</span> {
            <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unable to find module '{s}'&quot;</span>, .{name});
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">namedWriteFiles</span>(d: *<a href="std.Build.Dependency.html">Dependency</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
        <span class="tok-kw">return</span> d.builder.named_writefiles.get(name) <span class="tok-kw">orelse</span> {
            <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unable to find named writefiles '{s}'&quot;</span>, .{name});
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">namedLazyPath</span>(d: *<a href="std.Build.Dependency.html">Dependency</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.Build.LazyPath.html">LazyPath</a> {
        <span class="tok-kw">return</span> d.builder.named_lazy_paths.get(name) <span class="tok-kw">orelse</span> {
            <a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unable to find named lazypath '{s}'&quot;</span>, .{name});
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">path</span>(d: *<a href="std.Build.Dependency.html">Dependency</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.Build.LazyPath.html">LazyPath</a> {
        <span class="tok-kw">return</span> .{
            .dependency = .{
                .dependency = d,
                .sub_path = sub_path,
            },
        };
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">findPkgHashOrFatal</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">for</span> (b.available_deps) |dep| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, dep[<span class="tok-number">0</span>], name)) <span class="tok-kw">return</span> dep[<span class="tok-number">1</span>];
    }

    <span class="tok-kw">const</span> full_path = b.pathFromRoot(<span class="tok-str">&quot;build.zig.zon&quot;</span>);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;no dependency named '{s}' in '{s}'. All packages used in build.zig must be declared in this file&quot;</span>, .{ name, full_path });
}

<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">findImportPkgHashOrFatal</span>(b: *<a href="std.Build.html">Build</a>, <span class="tok-kw">comptime</span> asking_build_zig: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;

    <span class="tok-kw">const</span> b_pkg_hash, <span class="tok-kw">const</span> b_pkg_deps = <span class="tok-kw">comptime</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
        <span class="tok-kw">const</span> pkg_hash = decl.name;
        <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, pkg_hash);
        <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>) <span class="tok-kw">and</span> pkg.build_zig == asking_build_zig) <span class="tok-kw">break</span> .{ pkg_hash, pkg.deps };
    } <span class="tok-kw">else</span> .{ <span class="tok-str">&quot;&quot;</span>, deps.root_deps };
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, b_pkg_hash, b.pkg_hash)) {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;'{}' is not the struct that corresponds to '{s}'&quot;</span>, .{ asking_build_zig, b.pathFromRoot(<span class="tok-str">&quot;build.zig&quot;</span>) });
    }
    <span class="tok-kw">comptime</span> <span class="tok-kw">for</span> (b_pkg_deps) |dep| {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, dep[<span class="tok-number">0</span>], dep_name)) <span class="tok-kw">return</span> dep[<span class="tok-number">1</span>];
    };

    <span class="tok-kw">const</span> full_path = b.pathFromRoot(<span class="tok-str">&quot;build.zig.zon&quot;</span>);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;no dependency named '{s}' in '{s}'. All packages used in build.zig must be declared in this file&quot;</span>, .{ dep_name, full_path });
}

<span class="tok-kw">fn</span> <span class="tok-fn">markNeededLazyDep</span>(b: *<a href="std.Build.html">Build</a>, pkg_hash: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    b.graph.needed_lazy_dependencies.put(b.graph.arena, pkg_hash, {}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-comment">/// When this function is called, it means that the current build does, in</span>
<span class="tok-comment">/// fact, require this dependency. If the dependency is already fetched, it</span>
<span class="tok-comment">/// proceeds in the same manner as `dependency`. However if the dependency was</span>
<span class="tok-comment">/// not fetched, then when the build script is finished running, the build will</span>
<span class="tok-comment">/// not proceed to the make phase. Instead, the parent process will</span>
<span class="tok-comment">/// additionally fetch all the lazy dependencies that were actually required by</span>
<span class="tok-comment">/// running the build script, rebuild the build script, and then run it again.</span>
<span class="tok-comment">/// In other words, if this function returns `null` it means that the only</span>
<span class="tok-comment">/// purpose of completing the configure phase is to find out all the other lazy</span>
<span class="tok-comment">/// dependencies that are also required.</span>
<span class="tok-comment">/// It is allowed to use this function for non-lazy dependencies, in which case</span>
<span class="tok-comment">/// it will never return `null`. This allows toggling laziness via</span>
<span class="tok-comment">/// build.zig.zon without changing build.zig logic.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lazyDependency</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) ?*<a href="std.Build.Dependency.html">Dependency</a> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;
    <span class="tok-kw">const</span> pkg_hash = <a href="std.Build.html#std.Build.findPkgHashOrFatal">findPkgHashOrFatal</a>(b, name);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {
            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);
            <span class="tok-kw">const</span> available = !<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;available&quot;</span>) <span class="tok-kw">or</span> pkg.available;
            <span class="tok-kw">if</span> (!available) {
                <a href="std.Build.html#std.Build.markNeededLazyDep">markNeededLazyDep</a>(b, pkg_hash);
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dependencyInner">dependencyInner</a>(b, name, pkg.build_root, <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>)) pkg.build_zig <span class="tok-kw">else</span> <span class="tok-null">null</span>, pkg_hash, pkg.deps, args);
        }
    }

    <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // Bad @dependencies source
</span>}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependency</span>(b: *<a href="std.Build.html">Build</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) *<a href="std.Build.Dependency.html">Dependency</a> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;
    <span class="tok-kw">const</span> pkg_hash = <a href="std.Build.html#std.Build.findPkgHashOrFatal">findPkgHashOrFatal</a>(b, name);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {
            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;available&quot;</span>)) {
                <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;dependency '{s}{s}' is marked as lazy in build.zig.zon which means it must use the lazyDependency function instead&quot;</span>, .{ b.dep_prefix, name });
            }
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dependencyInner">dependencyInner</a>(b, name, pkg.build_root, <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>)) pkg.build_zig <span class="tok-kw">else</span> <span class="tok-null">null</span>, pkg_hash, pkg.deps, args);
        }
    }

    <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // Bad @dependencies source
</span>}

<span class="tok-comment">/// In a build.zig file, this function is to `@import` what `lazyDependency` is to `dependency`.</span>
<span class="tok-comment">/// If the dependency is lazy and has not yet been fetched, it instructs the parent process to fetch</span>
<span class="tok-comment">/// that dependency after the build script has finished running, then returns `null`.</span>
<span class="tok-comment">/// If the dependency is lazy but has already been fetched, or if it is eager, it returns</span>
<span class="tok-comment">/// the build.zig struct of that dependency, just like a regular `@import`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">lazyImport</span>(
    b: *<a href="std.Build.html">Build</a>,
    <span class="tok-comment">/// The build.zig struct of the package importing the dependency.</span>
    <span class="tok-comment">/// When calling this function from the `build` function of a build.zig file's, you normally</span>
    <span class="tok-comment">/// pass `@This()`.</span>
    <span class="tok-kw">comptime</span> asking_build_zig: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) ?<span class="tok-type">type</span> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;
    <span class="tok-kw">const</span> pkg_hash = <a href="std.Build.html#std.Build.findImportPkgHashOrFatal">findImportPkgHashOrFatal</a>(b, asking_build_zig, dep_name);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {
            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);
            <span class="tok-kw">const</span> available = !<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;available&quot;</span>) <span class="tok-kw">or</span> pkg.available;
            <span class="tok-kw">if</span> (!available) {
                <a href="std.Build.html#std.Build.markNeededLazyDep">markNeededLazyDep</a>(b, pkg_hash);
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>))
                pkg.build_zig
            <span class="tok-kw">else</span>
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;dependency '&quot;</span> ++ dep_name ++ <span class="tok-str">&quot;' does not have a build.zig&quot;</span>);
        }
    }

    <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // Bad @dependencies source
</span>}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependencyFromBuildZig</span>(
    b: *<a href="std.Build.html">Build</a>,
    <span class="tok-comment">/// The build.zig struct of the dependency, normally obtained by `@import` of the dependency.</span>
    <span class="tok-comment">/// If called from the build.zig file itself, use `@This` to obtain a reference to the struct.</span>
    <span class="tok-kw">comptime</span> build_zig: <span class="tok-type">type</span>,
    args: <span class="tok-kw">anytype</span>,
) *<a href="std.Build.Dependency.html">Dependency</a> {
    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
    <span class="tok-kw">const</span> deps = build_runner.dependencies;

    find_dep: {
        <span class="tok-kw">const</span> pkg, <span class="tok-kw">const</span> pkg_hash = <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).@&quot;struct&quot;.decls) |decl| {
            <span class="tok-kw">const</span> pkg_hash = decl.name;
            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, pkg_hash);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>) <span class="tok-kw">and</span> pkg.build_zig == build_zig) <span class="tok-kw">break</span> .{ pkg, pkg_hash };
        } <span class="tok-kw">else</span> <span class="tok-kw">break</span> :find_dep;
        <span class="tok-kw">const</span> dep_name = <span class="tok-kw">for</span> (b.available_deps) |dep| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, dep[<span class="tok-number">1</span>], pkg_hash)) <span class="tok-kw">break</span> dep[<span class="tok-number">1</span>];
        } <span class="tok-kw">else</span> <span class="tok-kw">break</span> :find_dep;
        <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.dependencyInner">dependencyInner</a>(b, dep_name, pkg.build_root, pkg.build_zig, pkg_hash, pkg.deps, args);
    }

    <span class="tok-kw">const</span> full_path = b.pathFromRoot(<span class="tok-str">&quot;build.zig.zon&quot;</span>);
    <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;'{}' is not a build.zig struct of a dependency in '{s}'&quot;</span>, .{ build_zig, full_path });
}

<span class="tok-kw">fn</span> <span class="tok-fn">userValuesAreSame</span>(lhs: <a href="std.Build.UserValue.html">UserValue</a>, rhs: <a href="std.Build.UserValue.html">UserValue</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.activeTag">activeTag</a>(lhs) != rhs) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">switch</span> (lhs) {
        .flag =&gt; {},
        .scalar =&gt; |lhs_scalar| {
            <span class="tok-kw">const</span> rhs_scalar = rhs.scalar;

            <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_scalar, rhs_scalar))
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
        .list =&gt; |lhs_list| {
            <span class="tok-kw">const</span> rhs_list = rhs.list;

            <span class="tok-kw">if</span> (lhs_list.items.len != rhs_list.items.len)
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;

            <span class="tok-kw">for</span> (lhs_list.items, rhs_list.items) |lhs_list_entry, rhs_list_entry| {
                <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_list_entry, rhs_list_entry))
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
        },
        .map =&gt; |lhs_map| {
            <span class="tok-kw">const</span> rhs_map = rhs.map;

            <span class="tok-kw">if</span> (lhs_map.count() != rhs_map.count())
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;

            <span class="tok-kw">var</span> lhs_it = lhs_map.iterator();
            <span class="tok-kw">while</span> (lhs_it.next()) |lhs_entry| {
                <span class="tok-kw">const</span> rhs_value = rhs_map.get(lhs_entry.key_ptr.*) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                <span class="tok-kw">if</span> (!<a href="std.Build.html#std.Build.userValuesAreSame">userValuesAreSame</a>(lhs_entry.value_ptr.*.*, rhs_value.*))
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
        },
        .lazy_path =&gt; |lhs_lp| {
            <span class="tok-kw">const</span> rhs_lp = rhs.lazy_path;
            <span class="tok-kw">return</span> <a href="std.Build.html#std.Build.userLazyPathsAreTheSame">userLazyPathsAreTheSame</a>(lhs_lp, rhs_lp);
        },
        .lazy_path_list =&gt; |lhs_lp_list| {
            <span class="tok-kw">const</span> rhs_lp_list = rhs.lazy_path_list;
            <span class="tok-kw">if</span> (lhs_lp_list.items.len != rhs_lp_list.items.len) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">for</span> (lhs_lp_list.items, rhs_lp_list.items) |lhs_lp, rhs_lp| {
                <span class="tok-kw">if</span> (!<a href="std.Build.html#std.Build.userLazyPathsAreTheSame">userLazyPathsAreTheSame</a>(lhs_lp, rhs_lp)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
    }

    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">userLazyPathsAreTheSame</span>(lhs_lp: <a href="std.Build.LazyPath.html">LazyPath</a>, rhs_lp: <a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.activeTag">activeTag</a>(lhs_lp) != rhs_lp) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">switch</span> (lhs_lp) {
        .src_path =&gt; |lhs_sp| {
            <span class="tok-kw">const</span> rhs_sp = rhs_lp.src_path;

            <span class="tok-kw">if</span> (lhs_sp.owner != rhs_sp.owner) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_sp.sub_path, rhs_sp.sub_path)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
        .generated =&gt; |lhs_gen| {
            <span class="tok-kw">const</span> rhs_gen = rhs_lp.generated;

            <span class="tok-kw">if</span> (lhs_gen.file != rhs_gen.file) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">if</span> (lhs_gen.up != rhs_gen.up) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_gen.sub_path, rhs_gen.sub_path)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
        .cwd_relative =&gt; |lhs_rel_path| {
            <span class="tok-kw">const</span> rhs_rel_path = rhs_lp.cwd_relative;

            <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_rel_path, rhs_rel_path)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
        .dependency =&gt; |lhs_dep| {
            <span class="tok-kw">const</span> rhs_dep = rhs_lp.dependency;

            <span class="tok-kw">if</span> (lhs_dep.dependency != rhs_dep.dependency) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_dep.sub_path, rhs_dep.sub_path)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">dependencyInner</span>(
    b: *<a href="std.Build.html">Build</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    build_root_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    <span class="tok-kw">comptime</span> build_zig: ?<span class="tok-type">type</span>,
    pkg_hash: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    pkg_deps: <a href="std.Build.html#std.Build.AvailableDeps">AvailableDeps</a>,
    args: <span class="tok-kw">anytype</span>,
) *<a href="std.Build.Dependency.html">Dependency</a> {
    <span class="tok-kw">const</span> user_input_options = <a href="std.Build.html#std.Build.userInputOptionsFromArgs">userInputOptionsFromArgs</a>(b.allocator, args);
    <span class="tok-kw">if</span> (b.graph.dependency_cache.getContext(.{
        .build_root_string = build_root_string,
        .user_input_options = user_input_options,
    }, .{ .allocator = b.graph.arena })) |dep|
        <span class="tok-kw">return</span> dep;

    <span class="tok-kw">const</span> build_root: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a> = .{
        .path = build_root_string,
        .handle = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openDir(build_root_string, .{}) <span class="tok-kw">catch</span> |err| {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to open '{s}': {s}\n&quot;</span>, .{
                build_root_string, <span class="tok-builtin">@errorName</span>(err),
            });
            <a href="std.process.html">process</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
        },
    };

    <span class="tok-kw">const</span> sub_builder = b.createChild(name, build_root, pkg_hash, pkg_deps, user_input_options) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>);
    <span class="tok-kw">if</span> (build_zig) |bz| {
        sub_builder.runBuild(bz) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>);

        <span class="tok-kw">if</span> (sub_builder.validateUserInputDidItFail()) {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.dumpCurrentStackTrace">dumpCurrentStackTrace</a>(<span class="tok-builtin">@returnAddress</span>());
        }
    }

    <span class="tok-kw">const</span> dep = b.allocator.create(<a href="std.Build.Dependency.html">Dependency</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    dep.* = .{ .builder = sub_builder };

    b.graph.dependency_cache.putContext(b.graph.arena, .{
        .build_root_string = build_root_string,
        .user_input_options = user_input_options,
    }, dep, .{ .allocator = b.graph.arena }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">return</span> dep;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runBuild</span>(b: *<a href="std.Build.html">Build</a>, build_zig: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(build_zig.build)).@&quot;fn&quot;.return_type.?)) {
        .<span class="tok-type">void</span> =&gt; build_zig.build(b),
        .error_union =&gt; <span class="tok-kw">try</span> build_zig.build(b),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected return type of build to be 'void' or '!void'&quot;</span>),
    }
}

<span class="tok-comment">/// A file that is generated by a build step.</span>
<span class="tok-comment">/// This struct is an interface that is meant to be used with `@fieldParentPtr` to implement the actual path logic.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GeneratedFile = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The step that generates the file</span>
    step: *<a href="std.Build.Step.html">Step</a>,

    <span class="tok-comment">/// The path to the generated file. Must be either absolute or relative to the build root.</span>
    <span class="tok-comment">/// This value must be set in the `fn make()` of the `step` and must not be `null` afterwards.</span>
    path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath</span>(gen: <a href="std.Build.GeneratedFile.html">GeneratedFile</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> gen.step.owner.pathFromRoot(gen.path <span class="tok-kw">orelse</span> <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(
            <span class="tok-str">&quot;getPath() was called on a GeneratedFile that wasn't built yet. Is there a missing Step dependency on step '{s}'?&quot;</span>,
            .{gen.step.name},
        ));
    }
};<span class="tok-comment">

// dirnameAllowEmpty is a variant of fs.path.dirname
// that allows &quot;&quot; to refer to the root for relative paths.
//
// For context, dirname(&quot;foo&quot;) and dirname(&quot;&quot;) are both null.
// However, for relative paths, we want dirname(&quot;foo&quot;) to be &quot;&quot;
// so that we can join it with another path (e.g. build root, cache root, etc.)
//
// dirname(&quot;&quot;) should still be null, because we can't go up any further.
</span><span class="tok-kw">fn</span> <span class="tok-fn">dirnameAllowEmpty</span>(full_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(full_path) <span class="tok-kw">orelse</span> {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(full_path) <span class="tok-kw">or</span> full_path.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

        <span class="tok-kw">return</span> <span class="tok-str">&quot;&quot;</span>;
    };
}

<span class="tok-kw">test</span> dirnameAllowEmpty {
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(
        <span class="tok-str">&quot;foo&quot;</span>,
        <a href="std.Build.html#std.Build.dirnameAllowEmpty">dirnameAllowEmpty</a>(<span class="tok-str">&quot;foo&quot;</span> ++ <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep_str">sep_str</a> ++ <span class="tok-str">&quot;bar&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected null&quot;</span>),
    );

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(
        <span class="tok-str">&quot;&quot;</span>,
        <a href="std.Build.html#std.Build.dirnameAllowEmpty">dirnameAllowEmpty</a>(<span class="tok-str">&quot;foo&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected null&quot;</span>),
    );

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.Build.html#std.Build.dirnameAllowEmpty">dirnameAllowEmpty</a>(<span class="tok-str">&quot;&quot;</span>) == <span class="tok-null">null</span>);
}

<span class="tok-comment">/// A reference to an existing or future path.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> LazyPath = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    <span class="tok-comment">/// A source file path relative to build root.</span>
    src_path: <span class="tok-kw">struct</span> {
        owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>,
        sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    },

    generated: <span class="tok-kw">struct</span> {
        file: *<span class="tok-kw">const</span> <a href="std.Build.GeneratedFile.html">GeneratedFile</a>,

        <span class="tok-comment">/// The number of parent directories to go up.</span>
        <span class="tok-comment">/// 0 means the generated file itself.</span>
        <span class="tok-comment">/// 1 means the directory of the generated file.</span>
        <span class="tok-comment">/// 2 means the parent of that directory, and so on.</span>
        up: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-comment">/// Applied after `up`.</span>
        sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,
    },

    <span class="tok-comment">/// An absolute path or a path relative to the current working directory of</span>
    <span class="tok-comment">/// the build runner process.</span>
    <span class="tok-comment">/// This is uncommon but used for system environment paths such as `--zig-lib-dir` which</span>
    <span class="tok-comment">/// ignore the file system path of build.zig and instead are relative to the directory from</span>
    <span class="tok-comment">/// which `zig build` was invoked.</span>
    <span class="tok-comment">/// Use of this tag indicates a dependency on the host system.</span>
    cwd_relative: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    dependency: <span class="tok-kw">struct</span> {
        dependency: *<a href="std.Build.Dependency.html">Dependency</a>,
        sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    },

    <span class="tok-comment">/// Returns a lazy path referring to the directory containing this path.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The dirname is not allowed to escape the logical root for underlying path.</span>
    <span class="tok-comment">/// For example, if the path is relative to the build root,</span>
    <span class="tok-comment">/// the dirname is not allowed to traverse outside of the build root.</span>
    <span class="tok-comment">/// Similarly, if the path is a generated file inside zig-cache,</span>
    <span class="tok-comment">/// the dirname is not allowed to traverse outside of zig-cache.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dirname</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (lazy_path) {
            .src_path =&gt; |sp| .{ .src_path = .{
                .owner = sp.owner,
                .sub_path = <a href="std.Build.html#std.Build.dirnameAllowEmpty">dirnameAllowEmpty</a>(sp.sub_path) <span class="tok-kw">orelse</span> {
                    <a href="std.Build.html#std.Build.dumpBadDirnameHelp">dumpBadDirnameHelp</a>(<span class="tok-null">null</span>, <span class="tok-null">null</span>, <span class="tok-str">&quot;dirname() attempted to traverse outside the build root\n&quot;</span>, .{}) <span class="tok-kw">catch</span> {};
                    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);
                },
            } },
            .generated =&gt; |generated| .{ .generated = <span class="tok-kw">if</span> (<a href="std.Build.html#std.Build.dirnameAllowEmpty">dirnameAllowEmpty</a>(generated.sub_path)) |sub_dirname| .{
                .file = generated.file,
                .up = generated.up,
                .sub_path = sub_dirname,
            } <span class="tok-kw">else</span> .{
                .file = generated.file,
                .up = generated.up + <span class="tok-number">1</span>,
                .sub_path = <span class="tok-str">&quot;&quot;</span>,
            } },
            .cwd_relative =&gt; |rel_path| .{
                .cwd_relative = <a href="std.Build.html#std.Build.dirnameAllowEmpty">dirnameAllowEmpty</a>(rel_path) <span class="tok-kw">orelse</span> {<span class="tok-comment">
                    // If we get null, it means one of two things:
                    // - rel_path was absolute, and is now root
                    // - rel_path was relative, and is now &quot;&quot;
                    // In either case, the build script tried to go too far
                    // and we should panic.
                    </span><span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.isAbsolute">isAbsolute</a>(rel_path)) {
                        <a href="std.Build.html#std.Build.dumpBadDirnameHelp">dumpBadDirnameHelp</a>(<span class="tok-null">null</span>, <span class="tok-null">null</span>,
                            <span class="tok-str">\\dirname() attempted to traverse outside the root.</span>
                            <span class="tok-str">\\No more directories left to go up.</span>
                            <span class="tok-str">\\</span>
                        , .{}) <span class="tok-kw">catch</span> {};
                        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);
                    } <span class="tok-kw">else</span> {
                        <a href="std.Build.html#std.Build.dumpBadDirnameHelp">dumpBadDirnameHelp</a>(<span class="tok-null">null</span>, <span class="tok-null">null</span>,
                            <span class="tok-str">\\dirname() attempted to traverse outside the current working directory.</span>
                            <span class="tok-str">\\</span>
                        , .{}) <span class="tok-kw">catch</span> {};
                        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);
                    }
                },
            },
            .dependency =&gt; |dep| .{ .dependency = .{
                .dependency = dep.dependency,
                .sub_path = <a href="std.Build.html#std.Build.dirnameAllowEmpty">dirnameAllowEmpty</a>(dep.sub_path) <span class="tok-kw">orelse</span> {
                    <a href="std.Build.html#std.Build.dumpBadDirnameHelp">dumpBadDirnameHelp</a>(<span class="tok-null">null</span>, <span class="tok-null">null</span>,
                        <span class="tok-str">\\dirname() attempted to traverse outside the dependency root.</span>
                        <span class="tok-str">\\</span>
                    , .{}) <span class="tok-kw">catch</span> {};
                    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);
                },
            } },
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">path</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>, b: *<a href="std.Build.html">Build</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.Build.LazyPath.html">LazyPath</a> {
        <span class="tok-kw">return</span> lazy_path.join(b.allocator, sub_path) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>, arena: <a href="std.mem.Allocator.html">Allocator</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.Build.LazyPath.html">LazyPath</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (lazy_path) {
            .src_path =&gt; |src| .{ .src_path = .{
                .owner = src.owner,
                .sub_path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(arena, &amp;.{ src.sub_path, sub_path }),
            } },
            .generated =&gt; |gen| .{ .generated = .{
                .file = gen.file,
                .up = gen.up,
                .sub_path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(arena, &amp;.{ gen.sub_path, sub_path }),
            } },
            .cwd_relative =&gt; |cwd_relative| .{
                .cwd_relative = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(arena, &amp;.{ cwd_relative, sub_path }),
            },
            .dependency =&gt; |dep| .{ .dependency = .{
                .dependency = dep.dependency,
                .sub_path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(arena, &amp;.{ dep.sub_path, sub_path }),
            } },
        };
    }

    <span class="tok-comment">/// Returns a string that can be shown to represent the file source.</span>
    <span class="tok-comment">/// Either returns the path, `&quot;generated&quot;`, or `&quot;dependency&quot;`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDisplayName</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (lazy_path) {
            .src_path =&gt; |sp| sp.sub_path,
            .cwd_relative =&gt; |p| p,
            .generated =&gt; <span class="tok-str">&quot;generated&quot;</span>,
            .dependency =&gt; <span class="tok-str">&quot;dependency&quot;</span>,
        };
    }

    <span class="tok-comment">/// Adds dependencies this file source implies to the given step.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addStepDependencies</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>, other_step: *<a href="std.Build.Step.html">Step</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (lazy_path) {
            .src_path, .cwd_relative, .dependency =&gt; {},
            .generated =&gt; |gen| other_step.dependOn(gen.file.step),
        }
    }

    <span class="tok-comment">/// Deprecated, see `getPath3`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>, src_builder: *<a href="std.Build.html">Build</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <a href="std.Build.LazyPath.html#std.Build.LazyPath.getPath2">getPath2</a>(lazy_path, src_builder, <span class="tok-null">null</span>);
    }

    <span class="tok-comment">/// Deprecated, see `getPath3`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath2</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>, src_builder: *<a href="std.Build.html">Build</a>, asking_step: ?*<a href="std.Build.Step.html">Step</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> p = <a href="std.Build.LazyPath.html#std.Build.LazyPath.getPath3">getPath3</a>(lazy_path, src_builder, asking_step);
        <span class="tok-kw">return</span> src_builder.pathResolve(&amp;.{ p.root_dir.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>, p.sub_path });
    }

    <span class="tok-comment">/// Intended to be used during the make phase only.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `asking_step` is only used for debugging purposes; it's the step being</span>
    <span class="tok-comment">/// run that is asking for the path.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath3</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>, src_builder: *<a href="std.Build.html">Build</a>, asking_step: ?*<a href="std.Build.Step.html">Step</a>) <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Path.html">Path</a> {
        <span class="tok-kw">switch</span> (lazy_path) {
            .src_path =&gt; |sp| <span class="tok-kw">return</span> .{
                .root_dir = sp.owner.build_root,
                .sub_path = sp.sub_path,
            },
            .cwd_relative =&gt; |sub_path| <span class="tok-kw">return</span> .{
                .root_dir = <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>.<a href="std.Build.Cache.Directory.html#std.Build.Cache.Directory.cwd">cwd</a>(),
                .sub_path = sub_path,
            },
            .generated =&gt; |gen| {<span class="tok-comment">
                // TODO make gen.file.path not be absolute and use that as the
                // basis for not traversing up too many directories.

                </span><span class="tok-kw">var</span> file_path: <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Path.html">Path</a> = .{
                    .root_dir = <a href="std.Build.Cache.html">Cache</a>.<a href="std.Build.Cache.Directory.html">Directory</a>.<a href="std.Build.Cache.Directory.html#std.Build.Cache.Directory.cwd">cwd</a>(),
                    .sub_path = gen.file.path <span class="tok-kw">orelse</span> {
                        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
                        <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();
                        <a href="std.Build.html#std.Build.dumpBadGetPathHelp">dumpBadGetPathHelp</a>(gen.file.step, stderr, src_builder, asking_step) <span class="tok-kw">catch</span> {};
                        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();
                        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);
                    },
                };

                <span class="tok-kw">if</span> (gen.up &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> cache_root_path = src_builder.cache_root.path <span class="tok-kw">orelse</span>
                        (src_builder.cache_root.join(src_builder.allocator, &amp;.{<span class="tok-str">&quot;.&quot;</span>}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>));

                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..gen.up) |_| {
                        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, file_path.sub_path, cache_root_path)) {<span class="tok-comment">
                            // If we hit the cache root and there's still more to go,
                            // the script attempted to go too far.
                            </span><a href="std.Build.html#std.Build.dumpBadDirnameHelp">dumpBadDirnameHelp</a>(gen.file.step, asking_step,
                                <span class="tok-str">\\dirname() attempted to traverse outside the cache root.</span>
                                <span class="tok-str">\\This is not allowed.</span>
                                <span class="tok-str">\\</span>
                            , .{}) <span class="tok-kw">catch</span> {};
                            <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);
                        }<span class="tok-comment">

                        // path is absolute.
                        // dirname will return null only if we're at root.
                        // Typically, we'll stop well before that at the cache root.
                        </span>file_path.sub_path = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(file_path.sub_path) <span class="tok-kw">orelse</span> {
                            <a href="std.Build.html#std.Build.dumpBadDirnameHelp">dumpBadDirnameHelp</a>(gen.file.step, asking_step,
                                <span class="tok-str">\\dirname() reached root.</span>
                                <span class="tok-str">\\No more directories left to go up.</span>
                                <span class="tok-str">\\</span>
                            , .{}) <span class="tok-kw">catch</span> {};
                            <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);
                        };
                    }
                }

                <span class="tok-kw">return</span> file_path.join(src_builder.allocator, gen.sub_path) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
            },
            .dependency =&gt; |dep| <span class="tok-kw">return</span> .{
                .root_dir = dep.dependency.builder.build_root,
                .sub_path = dep.sub_path,
            },
        }
    }

    <span class="tok-comment">/// Copies the internal strings.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The `b` parameter is only used for its allocator. All *Build instances</span>
    <span class="tok-comment">/// share the same allocator.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>, b: *<a href="std.Build.html">Build</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
        <span class="tok-kw">return</span> lazy_path.dupeInner(b.allocator);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">dupeInner</span>(lazy_path: <a href="std.Build.LazyPath.html">LazyPath</a>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <a href="std.Build.LazyPath.html">LazyPath</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (lazy_path) {
            .src_path =&gt; |sp| .{ .src_path = .{
                .owner = sp.owner,
                .sub_path = sp.owner.dupePath(sp.sub_path),
            } },
            .cwd_relative =&gt; |p| .{ .cwd_relative = <a href="std.Build.html#std.Build.dupePathInner">dupePathInner</a>(allocator, p) },
            .generated =&gt; |gen| .{ .generated = .{
                .file = gen.file,
                .up = gen.up,
                .sub_path = <a href="std.Build.html#std.Build.dupePathInner">dupePathInner</a>(allocator, gen.sub_path),
            } },
            .dependency =&gt; |dep| .{ .dependency = dep },
        };
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">dumpBadDirnameHelp</span>(
    fail_step: ?*<a href="std.Build.Step.html">Step</a>,
    asking_step: ?*<a href="std.Build.Step.html">Step</a>,
    <span class="tok-kw">comptime</span> msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
    <span class="tok-kw">defer</span> <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();

    <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();
    <span class="tok-kw">const</span> w = stderr.writer();
    <span class="tok-kw">try</span> w.print(msg, args);

    <span class="tok-kw">const</span> tty_config = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(stderr);

    <span class="tok-kw">if</span> (fail_step) |s| {
        tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
        <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    The step was created by this stack trace:\n&quot;</span>);
        tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};

        s.dump(stderr);
    }

    <span class="tok-kw">if</span> (asking_step) |as| {
        tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
        <span class="tok-kw">try</span> stderr.writer().print(<span class="tok-str">&quot;    The step '{s}' that is missing a dependency on the above step was created by this stack trace:\n&quot;</span>, .{as.name});
        tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};

        as.dump(stderr);
    }

    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    Hope that helps. Proceeding to panic.\n&quot;</span>);
    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};
}

<span class="tok-comment">/// In this function the stderr mutex has already been locked.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpBadGetPathHelp</span>(
    s: *<a href="std.Build.Step.html">Step</a>,
    stderr: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,
    src_builder: *<a href="std.Build.html">Build</a>,
    asking_step: ?*<a href="std.Build.Step.html">Step</a>,
) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> w = stderr.writer();
    <span class="tok-kw">try</span> w.print(
        <span class="tok-str">\\getPath() was called on a GeneratedFile that wasn't built yet.</span>
        <span class="tok-str">\\  source package path: {s}</span>
        <span class="tok-str">\\  Is there a missing Step dependency on step '{s}'?</span>
        <span class="tok-str">\\</span>
    , .{
        src_builder.build_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>,
        s.name,
    });

    <span class="tok-kw">const</span> tty_config = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(stderr);
    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    The step was created by this stack trace:\n&quot;</span>);
    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};

    s.dump(stderr);
    <span class="tok-kw">if</span> (asking_step) |as| {
        tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
        <span class="tok-kw">try</span> stderr.writer().print(<span class="tok-str">&quot;    The step '{s}' that is missing a dependency on the above step was created by this stack trace:\n&quot;</span>, .{as.name});
        tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};

        as.dump(stderr);
    }
    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};
    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    Hope that helps. Proceeding to panic.\n&quot;</span>);
    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstallDir = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    prefix: <span class="tok-type">void</span>,
    lib: <span class="tok-type">void</span>,
    bin: <span class="tok-type">void</span>,
    header: <span class="tok-type">void</span>,
    <span class="tok-comment">/// A path relative to the prefix</span>
    custom: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-comment">/// Duplicates the install directory including the path if set to custom.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(dir: <a href="std.Build.InstallDir.html">InstallDir</a>, builder: *<a href="std.Build.html">Build</a>) <a href="std.Build.InstallDir.html">InstallDir</a> {
        <span class="tok-kw">if</span> (dir == .custom) {
            <span class="tok-kw">return</span> .{ .custom = builder.dupe(dir.custom) };
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> dir;
        }
    }
};

<span class="tok-comment">/// This function is intended to be called in the `configure` phase only.</span>
<span class="tok-comment">/// It returns an absolute directory path, which is potentially going to be a</span>
<span class="tok-comment">/// source of API breakage in the future, so keep that in mind when using this</span>
<span class="tok-comment">/// function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeTempPath</span>(b: *<a href="std.Build.html">Build</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> rand_int = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">int</a>(<span class="tok-type">u64</span>);
    <span class="tok-kw">const</span> tmp_dir_sub_path = <span class="tok-str">&quot;tmp&quot;</span> ++ <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep_str">sep_str</a> ++ <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.hex">hex</a>(rand_int);
    <span class="tok-kw">const</span> result_path = b.cache_root.join(b.allocator, &amp;.{tmp_dir_sub_path}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    b.cache_root.handle.makePath(tmp_dir_sub_path) <span class="tok-kw">catch</span> |err| {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;unable to make tmp path '{s}': {s}\n&quot;</span>, .{
            result_path, <span class="tok-builtin">@errorName</span>(err),
        });
    };
    <span class="tok-kw">return</span> result_path;
}

<span class="tok-comment">/// Deprecated; use `std.fmt.hex` instead.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hex64</span>(x: <span class="tok-type">u64</span>) [<span class="tok-number">16</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.hex">hex</a>(x);
}

<span class="tok-comment">/// A pair of target query and fully resolved target.</span>
<span class="tok-comment">/// This type is generally required by build system API that need to be given a</span>
<span class="tok-comment">/// target. The query is kept because the Zig toolchain needs to know which parts</span>
<span class="tok-comment">/// of the target are &quot;native&quot;. This can apply to the CPU, the OS, or even the ABI.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ResolvedTarget = <span class="tok-kw">struct</span> {
    query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>,
    result: <a href="std.Target.html">Target</a>,
};

<span class="tok-comment">/// Converts a target query into a fully resolved target that can be passed to</span>
<span class="tok-comment">/// various parts of the API.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveTargetQuery</span>(b: *<a href="std.Build.html">Build</a>, query: <a href="std.Target.html">Target</a>.<a href="std.Target.Query.html">Query</a>) <a href="std.Build.ResolvedTarget.html">ResolvedTarget</a> {
    <span class="tok-kw">if</span> (query.isNative()) {<span class="tok-comment">
        // Hot path. This is faster than querying the native CPU and OS again.
        </span><span class="tok-kw">return</span> b.graph.host;
    }
    <span class="tok-kw">return</span> .{
        .query = query,
        .result = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.system.html">system</a>.<a href="std.zig.system.html#std.zig.system.resolveTargetQuery">resolveTargetQuery</a>(query) <span class="tok-kw">catch</span>
            <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unable to resolve target query&quot;</span>),
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wantSharedLibSymLinks</span>(target: <a href="std.Target.html">Target</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> target.os.tag != .windows;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SystemIntegrationOptionConfig = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// If left as null, then the default will depend on system_package_mode.</span>
    default: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">systemIntegrationOption</span>(
    b: *<a href="std.Build.html">Build</a>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    config: <a href="std.Build.SystemIntegrationOptionConfig.html">SystemIntegrationOptionConfig</a>,
) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> gop = b.graph.system_library_options.getOrPut(b.allocator, name) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    <span class="tok-kw">if</span> (gop.found_existing) <span class="tok-kw">switch</span> (gop.value_ptr.*) {
        .user_disabled =&gt; {
            gop.value_ptr.* = .declared_disabled;
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
        .user_enabled =&gt; {
            gop.value_ptr.* = .declared_enabled;
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        },
        .declared_disabled =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
        .declared_enabled =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
    } <span class="tok-kw">else</span> {
        gop.key_ptr.* = b.dupe(name);
        <span class="tok-kw">if</span> (config.default <span class="tok-kw">orelse</span> b.graph.system_package_mode) {
            gop.value_ptr.* = .declared_enabled;
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        } <span class="tok-kw">else</span> {
            gop.value_ptr.* = .declared_disabled;
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }
}

<span class="tok-kw">test</span> {
    _ = <a href="std.Build.Cache.html">Cache</a>;
    _ = <a href="std.Build.Step.html">Step</a>;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
