<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">Build</a></li><li><a href="std.Build.html" class="">Step</a></li><li><a href="std.Build.Step.CheckObject.html" class="active">CheckObject</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Build.Step.CheckObject" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Build.Step.CheckObject</span><a href="#src.zig-std.Build.Step.CheckObject">[src]</a></h1><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>step: <a href="std.Build.Step.html">Step</a></code></pre></div><div><pre><code>source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>max_bytes: <span class="tok-type">usize</span> = <span class="tok-number">20</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span></code></pre></div><div><pre><code>checks: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.Check.html">Check</a>)</code></pre></div><div><pre><code>obj_format: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a></code></pre></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.Build.Step.CheckObject.base_id" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">base_id</span><a href="#src.zig-std.Build.Step.CheckObject.base_id">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.base_id">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Id.html">Id</a> = .check_object</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Build.Step.CheckObject.create" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">create</span><a href="#src.zig-std.Build.Step.CheckObject.create">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>( owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>, source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>, obj_format: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a>, ) *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a></code></pre></div><div><pre><code>source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>obj_format: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.create">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(
    owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>,
    source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
    obj_format: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a>,
) *<a href="std.Build.Step.CheckObject.html">CheckObject</a> {
    <span class="tok-kw">const</span> gpa = owner.allocator;
    <span class="tok-kw">const</span> check_object = gpa.create(<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    check_object.* = .{
        .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
            .id = <a href="std.Build.Step.CheckObject.html#std.Build.Step.CheckObject.base_id">base_id</a>,
            .name = <span class="tok-str">&quot;CheckObject&quot;</span>,
            .owner = owner,
            .makeFn = <a href="std.Build.Step.CheckObject.html#std.Build.Step.CheckObject.make">make</a>,
        }),
        .source = source.dupe(owner),
        .checks = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.Check.html">Check</a>).init(gpa),
        .obj_format = obj_format,
    };
    check_object.source.addStepDependencies(&amp;check_object.step);
    <span class="tok-kw">return</span> check_object;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkExact" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkExact</span><a href="#src.zig-std.Build.Step.CheckObject.checkExact">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExact</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds an exact match phrase to the latest created Check.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkExact">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExact</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    check_object.checkExactInner(phrase, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkExactPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkExactPath</span><a href="#src.zig-std.Build.Step.CheckObject.checkExactPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExactPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code>checkExact()</code> but takes an additional argument <code>LazyPath</code> which will be
resolved to a full search query in <code>make()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkExactPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExactPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    check_object.checkExactInner(phrase, lazy_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkContains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkContains</span><a href="#src.zig-std.Build.Step.CheckObject.checkContains">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkContains</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds a fuzzy match phrase to the latest created Check.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkContains">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkContains</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    check_object.checkContainsInner(phrase, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkContainsPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkContainsPath</span><a href="#src.zig-std.Build.Step.CheckObject.checkContainsPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkContainsPath</span>( check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code>checkContains()</code> but takes an additional argument <code>lazy_path</code> which will be
resolved to a full search query in <code>make()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkContainsPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkContainsPath</span>(
    check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>,
    phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
) <span class="tok-type">void</span> {
    check_object.checkContainsInner(phrase, lazy_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkExtract" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkExtract</span><a href="#src.zig-std.Build.Step.CheckObject.checkExtract">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExtract</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds an exact match phrase with variable extractor to the latest created Check.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkExtract">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExtract</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    check_object.checkExtractInner(phrase, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkExtractLazyPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkExtractLazyPath</span><a href="#src.zig-std.Build.Step.CheckObject.checkExtractLazyPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExtractLazyPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code>checkExtract()</code> but takes an additional argument <code>LazyPath</code> which will be
resolved to a full search query in <code>make()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkExtractLazyPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExtractLazyPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    check_object.checkExtractInner(phrase, lazy_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkNotPresent" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkNotPresent</span><a href="#src.zig-std.Build.Step.CheckObject.checkNotPresent">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresent</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Adds another searched phrase to the latest created Check
however ensures there is no matching phrase in the output.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkNotPresent">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresent</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    check_object.checkNotPresentInner(phrase, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkNotPresentLazyPath" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkNotPresentLazyPath</span><a href="#src.zig-std.Build.Step.CheckObject.checkNotPresentLazyPath">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresentLazyPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Like <code>checkExtract()</code> but takes an additional argument <code>LazyPath</code> which will be
resolved to a full search query in <code>make()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkNotPresentLazyPath">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresentLazyPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    check_object.checkNotPresentInner(phrase, lazy_path);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInHeaders" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInHeaders</span><a href="#src.zig-std.Build.Step.CheckObject.checkInHeaders">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInHeaders</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking in the file headers (section, program headers, etc.).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInHeaders">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInHeaders</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    check_object.checkStart(.headers);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInSymtab" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInSymtab</span><a href="#src.zig-std.Build.Step.CheckObject.checkInSymtab">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically symbol table parsed and dumped from the object
file.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInSymtab">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.symtab_label">symtab_label</a>,
        .elf =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.symtab_label">symtab_label</a>,
        .wasm =&gt; <a href="std.Build.Step.CheckObject.WasmDumper.html">WasmDumper</a>.<a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.symtab_label">symtab_label</a>,
        .coff =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO symtab for coff&quot;</span>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO other file formats&quot;</span>),
    };
    check_object.checkStart(.symtab);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInDyldRebase" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInDyldRebase</span><a href="#src.zig-std.Build.Step.CheckObject.checkInDyldRebase">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldRebase</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically dyld rebase opcodes contents parsed and dumped
from the object file.
This check is target-dependent and applicable to MachO only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInDyldRebase">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldRebase</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_rebase_label">dyld_rebase_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dyld_rebase);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInDyldBind" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInDyldBind</span><a href="#src.zig-std.Build.Step.CheckObject.checkInDyldBind">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically dyld bind opcodes contents parsed and dumped
from the object file.
This check is target-dependent and applicable to MachO only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInDyldBind">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_bind_label">dyld_bind_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dyld_bind);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInDyldWeakBind" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInDyldWeakBind</span><a href="#src.zig-std.Build.Step.CheckObject.checkInDyldWeakBind">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldWeakBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically dyld weak bind opcodes contents parsed and dumped
from the object file.
This check is target-dependent and applicable to MachO only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInDyldWeakBind">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldWeakBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_weak_bind_label">dyld_weak_bind_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dyld_weak_bind);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInDyldLazyBind" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInDyldLazyBind</span><a href="#src.zig-std.Build.Step.CheckObject.checkInDyldLazyBind">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldLazyBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically dyld lazy bind opcodes contents parsed and dumped
from the object file.
This check is target-dependent and applicable to MachO only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInDyldLazyBind">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldLazyBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_lazy_bind_label">dyld_lazy_bind_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dyld_lazy_bind);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInExports" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInExports</span><a href="#src.zig-std.Build.Step.CheckObject.checkInExports">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInExports</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically exports info contents parsed and dumped
from the object file.
This check is target-dependent and applicable to MachO only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInExports">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInExports</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.exports_label">exports_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.exports);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInIndirectSymtab" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInIndirectSymtab</span><a href="#src.zig-std.Build.Step.CheckObject.checkInIndirectSymtab">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInIndirectSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically indirect symbol table parsed and dumped
from the object file.
This check is target-dependent and applicable to MachO only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInIndirectSymtab">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInIndirectSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.indirect_symtab_label">indirect_symtab_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.indirect_symtab);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInDynamicSymtab" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInDynamicSymtab</span><a href="#src.zig-std.Build.Step.CheckObject.checkInDynamicSymtab">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDynamicSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically dynamic symbol table parsed and dumped from the object
file.
This check is target-dependent and applicable to ELF only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInDynamicSymtab">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDynamicSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .elf =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.dynamic_symtab_label">dynamic_symtab_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dynamic_symtab);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInDynamicSection" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInDynamicSection</span><a href="#src.zig-std.Build.Step.CheckObject.checkInDynamicSection">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDynamicSection</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically dynamic section parsed and dumped from the object
file.
This check is target-dependent and applicable to ELF only.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInDynamicSection">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDynamicSection</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .elf =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.dynamic_section_label">dynamic_section_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dynamic_section);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkInArchiveSymtab" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkInArchiveSymtab</span><a href="#src.zig-std.Build.Step.CheckObject.checkInArchiveSymtab">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInArchiveSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new check checking specifically symbol table parsed and dumped from the archive
file.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkInArchiveSymtab">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInArchiveSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .elf =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.archive_symtab_label">archive_symtab_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO other file formats&quot;</span>),
    };
    check_object.checkStart(.archive_symtab);
    check_object.checkExact(label);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.dumpSection" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dumpSection</span><a href="#src.zig-std.Build.Step.CheckObject.dumpSection">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpSection</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, name: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>name: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.dumpSection">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpSection</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, name: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> check = <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.html#std.Build.Step.CheckObject.Check.dumpSection">dumpSection</a>(check_object.step.owner.allocator, name);
    check_object.checks.append(check) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.CheckObject.checkComputeCompare" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">checkComputeCompare</span><a href="#src.zig-std.Build.Step.CheckObject.checkComputeCompare">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkComputeCompare</span>( check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, program: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected: <a href="std.Build.Step.CheckObject.ComputeCompareExpected.html">ComputeCompareExpected</a>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Creates a new standalone, singular check which allows running simple binary operations
on the extracted variables. It will then compare the reduced program with the value of
the expected variable.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a></code></pre></div><div><pre><code>program: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>expected: <a href="std.Build.Step.CheckObject.ComputeCompareExpected.html">ComputeCompareExpected</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject.checkComputeCompare">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkComputeCompare</span>(
    check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>,
    program: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    expected: <a href="std.Build.Step.CheckObject.ComputeCompareExpected.html">ComputeCompareExpected</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> check = <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.html#std.Build.Step.CheckObject.Check.create">create</a>(check_object.step.owner.allocator, .compute_compare);
    check.computeCmp(.{ .string = check_object.step.owner.dupe(program) }, expected);
    check_object.checks.append(check) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Build.Step.CheckObject">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> elf = <a href="std.html">std</a>.<a href="std.elf.html">elf</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> macho = <a href="std.html">std</a>.<a href="std.macho.html">macho</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;

<span class="tok-kw">const</span> CheckObject = <span class="tok-builtin">@This</span>();

<span class="tok-kw">const</span> Allocator = <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> Step = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Step.html">Step</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Id.html">Id</a> = .check_object;

step: <a href="std.Build.Step.html">Step</a>,
source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
max_bytes: <span class="tok-type">usize</span> = <span class="tok-number">20</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>,
checks: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.Check.html">Check</a>),
obj_format: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a>,

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(
    owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>,
    source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
    obj_format: <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.ObjectFormat.html">ObjectFormat</a>,
) *<a href="std.Build.Step.CheckObject.html">CheckObject</a> {
    <span class="tok-kw">const</span> gpa = owner.allocator;
    <span class="tok-kw">const</span> check_object = gpa.create(<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    check_object.* = .{
        .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
            .id = <a href="std.Build.Step.CheckObject.html#std.Build.Step.CheckObject.base_id">base_id</a>,
            .name = <span class="tok-str">&quot;CheckObject&quot;</span>,
            .owner = owner,
            .makeFn = <a href="std.Build.Step.CheckObject.html#std.Build.Step.CheckObject.make">make</a>,
        }),
        .source = source.dupe(owner),
        .checks = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.Check.html">Check</a>).init(gpa),
        .obj_format = obj_format,
    };
    check_object.source.addStepDependencies(&amp;check_object.step);
    <span class="tok-kw">return</span> check_object;
}

<span class="tok-kw">const</span> SearchPhrase = <span class="tok-kw">struct</span> {
    string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    lazy_path: ?<a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> = <span class="tok-null">null</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">resolve</span>(phrase: <a href="std.Build.Step.CheckObject.SearchPhrase.html">SearchPhrase</a>, b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>, step: *<a href="std.Build.Step.html">Step</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> lazy_path = phrase.lazy_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> phrase.string;
        <span class="tok-kw">return</span> b.fmt(<span class="tok-str">&quot;{s} {s}&quot;</span>, .{ phrase.string, lazy_path.getPath2(b, step) });
    }
};

<span class="tok-comment">/// There five types of actions currently supported:</span>
<span class="tok-comment">/// .exact - will do an exact match against the haystack</span>
<span class="tok-comment">/// .contains - will check for existence within the haystack</span>
<span class="tok-comment">/// .not_present - will check for non-existence within the haystack</span>
<span class="tok-comment">/// .extract - will do an exact match and extract into a variable enclosed within `{name}` braces</span>
<span class="tok-comment">/// .compute_cmp - will perform an operation on the extracted global variables</span>
<span class="tok-comment">/// using the MatchAction. It currently only supports an addition. The operation is required</span>
<span class="tok-comment">/// to be specified in Reverse Polish Notation to ease in operator-precedence parsing (well,</span>
<span class="tok-comment">/// to avoid any parsing really).</span>
<span class="tok-comment">/// For example, if the two extracted values were saved as `vmaddr` and `entryoff` respectively</span>
<span class="tok-comment">/// they could then be added with this simple program `vmaddr entryoff +`.</span>
<span class="tok-kw">const</span> Action = <span class="tok-kw">struct</span> {
    tag: <span class="tok-kw">enum</span> { <a href="std.Build.Step.CheckObject.Action.html#std.Build.Step.CheckObject.Action.exact">exact</a>, <a href="std.Build.Step.CheckObject.Action.html#std.Build.Step.CheckObject.Action.contains">contains</a>, not_present, <a href="std.Build.Step.CheckObject.Action.html#std.Build.Step.CheckObject.Action.extract">extract</a>, compute_cmp },
    phrase: <a href="std.Build.Step.CheckObject.SearchPhrase.html">SearchPhrase</a>,
    expected: ?<a href="std.Build.Step.CheckObject.ComputeCompareExpected.html">ComputeCompareExpected</a> = <span class="tok-null">null</span>,

    <span class="tok-comment">/// Returns true if the `phrase` is an exact match with the haystack and variable was successfully extracted.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">extract</span>(
        act: <a href="std.Build.Step.CheckObject.Action.html">Action</a>,
        b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>,
        step: *<a href="std.Build.Step.html">Step</a>,
        haystack: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        global_vars: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(act.tag == .extract);
        <span class="tok-kw">const</span> hay = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, haystack, <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">const</span> phrase = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, act.phrase.resolve(b, step), <span class="tok-str">&quot; &quot;</span>);

        <span class="tok-kw">var</span> candidate_vars = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-kw">struct</span> { name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value: <span class="tok-type">u64</span> }).init(b.allocator);
        <span class="tok-kw">var</span> hay_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, hay, <span class="tok-str">' '</span>);
        <span class="tok-kw">var</span> needle_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, phrase, <span class="tok-str">' '</span>);

        <span class="tok-kw">while</span> (needle_it.next()) |needle_tok| {
            <span class="tok-kw">const</span> hay_tok = hay_it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">break</span>;
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, needle_tok, <span class="tok-str">&quot;{&quot;</span>)) {
                <span class="tok-kw">const</span> closing_brace = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, needle_tok, <span class="tok-str">&quot;}&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingClosingBrace;
                <span class="tok-kw">if</span> (closing_brace != needle_tok.len - <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ClosingBraceNotLast;

                <span class="tok-kw">const</span> name = needle_tok[<span class="tok-number">1</span>..closing_brace];
                <span class="tok-kw">if</span> (name.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingBraceValue;
                <span class="tok-kw">const</span> value = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, hay_tok, <span class="tok-number">16</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                <span class="tok-kw">try</span> candidate_vars.append(.{
                    .name = name,
                    .value = value,
                });
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, hay_tok, needle_tok)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
        }

        <span class="tok-kw">if</span> (candidate_vars.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;

        <span class="tok-kw">for</span> (candidate_vars.items) |cv| <span class="tok-kw">try</span> global_vars.putNoClobber(cv.name, cv.value);

        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Returns true if the `phrase` is an exact match with the haystack.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">exact</span>(
        act: <a href="std.Build.Step.CheckObject.Action.html">Action</a>,
        b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>,
        step: *<a href="std.Build.Step.html">Step</a>,
        haystack: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(act.tag == .exact);
        <span class="tok-kw">const</span> hay = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, haystack, <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">const</span> phrase = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, act.phrase.resolve(b, step), <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, hay, phrase);
    }

    <span class="tok-comment">/// Returns true if the `phrase` exists within the haystack.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(
        act: <a href="std.Build.Step.CheckObject.Action.html">Action</a>,
        b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>,
        step: *<a href="std.Build.Step.html">Step</a>,
        haystack: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(act.tag == .contains);
        <span class="tok-kw">const</span> hay = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, haystack, <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">const</span> phrase = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, act.phrase.resolve(b, step), <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, hay, phrase) != <span class="tok-null">null</span>;
    }

    <span class="tok-comment">/// Returns true if the `phrase` does not exist within the haystack.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">notPresent</span>(
        act: <a href="std.Build.Step.CheckObject.Action.html">Action</a>,
        b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>,
        step: *<a href="std.Build.Step.html">Step</a>,
        haystack: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(act.tag == .not_present);
        <span class="tok-kw">return</span> !<a href="std.Build.Step.CheckObject.Action.html#std.Build.Step.CheckObject.Action.contains">contains</a>(.{
            .tag = .contains,
            .phrase = act.phrase,
            .expected = act.expected,
        }, b, step, haystack);
    }

    <span class="tok-comment">/// Will return true if the `phrase` is correctly parsed into an RPN program and</span>
    <span class="tok-comment">/// its reduced, computed value compares using `op` with the expected value, either</span>
    <span class="tok-comment">/// a literal or another extracted variable.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">computeCmp</span>(act: <a href="std.Build.Step.CheckObject.Action.html">Action</a>, b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>, step: *<a href="std.Build.Step.html">Step</a>, global_vars: <span class="tok-kw">anytype</span>) !<span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> gpa = step.owner.allocator;
        <span class="tok-kw">const</span> phrase = act.phrase.resolve(b, step);
        <span class="tok-kw">var</span> op_stack = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-kw">enum</span> { add, sub, mod, mul }).init(gpa);
        <span class="tok-kw">var</span> values = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u64</span>).init(gpa);

        <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, phrase, <span class="tok-str">' '</span>);
        <span class="tok-kw">while</span> (it.next()) |next| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, next, <span class="tok-str">&quot;+&quot;</span>)) {
                <span class="tok-kw">try</span> op_stack.append(.add);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, next, <span class="tok-str">&quot;-&quot;</span>)) {
                <span class="tok-kw">try</span> op_stack.append(.sub);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, next, <span class="tok-str">&quot;%&quot;</span>)) {
                <span class="tok-kw">try</span> op_stack.append(.mod);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, next, <span class="tok-str">&quot;*&quot;</span>)) {
                <span class="tok-kw">try</span> op_stack.append(.mul);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> val = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, next, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> blk: {
                    <span class="tok-kw">break</span> :blk global_vars.get(next) <span class="tok-kw">orelse</span> {
                        <span class="tok-kw">try</span> step.addError(
                            <span class="tok-str">\\</span>
                            <span class="tok-str">\\========= variable was not extracted: ===========</span>
                            <span class="tok-str">\\{s}</span>
                            <span class="tok-str">\\=================================================</span>
                        , .{next});
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownVariable;
                    };
                };
                <span class="tok-kw">try</span> values.append(val);
            }
        }

        <span class="tok-kw">var</span> op_i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> reduced: <span class="tok-type">u64</span> = values.items[<span class="tok-number">0</span>];
        <span class="tok-kw">for</span> (op_stack.items) |op| {
            <span class="tok-kw">const</span> other = values.items[op_i];
            <span class="tok-kw">switch</span> (op) {
                .add =&gt; {
                    reduced += other;
                },
                .sub =&gt; {
                    reduced -= other;
                },
                .mod =&gt; {
                    reduced %= other;
                },
                .mul =&gt; {
                    reduced *= other;
                },
            }
            op_i += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">const</span> exp_value = <span class="tok-kw">switch</span> (act.expected.?.value) {
            .variable =&gt; |name| global_vars.get(name) <span class="tok-kw">orelse</span> {
                <span class="tok-kw">try</span> step.addError(
                    <span class="tok-str">\\</span>
                    <span class="tok-str">\\========= variable was not extracted: ===========</span>
                    <span class="tok-str">\\{s}</span>
                    <span class="tok-str">\\=================================================</span>
                , .{name});
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownVariable;
            },
            .literal =&gt; |x| x,
        };
        <span class="tok-kw">return</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.compare">compare</a>(reduced, act.expected.?.op, exp_value);
    }
};

<span class="tok-kw">const</span> ComputeCompareExpected = <span class="tok-kw">struct</span> {
    op: <a href="std.math.html">math</a>.<a href="std.math.CompareOperator.html">CompareOperator</a>,
    value: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        variable: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        literal: <span class="tok-type">u64</span>,
    },

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        value: <span class="tok-builtin">@This</span>(),
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.invalidFmtError">invalidFmtError</a>(fmt, value);
        _ = options;
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s} &quot;</span>, .{<span class="tok-builtin">@tagName</span>(value.op)});
        <span class="tok-kw">switch</span> (value.value) {
            .variable =&gt; |name| <span class="tok-kw">try</span> writer.writeAll(name),
            .literal =&gt; |x| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x}&quot;</span>, .{x}),
        }
    }
};

<span class="tok-kw">const</span> Check = <span class="tok-kw">struct</span> {
    kind: <a href="std.Build.Step.CheckObject.Check.Kind.html">Kind</a>,
    payload: <a href="std.Build.Step.CheckObject.Check.Payload.html">Payload</a>,
    data: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    actions: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.Action.html">Action</a>),

    <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, kind: <a href="std.Build.Step.CheckObject.Check.Kind.html">Kind</a>) <a href="std.Build.Step.CheckObject.Check.html">Check</a> {
        <span class="tok-kw">return</span> .{
            .kind = kind,
            .payload = .{ .none = {} },
            .data = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator),
            .actions = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.Action.html">Action</a>).init(allocator),
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">dumpSection</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, name: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.Build.Step.CheckObject.Check.html">Check</a> {
        <span class="tok-kw">var</span> check = <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.html#std.Build.Step.CheckObject.Check.create">create</a>(allocator, .dump_section);
        <span class="tok-kw">const</span> off: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(check.data.items.len);
        check.data.writer().print(<span class="tok-str">&quot;{s}\x00&quot;</span>, .{name}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
        check.payload = .{ .dump_section = off };
        <span class="tok-kw">return</span> check;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">extract</span>(check: *<a href="std.Build.Step.CheckObject.Check.html">Check</a>, phrase: <a href="std.Build.Step.CheckObject.SearchPhrase.html">SearchPhrase</a>) <span class="tok-type">void</span> {
        check.actions.append(.{
            .tag = .extract,
            .phrase = phrase,
        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">exact</span>(check: *<a href="std.Build.Step.CheckObject.Check.html">Check</a>, phrase: <a href="std.Build.Step.CheckObject.SearchPhrase.html">SearchPhrase</a>) <span class="tok-type">void</span> {
        check.actions.append(.{
            .tag = .exact,
            .phrase = phrase,
        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(check: *<a href="std.Build.Step.CheckObject.Check.html">Check</a>, phrase: <a href="std.Build.Step.CheckObject.SearchPhrase.html">SearchPhrase</a>) <span class="tok-type">void</span> {
        check.actions.append(.{
            .tag = .contains,
            .phrase = phrase,
        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">notPresent</span>(check: *<a href="std.Build.Step.CheckObject.Check.html">Check</a>, phrase: <a href="std.Build.Step.CheckObject.SearchPhrase.html">SearchPhrase</a>) <span class="tok-type">void</span> {
        check.actions.append(.{
            .tag = .not_present,
            .phrase = phrase,
        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">computeCmp</span>(check: *<a href="std.Build.Step.CheckObject.Check.html">Check</a>, phrase: <a href="std.Build.Step.CheckObject.SearchPhrase.html">SearchPhrase</a>, expected: <a href="std.Build.Step.CheckObject.ComputeCompareExpected.html">ComputeCompareExpected</a>) <span class="tok-type">void</span> {
        check.actions.append(.{
            .tag = .compute_cmp,
            .phrase = phrase,
            .expected = expected,
        }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    }

    <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> {
        headers,
        symtab,
        indirect_symtab,
        dynamic_symtab,
        archive_symtab,
        dynamic_section,
        dyld_rebase,
        dyld_bind,
        dyld_weak_bind,
        dyld_lazy_bind,
        exports,
        compute_compare,
        dump_section,
    };

    <span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
        none: <span class="tok-type">void</span>,
        <span class="tok-comment">/// Null-delimited string in the 'data' buffer.</span>
        dump_section: <span class="tok-type">u32</span>,
    };
};

<span class="tok-comment">/// Creates a new empty sequence of actions.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">checkStart</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, kind: <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.Kind.html">Kind</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> check = <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.html#std.Build.Step.CheckObject.Check.create">create</a>(check_object.step.owner.allocator, kind);
    check_object.checks.append(check) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-comment">/// Adds an exact match phrase to the latest created Check.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExact</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    check_object.checkExactInner(phrase, <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Like `checkExact()` but takes an additional argument `LazyPath` which will be</span>
<span class="tok-comment">/// resolved to a full search query in `make()`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExactPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    check_object.checkExactInner(phrase, lazy_path);
}

<span class="tok-kw">fn</span> <span class="tok-fn">checkExactInner</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: ?<a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(check_object.checks.items.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> last = &amp;check_object.checks.items[check_object.checks.items.len - <span class="tok-number">1</span>];
    last.exact(.{ .string = check_object.step.owner.dupe(phrase), .lazy_path = lazy_path });
}

<span class="tok-comment">/// Adds a fuzzy match phrase to the latest created Check.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkContains</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    check_object.checkContainsInner(phrase, <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Like `checkContains()` but takes an additional argument `lazy_path` which will be</span>
<span class="tok-comment">/// resolved to a full search query in `make()`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkContainsPath</span>(
    check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>,
    phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
) <span class="tok-type">void</span> {
    check_object.checkContainsInner(phrase, lazy_path);
}

<span class="tok-kw">fn</span> <span class="tok-fn">checkContainsInner</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: ?<a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(check_object.checks.items.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> last = &amp;check_object.checks.items[check_object.checks.items.len - <span class="tok-number">1</span>];
    last.contains(.{ .string = check_object.step.owner.dupe(phrase), .lazy_path = lazy_path });
}

<span class="tok-comment">/// Adds an exact match phrase with variable extractor to the latest created Check.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExtract</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    check_object.checkExtractInner(phrase, <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Like `checkExtract()` but takes an additional argument `LazyPath` which will be</span>
<span class="tok-comment">/// resolved to a full search query in `make()`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkExtractLazyPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    check_object.checkExtractInner(phrase, lazy_path);
}

<span class="tok-kw">fn</span> <span class="tok-fn">checkExtractInner</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: ?<a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(check_object.checks.items.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> last = &amp;check_object.checks.items[check_object.checks.items.len - <span class="tok-number">1</span>];
    last.extract(.{ .string = check_object.step.owner.dupe(phrase), .lazy_path = lazy_path });
}

<span class="tok-comment">/// Adds another searched phrase to the latest created Check</span>
<span class="tok-comment">/// however ensures there is no matching phrase in the output.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresent</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    check_object.checkNotPresentInner(phrase, <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Like `checkExtract()` but takes an additional argument `LazyPath` which will be</span>
<span class="tok-comment">/// resolved to a full search query in `make()`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresentLazyPath</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    check_object.checkNotPresentInner(phrase, lazy_path);
}

<span class="tok-kw">fn</span> <span class="tok-fn">checkNotPresentInner</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, phrase: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, lazy_path: ?<a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(check_object.checks.items.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> last = &amp;check_object.checks.items[check_object.checks.items.len - <span class="tok-number">1</span>];
    last.notPresent(.{ .string = check_object.step.owner.dupe(phrase), .lazy_path = lazy_path });
}

<span class="tok-comment">/// Creates a new check checking in the file headers (section, program headers, etc.).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInHeaders</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    check_object.checkStart(.headers);
}

<span class="tok-comment">/// Creates a new check checking specifically symbol table parsed and dumped from the object</span>
<span class="tok-comment">/// file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.symtab_label">symtab_label</a>,
        .elf =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.symtab_label">symtab_label</a>,
        .wasm =&gt; <a href="std.Build.Step.CheckObject.WasmDumper.html">WasmDumper</a>.<a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.symtab_label">symtab_label</a>,
        .coff =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO symtab for coff&quot;</span>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO other file formats&quot;</span>),
    };
    check_object.checkStart(.symtab);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically dyld rebase opcodes contents parsed and dumped</span>
<span class="tok-comment">/// from the object file.</span>
<span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldRebase</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_rebase_label">dyld_rebase_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dyld_rebase);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically dyld bind opcodes contents parsed and dumped</span>
<span class="tok-comment">/// from the object file.</span>
<span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_bind_label">dyld_bind_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dyld_bind);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically dyld weak bind opcodes contents parsed and dumped</span>
<span class="tok-comment">/// from the object file.</span>
<span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldWeakBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_weak_bind_label">dyld_weak_bind_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dyld_weak_bind);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically dyld lazy bind opcodes contents parsed and dumped</span>
<span class="tok-comment">/// from the object file.</span>
<span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDyldLazyBind</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_lazy_bind_label">dyld_lazy_bind_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dyld_lazy_bind);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically exports info contents parsed and dumped</span>
<span class="tok-comment">/// from the object file.</span>
<span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInExports</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.exports_label">exports_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.exports);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically indirect symbol table parsed and dumped</span>
<span class="tok-comment">/// from the object file.</span>
<span class="tok-comment">/// This check is target-dependent and applicable to MachO only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInIndirectSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .macho =&gt; <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.indirect_symtab_label">indirect_symtab_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.indirect_symtab);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically dynamic symbol table parsed and dumped from the object</span>
<span class="tok-comment">/// file.</span>
<span class="tok-comment">/// This check is target-dependent and applicable to ELF only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDynamicSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .elf =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.dynamic_symtab_label">dynamic_symtab_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dynamic_symtab);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically dynamic section parsed and dumped from the object</span>
<span class="tok-comment">/// file.</span>
<span class="tok-comment">/// This check is target-dependent and applicable to ELF only.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInDynamicSection</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .elf =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.dynamic_section_label">dynamic_section_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;Unsupported target platform&quot;</span>),
    };
    check_object.checkStart(.dynamic_section);
    check_object.checkExact(label);
}

<span class="tok-comment">/// Creates a new check checking specifically symbol table parsed and dumped from the archive</span>
<span class="tok-comment">/// file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkInArchiveSymtab</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> label = <span class="tok-kw">switch</span> (check_object.obj_format) {
        .elf =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.archive_symtab_label">archive_symtab_label</a>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO other file formats&quot;</span>),
    };
    check_object.checkStart(.archive_symtab);
    check_object.checkExact(label);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpSection</span>(check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>, name: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> check = <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.html#std.Build.Step.CheckObject.Check.dumpSection">dumpSection</a>(check_object.step.owner.allocator, name);
    check_object.checks.append(check) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-comment">/// Creates a new standalone, singular check which allows running simple binary operations</span>
<span class="tok-comment">/// on the extracted variables. It will then compare the reduced program with the value of</span>
<span class="tok-comment">/// the expected variable.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkComputeCompare</span>(
    check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a>,
    program: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    expected: <a href="std.Build.Step.CheckObject.ComputeCompareExpected.html">ComputeCompareExpected</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> check = <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.html#std.Build.Step.CheckObject.Check.create">create</a>(check_object.step.owner.allocator, .compute_compare);
    check.computeCmp(.{ .string = check_object.step.owner.dupe(program) }, expected);
    check_object.checks.append(check) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">make</span>(step: *<a href="std.Build.Step.html">Step</a>, make_options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.MakeOptions.html">MakeOptions</a>) !<span class="tok-type">void</span> {
    _ = make_options;
    <span class="tok-kw">const</span> b = step.owner;
    <span class="tok-kw">const</span> gpa = b.allocator;
    <span class="tok-kw">const</span> check_object: *<a href="std.Build.Step.CheckObject.html">CheckObject</a> = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;step&quot;</span>, step);
    <span class="tok-kw">try</span> step.singleUnchangingWatchInput(check_object.source);

    <span class="tok-kw">const</span> src_path = check_object.source.getPath3(b, step);
    <span class="tok-kw">const</span> contents = src_path.root_dir.handle.readFileAllocOptions(
        gpa,
        src_path.sub_path,
        check_object.max_bytes,
        <span class="tok-null">null</span>,
        <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u64</span>),
        <span class="tok-null">null</span>,
    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to read '{'}': {s}&quot;</span>, .{ src_path, <span class="tok-builtin">@errorName</span>(err) });

    <span class="tok-kw">var</span> vars = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.StringHashMap">StringHashMap</a>(<span class="tok-type">u64</span>).init(gpa);
    <span class="tok-kw">for</span> (check_object.checks.items) |chk| {
        <span class="tok-kw">if</span> (chk.kind == .compute_compare) {
            <a href="std.debug.html#std.debug.assert">assert</a>(chk.actions.items.len == <span class="tok-number">1</span>);
            <span class="tok-kw">const</span> act = chk.actions.items[<span class="tok-number">0</span>];
            <a href="std.debug.html#std.debug.assert">assert</a>(act.tag == .compute_cmp);
            <span class="tok-kw">const</span> res = act.computeCmp(b, step, vars) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnknownVariable =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;Unknown variable&quot;</span>, .{}),
                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
            };
            <span class="tok-kw">if</span> (!res) {
                <span class="tok-kw">return</span> step.fail(
                    <span class="tok-str">\\</span>
                    <span class="tok-str">\\========= comparison failed for action: ===========</span>
                    <span class="tok-str">\\{s} {}</span>
                    <span class="tok-str">\\===================================================</span>
                , .{ act.phrase.resolve(b, step), act.expected.? });
            }
            <span class="tok-kw">continue</span>;
        }

        <span class="tok-kw">const</span> output = <span class="tok-kw">switch</span> (check_object.obj_format) {
            .macho =&gt; <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.MachODumper.html">MachODumper</a>.<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.parseAndDump">parseAndDump</a>(step, chk, contents),
            .elf =&gt; <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.parseAndDump">parseAndDump</a>(step, chk, contents),
            .coff =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;TODO coff parser&quot;</span>, .{}),
            .wasm =&gt; <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html">WasmDumper</a>.<a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseAndDump">parseAndDump</a>(step, chk, contents),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };<span class="tok-comment">

        // Depending on whether we requested dumping section verbatim or not,
        // we either format message string with escaped codes, or not to aid debugging
        // the failed test.
        </span><span class="tok-kw">const</span> fmtMessageString = <span class="tok-kw">struct</span> {
            <span class="tok-kw">fn</span> <span class="tok-fn">fmtMessageString</span>(kind: <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.Kind.html">Kind</a>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.Build.Step.CheckObject.html#std.Build.Step.CheckObject.make.formatMessageString">formatMessageString</a>) {
                <span class="tok-kw">return</span> .{ .data = .{
                    .kind = kind,
                    .msg = msg,
                } };
            }

            <span class="tok-kw">const</span> Ctx = <span class="tok-kw">struct</span> {
                kind: <a href="std.Build.Step.CheckObject.Check.html">Check</a>.<a href="std.Build.Step.CheckObject.Check.Kind.html">Kind</a>,
                msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            };

            <span class="tok-kw">fn</span> <span class="tok-fn">formatMessageString</span>(
                ctx: <a href="std.Build.Step.CheckObject.make.Ctx.html">Ctx</a>,
                <span class="tok-kw">comptime</span> unused_fmt_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
                writer: <span class="tok-kw">anytype</span>,
            ) !<span class="tok-type">void</span> {
                _ = unused_fmt_string;
                _ = options;
                <span class="tok-kw">switch</span> (ctx.kind) {
                    .dump_section =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceEscapeLower">fmtSliceEscapeLower</a>(ctx.msg)}),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> writer.writeAll(ctx.msg),
                }
            }
        }.fmtMessageString;

        <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, output, <span class="tok-str">&quot;\r\n&quot;</span>);
        <span class="tok-kw">for</span> (chk.actions.items) |act| {
            <span class="tok-kw">switch</span> (act.tag) {
                .exact =&gt; {
                    <span class="tok-kw">while</span> (it.next()) |line| {
                        <span class="tok-kw">if</span> (act.exact(b, step, line)) <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> step.fail(
                            <span class="tok-str">\\</span>
                            <span class="tok-str">\\========= expected to find: ==========================</span>
                            <span class="tok-str">\\{s}</span>
                            <span class="tok-str">\\========= but parsed file does not contain it: =======</span>
                            <span class="tok-str">\\{s}</span>
                            <span class="tok-str">\\========= file path: =================================</span>
                            <span class="tok-str">\\{}</span>
                        , .{
                            fmtMessageString(chk.kind, act.phrase.resolve(b, step)),
                            fmtMessageString(chk.kind, output),
                            src_path,
                        });
                    }
                },

                .contains =&gt; {
                    <span class="tok-kw">while</span> (it.next()) |line| {
                        <span class="tok-kw">if</span> (act.contains(b, step, line)) <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> step.fail(
                            <span class="tok-str">\\</span>
                            <span class="tok-str">\\========= expected to find: ==========================</span>
                            <span class="tok-str">\\*{s}*</span>
                            <span class="tok-str">\\========= but parsed file does not contain it: =======</span>
                            <span class="tok-str">\\{s}</span>
                            <span class="tok-str">\\========= file path: =================================</span>
                            <span class="tok-str">\\{}</span>
                        , .{
                            fmtMessageString(chk.kind, act.phrase.resolve(b, step)),
                            fmtMessageString(chk.kind, output),
                            src_path,
                        });
                    }
                },

                .not_present =&gt; {
                    <span class="tok-kw">while</span> (it.next()) |line| {
                        <span class="tok-kw">if</span> (act.notPresent(b, step, line)) <span class="tok-kw">continue</span>;
                        <span class="tok-kw">return</span> step.fail(
                            <span class="tok-str">\\</span>
                            <span class="tok-str">\\========= expected not to find: ===================</span>
                            <span class="tok-str">\\{s}</span>
                            <span class="tok-str">\\========= but parsed file does contain it: ========</span>
                            <span class="tok-str">\\{s}</span>
                            <span class="tok-str">\\========= file path: ==============================</span>
                            <span class="tok-str">\\{}</span>
                        , .{
                            fmtMessageString(chk.kind, act.phrase.resolve(b, step)),
                            fmtMessageString(chk.kind, output),
                            src_path,
                        });
                    }
                },

                .extract =&gt; {
                    <span class="tok-kw">while</span> (it.next()) |line| {
                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> act.extract(b, step, line, &amp;vars)) <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> step.fail(
                            <span class="tok-str">\\</span>
                            <span class="tok-str">\\========= expected to find and extract: ==============</span>
                            <span class="tok-str">\\{s}</span>
                            <span class="tok-str">\\========= but parsed file does not contain it: =======</span>
                            <span class="tok-str">\\{s}</span>
                            <span class="tok-str">\\========= file path: ==============================</span>
                            <span class="tok-str">\\{}</span>
                        , .{
                            act.phrase.resolve(b, step),
                            fmtMessageString(chk.kind, output),
                            src_path,
                        });
                    }
                },

                .compute_cmp =&gt; <span class="tok-kw">unreachable</span>,
            }
        }
    }
}

<span class="tok-kw">const</span> MachODumper = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> dyld_rebase_label = <span class="tok-str">&quot;dyld rebase data&quot;</span>;
    <span class="tok-kw">const</span> dyld_bind_label = <span class="tok-str">&quot;dyld bind data&quot;</span>;
    <span class="tok-kw">const</span> dyld_weak_bind_label = <span class="tok-str">&quot;dyld weak bind data&quot;</span>;
    <span class="tok-kw">const</span> dyld_lazy_bind_label = <span class="tok-str">&quot;dyld lazy bind data&quot;</span>;
    <span class="tok-kw">const</span> exports_label = <span class="tok-str">&quot;exports data&quot;</span>;
    <span class="tok-kw">const</span> symtab_label = <span class="tok-str">&quot;symbol table&quot;</span>;
    <span class="tok-kw">const</span> indirect_symtab_label = <span class="tok-str">&quot;indirect symbol table&quot;</span>;

    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDump</span>(step: *<a href="std.Build.Step.html">Step</a>, check: <a href="std.Build.Step.CheckObject.Check.html">Check</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {<span class="tok-comment">
        // TODO: handle archives and fat files
        </span><span class="tok-kw">return</span> <a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.parseAndDumpObject">parseAndDumpObject</a>(step, check, bytes);
    }

    <span class="tok-kw">const</span> ObjectContext = <span class="tok-kw">struct</span> {
        gpa: <a href="std.mem.Allocator.html">Allocator</a>,
        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        header: <a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>,
        segments: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.macho.html">macho</a>.<a href="std.macho.segment_command_64.html">segment_command_64</a>) = .empty,
        sections: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.macho.html">macho</a>.<a href="std.macho.section_64.html">section_64</a>) = .empty,
        symtab: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.macho.html">macho</a>.<a href="std.macho.nlist_64.html">nlist_64</a>) = .empty,
        strtab: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>) = .empty,
        indsymtab: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>) = .empty,
        imports: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) = .empty,

        <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(ctx: *<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> it = ctx.getLoadCommandIterator();
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (it.next()) |cmd| {
                <span class="tok-kw">switch</span> (cmd.cmd()) {
                    .SEGMENT_64 =&gt; {
                        <span class="tok-kw">const</span> seg = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.segment_command_64.html">segment_command_64</a>).?;
                        <span class="tok-kw">try</span> ctx.segments.append(ctx.gpa, seg);
                        <span class="tok-kw">try</span> ctx.sections.ensureUnusedCapacity(ctx.gpa, seg.nsects);
                        <span class="tok-kw">for</span> (cmd.getSections()) |sect| {
                            ctx.sections.appendAssumeCapacity(sect);
                        }
                    },
                    .SYMTAB =&gt; {
                        <span class="tok-kw">const</span> lc = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.symtab_command.html">symtab_command</a>).?;
                        <span class="tok-kw">const</span> symtab = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.macho.html">macho</a>.<a href="std.macho.nlist_64.html">nlist_64</a>, <span class="tok-builtin">@ptrCast</span>(ctx.data.ptr + lc.symoff))[<span class="tok-number">0</span>..lc.nsyms];
                        <span class="tok-kw">const</span> strtab = ctx.data[lc.stroff..][<span class="tok-number">0</span>..lc.strsize];
                        <span class="tok-kw">try</span> ctx.symtab.appendUnalignedSlice(ctx.gpa, symtab);
                        <span class="tok-kw">try</span> ctx.strtab.appendSlice(ctx.gpa, strtab);
                    },
                    .DYSYMTAB =&gt; {
                        <span class="tok-kw">const</span> lc = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.dysymtab_command.html">dysymtab_command</a>).?;
                        <span class="tok-kw">const</span> indexes = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(ctx.data.ptr + lc.indirectsymoff))[<span class="tok-number">0</span>..lc.nindirectsyms];
                        <span class="tok-kw">try</span> ctx.indsymtab.appendUnalignedSlice(ctx.gpa, indexes);
                    },
                    .LOAD_DYLIB,
                    .LOAD_WEAK_DYLIB,
                    .REEXPORT_DYLIB,
                    =&gt; {
                        <span class="tok-kw">try</span> ctx.imports.append(ctx.gpa, cmd.getDylibPathName());
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                }

                i += <span class="tok-number">1</span>;
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, off: <span class="tok-type">u32</span>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(off &lt; ctx.strtab.items.len);
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(ctx.strtab.items.ptr + off)), <span class="tok-number">0</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getLoadCommandIterator</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>) <a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a> {
            <span class="tok-kw">const</span> data = ctx.data[<span class="tok-builtin">@sizeOf</span>(<a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>)..][<span class="tok-number">0</span>..ctx.header.sizeofcmds];
            <span class="tok-kw">return</span> .{ .ncmds = ctx.header.ncmds, .buffer = data };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getLoadCommand</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, cmd: <a href="std.macho.html">macho</a>.<a href="std.macho.LC.html">LC</a>) ?<a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>.<a href="std.macho.LoadCommandIterator.LoadCommand.html">LoadCommand</a> {
            <span class="tok-kw">var</span> it = ctx.getLoadCommandIterator();
            <span class="tok-kw">while</span> (it.next()) |lc| <span class="tok-kw">if</span> (lc.cmd() == cmd) {
                <span class="tok-kw">return</span> lc;
            };
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSegmentByName</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.macho.html">macho</a>.<a href="std.macho.segment_command_64.html">segment_command_64</a> {
            <span class="tok-kw">for</span> (ctx.segments.items) |seg| {
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, seg.segName(), name)) <span class="tok-kw">return</span> seg;
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSectionByName</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, segname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, sectname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.macho.html">macho</a>.<a href="std.macho.section_64.html">section_64</a> {
            <span class="tok-kw">for</span> (ctx.sections.items) |sect| {
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sect.segName(), segname) <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sect.sectName(), sectname)) <span class="tok-kw">return</span> sect;
            }
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpHeader</span>(hdr: <a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> cputype = <span class="tok-kw">switch</span> (hdr.cputype) {
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.CPU_TYPE_ARM64">CPU_TYPE_ARM64</a> =&gt; <span class="tok-str">&quot;ARM64&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.CPU_TYPE_X86_64">CPU_TYPE_X86_64</a> =&gt; <span class="tok-str">&quot;X86_64&quot;</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;Unknown&quot;</span>,
            };
            <span class="tok-kw">const</span> filetype = <span class="tok-kw">switch</span> (hdr.filetype) {
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_OBJECT">MH_OBJECT</a> =&gt; <span class="tok-str">&quot;MH_OBJECT&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_EXECUTE">MH_EXECUTE</a> =&gt; <span class="tok-str">&quot;MH_EXECUTE&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_FVMLIB">MH_FVMLIB</a> =&gt; <span class="tok-str">&quot;MH_FVMLIB&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_CORE">MH_CORE</a> =&gt; <span class="tok-str">&quot;MH_CORE&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_PRELOAD">MH_PRELOAD</a> =&gt; <span class="tok-str">&quot;MH_PRELOAD&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_DYLIB">MH_DYLIB</a> =&gt; <span class="tok-str">&quot;MH_DYLIB&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_DYLINKER">MH_DYLINKER</a> =&gt; <span class="tok-str">&quot;MH_DYLINKER&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_BUNDLE">MH_BUNDLE</a> =&gt; <span class="tok-str">&quot;MH_BUNDLE&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_DYLIB_STUB">MH_DYLIB_STUB</a> =&gt; <span class="tok-str">&quot;MH_DYLIB_STUB&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_DSYM">MH_DSYM</a> =&gt; <span class="tok-str">&quot;MH_DSYM&quot;</span>,
                <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_KEXT_BUNDLE">MH_KEXT_BUNDLE</a> =&gt; <span class="tok-str">&quot;MH_KEXT_BUNDLE&quot;</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;Unknown&quot;</span>,
            };

            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\header</span>
                <span class="tok-str">\\cputype {s}</span>
                <span class="tok-str">\\filetype {s}</span>
                <span class="tok-str">\\ncmds {d}</span>
                <span class="tok-str">\\sizeofcmds {x}</span>
                <span class="tok-str">\\flags</span>
            , .{
                cputype,
                filetype,
                hdr.ncmds,
                hdr.sizeofcmds,
            });

            <span class="tok-kw">if</span> (hdr.flags &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_NOUNDEFS">MH_NOUNDEFS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOUNDEFS&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_INCRLINK">MH_INCRLINK</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; INCRLINK&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_DYLDLINK">MH_DYLDLINK</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DYLDLINK&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_BINDATLOAD">MH_BINDATLOAD</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; BINDATLOAD&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_PREBOUND">MH_PREBOUND</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; PREBOUND&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_SPLIT_SEGS">MH_SPLIT_SEGS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SPLIT_SEGS&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_LAZY_INIT">MH_LAZY_INIT</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; LAZY_INIT&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_TWOLEVEL">MH_TWOLEVEL</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; TWOLEVEL&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_FORCE_FLAT">MH_FORCE_FLAT</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; FORCE_FLAT&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_NOMULTIDEFS">MH_NOMULTIDEFS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOMULTIDEFS&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_NOFIXPREBINDING">MH_NOFIXPREBINDING</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOFIXPREBINDING&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_PREBINDABLE">MH_PREBINDABLE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; PREBINDABLE&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_ALLMODSBOUND">MH_ALLMODSBOUND</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ALLMODSBOUND&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_SUBSECTIONS_VIA_SYMBOLS">MH_SUBSECTIONS_VIA_SYMBOLS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SUBSECTIONS_VIA_SYMBOLS&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_CANONICAL">MH_CANONICAL</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; CANONICAL&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_WEAK_DEFINES">MH_WEAK_DEFINES</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; WEAK_DEFINES&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_BINDS_TO_WEAK">MH_BINDS_TO_WEAK</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; BINDS_TO_WEAK&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_ALLOW_STACK_EXECUTION">MH_ALLOW_STACK_EXECUTION</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ALLOW_STACK_EXECUTION&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_ROOT_SAFE">MH_ROOT_SAFE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ROOT_SAFE&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_SETUID_SAFE">MH_SETUID_SAFE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SETUID_SAFE&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_NO_REEXPORTED_DYLIBS">MH_NO_REEXPORTED_DYLIBS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NO_REEXPORTED_DYLIBS&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_PIE">MH_PIE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; PIE&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_DEAD_STRIPPABLE_DYLIB">MH_DEAD_STRIPPABLE_DYLIB</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DEAD_STRIPPABLE_DYLIB&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_HAS_TLV_DESCRIPTORS">MH_HAS_TLV_DESCRIPTORS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; HAS_TLV_DESCRIPTORS&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_NO_HEAP_EXECUTION">MH_NO_HEAP_EXECUTION</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NO_HEAP_EXECUTION&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_APP_EXTENSION_SAFE">MH_APP_EXTENSION_SAFE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; APP_EXTENSION_SAFE&quot;</span>);
                <span class="tok-kw">if</span> (hdr.flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_NLIST_OUTOFSYNC_WITH_DYLDINFO">MH_NLIST_OUTOFSYNC_WITH_DYLDINFO</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NLIST_OUTOFSYNC_WITH_DYLDINFO&quot;</span>);
            }

            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpLoadCommand</span>(lc: <a href="std.macho.html">macho</a>.<a href="std.macho.LoadCommandIterator.html">LoadCommandIterator</a>.<a href="std.macho.LoadCommandIterator.LoadCommand.html">LoadCommand</a>, index: <span class="tok-type">usize</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {<span class="tok-comment">
            // print header first
            </span><span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\LC {d}</span>
                <span class="tok-str">\\cmd {s}</span>
                <span class="tok-str">\\cmdsize {d}</span>
            , .{ index, <span class="tok-builtin">@tagName</span>(lc.cmd()), lc.cmdsize() });

            <span class="tok-kw">switch</span> (lc.cmd()) {
                .SEGMENT_64 =&gt; {
                    <span class="tok-kw">const</span> seg = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.segment_command_64.html">segment_command_64</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\segname {s}</span>
                        <span class="tok-str">\\vmaddr {x}</span>
                        <span class="tok-str">\\vmsize {x}</span>
                        <span class="tok-str">\\fileoff {x}</span>
                        <span class="tok-str">\\filesz {x}</span>
                    , .{
                        seg.segName(),
                        seg.vmaddr,
                        seg.vmsize,
                        seg.fileoff,
                        seg.filesize,
                    });

                    <span class="tok-kw">for</span> (lc.getSections()) |sect| {
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                        <span class="tok-kw">try</span> writer.print(
                            <span class="tok-str">\\sectname {s}</span>
                            <span class="tok-str">\\addr {x}</span>
                            <span class="tok-str">\\size {x}</span>
                            <span class="tok-str">\\offset {x}</span>
                            <span class="tok-str">\\align {x}</span>
                        , .{
                            sect.sectName(),
                            sect.addr,
                            sect.size,
                            sect.offset,
                            sect.@&quot;align&quot;,
                        });
                    }
                },

                .ID_DYLIB,
                .LOAD_DYLIB,
                .LOAD_WEAK_DYLIB,
                .REEXPORT_DYLIB,
                =&gt; {
                    <span class="tok-kw">const</span> dylib = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.dylib_command.html">dylib_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\name {s}</span>
                        <span class="tok-str">\\timestamp {d}</span>
                        <span class="tok-str">\\current version {x}</span>
                        <span class="tok-str">\\compatibility version {x}</span>
                    , .{
                        lc.getDylibPathName(),
                        dylib.dylib.timestamp,
                        dylib.dylib.current_version,
                        dylib.dylib.compatibility_version,
                    });
                },

                .MAIN =&gt; {
                    <span class="tok-kw">const</span> main = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.entry_point_command.html">entry_point_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\entryoff {x}</span>
                        <span class="tok-str">\\stacksize {x}</span>
                    , .{ main.entryoff, main.stacksize });
                },

                .RPATH =&gt; {
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\path {s}</span>
                    , .{
                        lc.getRpathPathName(),
                    });
                },

                .UUID =&gt; {
                    <span class="tok-kw">const</span> uuid = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.uuid_command.html">uuid_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;uuid {x}&quot;</span>, .{<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(&amp;uuid.uuid)});
                },

                .DATA_IN_CODE,
                .FUNCTION_STARTS,
                .CODE_SIGNATURE,
                =&gt; {
                    <span class="tok-kw">const</span> llc = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.linkedit_data_command.html">linkedit_data_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\dataoff {x}</span>
                        <span class="tok-str">\\datasize {x}</span>
                    , .{ llc.dataoff, llc.datasize });
                },

                .DYLD_INFO_ONLY =&gt; {
                    <span class="tok-kw">const</span> dlc = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.dyld_info_command.html">dyld_info_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\rebaseoff {x}</span>
                        <span class="tok-str">\\rebasesize {x}</span>
                        <span class="tok-str">\\bindoff {x}</span>
                        <span class="tok-str">\\bindsize {x}</span>
                        <span class="tok-str">\\weakbindoff {x}</span>
                        <span class="tok-str">\\weakbindsize {x}</span>
                        <span class="tok-str">\\lazybindoff {x}</span>
                        <span class="tok-str">\\lazybindsize {x}</span>
                        <span class="tok-str">\\exportoff {x}</span>
                        <span class="tok-str">\\exportsize {x}</span>
                    , .{
                        dlc.rebase_off,
                        dlc.rebase_size,
                        dlc.bind_off,
                        dlc.bind_size,
                        dlc.weak_bind_off,
                        dlc.weak_bind_size,
                        dlc.lazy_bind_off,
                        dlc.lazy_bind_size,
                        dlc.export_off,
                        dlc.export_size,
                    });
                },

                .SYMTAB =&gt; {
                    <span class="tok-kw">const</span> slc = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.symtab_command.html">symtab_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\symoff {x}</span>
                        <span class="tok-str">\\nsyms {x}</span>
                        <span class="tok-str">\\stroff {x}</span>
                        <span class="tok-str">\\strsize {x}</span>
                    , .{
                        slc.symoff,
                        slc.nsyms,
                        slc.stroff,
                        slc.strsize,
                    });
                },

                .DYSYMTAB =&gt; {
                    <span class="tok-kw">const</span> dlc = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.dysymtab_command.html">dysymtab_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\ilocalsym {x}</span>
                        <span class="tok-str">\\nlocalsym {x}</span>
                        <span class="tok-str">\\iextdefsym {x}</span>
                        <span class="tok-str">\\nextdefsym {x}</span>
                        <span class="tok-str">\\iundefsym {x}</span>
                        <span class="tok-str">\\nundefsym {x}</span>
                        <span class="tok-str">\\indirectsymoff {x}</span>
                        <span class="tok-str">\\nindirectsyms {x}</span>
                    , .{
                        dlc.ilocalsym,
                        dlc.nlocalsym,
                        dlc.iextdefsym,
                        dlc.nextdefsym,
                        dlc.iundefsym,
                        dlc.nundefsym,
                        dlc.indirectsymoff,
                        dlc.nindirectsyms,
                    });
                },

                .BUILD_VERSION =&gt; {
                    <span class="tok-kw">const</span> blc = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.build_version_command.html">build_version_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\platform {s}</span>
                        <span class="tok-str">\\minos {d}.{d}.{d}</span>
                        <span class="tok-str">\\sdk {d}.{d}.{d}</span>
                        <span class="tok-str">\\ntools {d}</span>
                    , .{
                        <span class="tok-builtin">@tagName</span>(blc.platform),
                        blc.minos &gt;&gt; <span class="tok-number">16</span>,
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(blc.minos &gt;&gt; <span class="tok-number">8</span>)),
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(blc.minos)),
                        blc.sdk &gt;&gt; <span class="tok-number">16</span>,
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(blc.sdk &gt;&gt; <span class="tok-number">8</span>)),
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(blc.sdk)),
                        blc.ntools,
                    });
                    <span class="tok-kw">for</span> (lc.getBuildVersionTools()) |tool| {
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                        <span class="tok-kw">switch</span> (tool.tool) {
                            .CLANG, .SWIFT, .LD, .LLD, .ZIG =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;tool {s}\n&quot;</span>, .{<span class="tok-builtin">@tagName</span>(tool.tool)}),
                            <span class="tok-kw">else</span> =&gt; |x| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;tool {d}\n&quot;</span>, .{<span class="tok-builtin">@intFromEnum</span>(x)}),
                        }
                        <span class="tok-kw">try</span> writer.print(
                            <span class="tok-str">\\version {d}.{d}.{d}</span>
                        , .{
                            tool.version &gt;&gt; <span class="tok-number">16</span>,
                            <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(tool.version &gt;&gt; <span class="tok-number">8</span>)),
                            <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(tool.version)),
                        });
                    }
                },

                .VERSION_MIN_MACOSX,
                .VERSION_MIN_IPHONEOS,
                .VERSION_MIN_WATCHOS,
                .VERSION_MIN_TVOS,
                =&gt; {
                    <span class="tok-kw">const</span> vlc = lc.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.version_min_command.html">version_min_command</a>).?;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\version {d}.{d}.{d}</span>
                        <span class="tok-str">\\sdk {d}.{d}.{d}</span>
                    , .{
                        vlc.version &gt;&gt; <span class="tok-number">16</span>,
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(vlc.version &gt;&gt; <span class="tok-number">8</span>)),
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(vlc.version)),
                        vlc.sdk &gt;&gt; <span class="tok-number">16</span>,
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(vlc.sdk &gt;&gt; <span class="tok-number">8</span>)),
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(vlc.sdk)),
                    });
                },

                <span class="tok-kw">else</span> =&gt; {},
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpSymtab</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.symtab_label">symtab_label</a> ++ <span class="tok-str">&quot;\n&quot;</span>);

            <span class="tok-kw">for</span> (ctx.symtab.items) |sym| {
                <span class="tok-kw">const</span> sym_name = ctx.getString(sym.n_strx);
                <span class="tok-kw">if</span> (sym.stab()) {
                    <span class="tok-kw">const</span> tt = <span class="tok-kw">switch</span> (sym.n_type) {
                        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_SO">N_SO</a> =&gt; <span class="tok-str">&quot;SO&quot;</span>,
                        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_OSO">N_OSO</a> =&gt; <span class="tok-str">&quot;OSO&quot;</span>,
                        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_BNSYM">N_BNSYM</a> =&gt; <span class="tok-str">&quot;BNSYM&quot;</span>,
                        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_ENSYM">N_ENSYM</a> =&gt; <span class="tok-str">&quot;ENSYM&quot;</span>,
                        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_FUN">N_FUN</a> =&gt; <span class="tok-str">&quot;FUN&quot;</span>,
                        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_GSYM">N_GSYM</a> =&gt; <span class="tok-str">&quot;GSYM&quot;</span>,
                        <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_STSYM">N_STSYM</a> =&gt; <span class="tok-str">&quot;STSYM&quot;</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;UNKNOWN STAB&quot;</span>,
                    };
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x}&quot;</span>, .{sym.n_value});
                    <span class="tok-kw">if</span> (sym.n_sect &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">const</span> sect = ctx.sections.items[sym.n_sect - <span class="tok-number">1</span>];
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; ({s},{s})&quot;</span>, .{ sect.segName(), sect.sectName() });
                    }
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s} (stab) {s}\n&quot;</span>, .{ tt, sym_name });
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.sect()) {
                    <span class="tok-kw">const</span> sect = ctx.sections.items[sym.n_sect - <span class="tok-number">1</span>];
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x} ({s},{s})&quot;</span>, .{
                        sym.n_value,
                        sect.segName(),
                        sect.sectName(),
                    });
                    <span class="tok-kw">if</span> (sym.n_desc &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REFERENCED_DYNAMICALLY">REFERENCED_DYNAMICALLY</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; [referenced dynamically]&quot;</span>);
                    <span class="tok-kw">if</span> (sym.weakDef()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; weak&quot;</span>);
                    <span class="tok-kw">if</span> (sym.weakRef()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; weakref&quot;</span>);
                    <span class="tok-kw">if</span> (sym.ext()) {
                        <span class="tok-kw">if</span> (sym.pext()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; private&quot;</span>);
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; external&quot;</span>);
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.pext()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; (was private external)&quot;</span>);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}\n&quot;</span>, .{sym_name});
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.tentative()) {
                    <span class="tok-kw">const</span> alignment = (sym.n_desc &gt;&gt; <span class="tok-number">8</span>) &amp; <span class="tok-number">0x0F</span>;
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  0x{x:0&gt;16} (common) (alignment 2^{d})&quot;</span>, .{ sym.n_value, alignment });
                    <span class="tok-kw">if</span> (sym.ext()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; external&quot;</span>);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}\n&quot;</span>, .{sym_name});
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.undf()) {
                    <span class="tok-kw">const</span> ordinal = <span class="tok-builtin">@divFloor</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-builtin">@bitCast</span>(sym.n_desc)), <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.N_SYMBOL_RESOLVER">N_SYMBOL_RESOLVER</a>);
                    <span class="tok-kw">const</span> import_name = blk: {
                        <span class="tok-kw">if</span> (ordinal &lt;= <span class="tok-number">0</span>) {
                            <span class="tok-kw">if</span> (ordinal == <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_SPECIAL_DYLIB_SELF">BIND_SPECIAL_DYLIB_SELF</a>)
                                <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;self import&quot;</span>;
                            <span class="tok-kw">if</span> (ordinal == <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE">BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE</a>)
                                <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;main executable&quot;</span>;
                            <span class="tok-kw">if</span> (ordinal == <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_SPECIAL_DYLIB_FLAT_LOOKUP">BIND_SPECIAL_DYLIB_FLAT_LOOKUP</a>)
                                <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;flat lookup&quot;</span>;
                            <span class="tok-kw">unreachable</span>;
                        }
                        <span class="tok-kw">const</span> full_path = ctx.imports.items[<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@bitCast</span>(ordinal)) - <span class="tok-number">1</span>];
                        <span class="tok-kw">const</span> basename = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(full_path);
                        <a href="std.debug.html#std.debug.assert">assert</a>(basename.len &gt; <span class="tok-number">0</span>);
                        <span class="tok-kw">const</span> ext = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(<span class="tok-type">u8</span>, basename, <span class="tok-str">'.'</span>) <span class="tok-kw">orelse</span> basename.len;
                        <span class="tok-kw">break</span> :blk basename[<span class="tok-number">0</span>..ext];
                    };
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;(undefined)&quot;</span>);
                    <span class="tok-kw">if</span> (sym.weakRef()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; weakref&quot;</span>);
                    <span class="tok-kw">if</span> (sym.ext()) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; external&quot;</span>);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s} (from {s})\n&quot;</span>, .{
                        sym_name,
                        import_name,
                    });
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpIndirectSymtab</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.indirect_symtab_label">indirect_symtab_label</a> ++ <span class="tok-str">&quot;\n&quot;</span>);

            <span class="tok-kw">var</span> sects_buffer: [<span class="tok-number">3</span>]<a href="std.macho.html">macho</a>.<a href="std.macho.section_64.html">section_64</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> sects = blk: {
                <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">if</span> (ctx.getSectionByName(<span class="tok-str">&quot;__TEXT&quot;</span>, <span class="tok-str">&quot;__stubs&quot;</span>)) |sect| {
                    sects_buffer[count] = sect;
                    count += <span class="tok-number">1</span>;
                }
                <span class="tok-kw">if</span> (ctx.getSectionByName(<span class="tok-str">&quot;__DATA_CONST&quot;</span>, <span class="tok-str">&quot;__got&quot;</span>)) |sect| {
                    sects_buffer[count] = sect;
                    count += <span class="tok-number">1</span>;
                }
                <span class="tok-kw">if</span> (ctx.getSectionByName(<span class="tok-str">&quot;__DATA&quot;</span>, <span class="tok-str">&quot;__la_symbol_ptr&quot;</span>)) |sect| {
                    sects_buffer[count] = sect;
                    count += <span class="tok-number">1</span>;
                }
                <span class="tok-kw">break</span> :blk sects_buffer[<span class="tok-number">0</span>..count];
            };

            <span class="tok-kw">const</span> sortFn = <span class="tok-kw">struct</span> {
                <span class="tok-kw">fn</span> <span class="tok-fn">sortFn</span>(c: <span class="tok-type">void</span>, lhs: <a href="std.macho.html">macho</a>.<a href="std.macho.section_64.html">section_64</a>, rhs: <a href="std.macho.html">macho</a>.<a href="std.macho.section_64.html">section_64</a>) <span class="tok-type">bool</span> {
                    _ = c;
                    <span class="tok-kw">return</span> lhs.reserved1 &lt; rhs.reserved1;
                }
            }.sortFn;
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(<a href="std.macho.html">macho</a>.<a href="std.macho.section_64.html">section_64</a>, sects, {}, sortFn);

            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (i &lt; sects.len) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> sect = sects[i];
                <span class="tok-kw">const</span> start = sect.reserved1;
                <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (i + <span class="tok-number">1</span> &gt;= sects.len) ctx.indsymtab.items.len <span class="tok-kw">else</span> sects[i + <span class="tok-number">1</span>].reserved1;
                <span class="tok-kw">const</span> entry_size = blk: {
                    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, sect.sectName(), <span class="tok-str">&quot;__stubs&quot;</span>)) <span class="tok-kw">break</span> :blk sect.reserved2;
                    <span class="tok-kw">break</span> :blk <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);
                };

                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s},{s}\n&quot;</span>, .{ sect.segName(), sect.sectName() });
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;nentries {d}\n&quot;</span>, .{end - start});
                <span class="tok-kw">for</span> (ctx.indsymtab.items[start..end], <span class="tok-number">0</span>..) |index, j| {
                    <span class="tok-kw">const</span> sym = ctx.symtab.items[index];
                    <span class="tok-kw">const</span> addr = sect.addr + entry_size * j;
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{x} {d} {s}\n&quot;</span>, .{ addr, index, ctx.getString(sym.n_strx) });
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpRebaseInfo</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> rebases = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u64</span>).init(ctx.gpa);
            <span class="tok-kw">defer</span> rebases.deinit();
            <span class="tok-kw">try</span> ctx.parseRebaseInfo(data, &amp;rebases);
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(<span class="tok-type">u64</span>, rebases.items, {}, <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.asc">asc</a>(<span class="tok-type">u64</span>));
            <span class="tok-kw">for</span> (rebases.items) |addr| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{x}\n&quot;</span>, .{addr});
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">parseRebaseInfo</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, rebases: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u64</span>)) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
            <span class="tok-kw">var</span> creader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.counting_reader.html#std.io.counting_reader.countingReader">countingReader</a>(stream.reader());
            <span class="tok-kw">const</span> reader = creader.reader();

            <span class="tok-kw">var</span> seg_id: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> byte = reader.readByte() <span class="tok-kw">catch</span> <span class="tok-kw">break</span>;
                <span class="tok-kw">const</span> opc = byte &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_MASK">REBASE_OPCODE_MASK</a>;
                <span class="tok-kw">const</span> imm = byte &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_IMMEDIATE_MASK">REBASE_IMMEDIATE_MASK</a>;
                <span class="tok-kw">switch</span> (opc) {
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_DONE">REBASE_OPCODE_DONE</a> =&gt; <span class="tok-kw">break</span>,
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_SET_TYPE_IMM">REBASE_OPCODE_SET_TYPE_IMM</a> =&gt; {},
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB">REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</a> =&gt; {
                        seg_id = imm;
                        offset = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_ADD_ADDR_IMM_SCALED">REBASE_OPCODE_ADD_ADDR_IMM_SCALED</a> =&gt; {
                        offset += imm * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_ADD_ADDR_ULEB">REBASE_OPCODE_ADD_ADDR_ULEB</a> =&gt; {
                        <span class="tok-kw">const</span> addend = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                        offset += addend;
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB">REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB</a> =&gt; {
                        <span class="tok-kw">const</span> addend = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                        <span class="tok-kw">const</span> seg = ctx.segments.items[seg_id.?];
                        <span class="tok-kw">const</span> addr = seg.vmaddr + offset;
                        <span class="tok-kw">try</span> rebases.append(addr);
                        offset += addend + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_DO_REBASE_IMM_TIMES">REBASE_OPCODE_DO_REBASE_IMM_TIMES</a>,
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_DO_REBASE_ULEB_TIMES">REBASE_OPCODE_DO_REBASE_ULEB_TIMES</a>,
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB">REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB</a>,
                    =&gt; {
                        <span class="tok-kw">var</span> ntimes: <span class="tok-type">u64</span> = <span class="tok-number">1</span>;
                        <span class="tok-kw">var</span> skip: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
                        <span class="tok-kw">switch</span> (opc) {
                            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_DO_REBASE_IMM_TIMES">REBASE_OPCODE_DO_REBASE_IMM_TIMES</a> =&gt; {
                                ntimes = imm;
                            },
                            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_DO_REBASE_ULEB_TIMES">REBASE_OPCODE_DO_REBASE_ULEB_TIMES</a> =&gt; {
                                ntimes = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                            },
                            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB">REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB</a> =&gt; {
                                ntimes = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                                skip = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                            },
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }
                        <span class="tok-kw">const</span> seg = ctx.segments.items[seg_id.?];
                        <span class="tok-kw">const</span> base_addr = seg.vmaddr;
                        <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                        <span class="tok-kw">while</span> (count &lt; ntimes) : (count += <span class="tok-number">1</span>) {
                            <span class="tok-kw">const</span> addr = base_addr + offset;
                            <span class="tok-kw">try</span> rebases.append(addr);
                            offset += skip + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
                }
            }
        }

        <span class="tok-kw">const</span> Binding = <span class="tok-kw">struct</span> {
            address: <span class="tok-type">u64</span>,
            addend: <span class="tok-type">i64</span>,
            ordinal: <span class="tok-type">u16</span>,
            tag: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.Tag.html">Tag</a>,
            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(binding: *<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html">Binding</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
                gpa.free(binding.name);
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, lhs: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html">Binding</a>, rhs: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html">Binding</a>) <span class="tok-type">bool</span> {
                _ = ctx;
                <span class="tok-kw">return</span> lhs.address &lt; rhs.address;
            }

            <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span> {
                ord,
                self,
                exe,
                flat,
            };
        };

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpBindInfo</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> bindings = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html">Binding</a>).init(ctx.gpa);
            <span class="tok-kw">defer</span> {
                <span class="tok-kw">for</span> (bindings.items) |*b| {
                    b.deinit(ctx.gpa);
                }
                bindings.deinit();
            }
            <span class="tok-kw">try</span> ctx.parseBindInfo(data, &amp;bindings);
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html">Binding</a>, bindings.items, {}, <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html">Binding</a>.<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html#std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.lessThan">lessThan</a>);
            <span class="tok-kw">for</span> (bindings.items) |binding| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{x} [addend: {d}]&quot;</span>, .{ binding.address, binding.addend });
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; (&quot;</span>);
                <span class="tok-kw">switch</span> (binding.tag) {
                    .self =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;self&quot;</span>),
                    .exe =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;main executable&quot;</span>),
                    .flat =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;flat lookup&quot;</span>),
                    .ord =&gt; <span class="tok-kw">try</span> writer.writeAll(<a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.basename">basename</a>(ctx.imports.items[binding.ordinal - <span class="tok-number">1</span>])),
                }
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;) {s}\n&quot;</span>, .{binding.name});
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">parseBindInfo</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bindings: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html">Binding</a>)) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
            <span class="tok-kw">var</span> creader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.counting_reader.html#std.io.counting_reader.countingReader">countingReader</a>(stream.reader());
            <span class="tok-kw">const</span> reader = creader.reader();

            <span class="tok-kw">var</span> seg_id: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> tag: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.html">Binding</a>.<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Binding.Tag.html">Tag</a> = .self;
            <span class="tok-kw">var</span> ordinal: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> addend: <span class="tok-type">i64</span> = <span class="tok-number">0</span>;

            <span class="tok-kw">var</span> name_buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(ctx.gpa);
            <span class="tok-kw">defer</span> name_buf.deinit();

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> byte = reader.readByte() <span class="tok-kw">catch</span> <span class="tok-kw">break</span>;
                <span class="tok-kw">const</span> opc = byte &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_MASK">BIND_OPCODE_MASK</a>;
                <span class="tok-kw">const</span> imm = byte &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_IMMEDIATE_MASK">BIND_IMMEDIATE_MASK</a>;
                <span class="tok-kw">switch</span> (opc) {
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DONE">BIND_OPCODE_DONE</a>,
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_SET_TYPE_IMM">BIND_OPCODE_SET_TYPE_IMM</a>,
                    =&gt; {},
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_SET_DYLIB_ORDINAL_IMM">BIND_OPCODE_SET_DYLIB_ORDINAL_IMM</a> =&gt; {
                        tag = .ord;
                        ordinal = imm;
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_SET_DYLIB_SPECIAL_IMM">BIND_OPCODE_SET_DYLIB_SPECIAL_IMM</a> =&gt; {
                        <span class="tok-kw">switch</span> (imm) {
                            <span class="tok-number">0</span> =&gt; tag = .self,
                            <span class="tok-number">0xf</span> =&gt; tag = .exe,
                            <span class="tok-number">0xe</span> =&gt; tag = .flat,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB">BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</a> =&gt; {
                        seg_id = imm;
                        offset = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM">BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM</a> =&gt; {
                        name_buf.clearRetainingCapacity();
                        <span class="tok-kw">try</span> reader.readUntilDelimiterArrayList(&amp;name_buf, <span class="tok-number">0</span>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>));
                        <span class="tok-kw">try</span> name_buf.append(<span class="tok-number">0</span>);
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_SET_ADDEND_SLEB">BIND_OPCODE_SET_ADDEND_SLEB</a> =&gt; {
                        addend = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader);
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_ADD_ADDR_ULEB">BIND_OPCODE_ADD_ADDR_ULEB</a> =&gt; {
                        <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                        offset = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(offset)) + <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@bitCast</span>(x)));
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DO_BIND">BIND_OPCODE_DO_BIND</a>,
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB">BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB</a>,
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED">BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED</a>,
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB">BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB</a>,
                    =&gt; {
                        <span class="tok-kw">var</span> add_addr: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
                        <span class="tok-kw">var</span> count: <span class="tok-type">u64</span> = <span class="tok-number">1</span>;
                        <span class="tok-kw">var</span> skip: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;

                        <span class="tok-kw">switch</span> (opc) {
                            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DO_BIND">BIND_OPCODE_DO_BIND</a> =&gt; {},
                            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB">BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB</a> =&gt; {
                                add_addr = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                            },
                            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED">BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED</a> =&gt; {
                                add_addr = imm * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>);
                            },
                            <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB">BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB</a> =&gt; {
                                count = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                                skip = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                            },
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }

                        <span class="tok-kw">const</span> seg = ctx.segments.items[seg_id.?];
                        <span class="tok-kw">var</span> i: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
                        <span class="tok-kw">while</span> (i &lt; count) : (i += <span class="tok-number">1</span>) {
                            <span class="tok-kw">const</span> addr: <span class="tok-type">u64</span> = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(seg.vmaddr + offset)));
                            <span class="tok-kw">try</span> bindings.append(.{
                                .address = addr,
                                .addend = addend,
                                .tag = tag,
                                .ordinal = ordinal,
                                .name = <span class="tok-kw">try</span> ctx.gpa.dupe(<span class="tok-type">u8</span>, name_buf.items),
                            });
                            offset += skip + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>) + add_addr;
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpExportsTrie</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> seg = ctx.getSegmentByName(<span class="tok-str">&quot;__TEXT&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;

            <span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(ctx.gpa);
            <span class="tok-kw">defer</span> arena.deinit();

            <span class="tok-kw">var</span> exports = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.html">Export</a>).init(arena.allocator());
            <span class="tok-kw">var</span> it = <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.TrieIterator.html">TrieIterator</a>{ .data = data };
            <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html#std.Build.Step.CheckObject.MachODumper.ObjectContext.parseTrieNode">parseTrieNode</a>(arena.allocator(), &amp;it, <span class="tok-str">&quot;&quot;</span>, &amp;exports);

            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sort">sort</a>(<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.html">Export</a>, exports.items, {}, <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.html">Export</a>.<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.html#std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.lessThan">lessThan</a>);

            <span class="tok-kw">for</span> (exports.items) |exp| {
                <span class="tok-kw">switch</span> (exp.tag) {
                    .@&quot;export&quot; =&gt; {
                        <span class="tok-kw">const</span> info = exp.data.@&quot;export&quot;;
                        <span class="tok-kw">if</span> (info.kind != .regular <span class="tok-kw">or</span> info.weak) {
                            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'['</span>);
                        }
                        <span class="tok-kw">switch</span> (info.kind) {
                            .regular =&gt; {},
                            .absolute =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;ABS, &quot;</span>),
                            .tlv =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;THREAD_LOCAL, &quot;</span>),
                        }
                        <span class="tok-kw">if</span> (info.weak) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;WEAK&quot;</span>);
                        <span class="tok-kw">if</span> (info.kind != .regular <span class="tok-kw">or</span> info.weak) {
                            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;] &quot;</span>);
                        }
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x} &quot;</span>, .{seg.vmaddr + info.vmoffset});
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                }

                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{exp.name});
            }
        }

        <span class="tok-kw">const</span> TrieIterator = <span class="tok-kw">struct</span> {
            data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            pos: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">getStream</span>(it: *<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.TrieIterator.html">TrieIterator</a>) <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {
                <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(it.data[it.pos..]);
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">readUleb128</span>(it: *<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.TrieIterator.html">TrieIterator</a>) !<span class="tok-type">u64</span> {
                <span class="tok-kw">var</span> stream = it.getStream();
                <span class="tok-kw">var</span> creader = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.counting_reader.html#std.io.counting_reader.countingReader">countingReader</a>(stream.reader());
                <span class="tok-kw">const</span> reader = creader.reader();
                <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader);
                it.pos += creader.bytes_read;
                <span class="tok-kw">return</span> value;
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">readString</span>(it: *<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.TrieIterator.html">TrieIterator</a>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
                <span class="tok-kw">var</span> stream = it.getStream();
                <span class="tok-kw">const</span> reader = stream.reader();

                <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (count += <span class="tok-number">1</span>) {
                    <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> reader.readByte();
                    <span class="tok-kw">if</span> (byte == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                }

                <span class="tok-kw">const</span> str = <span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(it.data.ptr + it.pos))[<span class="tok-number">0</span>..count :<span class="tok-number">0</span>];
                it.pos += count + <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> str;
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">readByte</span>(it: *<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.TrieIterator.html">TrieIterator</a>) !<span class="tok-type">u8</span> {
                <span class="tok-kw">var</span> stream = it.getStream();
                <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> stream.reader().readByte();
                it.pos += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> value;
            }
        };

        <span class="tok-kw">const</span> Export = <span class="tok-kw">struct</span> {
            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            tag: <span class="tok-kw">enum</span> { @&quot;export&quot;, reexport, stub_resolver },
            data: <span class="tok-kw">union</span> {
                @&quot;export&quot;: <span class="tok-kw">struct</span> {
                    kind: <span class="tok-kw">enum</span> { regular, absolute, tlv },
                    weak: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
                    vmoffset: <span class="tok-type">u64</span>,
                },
                reexport: <span class="tok-type">u64</span>,
                stub_resolver: <span class="tok-kw">struct</span> {
                    stub_offset: <span class="tok-type">u64</span>,
                    resolver_offset: <span class="tok-type">u64</span>,
                },
            },

            <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">rankByTag</span>(@&quot;export&quot;: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.html">Export</a>) <span class="tok-type">u3</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (@&quot;export&quot;.tag) {
                    .@&quot;export&quot; =&gt; <span class="tok-number">1</span>,
                    .reexport =&gt; <span class="tok-number">2</span>,
                    .stub_resolver =&gt; <span class="tok-number">3</span>,
                };
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, lhs: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.html">Export</a>, rhs: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.html">Export</a>) <span class="tok-type">bool</span> {
                _ = ctx;
                <span class="tok-kw">if</span> (lhs.rankByTag() == rhs.rankByTag()) {
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (lhs.tag) {
                        .@&quot;export&quot; =&gt; lhs.data.@&quot;export&quot;.vmoffset &lt; rhs.data.@&quot;export&quot;.vmoffset,
                        .reexport =&gt; lhs.data.reexport &lt; rhs.data.reexport,
                        .stub_resolver =&gt; lhs.data.stub_resolver.stub_offset &lt; rhs.data.stub_resolver.stub_offset,
                    };
                }
                <span class="tok-kw">return</span> lhs.rankByTag() &lt; rhs.rankByTag();
            }
        };

        <span class="tok-kw">fn</span> <span class="tok-fn">parseTrieNode</span>(
            arena: <a href="std.mem.Allocator.html">Allocator</a>,
            it: *<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.TrieIterator.html">TrieIterator</a>,
            prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            exports: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.Export.html">Export</a>),
        ) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> it.readUleb128();
            <span class="tok-kw">if</span> (size &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> flags = <span class="tok-kw">try</span> it.readUleb128();
                <span class="tok-kw">switch</span> (flags) {
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.EXPORT_SYMBOL_FLAGS_REEXPORT">EXPORT_SYMBOL_FLAGS_REEXPORT</a> =&gt; {
                        <span class="tok-kw">const</span> ord = <span class="tok-kw">try</span> it.readUleb128();
                        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> arena.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> it.readString());
                        <span class="tok-kw">try</span> exports.append(.{
                            .name = <span class="tok-kw">if</span> (name.len &gt; <span class="tok-number">0</span>) name <span class="tok-kw">else</span> prefix,
                            .tag = .reexport,
                            .data = .{ .reexport = ord },
                        });
                    },
                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER">EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER</a> =&gt; {
                        <span class="tok-kw">const</span> stub_offset = <span class="tok-kw">try</span> it.readUleb128();
                        <span class="tok-kw">const</span> resolver_offset = <span class="tok-kw">try</span> it.readUleb128();
                        <span class="tok-kw">try</span> exports.append(.{
                            .name = prefix,
                            .tag = .stub_resolver,
                            .data = .{ .stub_resolver = .{
                                .stub_offset = stub_offset,
                                .resolver_offset = resolver_offset,
                            } },
                        });
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">const</span> vmoff = <span class="tok-kw">try</span> it.readUleb128();
                        <span class="tok-kw">try</span> exports.append(.{
                            .name = prefix,
                            .tag = .@&quot;export&quot;,
                            .data = .{ .@&quot;export&quot; = .{
                                .kind = <span class="tok-kw">switch</span> (flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.EXPORT_SYMBOL_FLAGS_KIND_MASK">EXPORT_SYMBOL_FLAGS_KIND_MASK</a>) {
                                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.EXPORT_SYMBOL_FLAGS_KIND_REGULAR">EXPORT_SYMBOL_FLAGS_KIND_REGULAR</a> =&gt; .regular,
                                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE">EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE</a> =&gt; .absolute,
                                    <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL">EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL</a> =&gt; .tlv,
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                },
                                .weak = flags &amp; <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION">EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION</a> != <span class="tok-number">0</span>,
                                .vmoffset = vmoff,
                            } },
                        });
                    },
                }
            }

            <span class="tok-kw">const</span> nedges = <span class="tok-kw">try</span> it.readByte();
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..nedges) |_| {
                <span class="tok-kw">const</span> label = <span class="tok-kw">try</span> it.readString();
                <span class="tok-kw">const</span> off = <span class="tok-kw">try</span> it.readUleb128();
                <span class="tok-kw">const</span> prefix_label = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(arena, <span class="tok-str">&quot;{s}{s}&quot;</span>, .{ prefix, label });
                <span class="tok-kw">const</span> curr = it.pos;
                it.pos = off;
                <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html#std.Build.Step.CheckObject.MachODumper.ObjectContext.parseTrieNode">parseTrieNode</a>(arena, it, prefix_label, exports);
                it.pos = curr;
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpSection</span>(ctx: <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>, sect: <a href="std.macho.html">macho</a>.<a href="std.macho.section_64.html">section_64</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> data = ctx.data[sect.offset..][<span class="tok-number">0</span>..sect.size];
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{data});
        }
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDumpObject</span>(step: *<a href="std.Build.Step.html">Step</a>, check: <a href="std.Build.Step.CheckObject.Check.html">Check</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> gpa = step.owner.allocator;
        <span class="tok-kw">const</span> hdr = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.macho.html">macho</a>.<a href="std.macho.mach_header_64.html">mach_header_64</a>, <span class="tok-builtin">@ptrCast</span>(bytes.ptr)).*;
        <span class="tok-kw">if</span> (hdr.magic != <a href="std.macho.html">macho</a>.<a href="std.macho.html#std.macho.MH_MAGIC_64">MH_MAGIC_64</a>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidMagicNumber;
        }

        <span class="tok-kw">var</span> ctx = <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>{ .gpa = gpa, .data = bytes, .header = hdr };
        <span class="tok-kw">try</span> ctx.parse();

        <span class="tok-kw">var</span> output = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(gpa);
        <span class="tok-kw">const</span> writer = output.writer();

        <span class="tok-kw">switch</span> (check.kind) {
            .headers =&gt; {
                <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>.<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html#std.Build.Step.CheckObject.MachODumper.ObjectContext.dumpHeader">dumpHeader</a>(ctx.header, writer);

                <span class="tok-kw">var</span> it = ctx.getLoadCommandIterator();
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (it.next()) |cmd| {
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html">ObjectContext</a>.<a href="std.Build.Step.CheckObject.MachODumper.ObjectContext.html#std.Build.Step.CheckObject.MachODumper.ObjectContext.dumpLoadCommand">dumpLoadCommand</a>(cmd, i, writer);
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);

                    i += <span class="tok-number">1</span>;
                }
            },

            .symtab =&gt; <span class="tok-kw">if</span> (ctx.symtab.items.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> ctx.dumpSymtab(writer);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no symbol table found&quot;</span>, .{}),

            .indirect_symtab =&gt; <span class="tok-kw">if</span> (ctx.symtab.items.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> ctx.indsymtab.items.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> ctx.dumpIndirectSymtab(writer);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no indirect symbol table found&quot;</span>, .{}),

            .dyld_rebase,
            .dyld_bind,
            .dyld_weak_bind,
            .dyld_lazy_bind,
            =&gt; {
                <span class="tok-kw">const</span> cmd = ctx.getLoadCommand(.DYLD_INFO_ONLY) <span class="tok-kw">orelse</span>
                    <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no dyld info found&quot;</span>, .{});
                <span class="tok-kw">const</span> lc = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.dyld_info_command.html">dyld_info_command</a>).?;

                <span class="tok-kw">switch</span> (check.kind) {
                    .dyld_rebase =&gt; <span class="tok-kw">if</span> (lc.rebase_size &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">const</span> data = ctx.data[lc.rebase_off..][<span class="tok-number">0</span>..lc.rebase_size];
                        <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_rebase_label">dyld_rebase_label</a> ++ <span class="tok-str">&quot;\n&quot;</span>);
                        <span class="tok-kw">try</span> ctx.dumpRebaseInfo(data, writer);
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no rebase data found&quot;</span>, .{}),

                    .dyld_bind =&gt; <span class="tok-kw">if</span> (lc.bind_size &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">const</span> data = ctx.data[lc.bind_off..][<span class="tok-number">0</span>..lc.bind_size];
                        <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_bind_label">dyld_bind_label</a> ++ <span class="tok-str">&quot;\n&quot;</span>);
                        <span class="tok-kw">try</span> ctx.dumpBindInfo(data, writer);
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no bind data found&quot;</span>, .{}),

                    .dyld_weak_bind =&gt; <span class="tok-kw">if</span> (lc.weak_bind_size &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">const</span> data = ctx.data[lc.weak_bind_off..][<span class="tok-number">0</span>..lc.weak_bind_size];
                        <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_weak_bind_label">dyld_weak_bind_label</a> ++ <span class="tok-str">&quot;\n&quot;</span>);
                        <span class="tok-kw">try</span> ctx.dumpBindInfo(data, writer);
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no weak bind data found&quot;</span>, .{}),

                    .dyld_lazy_bind =&gt; <span class="tok-kw">if</span> (lc.lazy_bind_size &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">const</span> data = ctx.data[lc.lazy_bind_off..][<span class="tok-number">0</span>..lc.lazy_bind_size];
                        <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.dyld_lazy_bind_label">dyld_lazy_bind_label</a> ++ <span class="tok-str">&quot;\n&quot;</span>);
                        <span class="tok-kw">try</span> ctx.dumpBindInfo(data, writer);
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no lazy bind data found&quot;</span>, .{}),

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            },

            .exports =&gt; blk: {
                <span class="tok-kw">if</span> (ctx.getLoadCommand(.DYLD_INFO_ONLY)) |cmd| {
                    <span class="tok-kw">const</span> lc = cmd.cast(<a href="std.macho.html">macho</a>.<a href="std.macho.dyld_info_command.html">dyld_info_command</a>).?;
                    <span class="tok-kw">if</span> (lc.export_size &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">const</span> data = ctx.data[lc.export_off..][<span class="tok-number">0</span>..lc.export_size];
                        <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Step.CheckObject.MachODumper.html#std.Build.Step.CheckObject.MachODumper.exports_label">exports_label</a> ++ <span class="tok-str">&quot;\n&quot;</span>);
                        <span class="tok-kw">try</span> ctx.dumpExportsTrie(data, writer);
                        <span class="tok-kw">break</span> :blk;
                    }
                }
                <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no exports data found&quot;</span>, .{});
            },

            .dump_section =&gt; {
                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(check.data.items.ptr + check.payload.dump_section)), <span class="tok-number">0</span>);
                <span class="tok-kw">const</span> sep_index = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">','</span>) <span class="tok-kw">orelse</span>
                    <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid section name: {s}&quot;</span>, .{name});
                <span class="tok-kw">const</span> segname = name[<span class="tok-number">0</span>..sep_index];
                <span class="tok-kw">const</span> sectname = name[sep_index + <span class="tok-number">1</span> ..];
                <span class="tok-kw">const</span> sect = ctx.getSectionByName(segname, sectname) <span class="tok-kw">orelse</span>
                    <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;section '{s}' not found&quot;</span>, .{name});
                <span class="tok-kw">try</span> ctx.dumpSection(sect, writer);
            },

            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid check kind for MachO file format: {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(check.kind)}),
        }

        <span class="tok-kw">return</span> output.toOwnedSlice();
    }
};

<span class="tok-kw">const</span> ElfDumper = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> symtab_label = <span class="tok-str">&quot;symbol table&quot;</span>;
    <span class="tok-kw">const</span> dynamic_symtab_label = <span class="tok-str">&quot;dynamic symbol table&quot;</span>;
    <span class="tok-kw">const</span> dynamic_section_label = <span class="tok-str">&quot;dynamic section&quot;</span>;
    <span class="tok-kw">const</span> archive_symtab_label = <span class="tok-str">&quot;archive symbol table&quot;</span>;

    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDump</span>(step: *<a href="std.Build.Step.html">Step</a>, check: <a href="std.Build.Step.CheckObject.Check.html">Check</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> <a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.parseAndDumpArchive">parseAndDumpArchive</a>(step, check, bytes) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.InvalidArchiveMagicNumber =&gt; <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.parseAndDumpObject">parseAndDumpObject</a>(step, check, bytes),
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDumpArchive</span>(step: *<a href="std.Build.Step.html">Step</a>, check: <a href="std.Build.Step.CheckObject.Check.html">Check</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> gpa = step.owner.allocator;
        <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(bytes);
        <span class="tok-kw">const</span> reader = stream.reader();

        <span class="tok-kw">const</span> magic = <span class="tok-kw">try</span> reader.readBytesNoEof(<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ARMAG">ARMAG</a>.<a href="#">len</a>);
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;magic, <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ARMAG">ARMAG</a>)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArchiveMagicNumber;
        }

        <span class="tok-kw">var</span> ctx = <a href="std.Build.Step.CheckObject.ElfDumper.ArchiveContext.html">ArchiveContext</a>{
            .gpa = gpa,
            .data = bytes,
            .strtab = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{},
        };
        <span class="tok-kw">defer</span> {
            <span class="tok-kw">for</span> (ctx.objects.items) |*object| {
                gpa.free(object.name);
            }
            ctx.objects.deinit(gpa);
        }

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">if</span> (stream.pos &gt;= ctx.data.len) <span class="tok-kw">break</span>;
            <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.isAligned">isAligned</a>(stream.pos, <span class="tok-number">2</span>)) stream.pos += <span class="tok-number">1</span>;

            <span class="tok-kw">const</span> hdr = <span class="tok-kw">try</span> reader.readStruct(<a href="std.elf.html">elf</a>.<a href="std.elf.ar_hdr.html">ar_hdr</a>);

            <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;hdr.ar_fmag, <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.ARFMAG">ARFMAG</a>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidArchiveHeaderMagicNumber;

            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> hdr.size();
            <span class="tok-kw">defer</span> {
                _ = stream.seekBy(size) <span class="tok-kw">catch</span> {};
            }

            <span class="tok-kw">if</span> (hdr.isSymtab()) {
                <span class="tok-kw">try</span> ctx.parseSymtab(ctx.data[stream.pos..][<span class="tok-number">0</span>..size], .p32);
                <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">if</span> (hdr.isSymtab64()) {
                <span class="tok-kw">try</span> ctx.parseSymtab(ctx.data[stream.pos..][<span class="tok-number">0</span>..size], .p64);
                <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">if</span> (hdr.isStrtab()) {
                ctx.strtab = ctx.data[stream.pos..][<span class="tok-number">0</span>..size];
                <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">if</span> (hdr.isSymdef() <span class="tok-kw">or</span> hdr.isSymdefSorted()) <span class="tok-kw">continue</span>;

            <span class="tok-kw">const</span> name = <span class="tok-kw">if</span> (hdr.name()) |name|
                <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name)
            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">try</span> hdr.nameOffset()) |off|
                <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, ctx.getString(off))
            <span class="tok-kw">else</span>
                <span class="tok-kw">unreachable</span>;

            <span class="tok-kw">try</span> ctx.objects.append(gpa, .{ .name = name, .off = stream.pos, .len = size });
        }

        <span class="tok-kw">var</span> output = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(gpa);
        <span class="tok-kw">const</span> writer = output.writer();

        <span class="tok-kw">switch</span> (check.kind) {
            .archive_symtab =&gt; <span class="tok-kw">if</span> (ctx.symtab.items.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> ctx.dumpSymtab(writer);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no archive symbol table found&quot;</span>, .{}),

            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (ctx.objects.items.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> ctx.dumpObjects(step, check, writer);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;empty archive&quot;</span>, .{}),
        }

        <span class="tok-kw">return</span> output.toOwnedSlice();
    }

    <span class="tok-kw">const</span> ArchiveContext = <span class="tok-kw">struct</span> {
        gpa: <a href="std.mem.Allocator.html">Allocator</a>,
        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        symtab: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.Build.Step.CheckObject.ElfDumper.ArchiveContext.ArSymtabEntry.html">ArSymtabEntry</a>) = .empty,
        strtab: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        objects: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-kw">struct</span> { name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, off: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span> }) = .empty,

        <span class="tok-kw">fn</span> <span class="tok-fn">parseSymtab</span>(ctx: *<a href="std.Build.Step.CheckObject.ElfDumper.ArchiveContext.html">ArchiveContext</a>, raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ptr_width: <span class="tok-kw">enum</span> { p32, p64 }) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(raw);
            <span class="tok-kw">const</span> reader = stream.reader();
            <span class="tok-kw">const</span> num = <span class="tok-kw">switch</span> (ptr_width) {
                .p32 =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .big),
                .p64 =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, .big),
            };
            <span class="tok-kw">const</span> ptr_size: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (ptr_width) {
                .p32 =&gt; <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u32</span>),
                .p64 =&gt; <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u64</span>),
            };
            <span class="tok-kw">const</span> strtab_off = (num + <span class="tok-number">1</span>) * ptr_size;
            <span class="tok-kw">const</span> strtab_len = raw.len - strtab_off;
            <span class="tok-kw">const</span> strtab = raw[strtab_off..][<span class="tok-number">0</span>..strtab_len];

            <span class="tok-kw">try</span> ctx.symtab.ensureTotalCapacityPrecise(ctx.gpa, num);

            <span class="tok-kw">var</span> stroff: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..num) |_| {
                <span class="tok-kw">const</span> off = <span class="tok-kw">switch</span> (ptr_width) {
                    .p32 =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .big),
                    .p64 =&gt; <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, .big),
                };
                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(strtab.ptr + stroff)), <span class="tok-number">0</span>);
                stroff += name.len + <span class="tok-number">1</span>;
                ctx.symtab.appendAssumeCapacity(.{ .off = off, .name = name });
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpSymtab</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ArchiveContext.html">ArchiveContext</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> files = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<span class="tok-type">usize</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(ctx.gpa);
            <span class="tok-kw">defer</span> files.deinit();
            <span class="tok-kw">try</span> files.ensureUnusedCapacity(<span class="tok-builtin">@intCast</span>(ctx.objects.items.len));

            <span class="tok-kw">for</span> (ctx.objects.items) |object| {
                files.putAssumeCapacityNoClobber(object.off - <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.ar_hdr.html">ar_hdr</a>), object.name);
            }

            <span class="tok-kw">var</span> symbols = <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">usize</span>, <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>)).init(ctx.gpa);
            <span class="tok-kw">defer</span> {
                <span class="tok-kw">for</span> (symbols.values()) |*value| {
                    value.deinit();
                }
                symbols.deinit();
            }

            <span class="tok-kw">for</span> (ctx.symtab.items) |entry| {
                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> symbols.getOrPut(<span class="tok-builtin">@intCast</span>(entry.off));
                <span class="tok-kw">if</span> (!gop.found_existing) {
                    gop.value_ptr.* = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(ctx.gpa);
                }
                <span class="tok-kw">try</span> gop.value_ptr.append(entry.name);
            }

            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.archive_symtab_label">archive_symtab_label</a>});
            <span class="tok-kw">for</span> (symbols.keys(), symbols.values()) |off, values| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;in object {s}\n&quot;</span>, .{files.get(off).?});
                <span class="tok-kw">for</span> (values.items) |value| {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{value});
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpObjects</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ArchiveContext.html">ArchiveContext</a>, step: *<a href="std.Build.Step.html">Step</a>, check: <a href="std.Build.Step.CheckObject.Check.html">Check</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (ctx.objects.items) |object| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;object {s}\n&quot;</span>, .{object.name});
                <span class="tok-kw">const</span> output = <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.parseAndDumpObject">parseAndDumpObject</a>(step, check, ctx.data[object.off..][<span class="tok-number">0</span>..object.len]);
                <span class="tok-kw">defer</span> ctx.gpa.free(output);
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{output});
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ArchiveContext.html">ArchiveContext</a>, off: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(off &lt; ctx.strtab.len);
            <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-str">'\n'</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(ctx.strtab.ptr + off)), <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> name[<span class="tok-number">0</span> .. name.len - <span class="tok-number">1</span>];
        }

        <span class="tok-kw">const</span> ArSymtabEntry = <span class="tok-kw">struct</span> {
            name: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            off: <span class="tok-type">u64</span>,
        };
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDumpObject</span>(step: *<a href="std.Build.Step.html">Step</a>, check: <a href="std.Build.Step.CheckObject.Check.html">Check</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> gpa = step.owner.allocator;
        <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(bytes);
        <span class="tok-kw">const</span> reader = stream.reader();

        <span class="tok-kw">const</span> hdr = <span class="tok-kw">try</span> reader.readStruct(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a>);
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, hdr.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <span class="tok-str">&quot;\x7fELF&quot;</span>)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidMagicNumber;
        }

        <span class="tok-kw">const</span> shdrs = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>, <span class="tok-builtin">@ptrCast</span>(bytes.ptr + hdr.e_shoff))[<span class="tok-number">0</span>..hdr.e_shnum];
        <span class="tok-kw">const</span> phdrs = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>, <span class="tok-builtin">@ptrCast</span>(bytes.ptr + hdr.e_phoff))[<span class="tok-number">0</span>..hdr.e_phnum];

        <span class="tok-kw">var</span> ctx = <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>{
            .gpa = gpa,
            .data = bytes,
            .hdr = hdr,
            .shdrs = shdrs,
            .phdrs = phdrs,
            .shstrtab = <span class="tok-null">undefined</span>,
        };
        ctx.shstrtab = ctx.getSectionContents(ctx.hdr.e_shstrndx);

        <span class="tok-kw">for</span> (ctx.shdrs, <span class="tok-number">0</span>..) |shdr, i| <span class="tok-kw">switch</span> (shdr.sh_type) {
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_SYMTAB">SHT_SYMTAB</a>, <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_DYNSYM">SHT_DYNSYM</a> =&gt; {
                <span class="tok-kw">const</span> raw = ctx.getSectionContents(i);
                <span class="tok-kw">const</span> nsyms = <span class="tok-builtin">@divExact</span>(raw.len, <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Sym.html">Elf64_Sym</a>));
                <span class="tok-kw">const</span> symbols = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Sym.html">Elf64_Sym</a>, <span class="tok-builtin">@ptrCast</span>(raw.ptr))[<span class="tok-number">0</span>..nsyms];
                <span class="tok-kw">const</span> strings = ctx.getSectionContents(shdr.sh_link);

                <span class="tok-kw">switch</span> (shdr.sh_type) {
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_SYMTAB">SHT_SYMTAB</a> =&gt; {
                        ctx.symtab = .{
                            .symbols = symbols,
                            .strings = strings,
                        };
                    },
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_DYNSYM">SHT_DYNSYM</a> =&gt; {
                        ctx.dysymtab = .{
                            .symbols = symbols,
                            .strings = strings,
                        };
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            },

            <span class="tok-kw">else</span> =&gt; {},
        };

        <span class="tok-kw">var</span> output = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(gpa);
        <span class="tok-kw">const</span> writer = output.writer();

        <span class="tok-kw">switch</span> (check.kind) {
            .headers =&gt; {
                <span class="tok-kw">try</span> ctx.dumpHeader(writer);
                <span class="tok-kw">try</span> ctx.dumpShdrs(writer);
                <span class="tok-kw">try</span> ctx.dumpPhdrs(writer);
            },

            .symtab =&gt; <span class="tok-kw">if</span> (ctx.symtab.symbols.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> ctx.dumpSymtab(.symtab, writer);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no symbol table found&quot;</span>, .{}),

            .dynamic_symtab =&gt; <span class="tok-kw">if</span> (ctx.dysymtab.symbols.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">try</span> ctx.dumpSymtab(.dysymtab, writer);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no dynamic symbol table found&quot;</span>, .{}),

            .dynamic_section =&gt; <span class="tok-kw">if</span> (ctx.getSectionByName(<span class="tok-str">&quot;.dynamic&quot;</span>)) |shndx| {
                <span class="tok-kw">try</span> ctx.dumpDynamicSection(shndx, writer);
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no .dynamic section found&quot;</span>, .{}),

            .dump_section =&gt; {
                <span class="tok-kw">const</span> name = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(check.data.items.ptr + check.payload.dump_section)), <span class="tok-number">0</span>);
                <span class="tok-kw">const</span> shndx = ctx.getSectionByName(name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;no '{s}' section found&quot;</span>, .{name});
                <span class="tok-kw">try</span> ctx.dumpSection(shndx, writer);
            },

            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid check kind for ELF file format: {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(check.kind)}),
        }

        <span class="tok-kw">return</span> output.toOwnedSlice();
    }

    <span class="tok-kw">const</span> ObjectContext = <span class="tok-kw">struct</span> {
        gpa: <a href="std.mem.Allocator.html">Allocator</a>,
        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        hdr: <a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Ehdr.html">Elf64_Ehdr</a>,
        shdrs: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Shdr.html">Elf64_Shdr</a>,
        phdrs: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Phdr.html">Elf64_Phdr</a>,
        shstrtab: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        symtab: <a href="std.Build.Step.CheckObject.ElfDumper.Symtab.html">Symtab</a> = .{},
        dysymtab: <a href="std.Build.Step.CheckObject.ElfDumper.Symtab.html">Symtab</a> = .{},

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpHeader</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;header\n&quot;</span>);
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;type {s}\n&quot;</span>, .{<span class="tok-builtin">@tagName</span>(ctx.hdr.e_type)});
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;entry {x}\n&quot;</span>, .{ctx.hdr.e_entry});
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpPhdrs</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (ctx.phdrs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;program headers\n&quot;</span>);

            <span class="tok-kw">for</span> (ctx.phdrs, <span class="tok-number">0</span>..) |phdr, phndx| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;phdr {d}\n&quot;</span>, .{phndx});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;type {s}\n&quot;</span>, .{<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.fmtPhType">fmtPhType</a>(phdr.p_type)});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;vaddr {x}\n&quot;</span>, .{phdr.p_vaddr});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;paddr {x}\n&quot;</span>, .{phdr.p_paddr});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;offset {x}\n&quot;</span>, .{phdr.p_offset});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;memsz {x}\n&quot;</span>, .{phdr.p_memsz});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;filesz {x}\n&quot;</span>, .{phdr.p_filesz});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;align {x}\n&quot;</span>, .{phdr.p_align});

                {
                    <span class="tok-kw">const</span> flags = phdr.p_flags;
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;flags&quot;</span>);
                    <span class="tok-kw">if</span> (flags &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">' '</span>);
                    <span class="tok-kw">if</span> (flags &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PF_R">PF_R</a> != <span class="tok-number">0</span>) {
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'R'</span>);
                    }
                    <span class="tok-kw">if</span> (flags &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PF_W">PF_W</a> != <span class="tok-number">0</span>) {
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'W'</span>);
                    }
                    <span class="tok-kw">if</span> (flags &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PF_X">PF_X</a> != <span class="tok-number">0</span>) {
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'E'</span>);
                    }
                    <span class="tok-kw">if</span> (flags &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PF_MASKOS">PF_MASKOS</a> != <span class="tok-number">0</span>) {
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;OS&quot;</span>);
                    }
                    <span class="tok-kw">if</span> (flags &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PF_MASKPROC">PF_MASKPROC</a> != <span class="tok-number">0</span>) {
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;PROC&quot;</span>);
                    }
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpShdrs</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (ctx.shdrs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;section headers\n&quot;</span>);

            <span class="tok-kw">for</span> (ctx.shdrs, <span class="tok-number">0</span>..) |shdr, shndx| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;shdr {d}\n&quot;</span>, .{shndx});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;name {s}\n&quot;</span>, .{ctx.getSectionName(shndx)});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;type {s}\n&quot;</span>, .{<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.fmtShType">fmtShType</a>(shdr.sh_type)});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;addr {x}\n&quot;</span>, .{shdr.sh_addr});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;offset {x}\n&quot;</span>, .{shdr.sh_offset});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;size {x}\n&quot;</span>, .{shdr.sh_size});
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;addralign {x}\n&quot;</span>, .{shdr.sh_addralign});<span class="tok-comment">
                // TODO dump formatted sh_flags
            </span>}
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpDynamicSection</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, shndx: <span class="tok-type">usize</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> shdr = ctx.shdrs[shndx];
            <span class="tok-kw">const</span> strtab = ctx.getSectionContents(shdr.sh_link);
            <span class="tok-kw">const</span> data = ctx.getSectionContents(shndx);
            <span class="tok-kw">const</span> nentries = <span class="tok-builtin">@divExact</span>(data.len, <span class="tok-builtin">@sizeOf</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>));
            <span class="tok-kw">const</span> entries = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Dyn.html">Elf64_Dyn</a>, <span class="tok-builtin">@ptrCast</span>(data.ptr))[<span class="tok-number">0</span>..nentries];

            <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Step.CheckObject.ElfDumper.html">ElfDumper</a>.<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.dynamic_section_label">dynamic_section_label</a> ++ <span class="tok-str">&quot;\n&quot;</span>);

            <span class="tok-kw">for</span> (entries) |entry| {
                <span class="tok-kw">const</span> key = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(entry.d_tag));
                <span class="tok-kw">const</span> value = entry.d_val;

                <span class="tok-kw">const</span> key_str = <span class="tok-kw">switch</span> (key) {
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_NEEDED">DT_NEEDED</a> =&gt; <span class="tok-str">&quot;NEEDED&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_SONAME">DT_SONAME</a> =&gt; <span class="tok-str">&quot;SONAME&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_INIT_ARRAY">DT_INIT_ARRAY</a> =&gt; <span class="tok-str">&quot;INIT_ARRAY&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_INIT_ARRAYSZ">DT_INIT_ARRAYSZ</a> =&gt; <span class="tok-str">&quot;INIT_ARRAYSZ&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FINI_ARRAY">DT_FINI_ARRAY</a> =&gt; <span class="tok-str">&quot;FINI_ARRAY&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FINI_ARRAYSZ">DT_FINI_ARRAYSZ</a> =&gt; <span class="tok-str">&quot;FINI_ARRAYSZ&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_HASH">DT_HASH</a> =&gt; <span class="tok-str">&quot;HASH&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_GNU_HASH">DT_GNU_HASH</a> =&gt; <span class="tok-str">&quot;GNU_HASH&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_STRTAB">DT_STRTAB</a> =&gt; <span class="tok-str">&quot;STRTAB&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_SYMTAB">DT_SYMTAB</a> =&gt; <span class="tok-str">&quot;SYMTAB&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_STRSZ">DT_STRSZ</a> =&gt; <span class="tok-str">&quot;STRSZ&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_SYMENT">DT_SYMENT</a> =&gt; <span class="tok-str">&quot;SYMENT&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_PLTGOT">DT_PLTGOT</a> =&gt; <span class="tok-str">&quot;PLTGOT&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_PLTRELSZ">DT_PLTRELSZ</a> =&gt; <span class="tok-str">&quot;PLTRELSZ&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_PLTREL">DT_PLTREL</a> =&gt; <span class="tok-str">&quot;PLTREL&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_JMPREL">DT_JMPREL</a> =&gt; <span class="tok-str">&quot;JMPREL&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELA">DT_RELA</a> =&gt; <span class="tok-str">&quot;RELA&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELASZ">DT_RELASZ</a> =&gt; <span class="tok-str">&quot;RELASZ&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELAENT">DT_RELAENT</a> =&gt; <span class="tok-str">&quot;RELAENT&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_VERDEF">DT_VERDEF</a> =&gt; <span class="tok-str">&quot;VERDEF&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_VERDEFNUM">DT_VERDEFNUM</a> =&gt; <span class="tok-str">&quot;VERDEFNUM&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FLAGS">DT_FLAGS</a> =&gt; <span class="tok-str">&quot;FLAGS&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FLAGS_1">DT_FLAGS_1</a> =&gt; <span class="tok-str">&quot;FLAGS_1&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_VERNEED">DT_VERNEED</a> =&gt; <span class="tok-str">&quot;VERNEED&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_VERNEEDNUM">DT_VERNEEDNUM</a> =&gt; <span class="tok-str">&quot;VERNEEDNUM&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_VERSYM">DT_VERSYM</a> =&gt; <span class="tok-str">&quot;VERSYM&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELACOUNT">DT_RELACOUNT</a> =&gt; <span class="tok-str">&quot;RELACOUNT&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RPATH">DT_RPATH</a> =&gt; <span class="tok-str">&quot;RPATH&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RUNPATH">DT_RUNPATH</a> =&gt; <span class="tok-str">&quot;RUNPATH&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_INIT">DT_INIT</a> =&gt; <span class="tok-str">&quot;INIT&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FINI">DT_FINI</a> =&gt; <span class="tok-str">&quot;FINI&quot;</span>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_NULL">DT_NULL</a> =&gt; <span class="tok-str">&quot;NULL&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;UNKNOWN&quot;</span>,
                };
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{key_str});

                <span class="tok-kw">switch</span> (key) {
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_NEEDED">DT_NEEDED</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_SONAME">DT_SONAME</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RPATH">DT_RPATH</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RUNPATH">DT_RUNPATH</a>,
                    =&gt; {
                        <span class="tok-kw">const</span> name = <a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.getString">getString</a>(strtab, <span class="tok-builtin">@intCast</span>(value));
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{name});
                    },

                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_INIT_ARRAY">DT_INIT_ARRAY</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FINI_ARRAY">DT_FINI_ARRAY</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_HASH">DT_HASH</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_GNU_HASH">DT_GNU_HASH</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_STRTAB">DT_STRTAB</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_SYMTAB">DT_SYMTAB</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_PLTGOT">DT_PLTGOT</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_JMPREL">DT_JMPREL</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELA">DT_RELA</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_VERDEF">DT_VERDEF</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_VERNEED">DT_VERNEED</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_VERSYM">DT_VERSYM</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_INIT">DT_INIT</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FINI">DT_FINI</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_NULL">DT_NULL</a>,
                    =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {x}&quot;</span>, .{value}),

                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_INIT_ARRAYSZ">DT_INIT_ARRAYSZ</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FINI_ARRAYSZ">DT_FINI_ARRAYSZ</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_STRSZ">DT_STRSZ</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_SYMENT">DT_SYMENT</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_PLTRELSZ">DT_PLTRELSZ</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELASZ">DT_RELASZ</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELAENT">DT_RELAENT</a>,
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELACOUNT">DT_RELACOUNT</a>,
                    =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {d}&quot;</span>, .{value}),

                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_PLTREL">DT_PLTREL</a> =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-kw">switch</span> (value) {
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_REL">DT_REL</a> =&gt; <span class="tok-str">&quot; REL&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_RELA">DT_RELA</a> =&gt; <span class="tok-str">&quot; RELA&quot;</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot; UNKNOWN&quot;</span>,
                    }),

                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FLAGS">DT_FLAGS</a> =&gt; <span class="tok-kw">if</span> (value &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_ORIGIN">DF_ORIGIN</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ORIGIN&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_SYMBOLIC">DF_SYMBOLIC</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SYMBOLIC&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_TEXTREL">DF_TEXTREL</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; TEXTREL&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_BIND_NOW">DF_BIND_NOW</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; BIND_NOW&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_STATIC_TLS">DF_STATIC_TLS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; STATIC_TLS&quot;</span>);
                    },

                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DT_FLAGS_1">DT_FLAGS_1</a> =&gt; <span class="tok-kw">if</span> (value &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NOW">DF_1_NOW</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOW&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_GLOBAL">DF_1_GLOBAL</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; GLOBAL&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_GROUP">DF_1_GROUP</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; GROUP&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NODELETE">DF_1_NODELETE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NODELETE&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_LOADFLTR">DF_1_LOADFLTR</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; LOADFLTR&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_INITFIRST">DF_1_INITFIRST</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; INITFIRST&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NOOPEN">DF_1_NOOPEN</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOOPEN&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_ORIGIN">DF_1_ORIGIN</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ORIGIN&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_DIRECT">DF_1_DIRECT</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DIRECT&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_TRANS">DF_1_TRANS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; TRANS&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_INTERPOSE">DF_1_INTERPOSE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; INTERPOSE&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NODEFLIB">DF_1_NODEFLIB</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NODEFLIB&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NODUMP">DF_1_NODUMP</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NODUMP&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_CONFALT">DF_1_CONFALT</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; CONFALT&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_ENDFILTEE">DF_1_ENDFILTEE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; ENDFILTEE&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_DISPRELDNE">DF_1_DISPRELDNE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DISPRELDNE&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_DISPRELPND">DF_1_DISPRELPND</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; DISPRELPND&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NODIRECT">DF_1_NODIRECT</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NODIRECT&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_IGNMULDEF">DF_1_IGNMULDEF</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; IGNMULDEF&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NOKSYMS">DF_1_NOKSYMS</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOKSYMS&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NOHDR">DF_1_NOHDR</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NOHDR&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_EDITED">DF_1_EDITED</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; EDITED&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_NORELOC">DF_1_NORELOC</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; NORELOC&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_SYMINTPOSE">DF_1_SYMINTPOSE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SYMINTPOSE&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_GLOBAUDIT">DF_1_GLOBAUDIT</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; GLOBAUDIT&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_SINGLETON">DF_1_SINGLETON</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; SINGLETON&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_STUB">DF_1_STUB</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; STUB&quot;</span>);
                        <span class="tok-kw">if</span> (value &amp; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.DF_1_PIE">DF_1_PIE</a> != <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; PIE&quot;</span>);
                    },

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {x}&quot;</span>, .{value}),
                }
                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpSymtab</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, <span class="tok-kw">comptime</span> @&quot;type&quot;: <span class="tok-kw">enum</span> { symtab, dysymtab }, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> symtab = <span class="tok-kw">switch</span> (@&quot;type&quot;) {
                .symtab =&gt; ctx.symtab,
                .dysymtab =&gt; ctx.dysymtab,
            };

            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-kw">switch</span> (@&quot;type&quot;) {
                .symtab =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.symtab_label">symtab_label</a>,
                .dysymtab =&gt; <a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.dynamic_symtab_label">dynamic_symtab_label</a>,
            } ++ <span class="tok-str">&quot;\n&quot;</span>);

            <span class="tok-kw">for</span> (symtab.symbols, <span class="tok-number">0</span>..) |sym, index| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x} {x}&quot;</span>, .{ sym.st_value, sym.st_size });

                {
                    <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_LORESERVE">SHN_LORESERVE</a> &lt;= sym.st_shndx <span class="tok-kw">and</span> sym.st_shndx &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_HIRESERVE">SHN_HIRESERVE</a>) {
                        <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_LOPROC">SHN_LOPROC</a> &lt;= sym.st_shndx <span class="tok-kw">and</span> sym.st_shndx &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_HIPROC">SHN_HIPROC</a>) {
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LO+{d}&quot;</span>, .{sym.st_shndx - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_LOPROC">SHN_LOPROC</a>});
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">const</span> sym_ndx = <span class="tok-kw">switch</span> (sym.st_shndx) {
                                <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_ABS">SHN_ABS</a> =&gt; <span class="tok-str">&quot;ABS&quot;</span>,
                                <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_COMMON">SHN_COMMON</a> =&gt; <span class="tok-str">&quot;COM&quot;</span>,
                                <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_LIVEPATCH">SHN_LIVEPATCH</a> =&gt; <span class="tok-str">&quot;LIV&quot;</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;UNK&quot;</span>,
                            };
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{sym_ndx});
                        }
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (sym.st_shndx == <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHN_UNDEF">SHN_UNDEF</a>) {
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; UND&quot;</span>);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {x}&quot;</span>, .{sym.st_shndx});
                    }
                }

                blk: {
                    <span class="tok-kw">const</span> tt = sym.st_type();
                    <span class="tok-kw">const</span> sym_type = <span class="tok-kw">switch</span> (tt) {
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_NOTYPE">STT_NOTYPE</a> =&gt; <span class="tok-str">&quot;NOTYPE&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_OBJECT">STT_OBJECT</a> =&gt; <span class="tok-str">&quot;OBJECT&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_FUNC">STT_FUNC</a> =&gt; <span class="tok-str">&quot;FUNC&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_SECTION">STT_SECTION</a> =&gt; <span class="tok-str">&quot;SECTION&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_FILE">STT_FILE</a> =&gt; <span class="tok-str">&quot;FILE&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_COMMON">STT_COMMON</a> =&gt; <span class="tok-str">&quot;COMMON&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_TLS">STT_TLS</a> =&gt; <span class="tok-str">&quot;TLS&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_NUM">STT_NUM</a> =&gt; <span class="tok-str">&quot;NUM&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_GNU_IFUNC">STT_GNU_IFUNC</a> =&gt; <span class="tok-str">&quot;IFUNC&quot;</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_LOPROC">STT_LOPROC</a> &lt;= tt <span class="tok-kw">and</span> tt &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_HIPROC">STT_HIPROC</a>) {
                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LOPROC+{d}&quot;</span>, .{tt - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_LOPROC">STT_LOPROC</a>});
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_LOOS">STT_LOOS</a> &lt;= tt <span class="tok-kw">and</span> tt &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_HIOS">STT_HIOS</a>) {
                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LOOS+{d}&quot;</span>, .{tt - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_LOOS">STT_LOOS</a>});
                        } <span class="tok-kw">else</span> <span class="tok-str">&quot;UNK&quot;</span>,
                    };
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{sym_type});
                }

                blk: {
                    <span class="tok-kw">const</span> bind = sym.st_bind();
                    <span class="tok-kw">const</span> sym_bind = <span class="tok-kw">switch</span> (bind) {
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_LOCAL">STB_LOCAL</a> =&gt; <span class="tok-str">&quot;LOCAL&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_GLOBAL">STB_GLOBAL</a> =&gt; <span class="tok-str">&quot;GLOBAL&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_WEAK">STB_WEAK</a> =&gt; <span class="tok-str">&quot;WEAK&quot;</span>,
                        <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_NUM">STB_NUM</a> =&gt; <span class="tok-str">&quot;NUM&quot;</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_LOPROC">STB_LOPROC</a> &lt;= bind <span class="tok-kw">and</span> bind &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_HIPROC">STB_HIPROC</a>) {
                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LOPROC+{d}&quot;</span>, .{bind - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_LOPROC">STB_LOPROC</a>});
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_LOOS">STB_LOOS</a> &lt;= bind <span class="tok-kw">and</span> bind &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_HIOS">STB_HIOS</a>) {
                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; LOOS+{d}&quot;</span>, .{bind - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STB_LOOS">STB_LOOS</a>});
                        } <span class="tok-kw">else</span> <span class="tok-str">&quot;UNKNOWN&quot;</span>,
                    };
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{sym_bind});
                }

                <span class="tok-kw">const</span> sym_vis = <span class="tok-builtin">@as</span>(<a href="std.elf.html">elf</a>.<a href="std.elf.STV.html">STV</a>, <span class="tok-builtin">@enumFromInt</span>(sym.st_other));
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(sym_vis)});

                <span class="tok-kw">const</span> sym_name = <span class="tok-kw">switch</span> (sym.st_type()) {
                    <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.STT_SECTION">STT_SECTION</a> =&gt; ctx.getSectionName(sym.st_shndx),
                    <span class="tok-kw">else</span> =&gt; symtab.getName(index).?,
                };
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}\n&quot;</span>, .{sym_name});
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpSection</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, shndx: <span class="tok-type">usize</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> data = ctx.getSectionContents(shndx);
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{data});
        }

        <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSectionName</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, shndx: <span class="tok-type">usize</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">const</span> shdr = ctx.shdrs[shndx];
            <span class="tok-kw">return</span> <a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.getString">getString</a>(ctx.shstrtab, shdr.sh_name);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSectionContents</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, shndx: <span class="tok-type">usize</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">const</span> shdr = ctx.shdrs[shndx];
            <a href="std.debug.html#std.debug.assert">assert</a>(shdr.sh_offset &lt; ctx.data.len);
            <a href="std.debug.html#std.debug.assert">assert</a>(shdr.sh_offset + shdr.sh_size &lt;= ctx.data.len);
            <span class="tok-kw">return</span> ctx.data[shdr.sh_offset..][<span class="tok-number">0</span>..shdr.sh_size];
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSectionByName</span>(ctx: <a href="std.Build.Step.CheckObject.ElfDumper.ObjectContext.html">ObjectContext</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..ctx.shdrs.len) |shndx| {
                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, ctx.getSectionName(shndx), name)) <span class="tok-kw">return</span> shndx;
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }
    };

    <span class="tok-kw">const</span> Symtab = <span class="tok-kw">struct</span> {
        symbols: []<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Sym.html">Elf64_Sym</a> = &amp;[<span class="tok-number">0</span>]<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Sym.html">Elf64_Sym</a>{},
        strings: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{},

        <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(st: <a href="std.Build.Step.CheckObject.ElfDumper.Symtab.html">Symtab</a>, index: <span class="tok-type">usize</span>) ?<a href="std.elf.html">elf</a>.<a href="std.elf.Elf64_Sym.html">Elf64_Sym</a> {
            <span class="tok-kw">if</span> (index &gt;= st.symbols.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> st.symbols[index];
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getName</span>(st: <a href="std.Build.Step.CheckObject.ElfDumper.Symtab.html">Symtab</a>, index: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">const</span> sym = st.get(index) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> <a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.getString">getString</a>(st.strings, sym.st_name);
        }
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(strtab: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, off: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(off &lt; strtab.len);
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(strtab.ptr + off)), <span class="tok-number">0</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fmtShType</span>(sh_type: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.formatShType">formatShType</a>) {
        <span class="tok-kw">return</span> .{ .data = sh_type };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">formatShType</span>(
        sh_type: <span class="tok-type">u32</span>,
        <span class="tok-kw">comptime</span> unused_fmt_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        _ = unused_fmt_string;
        _ = options;
        <span class="tok-kw">const</span> name = <span class="tok-kw">switch</span> (sh_type) {
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_NULL">SHT_NULL</a> =&gt; <span class="tok-str">&quot;NULL&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_PROGBITS">SHT_PROGBITS</a> =&gt; <span class="tok-str">&quot;PROGBITS&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_SYMTAB">SHT_SYMTAB</a> =&gt; <span class="tok-str">&quot;SYMTAB&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_STRTAB">SHT_STRTAB</a> =&gt; <span class="tok-str">&quot;STRTAB&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_RELA">SHT_RELA</a> =&gt; <span class="tok-str">&quot;RELA&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_HASH">SHT_HASH</a> =&gt; <span class="tok-str">&quot;HASH&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_DYNAMIC">SHT_DYNAMIC</a> =&gt; <span class="tok-str">&quot;DYNAMIC&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_NOTE">SHT_NOTE</a> =&gt; <span class="tok-str">&quot;NOTE&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_NOBITS">SHT_NOBITS</a> =&gt; <span class="tok-str">&quot;NOBITS&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_REL">SHT_REL</a> =&gt; <span class="tok-str">&quot;REL&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_SHLIB">SHT_SHLIB</a> =&gt; <span class="tok-str">&quot;SHLIB&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_DYNSYM">SHT_DYNSYM</a> =&gt; <span class="tok-str">&quot;DYNSYM&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_INIT_ARRAY">SHT_INIT_ARRAY</a> =&gt; <span class="tok-str">&quot;INIT_ARRAY&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_FINI_ARRAY">SHT_FINI_ARRAY</a> =&gt; <span class="tok-str">&quot;FINI_ARRAY&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_PREINIT_ARRAY">SHT_PREINIT_ARRAY</a> =&gt; <span class="tok-str">&quot;PREINIT_ARRAY&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_GROUP">SHT_GROUP</a> =&gt; <span class="tok-str">&quot;GROUP&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_SYMTAB_SHNDX">SHT_SYMTAB_SHNDX</a> =&gt; <span class="tok-str">&quot;SYMTAB_SHNDX&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_X86_64_UNWIND">SHT_X86_64_UNWIND</a> =&gt; <span class="tok-str">&quot;X86_64_UNWIND&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_LLVM_ADDRSIG">SHT_LLVM_ADDRSIG</a> =&gt; <span class="tok-str">&quot;LLVM_ADDRSIG&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_GNU_HASH">SHT_GNU_HASH</a> =&gt; <span class="tok-str">&quot;GNU_HASH&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_GNU_VERDEF">SHT_GNU_VERDEF</a> =&gt; <span class="tok-str">&quot;VERDEF&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_GNU_VERNEED">SHT_GNU_VERNEED</a> =&gt; <span class="tok-str">&quot;VERNEED&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_GNU_VERSYM">SHT_GNU_VERSYM</a> =&gt; <span class="tok-str">&quot;VERSYM&quot;</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_LOOS">SHT_LOOS</a> &lt;= sh_type <span class="tok-kw">and</span> sh_type &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_HIOS">SHT_HIOS</a>) {
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOOS+0x{x}&quot;</span>, .{sh_type - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_LOOS">SHT_LOOS</a>});
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_LOPROC">SHT_LOPROC</a> &lt;= sh_type <span class="tok-kw">and</span> sh_type &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_HIPROC">SHT_HIPROC</a>) {
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOPROC+0x{x}&quot;</span>, .{sh_type - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_LOPROC">SHT_LOPROC</a>});
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_LOUSER">SHT_LOUSER</a> &lt;= sh_type <span class="tok-kw">and</span> sh_type &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_HIUSER">SHT_HIUSER</a>) {
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOUSER+0x{x}&quot;</span>, .{sh_type - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.SHT_LOUSER">SHT_LOUSER</a>});
            } <span class="tok-kw">else</span> <span class="tok-str">&quot;UNKNOWN&quot;</span>,
        };
        <span class="tok-kw">try</span> writer.writeAll(name);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fmtPhType</span>(ph_type: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.Build.Step.CheckObject.ElfDumper.html#std.Build.Step.CheckObject.ElfDumper.formatPhType">formatPhType</a>) {
        <span class="tok-kw">return</span> .{ .data = ph_type };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">formatPhType</span>(
        ph_type: <span class="tok-type">u32</span>,
        <span class="tok-kw">comptime</span> unused_fmt_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        _ = unused_fmt_string;
        _ = options;
        <span class="tok-kw">const</span> p_type = <span class="tok-kw">switch</span> (ph_type) {
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_NULL">PT_NULL</a> =&gt; <span class="tok-str">&quot;NULL&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_LOAD">PT_LOAD</a> =&gt; <span class="tok-str">&quot;LOAD&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_DYNAMIC">PT_DYNAMIC</a> =&gt; <span class="tok-str">&quot;DYNAMIC&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_INTERP">PT_INTERP</a> =&gt; <span class="tok-str">&quot;INTERP&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_NOTE">PT_NOTE</a> =&gt; <span class="tok-str">&quot;NOTE&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_SHLIB">PT_SHLIB</a> =&gt; <span class="tok-str">&quot;SHLIB&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_PHDR">PT_PHDR</a> =&gt; <span class="tok-str">&quot;PHDR&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_TLS">PT_TLS</a> =&gt; <span class="tok-str">&quot;TLS&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_NUM">PT_NUM</a> =&gt; <span class="tok-str">&quot;NUM&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_GNU_EH_FRAME">PT_GNU_EH_FRAME</a> =&gt; <span class="tok-str">&quot;GNU_EH_FRAME&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_GNU_STACK">PT_GNU_STACK</a> =&gt; <span class="tok-str">&quot;GNU_STACK&quot;</span>,
            <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_GNU_RELRO">PT_GNU_RELRO</a> =&gt; <span class="tok-str">&quot;GNU_RELRO&quot;</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_LOOS">PT_LOOS</a> &lt;= ph_type <span class="tok-kw">and</span> ph_type &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_HIOS">PT_HIOS</a>) {
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOOS+0x{x}&quot;</span>, .{ph_type - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_LOOS">PT_LOOS</a>});
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_LOPROC">PT_LOPROC</a> &lt;= ph_type <span class="tok-kw">and</span> ph_type &lt; <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_HIPROC">PT_HIPROC</a>) {
                <span class="tok-kw">return</span> <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;LOPROC+0x{x}&quot;</span>, .{ph_type - <a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.PT_LOPROC">PT_LOPROC</a>});
            } <span class="tok-kw">else</span> <span class="tok-str">&quot;UNKNOWN&quot;</span>,
        };
        <span class="tok-kw">try</span> writer.writeAll(p_type);
    }
};

<span class="tok-kw">const</span> WasmDumper = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> symtab_label = <span class="tok-str">&quot;symbols&quot;</span>;

    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDump</span>(step: *<a href="std.Build.Step.html">Step</a>, check: <a href="std.Build.Step.CheckObject.Check.html">Check</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> gpa = step.owner.allocator;
        <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(bytes);
        <span class="tok-kw">const</span> reader = fbs.reader();

        <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> reader.readBytesNoEof(<span class="tok-number">8</span>);
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf[<span class="tok-number">0</span>..<span class="tok-number">4</span>], &amp;<a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.html#std.wasm.magic">magic</a>)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidMagicByte;
        }
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf[<span class="tok-number">4</span>..], &amp;<a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.html#std.wasm.version">version</a>)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedWasmVersion;
        }

        <span class="tok-kw">var</span> output = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(gpa);
        <span class="tok-kw">defer</span> output.deinit();
        <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseAndDumpInner">parseAndDumpInner</a>(step, check, bytes, &amp;fbs, &amp;output) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.EndOfStream =&gt; <span class="tok-kw">try</span> output.appendSlice(<span class="tok-str">&quot;\n&lt;UnexpectedEndOfStream&gt;&quot;</span>),
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">return</span> output.toOwnedSlice();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDumpInner</span>(
        step: *<a href="std.Build.Step.html">Step</a>,
        check: <a href="std.Build.Step.CheckObject.Check.html">Check</a>,
        bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        fbs: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),
        output: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>),
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> reader = fbs.reader();
        <span class="tok-kw">const</span> writer = output.writer();

        <span class="tok-kw">switch</span> (check.kind) {
            .headers =&gt; {
                <span class="tok-kw">while</span> (reader.readByte()) |current_byte| {
                    <span class="tok-kw">const</span> section = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(<a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Section.html">Section</a>, current_byte) <span class="tok-kw">catch</span> {
                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;Found invalid section id '{d}'&quot;</span>, .{current_byte});
                    };

                    <span class="tok-kw">const</span> section_length = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseAndDumpSection">parseAndDumpSection</a>(step, section, bytes[fbs.pos..][<span class="tok-number">0</span>..section_length], writer);
                    fbs.pos += section_length;
                } <span class="tok-kw">else</span> |_| {}<span class="tok-comment"> // reached end of stream
            </span>},

            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid check kind for Wasm file format: {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(check.kind)}),
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseAndDumpSection</span>(
        step: *<a href="std.Build.Step.html">Step</a>,
        section: <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Section.html">Section</a>,
        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        writer: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
        <span class="tok-kw">const</span> reader = fbs.reader();

        <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\Section {s}</span>
            <span class="tok-str">\\size {d}</span>
        , .{ <span class="tok-builtin">@tagName</span>(section), data.len });

        <span class="tok-kw">switch</span> (section) {
            .<span class="tok-type">type</span>,
            .import,
            .function,
            .table,
            .memory,
            .global,
            .@&quot;export&quot;,
            .element,
            .code,
            .data,
            =&gt; {
                <span class="tok-kw">const</span> entries = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\nentries {d}\n&quot;</span>, .{entries});
                <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseSection">parseSection</a>(step, section, data[fbs.pos..], entries, writer);
            },
            .custom =&gt; {
                <span class="tok-kw">const</span> name_length = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                <span class="tok-kw">const</span> name = data[fbs.pos..][<span class="tok-number">0</span>..name_length];
                fbs.pos += name_length;
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\nname {s}\n&quot;</span>, .{name});

                <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;name&quot;</span>)) {
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpNames">parseDumpNames</a>(step, reader, writer, data);
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;producers&quot;</span>)) {
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpProducers">parseDumpProducers</a>(reader, writer, data);
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;target_features&quot;</span>)) {
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpFeatures">parseDumpFeatures</a>(reader, writer, data);
                }<span class="tok-comment">
                // TODO: Implement parsing and dumping other custom sections (such as relocations)
            </span>},
            .start =&gt; {
                <span class="tok-kw">const</span> start = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\nstart {d}\n&quot;</span>, .{start});
            },
            .data_count =&gt; {
                <span class="tok-kw">const</span> count = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\ncount {d}\n&quot;</span>, .{count});
            },
            <span class="tok-kw">else</span> =&gt; {},<span class="tok-comment"> // skip unknown sections
        </span>}
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseSection</span>(step: *<a href="std.Build.Step.html">Step</a>, section: <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Section.html">Section</a>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, entries: <span class="tok-type">u32</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> fbs = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(data);
        <span class="tok-kw">const</span> reader = fbs.reader();

        <span class="tok-kw">switch</span> (section) {
            .<span class="tok-type">type</span> =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    <span class="tok-kw">const</span> func_type = <span class="tok-kw">try</span> reader.readByte();
                    <span class="tok-kw">if</span> (func_type != <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.html#std.wasm.function_type">function_type</a>) {
                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;expected function type, found byte '{d}'&quot;</span>, .{func_type});
                    }
                    <span class="tok-kw">const</span> params = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;params {d}\n&quot;</span>, .{params});
                    <span class="tok-kw">var</span> index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">while</span> (index &lt; params) : (index += <span class="tok-number">1</span>) {
                        _ = <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpType">parseDumpType</a>(step, <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Valtype.html">Valtype</a>, reader, writer);
                    } <span class="tok-kw">else</span> index = <span class="tok-number">0</span>;
                    <span class="tok-kw">const</span> returns = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;returns {d}\n&quot;</span>, .{returns});
                    <span class="tok-kw">while</span> (index &lt; returns) : (index += <span class="tok-number">1</span>) {
                        _ = <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpType">parseDumpType</a>(step, <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Valtype.html">Valtype</a>, reader, writer);
                    }
                }
            },
            .import =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    <span class="tok-kw">const</span> module_name_len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">const</span> module_name = data[fbs.pos..][<span class="tok-number">0</span>..module_name_len];
                    fbs.pos += module_name_len;
                    <span class="tok-kw">const</span> name_len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">const</span> name = data[fbs.pos..][<span class="tok-number">0</span>..name_len];
                    fbs.pos += name_len;

                    <span class="tok-kw">const</span> kind = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(<a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.ExternalKind.html">ExternalKind</a>, <span class="tok-kw">try</span> reader.readByte()) <span class="tok-kw">catch</span> {
                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid import kind&quot;</span>, .{});
                    };

                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\module {s}</span>
                        <span class="tok-str">\\name {s}</span>
                        <span class="tok-str">\\kind {s}</span>
                    , .{ module_name, name, <span class="tok-builtin">@tagName</span>(kind) });
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                    <span class="tok-kw">switch</span> (kind) {
                        .function =&gt; {
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;index {d}\n&quot;</span>, .{<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader)});
                        },
                        .memory =&gt; {
                            <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpLimits">parseDumpLimits</a>(reader, writer);
                        },
                        .global =&gt; {
                            _ = <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpType">parseDumpType</a>(step, <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Valtype.html">Valtype</a>, reader, writer);
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;mutable {}\n&quot;</span>, .{<span class="tok-number">0x01</span> == <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader)});
                        },
                        .table =&gt; {
                            _ = <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpType">parseDumpType</a>(step, <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.RefType.html">RefType</a>, reader, writer);
                            <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpLimits">parseDumpLimits</a>(reader, writer);
                        },
                    }
                }
            },
            .function =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;index {d}\n&quot;</span>, .{<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader)});
                }
            },
            .table =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    _ = <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpType">parseDumpType</a>(step, <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.RefType.html">RefType</a>, reader, writer);
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpLimits">parseDumpLimits</a>(reader, writer);
                }
            },
            .memory =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpLimits">parseDumpLimits</a>(reader, writer);
                }
            },
            .global =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    _ = <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpType">parseDumpType</a>(step, <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Valtype.html">Valtype</a>, reader, writer);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;mutable {}\n&quot;</span>, .{<span class="tok-number">0x01</span> == <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u1</span>, reader)});
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpInit">parseDumpInit</a>(step, reader, writer);
                }
            },
            .@&quot;export&quot; =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    <span class="tok-kw">const</span> name_len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">const</span> name = data[fbs.pos..][<span class="tok-number">0</span>..name_len];
                    fbs.pos += name_len;
                    <span class="tok-kw">const</span> kind_byte = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">const</span> kind = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(<a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.ExternalKind.html">ExternalKind</a>, kind_byte) <span class="tok-kw">catch</span> {
                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid export kind value '{d}'&quot;</span>, .{kind_byte});
                    };
                    <span class="tok-kw">const</span> index = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\name {s}</span>
                        <span class="tok-str">\\kind {s}</span>
                        <span class="tok-str">\\index {d}</span>
                    , .{ name, <span class="tok-builtin">@tagName</span>(kind), index });
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                }
            },
            .element =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;table index {d}\n&quot;</span>, .{<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader)});
                    <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpInit">parseDumpInit</a>(step, reader, writer);

                    <span class="tok-kw">const</span> function_indexes = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">var</span> function_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;indexes {d}\n&quot;</span>, .{function_indexes});
                    <span class="tok-kw">while</span> (function_index &lt; function_indexes) : (function_index += <span class="tok-number">1</span>) {
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;index {d}\n&quot;</span>, .{<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader)});
                    }
                }
            },
            .code =&gt; {},<span class="tok-comment"> // code section is considered opaque to linker
            </span>.data =&gt; {
                <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; entries) : (i += <span class="tok-number">1</span>) {
                    <span class="tok-kw">const</span> flags = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">const</span> index = <span class="tok-kw">if</span> (flags &amp; <span class="tok-number">0x02</span> != <span class="tok-number">0</span>)
                        <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader)
                    <span class="tok-kw">else</span>
                        <span class="tok-number">0</span>;
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;memory index 0x{x}\n&quot;</span>, .{index});
                    <span class="tok-kw">if</span> (flags == <span class="tok-number">0</span>) {
                        <span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpInit">parseDumpInit</a>(step, reader, writer);
                    }

                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;size {d}\n&quot;</span>, .{size});
                    <span class="tok-kw">try</span> reader.skipBytes(size, .{});<span class="tok-comment"> // we do not care about the content of the segments
                </span>}
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpType</span>(step: *<a href="std.Build.Step.html">Step</a>, <span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>) !E {
        <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> reader.readByte();
        <span class="tok-kw">const</span> tag = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(E, byte) <span class="tok-kw">catch</span> {
            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid wasm type value '{d}'&quot;</span>, .{byte});
        };
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;type {s}\n&quot;</span>, .{<span class="tok-builtin">@tagName</span>(tag)});
        <span class="tok-kw">return</span> tag;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpLimits</span>(reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> flags = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
        <span class="tok-kw">const</span> min = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);

        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;min {x}\n&quot;</span>, .{min});
        <span class="tok-kw">if</span> (flags != <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;max {x}\n&quot;</span>, .{<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader)});
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpInit</span>(step: *<a href="std.Build.Step.html">Step</a>, reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> byte = <span class="tok-kw">try</span> reader.readByte();
        <span class="tok-kw">const</span> opcode = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.intToEnum">intToEnum</a>(<a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Opcode.html">Opcode</a>, byte) <span class="tok-kw">catch</span> {
            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid wasm opcode '{d}'&quot;</span>, .{byte});
        };
        <span class="tok-kw">switch</span> (opcode) {
            .i32_const =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;i32.const {x}\n&quot;</span>, .{<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i32</span>, reader)}),
            .i64_const =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;i64.const {x}\n&quot;</span>, .{<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader)}),
            .f32_const =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;f32.const {x}\n&quot;</span>, .{<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, .little)))}),
            .f64_const =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;f64.const {x}\n&quot;</span>, .{<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, .little)))}),
            .global_get =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;global.get {x}\n&quot;</span>, .{<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader)}),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">const</span> end_opcode = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
        <span class="tok-kw">if</span> (end_opcode != <span class="tok-builtin">@intFromEnum</span>(<a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.Opcode.html">Opcode</a>.<a href="#">end</a>)) {
            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;expected 'end' opcode in init expression&quot;</span>, .{});
        }
    }

    <span class="tok-comment">/// https://webassembly.github.io/spec/core/appendix/custom.html</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpNames</span>(step: *<a href="std.Build.Step.html">Step</a>, reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">while</span> (reader.context.pos &lt; data.len) {
            <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> <a href="std.Build.Step.CheckObject.WasmDumper.html#std.Build.Step.CheckObject.WasmDumper.parseDumpType">parseDumpType</a>(step, <a href="std.html">std</a>.<a href="std.wasm.html">wasm</a>.<a href="std.wasm.NameSubsection.html">NameSubsection</a>, reader, writer)) {<span class="tok-comment">
                // The module name subsection ... consists of a single name
                // that is assigned to the module itself.
                </span>.module =&gt; {
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">const</span> name_len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">if</span> (size != name_len + <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadSubsectionSize;
                    <span class="tok-kw">if</span> (reader.context.pos + name_len &gt; data.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;name {s}\n&quot;</span>, .{data[reader.context.pos..][<span class="tok-number">0</span>..name_len]});
                    reader.context.pos += name_len;
                },<span class="tok-comment">

                // The function name subsection ... consists of a name map
                // assigning function names to function indices.
                </span>.function, .global, .data_segment =&gt; {
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">const</span> entries = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                    <span class="tok-kw">try</span> writer.print(
                        <span class="tok-str">\\size {d}</span>
                        <span class="tok-str">\\names {d}</span>
                        <span class="tok-str">\\</span>
                    , .{ size, entries });
                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..entries) |_| {
                        <span class="tok-kw">const</span> index = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                        <span class="tok-kw">const</span> name_len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                        <span class="tok-kw">if</span> (reader.context.pos + name_len &gt; data.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;
                        <span class="tok-kw">const</span> name = data[reader.context.pos..][<span class="tok-number">0</span>..name_len];
                        reader.context.pos += name.len;

                        <span class="tok-kw">try</span> writer.print(
                            <span class="tok-str">\\index {d}</span>
                            <span class="tok-str">\\name {s}</span>
                            <span class="tok-str">\\</span>
                        , .{ index, name });
                    }
                },<span class="tok-comment">

                // The local name subsection ... consists of an indirect name
                // map assigning local names to local indices grouped by
                // function indices.
                </span>.local =&gt; {
                    <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;TODO implement parseDumpNames for local subsections&quot;</span>, .{});
                },

                <span class="tok-kw">else</span> =&gt; |t| <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;invalid subsection type: {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(t)}),
            }
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpProducers</span>(reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> field_count = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;fields {d}\n&quot;</span>, .{field_count});
        <span class="tok-kw">var</span> current_field: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (current_field &lt; field_count) : (current_field += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> field_name_length = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
            <span class="tok-kw">const</span> field_name = data[reader.context.pos..][<span class="tok-number">0</span>..field_name_length];
            reader.context.pos += field_name_length;

            <span class="tok-kw">const</span> value_count = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\field_name {s}</span>
                <span class="tok-str">\\values {d}</span>
            , .{ field_name, value_count });
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
            <span class="tok-kw">var</span> current_value: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (current_value &lt; value_count) : (current_value += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> value_length = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                <span class="tok-kw">const</span> value = data[reader.context.pos..][<span class="tok-number">0</span>..value_length];
                reader.context.pos += value_length;

                <span class="tok-kw">const</span> version_length = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
                <span class="tok-kw">const</span> version = data[reader.context.pos..][<span class="tok-number">0</span>..version_length];
                reader.context.pos += version_length;

                <span class="tok-kw">try</span> writer.print(
                    <span class="tok-str">\\value_name {s}</span>
                    <span class="tok-str">\\version {s}</span>
                , .{ value, version });
                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
            }
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">parseDumpFeatures</span>(reader: <span class="tok-kw">anytype</span>, writer: <span class="tok-kw">anytype</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> feature_count = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;features {d}\n&quot;</span>, .{feature_count});

        <span class="tok-kw">var</span> index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (index &lt; feature_count) : (index += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> prefix_byte = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
            <span class="tok-kw">const</span> name_length = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u32</span>, reader);
            <span class="tok-kw">const</span> feature_name = data[reader.context.pos..][<span class="tok-number">0</span>..name_length];
            reader.context.pos += name_length;

            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{c} {s}\n&quot;</span>, .{ prefix_byte, feature_name });
        }
    }
};</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
