<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">math</a></li><li><a href="std.math.html" class="">big</a></li><li><a href="std.math.big.int.html" class="active">int</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.math.big.int" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.math.big.int</span><a href="#src.zig-std.math.big.int">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.math.big.int.TwosCompIntLimit.html">std.math.big.int.TwosCompIntLimit</a></li><li><a href="std.math.big.int.Mutable.html">std.math.big.int.Mutable</a></li><li><a href="std.math.big.int.Const.html">std.math.big.int.Const</a></li><li><a href="std.math.big.int.Managed.html">std.math.big.int.Managed</a></li></ul></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.math.big.int.calcLimbLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcLimbLen</span><a href="#src.zig-std.math.big.int.calcLimbLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcLimbLen</span>(scalar: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of limbs needed to store <code>scalar</code>, which must be a
primitive integer value.
Note: A comptime-known upper bound of this value that may be used
instead if <code>scalar</code> is not already comptime-known is
<code>calcTwosCompLimbCount(@typeInfo(@TypeOf(scalar)).int.bits)</code></p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcLimbLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcLimbLen</span>(scalar: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (scalar == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-number">1</span>;
    }

    <span class="tok-kw">const</span> w_value = <span class="tok-builtin">@abs</span>(scalar);
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@divFloor</span>(<span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@intCast</span>(<a href="std.math.html">math</a>.<a href="std.math.log2.html#std.math.log2.log2">log2</a>(w_value))), <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>));
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcToStringLimbsBufferLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcToStringLimbsBufferLen</span><a href="#src.zig-std.math.big.int.calcToStringLimbsBufferLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcToStringLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, base: <span class="tok-type">u8</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>base: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcToStringLimbsBufferLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcToStringLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, base: <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(base))
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> a_len + <span class="tok-number">2</span> + a_len + <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a_len, <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcDivLimbsBufferLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcDivLimbsBufferLen</span><a href="#src.zig-std.math.big.int.calcDivLimbsBufferLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcDivLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcDivLimbsBufferLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcDivLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> a_len + b_len + <span class="tok-number">4</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcMulLimbsBufferLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcMulLimbsBufferLen</span><a href="#src.zig-std.math.big.int.calcMulLimbsBufferLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcMulLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>, aliases: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>aliases: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcMulLimbsBufferLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcMulLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>, aliases: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> aliases * <span class="tok-builtin">@max</span>(a_len, b_len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcMulWrapLimbsBufferLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcMulWrapLimbsBufferLen</span><a href="#src.zig-std.math.big.int.calcMulWrapLimbsBufferLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcMulWrapLimbsBufferLen</span>(bit_count: <span class="tok-type">usize</span>, a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>, aliases: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>a_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>aliases: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcMulWrapLimbsBufferLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcMulWrapLimbsBufferLen</span>(bit_count: <span class="tok-type">usize</span>, a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>, aliases: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
    <span class="tok-kw">return</span> aliases * <span class="tok-builtin">@min</span>(req_limbs, <span class="tok-builtin">@max</span>(a_len, b_len));
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcSetStringLimbsBufferLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcSetStringLimbsBufferLen</span><a href="#src.zig-std.math.big.int.calcSetStringLimbsBufferLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSetStringLimbsBufferLen</span>(base: <span class="tok-type">u8</span>, string_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>base: <span class="tok-type">u8</span></code></pre></div><div><pre><code>string_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcSetStringLimbsBufferLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSetStringLimbsBufferLen</span>(base: <span class="tok-type">u8</span>, string_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> limb_count = <a href="std.math.big.int.html#std.math.big.int.calcSetStringLimbCount">calcSetStringLimbCount</a>(base, string_len);
    <span class="tok-kw">return</span> <a href="std.math.big.int.html#std.math.big.int.calcMulLimbsBufferLen">calcMulLimbsBufferLen</a>(limb_count, limb_count, <span class="tok-number">2</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcSetStringLimbCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcSetStringLimbCount</span><a href="#src.zig-std.math.big.int.calcSetStringLimbCount">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSetStringLimbCount</span>(base: <span class="tok-type">u8</span>, string_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Assumes <code>string_len</code> doesn't account for minus signs if the number is negative.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>base: <span class="tok-type">u8</span></code></pre></div><div><pre><code>string_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcSetStringLimbCount">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSetStringLimbCount</span>(base: <span class="tok-type">u8</span>, string_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> base_f: <span class="tok-type">f32</span> = <span class="tok-builtin">@floatFromInt</span>(base);
    <span class="tok-kw">const</span> string_len_f: <span class="tok-type">f32</span> = <span class="tok-builtin">@floatFromInt</span>(string_len);
    <span class="tok-kw">return</span> <span class="tok-number">1</span> + <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromFloat</span>(<span class="tok-builtin">@ceil</span>(string_len_f * <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.log2.html#std.math.log2.log2">log2</a>(base_f) / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcPowLimbsBufferLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcPowLimbsBufferLen</span><a href="#src.zig-std.math.big.int.calcPowLimbsBufferLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcPowLimbsBufferLen</span>(a_bit_count: <span class="tok-type">usize</span>, y: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a_bit_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>y: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcPowLimbsBufferLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcPowLimbsBufferLen</span>(a_bit_count: <span class="tok-type">usize</span>, y: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {<span class="tok-comment">
    // The 2 accounts for the minimum space requirement for llmulacc
    </span><span class="tok-kw">return</span> <span class="tok-number">2</span> + (a_bit_count * y + (<a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - <span class="tok-number">1</span>)) / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcSqrtLimbsBufferLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcSqrtLimbsBufferLen</span><a href="#src.zig-std.math.big.int.calcSqrtLimbsBufferLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSqrtLimbsBufferLen</span>(a_bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a_bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcSqrtLimbsBufferLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSqrtLimbsBufferLen</span>(a_bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> a_limb_count = (a_bit_count - <span class="tok-number">1</span>) / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> + <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> shift = (a_bit_count + <span class="tok-number">1</span>) / <span class="tok-number">2</span>;
    <span class="tok-kw">const</span> u_s_rem_limb_count = <span class="tok-number">1</span> + ((shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> a_limb_count + <span class="tok-number">3</span> * u_s_rem_limb_count + <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a_limb_count, u_s_rem_limb_count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcNonZeroTwosCompLimbCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcNonZeroTwosCompLimbCount</span><a href="#src.zig-std.math.big.int.calcNonZeroTwosCompLimbCount">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcNonZeroTwosCompLimbCount</span>(bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Compute the number of limbs required to store a 2s-complement number of <code>bit_count</code> bits.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcNonZeroTwosCompLimbCount">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcNonZeroTwosCompLimbCount</span>(bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(bit_count != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.calcTwosCompLimbCount" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">calcTwosCompLimbCount</span><a href="#src.zig-std.math.big.int.calcTwosCompLimbCount">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcTwosCompLimbCount</span>(bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Compute the number of limbs required to store a 2s-complement number of <code>bit_count</code> bits.</p>
<p>Special cases <code>bit_count == 0</code> to return 1. Zero-bit integers can only store the value zero
and this big integer implementation stores zero using one limb.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.calcTwosCompLimbCount">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcTwosCompLimbCount</span>(bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@max</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, bit_count, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>, <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.addMulLimbWithCarry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addMulLimbWithCarry</span><a href="#src.zig-std.math.big.int.addMulLimbWithCarry">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addMulLimbWithCarry</span>(a: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, c: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, carry: *<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div><div class="tldDocs"><p>a + b * c + *carry, sets carry to the overflow bits</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div><div><pre><code>b: <a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div><div><pre><code>c: <a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div><div><pre><code>carry: *<a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.addMulLimbWithCarry">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addMulLimbWithCarry</span>(a: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, c: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, carry: *<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.html#std.math.big.Limb">Limb</a> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);<span class="tok-comment">

    // ov1[0] = a + *carry
    </span><span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@addWithOverflow</span>(a, carry.*);<span class="tok-comment">

    // r2 = b * c
    </span><span class="tok-kw">const</span> bc = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, b, c));
    <span class="tok-kw">const</span> r2 = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(bc));
    <span class="tok-kw">const</span> c2 = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(bc &gt;&gt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));<span class="tok-comment">

    // ov2[0] = ov1[0] + r2
    </span><span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@addWithOverflow</span>(ov1[<span class="tok-number">0</span>], r2);<span class="tok-comment">

    // This never overflows, c1, c3 are either 0 or 1 and if both are 1 then
    // c2 is at least &lt;= maxInt(Limb) - 2.
    </span>carry.* = ov1[<span class="tok-number">1</span>] + c2 + ov2[<span class="tok-number">1</span>];

    <span class="tok-kw">return</span> ov2[<span class="tok-number">0</span>];
}</code></pre></details></div></div><div class="decl"><h2 id="std.math.big.int.llcmp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">llcmp</span><a href="#src.zig-std.math.big.int.llcmp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">llcmp</span>(a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">i8</span></code></pre></div><div class="tldDocs"><p>Returns -1, 0, 1 if |a| &lt; |b|, |a| == |b| or |a| &gt; |b| respectively for limbs.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div><div><pre><code>b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.math.big.int.llcmp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">llcmp</span>(a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">i8</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <span class="tok-kw">const</span> a_len = <a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(a);
    <span class="tok-kw">const</span> b_len = <a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(b);
    <span class="tok-kw">if</span> (a_len &lt; b_len) {
        <span class="tok-kw">return</span> -<span class="tok-number">1</span>;
    }
    <span class="tok-kw">if</span> (a_len &gt; b_len) {
        <span class="tok-kw">return</span> <span class="tok-number">1</span>;
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = a_len - <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) : (i -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (a[i] != b[i]) {
            <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">if</span> (a[i] &lt; b[i]) {
        <span class="tok-kw">return</span> -<span class="tok-number">1</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a[i] &gt; b[i]) {
        <span class="tok-kw">return</span> <span class="tok-number">1</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.math.big.int">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../../std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> Limb = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>;
<span class="tok-kw">const</span> limb_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>).int.bits;
<span class="tok-kw">const</span> HalfLimb = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>;
<span class="tok-kw">const</span> half_limb_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>).int.bits;
<span class="tok-kw">const</span> DoubleLimb = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>;
<span class="tok-kw">const</span> SignedDoubleLimb = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a>;
<span class="tok-kw">const</span> Log2Limb = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> maxInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>;
<span class="tok-kw">const</span> minInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> Endian = <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>;
<span class="tok-kw">const</span> Signedness = <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a>;
<span class="tok-kw">const</span> native_endian = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>();

<span class="tok-kw">const</span> debug_safety = <span class="tok-null">false</span>;

<span class="tok-comment">/// Returns the number of limbs needed to store `scalar`, which must be a</span>
<span class="tok-comment">/// primitive integer value.</span>
<span class="tok-comment">/// Note: A comptime-known upper bound of this value that may be used</span>
<span class="tok-comment">/// instead if `scalar` is not already comptime-known is</span>
<span class="tok-comment">/// `calcTwosCompLimbCount(@typeInfo(@TypeOf(scalar)).int.bits)`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcLimbLen</span>(scalar: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (scalar == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-number">1</span>;
    }

    <span class="tok-kw">const</span> w_value = <span class="tok-builtin">@abs</span>(scalar);
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@divFloor</span>(<span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@intCast</span>(<a href="std.math.html">math</a>.<a href="std.math.log2.html#std.math.log2.log2">log2</a>(w_value))), <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcToStringLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, base: <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(base))
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> a_len + <span class="tok-number">2</span> + a_len + <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a_len, <span class="tok-number">1</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcDivLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> a_len + b_len + <span class="tok-number">4</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcMulLimbsBufferLen</span>(a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>, aliases: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> aliases * <span class="tok-builtin">@max</span>(a_len, b_len);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcMulWrapLimbsBufferLen</span>(bit_count: <span class="tok-type">usize</span>, a_len: <span class="tok-type">usize</span>, b_len: <span class="tok-type">usize</span>, aliases: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
    <span class="tok-kw">return</span> aliases * <span class="tok-builtin">@min</span>(req_limbs, <span class="tok-builtin">@max</span>(a_len, b_len));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSetStringLimbsBufferLen</span>(base: <span class="tok-type">u8</span>, string_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> limb_count = <a href="std.math.big.int.html#std.math.big.int.calcSetStringLimbCount">calcSetStringLimbCount</a>(base, string_len);
    <span class="tok-kw">return</span> <a href="std.math.big.int.html#std.math.big.int.calcMulLimbsBufferLen">calcMulLimbsBufferLen</a>(limb_count, limb_count, <span class="tok-number">2</span>);
}

<span class="tok-comment">/// Assumes `string_len` doesn't account for minus signs if the number is negative.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSetStringLimbCount</span>(base: <span class="tok-type">u8</span>, string_len: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> base_f: <span class="tok-type">f32</span> = <span class="tok-builtin">@floatFromInt</span>(base);
    <span class="tok-kw">const</span> string_len_f: <span class="tok-type">f32</span> = <span class="tok-builtin">@floatFromInt</span>(string_len);
    <span class="tok-kw">return</span> <span class="tok-number">1</span> + <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromFloat</span>(<span class="tok-builtin">@ceil</span>(string_len_f * <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.log2.html#std.math.log2.log2">log2</a>(base_f) / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>)));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcPowLimbsBufferLen</span>(a_bit_count: <span class="tok-type">usize</span>, y: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {<span class="tok-comment">
    // The 2 accounts for the minimum space requirement for llmulacc
    </span><span class="tok-kw">return</span> <span class="tok-number">2</span> + (a_bit_count * y + (<a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - <span class="tok-number">1</span>)) / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcSqrtLimbsBufferLen</span>(a_bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> a_limb_count = (a_bit_count - <span class="tok-number">1</span>) / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> + <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> shift = (a_bit_count + <span class="tok-number">1</span>) / <span class="tok-number">2</span>;
    <span class="tok-kw">const</span> u_s_rem_limb_count = <span class="tok-number">1</span> + ((shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> a_limb_count + <span class="tok-number">3</span> * u_s_rem_limb_count + <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a_limb_count, u_s_rem_limb_count);
}

<span class="tok-comment">/// Compute the number of limbs required to store a 2s-complement number of `bit_count` bits.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcNonZeroTwosCompLimbCount</span>(bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(bit_count != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
}

<span class="tok-comment">/// Compute the number of limbs required to store a 2s-complement number of `bit_count` bits.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Special cases `bit_count == 0` to return 1. Zero-bit integers can only store the value zero</span>
<span class="tok-comment">/// and this big integer implementation stores zero using one limb.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">calcTwosCompLimbCount</span>(bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@max</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, bit_count, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>, <span class="tok-number">1</span>);
}

<span class="tok-comment">/// a + b * c + *carry, sets carry to the overflow bits</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addMulLimbWithCarry</span>(a: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, c: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, carry: *<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.html#std.math.big.Limb">Limb</a> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);<span class="tok-comment">

    // ov1[0] = a + *carry
    </span><span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@addWithOverflow</span>(a, carry.*);<span class="tok-comment">

    // r2 = b * c
    </span><span class="tok-kw">const</span> bc = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, b, c));
    <span class="tok-kw">const</span> r2 = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(bc));
    <span class="tok-kw">const</span> c2 = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(bc &gt;&gt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));<span class="tok-comment">

    // ov2[0] = ov1[0] + r2
    </span><span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@addWithOverflow</span>(ov1[<span class="tok-number">0</span>], r2);<span class="tok-comment">

    // This never overflows, c1, c3 are either 0 or 1 and if both are 1 then
    // c2 is at least &lt;= maxInt(Limb) - 2.
    </span>carry.* = ov1[<span class="tok-number">1</span>] + c2 + ov2[<span class="tok-number">1</span>];

    <span class="tok-kw">return</span> ov2[<span class="tok-number">0</span>];
}

<span class="tok-comment">/// a - b * c - *carry, sets carry to the overflow bits</span>
<span class="tok-kw">fn</span> <span class="tok-fn">subMulLimbWithBorrow</span>(a: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, c: <a href="std.math.big.html#std.math.big.Limb">Limb</a>, carry: *<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.html#std.math.big.Limb">Limb</a> {<span class="tok-comment">
    // ov1[0] = a - *carry
    </span><span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(a, carry.*);<span class="tok-comment">

    // r2 = b * c
    </span><span class="tok-kw">const</span> bc = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, b, c));
    <span class="tok-kw">const</span> r2 = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(bc));
    <span class="tok-kw">const</span> c2 = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(bc &gt;&gt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));<span class="tok-comment">

    // ov2[0] = ov1[0] - r2
    </span><span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@subWithOverflow</span>(ov1[<span class="tok-number">0</span>], r2);
    carry.* = ov1[<span class="tok-number">1</span>] + c2 + ov2[<span class="tok-number">1</span>];

    <span class="tok-kw">return</span> ov2[<span class="tok-number">0</span>];
}

<span class="tok-comment">/// Used to indicate either limit of a 2s-complement integer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TwosCompIntLimit = <span class="tok-kw">enum</span> {<span class="tok-comment">
    // The low limit, either 0x00 (unsigned) or (-)0x80 (signed) for an 8-bit integer.
    </span>min,<span class="tok-comment">

    // The high limit, either 0xFF (unsigned) or 0x7F (signed) for an 8-bit integer.
    </span>max,
};

<span class="tok-comment">/// A arbitrary-precision big integer, with a fixed set of mutable limbs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Mutable = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Raw digits. These are:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// * Little-endian ordered</span>
    <span class="tok-comment">/// * limbs.len &gt;= 1</span>
    <span class="tok-comment">/// * Zero is represented as limbs.len == 1 with limbs[0] == 0.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Accessing limbs directly should be avoided.</span>
    <span class="tok-comment">/// These are allocated limbs; the `len` field tells the valid range.</span>
    limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    len: <span class="tok-type">usize</span>,
    positive: <span class="tok-type">bool</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <a href="std.math.big.int.Const.html">Const</a> {
        <span class="tok-kw">return</span> .{
            .limbs = self.limbs[<span class="tok-number">0</span>..self.len],
            .positive = self.positive,
        };
    }

    <span class="tok-comment">/// Returns true if `a == 0`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.toConst().eqlZero();
    }

    <span class="tok-comment">/// Asserts that the allocator owns the limbs memory. If this is not the case,</span>
    <span class="tok-comment">/// use `toConst().toManaged()`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> .{
            .allocator = allocator,
            .limbs = self.limbs,
            .metadata = <span class="tok-kw">if</span> (self.positive)
                self.len &amp; ~<a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>
            <span class="tok-kw">else</span>
                self.len | <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>,
        };
    }

    <span class="tok-comment">/// `value` is a primitive integer type.</span>
    <span class="tok-comment">/// Asserts the value fits within the provided `limbs_buffer`.</span>
    <span class="tok-comment">/// Note: `calcLimbLen` can be used to figure out how big an array to allocate for `limbs_buffer`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, value: <span class="tok-kw">anytype</span>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
        limbs_buffer[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> self: <a href="std.math.big.int.Mutable.html">Mutable</a> = .{
            .limbs = limbs_buffer,
            .len = <span class="tok-number">1</span>,
            .positive = <span class="tok-null">true</span>,
        };
        self.set(value);
        <span class="tok-kw">return</span> self;
    }

    <span class="tok-comment">/// Copies the value of a Const to an existing Mutable so that they both have the same value.</span>
    <span class="tok-comment">/// Asserts the value fits in the limbs buffer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, other: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.limbs.ptr != other.limbs.ptr) {
            <span class="tok-builtin">@memcpy</span>(self.limbs[<span class="tok-number">0</span>..other.limbs.len], other.limbs[<span class="tok-number">0</span>..other.limbs.len]);
        }<span class="tok-comment">
        // Normalize before setting `positive` so the `eqlZero` doesn't need to iterate
        // over the extra zero limbs.
        </span>self.normalize(other.limbs.len);
        self.positive = other.positive <span class="tok-kw">or</span> other.eqlZero();
    }

    <span class="tok-comment">/// Efficiently swap an Mutable with another. This swaps the limb pointers and a full copy is not</span>
    <span class="tok-comment">/// performed. The address of the limbs field will not be the same after this function.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, other: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.math.big.int.Mutable.html">Mutable</a>, self, other);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.len]) |limb| {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{x} &quot;</span>, .{limb});
        }
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;capacity={} positive={}\n&quot;</span>, .{ self.limbs.len, self.positive });
    }

    <span class="tok-comment">/// Clones an Mutable and returns a new Mutable with the same value. The new Mutable is a deep copy and</span>
    <span class="tok-comment">/// can be modified separately from the original.</span>
    <span class="tok-comment">/// Asserts that limbs is big enough to store the value.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(other: <a href="std.math.big.int.Mutable.html">Mutable</a>, limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
        <span class="tok-builtin">@memcpy</span>(limbs[<span class="tok-number">0</span>..other.len], other.limbs[<span class="tok-number">0</span>..other.len]);
        <span class="tok-kw">return</span> .{
            .limbs = limbs,
            .len = other.len,
            .positive = other.positive,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        self.positive = !self.positive;
    }

    <span class="tok-comment">/// Modify to become the absolute value</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        self.positive = <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Sets the Mutable to value. Value must be an primitive integer type.</span>
    <span class="tok-comment">/// Asserts the value fits within the limbs buffer.</span>
    <span class="tok-comment">/// Note: `calcLimbLen` can be used to figure out how big the limbs buffer</span>
    <span class="tok-comment">/// needs to be to store a specific value.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.math.big.int.Mutable.html">Mutable</a>, value: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(value);
        <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(value);
        <a href="std.debug.html#std.debug.assert">assert</a>(needed_limbs &lt;= self.limbs.len);<span class="tok-comment"> // value too big

        </span>self.len = needed_limbs;
        self.positive = value &gt;= <span class="tok-number">0</span>;

        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            .int =&gt; |info| {
                <span class="tok-kw">var</span> w_value = <span class="tok-builtin">@abs</span>(value);

                <span class="tok-kw">if</span> (info.bits &lt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {
                    self.limbs[<span class="tok-number">0</span>] = w_value;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i += <span class="tok-number">1</span>) {
                        self.limbs[i] = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(w_value));
                        w_value &gt;&gt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;

                        <span class="tok-kw">if</span> (w_value == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                    }
                }
            },
            .<span class="tok-type">comptime_int</span> =&gt; {
                <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> w_value = <span class="tok-builtin">@abs</span>(value);

                <span class="tok-kw">if</span> (w_value &lt;= <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) {
                    self.limbs[<span class="tok-number">0</span>] = w_value;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">const</span> mask = (<span class="tok-number">1</span> &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) - <span class="tok-number">1</span>;

                    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
                    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i += <span class="tok-number">1</span>) {
                        self.limbs[i] = w_value &amp; mask;
                        w_value &gt;&gt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;

                        <span class="tok-kw">if</span> (w_value == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                    }
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;cannot set Mutable using type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),
        }
    }

    <span class="tok-comment">/// Set self from the string representation `value`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `value` must contain only digits &lt;= `base` and is case insensitive.  Base prefixes are</span>
    <span class="tok-comment">/// not allowed (e.g. 0x43 should simply be 43).  Underscores in the input string are</span>
    <span class="tok-comment">/// ignored and can be used as digit separators.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory for the value in `self.limbs`. An upper bound on number of limbs can</span>
    <span class="tok-comment">/// be determined with `calcSetStringLimbCount`.</span>
    <span class="tok-comment">/// Asserts the base is in the range [2, 36].</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if the value has invalid digits for the requested base.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The size required can be found with</span>
    <span class="tok-comment">/// `calcSetStringLimbsBufferLen`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If `allocator` is provided, it will be used for temporary storage to improve</span>
    <span class="tok-comment">/// multiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setString</span>(
        self: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        base: <span class="tok-type">u8</span>,
        value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
        allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
    ) <span class="tok-kw">error</span>{InvalidCharacter}!<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(base &gt;= <span class="tok-number">2</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(base &lt;= <span class="tok-number">36</span>);

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> positive = <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (value.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> value[<span class="tok-number">0</span>] == <span class="tok-str">'-'</span>) {
            positive = <span class="tok-null">false</span>;
            i += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">const</span> ap_base: <a href="std.math.big.int.Const.html">Const</a> = .{ .limbs = &amp;[_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{base}, .positive = <span class="tok-null">true</span> };
        self.set(<span class="tok-number">0</span>);

        <span class="tok-kw">for</span> (value[i..]) |ch| {
            <span class="tok-kw">if</span> (ch == <span class="tok-str">'_'</span>) {
                <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">const</span> d = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.charToDigit">charToDigit</a>(ch, base);
            <span class="tok-kw">const</span> ap_d: <a href="std.math.big.int.Const.html">Const</a> = .{ .limbs = &amp;[_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{d}, .positive = <span class="tok-null">true</span> };

            self.mul(self.toConst(), ap_base, limbs_buffer, allocator);
            self.add(self.toConst(), ap_d);
        }
        self.positive = positive;
    }

    <span class="tok-comment">/// Set self to either bound of a 2s-complement integer.</span>
    <span class="tok-comment">/// Note: The result is still sign-magnitude, not twos complement! In order to convert the</span>
    <span class="tok-comment">/// result to twos complement, it is sufficient to take the absolute value.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setTwosCompIntLimit</span>(
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) <span class="tok-type">void</span> {<span class="tok-comment">
        // Handle zero-bit types.
        </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
            r.set(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
        <span class="tok-kw">const</span> bit: <a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a> = <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> signmask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; bit;<span class="tok-comment"> // 0b0..010..0 where 1 is the sign bit.
        </span><span class="tok-kw">const</span> mask = (signmask &lt;&lt; <span class="tok-number">1</span>) -% <span class="tok-number">1</span>;<span class="tok-comment"> // 0b0..011..1 where the leftmost 1 is the sign bit.

        </span>r.positive = <span class="tok-null">true</span>;

        <span class="tok-kw">switch</span> (signedness) {
            .signed =&gt; <span class="tok-kw">switch</span> (limit) {
                .min =&gt; {<span class="tok-comment">
                    // Negative bound, signed = -0x80.
                    </span>r.len = req_limbs;
                    <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <span class="tok-number">0</span>);
                    r.limbs[r.len - <span class="tok-number">1</span>] = signmask;
                    r.positive = <span class="tok-null">false</span>;
                },
                .max =&gt; {<span class="tok-comment">
                    // Positive bound, signed = 0x7F
                    // Note, in this branch we need to normalize because the first bit is
                    // supposed to be 0.

                    // Special case for 1-bit integers.
                    </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">1</span>) {
                        r.set(<span class="tok-number">0</span>);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">const</span> new_req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count - <span class="tok-number">1</span>);
                        <span class="tok-kw">const</span> msb = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">2</span>));
                        <span class="tok-kw">const</span> new_signmask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; msb;<span class="tok-comment"> // 0b0..010..0 where 1 is the sign bit.
                        </span><span class="tok-kw">const</span> new_mask = (new_signmask &lt;&lt; <span class="tok-number">1</span>) -% <span class="tok-number">1</span>;<span class="tok-comment"> // 0b0..001..1 where the rightmost 0 is the sign bit.

                        </span>r.len = new_req_limbs;
                        <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                        r.limbs[r.len - <span class="tok-number">1</span>] = new_mask;
                    }
                },
            },
            .unsigned =&gt; <span class="tok-kw">switch</span> (limit) {
                .min =&gt; {<span class="tok-comment">
                    // Min bound, unsigned = 0x00
                    </span>r.set(<span class="tok-number">0</span>);
                },
                .max =&gt; {<span class="tok-comment">
                    // Max bound, unsigned = 0xFF
                    </span>r.len = req_limbs;
                    <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span> .. r.len - <span class="tok-number">1</span>], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                    r.limbs[r.len - <span class="tok-number">1</span>] = mask;
                },
            },
        }
    }

    <span class="tok-comment">/// r = a + scalar</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">/// scalar is a primitive integer type.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `@max(a.limbs.len, calcLimbLen(scalar)) + 1`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addScalar</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Normally we could just determine the number of limbs needed with calcLimbLen,
        // but that is not comptime-known when scalar is not a comptime_int.  Instead, we
        // use calcTwosCompLimbCount for a non-comptime_int scalar, which can be pessimistic
        // in the case that scalar happens to be small in magnitude within its type, but it
        // is well worth being able to use the stack and not needing an allocator passed in.
        // Note that Mutable.init still sets len to calcLimbLen(scalar) in any case.
        </span><span class="tok-kw">const</span> limb_len = <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(scalar))) {
            .<span class="tok-type">comptime_int</span> =&gt; <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(scalar),
            .int =&gt; |info| <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(info.bits),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected scalar to be an int&quot;</span>),
        };
        <span class="tok-kw">var</span> limbs: [limb_len]<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> operand = <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(&amp;limbs, scalar).toConst();
        <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.add">add</a>(r, a, operand);
    }

    <span class="tok-comment">/// Base implementation for addition. Adds `@max(a.limbs.len, b.limbs.len)` elements from a and b,</span>
    <span class="tok-comment">/// and returns whether any overflow occurred.</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts r has enough elements to hold the result. The upper bound is `@max(a.limbs.len, b.limbs.len)`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">addCarry</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(b);
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive != b.positive) {
            <span class="tok-kw">if</span> (a.positive) {<span class="tok-comment">
                // (a) + (-b) =&gt; a - b
                </span><span class="tok-kw">return</span> r.subCarry(a, b.abs());
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // (-a) + (b) =&gt; b - a
                </span><span class="tok-kw">return</span> r.subCarry(b, a.abs());
            }
        } <span class="tok-kw">else</span> {
            r.positive = a.positive;
            <span class="tok-kw">if</span> (a.limbs.len &gt;= b.limbs.len) {
                <span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.lladdcarry">lladdcarry</a>(r.limbs, a.limbs, b.limbs);
                r.normalize(a.limbs.len);
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.lladdcarry">lladdcarry</a>(r.limbs, b.limbs, a.limbs);
                r.normalize(b.limbs.len);
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            }
        }
    }

    <span class="tok-comment">/// r = a + b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `@max(a.limbs.len, b.limbs.len) + 1`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (r.addCarry(a, b)) {<span class="tok-comment">
            // Fix up the result. Note that addCarry normalizes by a.limbs.len or b.limbs.len,
            // so we need to set the length here.
            </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);<span class="tok-comment">
            // `[add|sub]Carry` normalizes by `msl`, so we need to fix up the result manually here.
            // Note, the fact that it normalized means that the intermediary limbs are zero here.
            </span>r.len = msl + <span class="tok-number">1</span>;
            r.limbs[msl] = <span class="tok-number">1</span>;<span class="tok-comment"> // If this panics, there wasn't enough space in `r`.
        </span>}
    }

    <span class="tok-comment">/// r = a + b with 2s-complement wrapping semantics. Returns whether overflow occurred.</span>
    <span class="tok-comment">/// r, a and b may be aliases</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

        // Slice of the upper bits if they exist, these will be ignored and allows us to use addCarry to determine
        // if an overflow occurred.
        </span><span class="tok-kw">const</span> x = <a href="std.math.big.int.Const.html">Const</a>{
            .positive = a.positive,
            .limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)],
        };

        <span class="tok-kw">const</span> y = <a href="std.math.big.int.Const.html">Const</a>{
            .positive = b.positive,
            .limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)],
        };

        <span class="tok-kw">var</span> carry_truncated = <span class="tok-null">false</span>;
        <span class="tok-kw">if</span> (r.addCarry(x, y)) {<span class="tok-comment">
            // There are two possibilities here:
            // - We overflowed req_limbs. In this case, the carry is ignored, as it would be removed by
            //   truncate anyway.
            // - a and b had less elements than req_limbs, and those were overflowed. This case needs to be handled.
            //   Note: after this we still might need to wrap.
            </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);
            <span class="tok-kw">if</span> (msl &lt; req_limbs) {
                r.limbs[msl] = <span class="tok-number">1</span>;
                r.len = req_limbs;
                <span class="tok-builtin">@memset</span>(r.limbs[msl + <span class="tok-number">1</span> .. req_limbs], <span class="tok-number">0</span>);
            } <span class="tok-kw">else</span> {
                carry_truncated = <span class="tok-null">true</span>;
            }
        }

        <span class="tok-kw">if</span> (!r.toConst().fitsInTwosComp(signedness, bit_count)) {
            r.truncate(r.toConst(), signedness, bit_count);
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">return</span> carry_truncated;
    }

    <span class="tok-comment">/// r = a + b with 2s-complement saturating semantics.</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Assets the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

        // Slice of the upper bits if they exist, these will be ignored and allows us to use addCarry to determine
        // if an overflow occurred.
        </span><span class="tok-kw">const</span> x = <a href="std.math.big.int.Const.html">Const</a>{
            .positive = a.positive,
            .limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)],
        };

        <span class="tok-kw">const</span> y = <a href="std.math.big.int.Const.html">Const</a>{
            .positive = b.positive,
            .limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)],
        };

        <span class="tok-kw">if</span> (r.addCarry(x, y)) {<span class="tok-comment">
            // There are two possibilities here:
            // - We overflowed req_limbs, in which case we need to saturate.
            // - a and b had less elements than req_limbs, and those were overflowed.
            //   Note: In this case, might _also_ need to saturate.
            </span><span class="tok-kw">const</span> msl = <span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len);
            <span class="tok-kw">if</span> (msl &lt; req_limbs) {
                r.limbs[msl] = <span class="tok-number">1</span>;
                r.len = req_limbs;<span class="tok-comment">
                // Note: Saturation may still be required if msl == req_limbs - 1
            </span>} <span class="tok-kw">else</span> {<span class="tok-comment">
                // Overflowed req_limbs, definitely saturate.
                </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (r.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
            }
        }<span class="tok-comment">

        // Saturate if the result didn't fit.
        </span>r.saturate(r.toConst(), signedness, bit_count);
    }

    <span class="tok-comment">/// Base implementation for subtraction. Subtracts `@max(a.limbs.len, b.limbs.len)` elements from a and b,</span>
    <span class="tok-comment">/// and returns whether any overflow occurred.</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts r has enough elements to hold the result. The upper bound is `@max(a.limbs.len, b.limbs.len)`.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">subCarry</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(b);
            r.positive = !b.positive;
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive != b.positive) {
            <span class="tok-kw">if</span> (a.positive) {<span class="tok-comment">
                // (a) - (-b) =&gt; a + b
                </span><span class="tok-kw">return</span> r.addCarry(a, b.abs());
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // (-a) - (b) =&gt; -a + -b
                </span><span class="tok-kw">return</span> r.addCarry(a, b.negate());
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive) {
            <span class="tok-kw">if</span> (a.order(b) != .lt) {<span class="tok-comment">
                // (a) - (b) =&gt; a - b
                </span><span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r.limbs, a.limbs, b.limbs);
                r.normalize(a.limbs.len);
                r.positive = <span class="tok-null">true</span>;
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // (a) - (b) =&gt; -b + a =&gt; -(b - a)
                </span><span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r.limbs, b.limbs, a.limbs);
                r.normalize(b.limbs.len);
                r.positive = <span class="tok-null">false</span>;
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">if</span> (a.order(b) == .lt) {<span class="tok-comment">
                // (-a) - (-b) =&gt; -(a - b)
                </span><span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r.limbs, a.limbs, b.limbs);
                r.normalize(a.limbs.len);
                r.positive = <span class="tok-null">false</span>;
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // (-a) - (-b) =&gt; --b + -a =&gt; b - a
                </span><span class="tok-kw">const</span> c = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r.limbs, b.limbs, a.limbs);
                r.normalize(b.limbs.len);
                r.positive = <span class="tok-null">true</span>;
                <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
            }
        }
    }

    <span class="tok-comment">/// r = a - b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `@max(a.limbs.len, b.limbs.len) + 1`. The +1 is not needed if both operands are positive.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
        r.add(a, b.negate());
    }

    <span class="tok-comment">/// r = a - b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> r.addWrap(a, b.negate(), signedness, bit_count);
    }

    <span class="tok-comment">/// r = a - b with 2s-complement saturating semantics.</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Assets the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        r.addSat(a, b.negate(), signedness, bit_count);
    }

    <span class="tok-comment">/// rma = a * b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may alias with `a` or `b`.</span>
    <span class="tok-comment">/// `a` and `b` may alias with each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `a.limbs.len + b.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The amount required is given by `calcMulLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

        <span class="tok-kw">const</span> a_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..a.limbs.len], a.limbs);
            buf_index += a.limbs.len;
            <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
        } <span class="tok-kw">else</span> a;

        <span class="tok-kw">const</span> b_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..b.limbs.len], b.limbs);
            buf_index += b.limbs.len;
            <span class="tok-kw">break</span> :blk b.toMutable(limbs_buffer[start..buf_index]).toConst();
        } <span class="tok-kw">else</span> b;

        <span class="tok-kw">return</span> rma.mulNoAlias(a_copy, b_copy, allocator);
    }

    <span class="tok-comment">/// rma = a * b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may not alias with `a` or `b`.</span>
    <span class="tok-comment">/// `a` and `b` may alias with each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `a.limbs.len + b.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If `allocator` is provided, it will be used for temporary storage to improve</span>
    <span class="tok-comment">/// multiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>, allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing
        </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != b.limbs.ptr);<span class="tok-comment"> // illegal aliasing

        </span><span class="tok-kw">if</span> (a.limbs.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> b.limbs.len == <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(a.limbs[<span class="tok-number">0</span>], b.limbs[<span class="tok-number">0</span>]);
            rma.limbs[<span class="tok-number">0</span>] = ov[<span class="tok-number">0</span>];
            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] == <span class="tok-number">0</span>) {
                rma.len = <span class="tok-number">1</span>;
                rma.positive = (a.positive == b.positive);
                <span class="tok-kw">return</span>;
            }
        }

        <span class="tok-builtin">@memset</span>(rma.limbs[<span class="tok-number">0</span> .. a.limbs.len + b.limbs.len], <span class="tok-number">0</span>);

        <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, allocator, rma.limbs, a.limbs, b.limbs);

        rma.normalize(a.limbs.len + b.limbs.len);
        rma.positive = (a.positive == b.positive);
    }

    <span class="tok-comment">/// rma = a * b with 2s-complement wrapping semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may alias with `a` or `b`.</span>
    <span class="tok-comment">/// `a` and `b` may alias with each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `a.limbs.len + b.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The amount required is given by `calcMulWrapLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrap</span>(
        rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        b: <a href="std.math.big.int.Const.html">Const</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
        allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);

        <span class="tok-kw">const</span> a_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-kw">const</span> a_len = <span class="tok-builtin">@min</span>(req_limbs, a.limbs.len);
            <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..a_len], a.limbs[<span class="tok-number">0</span>..a_len]);
            buf_index += a_len;
            <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
        } <span class="tok-kw">else</span> a;

        <span class="tok-kw">const</span> b_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-kw">const</span> b_len = <span class="tok-builtin">@min</span>(req_limbs, b.limbs.len);
            <span class="tok-builtin">@memcpy</span>(limbs_buffer[buf_index..][<span class="tok-number">0</span>..b_len], b.limbs[<span class="tok-number">0</span>..b_len]);
            buf_index += b_len;
            <span class="tok-kw">break</span> :blk a.toMutable(limbs_buffer[start..buf_index]).toConst();
        } <span class="tok-kw">else</span> b;

        <span class="tok-kw">return</span> rma.mulWrapNoAlias(a_copy, b_copy, signedness, bit_count, allocator);
    }

    <span class="tok-comment">/// rma = a * b with 2s-complement wrapping semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may not alias with `a` or `b`.</span>
    <span class="tok-comment">/// `a` and `b` may alias with each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `a.limbs.len + b.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If `allocator` is provided, it will be used for temporary storage to improve</span>
    <span class="tok-comment">/// multiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrapNoAlias</span>(
        rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        b: <a href="std.math.big.int.Const.html">Const</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
        allocator: ?<a href="std.mem.Allocator.html">Allocator</a>,
    ) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing
        </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != b.limbs.ptr);<span class="tok-comment"> // illegal aliasing

        </span><span class="tok-kw">const</span> req_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);<span class="tok-comment">

        // We can ignore the upper bits here, those results will be discarded anyway.
        </span><span class="tok-kw">const</span> a_limbs = a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len)];
        <span class="tok-kw">const</span> b_limbs = b.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(req_limbs, b.limbs.len)];

        <span class="tok-builtin">@memset</span>(rma.limbs[<span class="tok-number">0</span>..req_limbs], <span class="tok-number">0</span>);

        <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, allocator, rma.limbs, a_limbs, b_limbs);
        rma.normalize(<span class="tok-builtin">@min</span>(req_limbs, a.limbs.len + b.limbs.len));
        rma.positive = (a.positive == b.positive);
        rma.truncate(rma.toConst(), signedness, bit_count);
    }

    <span class="tok-comment">/// r = @bitReverse(a) with 2s-complement semantics.</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitReverse</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        r.copy(a);

        <span class="tok-kw">const</span> limbs_required = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);

        <span class="tok-kw">if</span> (!a.positive) {
            r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
            </span>r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
            </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
        </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (limbs_required &gt; a.limbs.len) {<span class="tok-comment">
            // Zero-extend to our output length
            </span><span class="tok-kw">for</span> (r.limbs[a.limbs.len..limbs_required]) |*limb| {
                limb.* = <span class="tok-number">0</span>;
            }
            r.len = limbs_required;
        }<span class="tok-comment">

        // 0b0..01..1000 with @log2(@sizeOf(Limb)) consecutive ones
        </span><span class="tok-kw">const</span> endian_mask: <span class="tok-type">usize</span> = (<span class="tok-builtin">@sizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>) - <span class="tok-number">1</span>) &lt;&lt; <span class="tok-number">3</span>;

        <span class="tok-kw">const</span> bytes = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(r.limbs);

        <span class="tok-kw">var</span> k: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (k &lt; ((bit_count + <span class="tok-number">1</span>) / <span class="tok-number">2</span>)) : (k += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> i = k;
            <span class="tok-kw">var</span> rev_i = bit_count - i - <span class="tok-number">1</span>;<span class="tok-comment">

            // This &quot;endian mask&quot; remaps a low (LE) byte to the corresponding high
            // (BE) byte in the Limb, without changing which limbs we are indexing
            </span><span class="tok-kw">if</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a> == .big) {
                i ^= endian_mask;
                rev_i ^= endian_mask;
            }

            <span class="tok-kw">const</span> bit_i = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, i, .little);
            <span class="tok-kw">const</span> bit_rev_i = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, rev_i, .little);
            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<span class="tok-type">u1</span>, bytes, i, bit_rev_i, .little);
            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<span class="tok-type">u1</span>, bytes, rev_i, bit_i, .little);
        }<span class="tok-comment">

        // Calculate signed-magnitude representation for output
        </span><span class="tok-kw">if</span> (signedness == .signed) {
            <span class="tok-kw">const</span> last_bit = <span class="tok-kw">switch</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a>) {
                .little =&gt; <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, bit_count - <span class="tok-number">1</span>, .little),
                .big =&gt; <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u1</span>, bytes, (bit_count - <span class="tok-number">1</span>) ^ endian_mask, .little),
            };
            <span class="tok-kw">if</span> (last_bit == <span class="tok-number">1</span>) {
                r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
                </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
                </span>r.positive = <span class="tok-null">false</span>;<span class="tok-comment"> // Negate.
            </span>}
        }
        r.normalize(r.len);
    }

    <span class="tok-comment">/// r = @byteSwap(a) with 2s-complement semantics.</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(8*byte_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">byteSwap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, byte_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (byte_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

        r.copy(a);
        <span class="tok-kw">const</span> limbs_required = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(<span class="tok-number">8</span> * byte_count);

        <span class="tok-kw">if</span> (!a.positive) {
            r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
            </span>r.bitNotWrap(r.toConst(), .unsigned, <span class="tok-number">8</span> * byte_count);<span class="tok-comment"> // Bitwise NOT.
            </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
        </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (limbs_required &gt; a.limbs.len) {<span class="tok-comment">
            // Zero-extend to our output length
            </span><span class="tok-kw">for</span> (r.limbs[a.limbs.len..limbs_required]) |*limb| {
                limb.* = <span class="tok-number">0</span>;
            }
            r.len = limbs_required;
        }<span class="tok-comment">

        // 0b0..01..1 with @log2(@sizeOf(Limb)) trailing ones
        </span><span class="tok-kw">const</span> endian_mask: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>) - <span class="tok-number">1</span>;

        <span class="tok-kw">var</span> bytes = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(r.limbs);
        <a href="std.debug.html#std.debug.assert">assert</a>(bytes.len &gt;= byte_count);

        <span class="tok-kw">var</span> k: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (k &lt; (byte_count + <span class="tok-number">1</span>) / <span class="tok-number">2</span>) : (k += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> i = k;
            <span class="tok-kw">var</span> rev_i = byte_count - k - <span class="tok-number">1</span>;<span class="tok-comment">

            // This &quot;endian mask&quot; remaps a low (LE) byte to the corresponding high
            // (BE) byte in the Limb, without changing which limbs we are indexing
            </span><span class="tok-kw">if</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a> == .big) {
                i ^= endian_mask;
                rev_i ^= endian_mask;
            }

            <span class="tok-kw">const</span> byte_i = bytes[i];
            <span class="tok-kw">const</span> byte_rev_i = bytes[rev_i];
            bytes[rev_i] = byte_i;
            bytes[i] = byte_rev_i;
        }<span class="tok-comment">

        // Calculate signed-magnitude representation for output
        </span><span class="tok-kw">if</span> (signedness == .signed) {
            <span class="tok-kw">const</span> last_byte = <span class="tok-kw">switch</span> (<a href="std.math.big.int.html#std.math.big.int.native_endian">native_endian</a>) {
                .little =&gt; bytes[byte_count - <span class="tok-number">1</span>],
                .big =&gt; bytes[(byte_count - <span class="tok-number">1</span>) ^ endian_mask],
            };

            <span class="tok-kw">if</span> (last_byte &amp; (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">7</span>) != <span class="tok-number">0</span>) {<span class="tok-comment"> // Check sign bit of last byte
                </span>r.bitNotWrap(r.toConst(), .unsigned, <span class="tok-number">8</span> * byte_count);<span class="tok-comment"> // Bitwise NOT.
                </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
                </span>r.positive = <span class="tok-null">false</span>;<span class="tok-comment"> // Negate.
            </span>}
        }
        r.normalize(r.len);
    }

    <span class="tok-comment">/// r = @popCount(a) with 2s-complement semantics.</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Assets the result fits in `r`. Upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        r.copy(a);

        <span class="tok-kw">if</span> (!a.positive) {
            r.positive = <span class="tok-null">true</span>;<span class="tok-comment"> // Negate.
            </span>r.bitNotWrap(r.toConst(), .unsigned, bit_count);<span class="tok-comment"> // Bitwise NOT.
            </span>r.addScalar(r.toConst(), <span class="tok-number">1</span>);<span class="tok-comment"> // Add one.
        </span>}

        <span class="tok-kw">var</span> sum: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (r.limbs[<span class="tok-number">0</span>..r.len]) |limb| {
            sum += <span class="tok-builtin">@popCount</span>(limb);
        }
        r.set(sum);
    }

    <span class="tok-comment">/// rma = a * a</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `rma` may not alias with `a`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts the result fits in `rma`. An upper bound on the number of limbs needed by</span>
    <span class="tok-comment">/// rma is given by `2 * a.limbs.len + 1`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If `allocator` is provided, it will be used for temporary storage to improve</span>
    <span class="tok-comment">/// multiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, opt_allocator: ?<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        _ = opt_allocator;
        <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing

        </span><span class="tok-builtin">@memset</span>(rma.limbs, <span class="tok-number">0</span>);

        <a href="std.math.big.int.html#std.math.big.int.llsquareBasecase">llsquareBasecase</a>(rma.limbs, a.limbs);

        rma.normalize(<span class="tok-number">2</span> * a.limbs.len + <span class="tok-number">1</span>);
        rma.positive = <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// q = a / b (rem r)</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a / b are floored (rounded towards 0).</span>
    <span class="tok-comment">/// q may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to store q and r.</span>
    <span class="tok-comment">/// The upper bound for r limb count is `b.limbs.len`.</span>
    <span class="tok-comment">/// The upper bound for q limb count is given by `a.limbs`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The amount required is given by `calcDivLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divFloor</span>(
        q: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        b: <a href="std.math.big.int.Const.html">Const</a>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> sep = a.limbs.len + <span class="tok-number">2</span>;
        <span class="tok-kw">var</span> x = a.toMutable(limbs_buffer[<span class="tok-number">0</span>..sep]);
        <span class="tok-kw">var</span> y = b.toMutable(limbs_buffer[sep..]);

        <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.div">div</a>(q, r, &amp;x, &amp;y);<span class="tok-comment">

        // Note, `div` performs truncating division, which satisfies
        // @divTrunc(a, b) * b + @rem(a, b) = a
        // so r = a - @divTrunc(a, b) * b
        // Note,  @rem(a, -b) = @rem(-b, a) = -@rem(a, b) = -@rem(-a, -b)
        // For divTrunc, we want to perform
        // @divFloor(a, b) * b + @mod(a, b) = a
        // Note:
        // @divFloor(-a, b)
        // = @divFloor(a, -b)
        // = -@divCeil(a, b)
        // = -@divFloor(a + b - 1, b)
        // = -@divTrunc(a + b - 1, b)

        // Note (1):
        // @divTrunc(a + b - 1, b) * b + @rem(a + b - 1, b) = a + b - 1
        // = @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) = a + b - 1
        // = @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = a

        </span><span class="tok-kw">if</span> (a.positive <span class="tok-kw">and</span> b.positive) {<span class="tok-comment">
            // Positive-positive case, don't need to do anything.
        </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive <span class="tok-kw">and</span> !b.positive) {<span class="tok-comment">
            // a/-b -&gt; q is negative, and so we need to fix flooring.
            // Subtract one to make the division flooring.

            // @divFloor(a, -b) * -b + @mod(a, -b) = a
            // If b divides a exactly, we have @divFloor(a, -b) * -b = a
            // Else, we have @divFloor(a, -b) * -b &gt; a, so @mod(a, -b) becomes negative

            // We have:
            // @divFloor(a, -b) * -b + @mod(a, -b) = a
            // = -@divTrunc(a + b - 1, b) * -b + @mod(a, -b) = a
            // = @divTrunc(a + b - 1, b) * b + @mod(a, -b) = a

            // Substitute a for (1):
            // @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = @divTrunc(a + b - 1, b) * b + @mod(a, -b)
            // Yields:
            // @mod(a, -b) = @rem(a - 1, b) - b + 1
            // Note that `r` holds @rem(a, b) at this point.
            //
            // If @rem(a, b) is not 0:
            //   @rem(a - 1, b) = @rem(a, b) - 1
            //   =&gt; @mod(a, -b) = @rem(a, b) - 1 - b + 1 = @rem(a, b) - b
            // Else:
            //   @rem(a - 1, b) = @rem(a + b - 1, b) = @rem(b - 1, b) = b - 1
            //   =&gt; @mod(a, -b) = b - 1 - b + 1 = 0
            </span><span class="tok-kw">if</span> (!r.eqlZero()) {
                q.addScalar(q.toConst(), -<span class="tok-number">1</span>);
                r.positive = <span class="tok-null">true</span>;
                r.sub(r.toConst(), y.toConst().abs());
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> b.positive) {<span class="tok-comment">
            // -a/b -&gt; q is negative, and so we need to fix flooring.
            // Subtract one to make the division flooring.

            // @divFloor(-a, b) * b + @mod(-a, b) = a
            // If b divides a exactly, we have @divFloor(-a, b) * b = -a
            // Else, we have @divFloor(-a, b) * b &lt; -a, so @mod(-a, b) becomes positive

            // We have:
            // @divFloor(-a, b) * b + @mod(-a, b) = -a
            // = -@divTrunc(a + b - 1, b) * b + @mod(-a, b) = -a
            // = @divTrunc(a + b - 1, b) * b - @mod(-a, b) = a

            // Substitute a for (1):
            // @divTrunc(a + b - 1, b) * b + @rem(a - 1, b) - b + 1 = @divTrunc(a + b - 1, b) * b - @mod(-a, b)
            // Yields:
            // @rem(a - 1, b) - b + 1 = -@mod(-a, b)
            // =&gt; -@mod(-a, b) = @rem(a - 1, b) - b + 1
            // =&gt; @mod(-a, b) = -(@rem(a - 1, b) - b + 1) = -@rem(a - 1, b) + b - 1
            //
            // If @rem(a, b) is not 0:
            //   @rem(a - 1, b) = @rem(a, b) - 1
            //   =&gt; @mod(-a, b) = -(@rem(a, b) - 1) + b - 1 = -@rem(a, b) + 1 + b - 1 = -@rem(a, b) + b
            // Else :
            //   @rem(a - 1, b) = b - 1
            //   =&gt; @mod(-a, b) = -(b - 1) + b - 1 = 0
            </span><span class="tok-kw">if</span> (!r.eqlZero()) {
                q.addScalar(q.toConst(), -<span class="tok-number">1</span>);
                r.positive = <span class="tok-null">false</span>;
                r.add(r.toConst(), y.toConst().abs());
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> !b.positive) {<span class="tok-comment">
            // a/b -&gt; q is positive, don't need to do anything to fix flooring.

            // @divFloor(-a, -b) * -b + @mod(-a, -b) = -a
            // If b divides a exactly, we have @divFloor(-a, -b) * -b = -a
            // Else, we have @divFloor(-a, -b) * -b &gt; -a, so @mod(-a, -b) becomes negative

            // We have:
            // @divFloor(-a, -b) * -b + @mod(-a, -b) = -a
            // = @divTrunc(a, b) * -b + @mod(-a, -b) = -a
            // = @divTrunc(a, b) * b - @mod(-a, -b) = a

            // We also have:
            // @divTrunc(a, b) * b + @rem(a, b) = a

            // Substitute a:
            // @divTrunc(a, b) * b + @rem(a, b) = @divTrunc(a, b) * b - @mod(-a, -b)
            // =&gt; @rem(a, b) = -@mod(-a, -b)
            // =&gt; @mod(-a, -b) = -@rem(a, b)
            </span>r.positive = <span class="tok-null">false</span>;
        }
    }

    <span class="tok-comment">/// q = a / b (rem r)</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a / b are truncated (rounded towards -inf).</span>
    <span class="tok-comment">/// q may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to store q and r.</span>
    <span class="tok-comment">/// The upper bound for r limb count is `b.limbs.len`.</span>
    <span class="tok-comment">/// The upper bound for q limb count is given by `a.limbs.len`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage. The amount required is given by `calcDivLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divTrunc</span>(
        q: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        b: <a href="std.math.big.int.Const.html">Const</a>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> sep = a.limbs.len + <span class="tok-number">2</span>;
        <span class="tok-kw">var</span> x = a.toMutable(limbs_buffer[<span class="tok-number">0</span>..sep]);
        <span class="tok-kw">var</span> y = b.toMutable(limbs_buffer[sep..]);

        <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.div">div</a>(q, r, &amp;x, &amp;y);
    }

    <span class="tok-comment">/// r = a &lt;&lt; shift, in other words, r = a * 2^shift</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to fit the result. The upper bound Limb count is</span>
    <span class="tok-comment">/// `a.limbs.len + (shift / (@sizeOf(Limb) * 8))`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeft</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.math.big.int.html#std.math.big.int.llshl">llshl</a>(r.limbs, a.limbs, shift);
        r.normalize(a.limbs.len + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
        r.positive = a.positive;
    }

    <span class="tok-comment">/// r = a &lt;&lt;| shift with 2s-complement saturating semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to fit the result. The upper bound Limb count is</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftSat</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Special case: When the argument is negative, but the result is supposed to be unsigned,
        // return 0 in all cases.
        </span><span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> signedness == .unsigned) {
            r.set(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Check whether the shift is going to overflow. This is the case
        // when (in 2s complement) any bit above `bit_count - shift` is set in the unshifted value.
        // Note, the sign bit is not counted here.

        // Handle shifts larger than the target type. This also deals with
        // 0-bit integers.
        </span><span class="tok-kw">if</span> (bit_count &lt;= shift) {<span class="tok-comment">
            // In this case, there is only no overflow if `a` is zero.
            </span><span class="tok-kw">if</span> (a.eqlZero()) {
                r.set(<span class="tok-number">0</span>);
            } <span class="tok-kw">else</span> {
                r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
            }
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">const</span> checkbit = bit_count - shift - <span class="tok-builtin">@intFromBool</span>(signedness == .signed);<span class="tok-comment">
        // If `checkbit` and more significant bits are zero, no overflow will take place.

        </span><span class="tok-kw">if</span> (checkbit &gt;= a.limbs.len * <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
            // `checkbit` is outside the range of a, so definitely no overflow will take place. We
            // can defer to a normal shift.
            // Note that if `a` is normalized (which we assume), this checks for set bits in the upper limbs.

            // Note, in this case r should already have enough limbs required to perform the normal shift.
            // In this case the shift of the most significant limb may still overflow.
            </span>r.shiftLeft(a, shift);
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (checkbit &lt; (a.limbs.len - <span class="tok-number">1</span>) * <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
            // `checkbit` is not in the most significant limb. If `a` is normalized the most significant
            // limb will not be zero, so in this case we need to saturate. Note that `a.limbs.len` must be
            // at least one according to normalization rules.

            </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Generate a mask with the bits to check in the most significant limb. We'll need to check
        // all bits with equal or more significance than checkbit.
        // const msb = @truncate(Log2Limb, checkbit);
        // const checkmask = (@as(Limb, 1) &lt;&lt; msb) -% 1;

        </span><span class="tok-kw">if</span> (a.limbs[a.limbs.len - <span class="tok-number">1</span>] &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@truncate</span>(checkbit)) != <span class="tok-number">0</span>) {<span class="tok-comment">
            // Need to saturate.
            </span>r.setTwosCompIntLimit(<span class="tok-kw">if</span> (a.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // This shift should not be able to overflow, so invoke llshl and normalize manually
        // to avoid the extra required limb.
        </span><a href="std.math.big.int.html#std.math.big.int.llshl">llshl</a>(r.limbs, a.limbs, shift);
        r.normalize(a.limbs.len + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));
        r.positive = a.positive;
    }

    <span class="tok-comment">/// r = a &gt;&gt; shift</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts there is enough memory to fit the result. The upper bound Limb count is</span>
    <span class="tok-comment">/// `a.limbs.len - (shift / (@sizeOf(Limb) * 8))`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRight</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> full_limbs_shifted_out = shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
        <span class="tok-kw">const</span> remaining_bits_shifted_out = shift % <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
        <span class="tok-kw">if</span> (a.limbs.len &lt;= full_limbs_shifted_out) {<span class="tok-comment">
            // Shifting negative numbers converges to -1 instead of 0
            </span><span class="tok-kw">if</span> (a.positive) {
                r.len = <span class="tok-number">1</span>;
                r.positive = <span class="tok-null">true</span>;
                r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {
                r.len = <span class="tok-number">1</span>;
                r.positive = <span class="tok-null">false</span>;
                r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> nonzero_negative_shiftout = <span class="tok-kw">if</span> (a.positive) <span class="tok-null">false</span> <span class="tok-kw">else</span> nonzero: {
            <span class="tok-kw">for</span> (a.limbs[<span class="tok-number">0</span>..full_limbs_shifted_out]) |x| {
                <span class="tok-kw">if</span> (x != <span class="tok-number">0</span>)
                    <span class="tok-kw">break</span> :nonzero <span class="tok-null">true</span>;
            }
            <span class="tok-kw">if</span> (remaining_bits_shifted_out == <span class="tok-number">0</span>)
                <span class="tok-kw">break</span> :nonzero <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> not_covered: <a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a> = <span class="tok-builtin">@intCast</span>(<a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - remaining_bits_shifted_out);
            <span class="tok-kw">break</span> :nonzero a.limbs[full_limbs_shifted_out] &lt;&lt; not_covered != <span class="tok-number">0</span>;
        };

        <a href="std.math.big.int.html#std.math.big.int.llshr">llshr</a>(r.limbs, a.limbs, shift);

        r.len = a.limbs.len - full_limbs_shifted_out;
        r.positive = a.positive;
        <span class="tok-kw">if</span> (nonzero_negative_shiftout) r.addScalar(r.toConst(), -<span class="tok-number">1</span>);
        r.normalize(r.len);
    }

    <span class="tok-comment">/// r = ~a under 2s complement wrapping semantics.</span>
    <span class="tok-comment">/// r may alias with a.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Assets that r has enough limbs to store the result. The upper bound Limb count is</span>
    <span class="tok-comment">/// r is `calcTwosCompLimbCount(bit_count)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitNotWrap</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        r.copy(a.negate());
        <span class="tok-kw">const</span> negative_one = <a href="std.math.big.int.Const.html">Const</a>{ .limbs = &amp;.{<span class="tok-number">1</span>}, .positive = <span class="tok-null">false</span> };
        _ = r.addWrap(r.toConst(), negative_one, signedness, bit_count);
    }

    <span class="tok-comment">/// r = a | b under 2s complement semantics.</span>
    <span class="tok-comment">/// r may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a and b are zero-extended to the longer of a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that r has enough limbs to store the result. Upper bound is `@max(a.limbs.len, b.limbs.len)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOr</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Trivial cases, llsignedor does not support zero.
        </span><span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(b);
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (a.limbs.len &gt;= b.limbs.len) {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedor">llsignedor</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
            r.normalize(<span class="tok-kw">if</span> (b.positive) a.limbs.len <span class="tok-kw">else</span> b.limbs.len);
        } <span class="tok-kw">else</span> {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedor">llsignedor</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
            r.normalize(<span class="tok-kw">if</span> (a.positive) b.limbs.len <span class="tok-kw">else</span> a.limbs.len);
        }
    }

    <span class="tok-comment">/// r = a &amp; b under 2s complement semantics.</span>
    <span class="tok-comment">/// r may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that r has enough limbs to store the result.</span>
    <span class="tok-comment">/// If only a is positive, the upper bound is `a.limbs.len`.</span>
    <span class="tok-comment">/// If only b is positive, the upper bound is `b.limbs.len`.</span>
    <span class="tok-comment">/// If a and b are positive, the upper bound is `@min(a.limbs.len, b.limbs.len)`.</span>
    <span class="tok-comment">/// If a and b are negative, the upper bound is `@max(a.limbs.len, b.limbs.len) + 1`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAnd</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Trivial cases, llsignedand does not support zero.
        </span><span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(b);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (a.limbs.len &gt;= b.limbs.len) {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedand">llsignedand</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
            r.normalize(<span class="tok-kw">if</span> (b.positive) b.limbs.len <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.positive) a.limbs.len <span class="tok-kw">else</span> a.limbs.len + <span class="tok-number">1</span>);
        } <span class="tok-kw">else</span> {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedand">llsignedand</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
            r.normalize(<span class="tok-kw">if</span> (a.positive) a.limbs.len <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.positive) b.limbs.len <span class="tok-kw">else</span> b.limbs.len + <span class="tok-number">1</span>);
        }
    }

    <span class="tok-comment">/// r = a ^ b under 2s complement semantics.</span>
    <span class="tok-comment">/// r may alias with a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that r has enough limbs to store the result. If a and b share the same signedness, the</span>
    <span class="tok-comment">/// upper bound is `@max(a.limbs.len, b.limbs.len)`. Otherwise, if either a or b is negative</span>
    <span class="tok-comment">/// but not both, the upper bound is `@max(a.limbs.len, b.limbs.len) + 1`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitXor</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Trivial cases, because llsignedxor does not support negative zero.
        </span><span class="tok-kw">if</span> (a.eqlZero()) {
            r.copy(b);
            <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.eqlZero()) {
            r.copy(a);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (a.limbs.len &gt; b.limbs.len) {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedxor">llsignedxor</a>(r.limbs, a.limbs, a.positive, b.limbs, b.positive);
            r.normalize(a.limbs.len + <span class="tok-builtin">@intFromBool</span>(a.positive != b.positive));
        } <span class="tok-kw">else</span> {
            r.positive = <a href="std.math.big.int.html#std.math.big.int.llsignedxor">llsignedxor</a>(r.limbs, b.limbs, b.positive, a.limbs, a.positive);
            r.normalize(b.limbs.len + <span class="tok-builtin">@intFromBool</span>(a.positive != b.positive));
        }
    }

    <span class="tok-comment">/// rma may alias x or y.</span>
    <span class="tok-comment">/// x and y may alias each other.</span>
    <span class="tok-comment">/// Asserts that `rma` has enough limbs to store the result. Upper bound is</span>
    <span class="tok-comment">/// `@min(x.limbs.len, y.limbs.len)`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage during the operation. When this function returns,</span>
    <span class="tok-comment">/// it will have the same length as it had when the function was called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcd</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: <a href="std.math.big.int.Const.html">Const</a>, y: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> prev_len = limbs_buffer.items.len;
        <span class="tok-kw">defer</span> limbs_buffer.shrinkRetainingCapacity(prev_len);
        <span class="tok-kw">const</span> x_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == x.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = limbs_buffer.items.len;
            <span class="tok-kw">try</span> limbs_buffer.appendSlice(x.limbs);
            <span class="tok-kw">break</span> :blk x.toMutable(limbs_buffer.items[start..]).toConst();
        } <span class="tok-kw">else</span> x;
        <span class="tok-kw">const</span> y_copy = <span class="tok-kw">if</span> (rma.limbs.ptr == y.limbs.ptr) blk: {
            <span class="tok-kw">const</span> start = limbs_buffer.items.len;
            <span class="tok-kw">try</span> limbs_buffer.appendSlice(y.limbs);
            <span class="tok-kw">break</span> :blk y.toMutable(limbs_buffer.items[start..]).toConst();
        } <span class="tok-kw">else</span> y;

        <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.gcdLehmer">gcdLehmer</a>(rma, x_copy, y_copy, limbs_buffer);
    }

    <span class="tok-comment">/// q = a ^ b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r may not alias a.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that `r` has enough limbs to store the result. Upper bound is</span>
    <span class="tok-comment">/// `calcPowLimbsBufferLen(a.bitCountAbs(), b)`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage.</span>
    <span class="tok-comment">/// The amount required is given by `calcPowLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <span class="tok-type">u32</span>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(r.limbs.ptr != a.limbs.ptr);<span class="tok-comment"> // illegal aliasing

        // Handle all the trivial cases first
        </span><span class="tok-kw">switch</span> (b) {
            <span class="tok-number">0</span> =&gt; {<span class="tok-comment">
                // a^0 = 1
                </span><span class="tok-kw">return</span> r.set(<span class="tok-number">1</span>);
            },
            <span class="tok-number">1</span> =&gt; {<span class="tok-comment">
                // a^1 = a
                </span><span class="tok-kw">return</span> r.copy(a);
            },
            <span class="tok-kw">else</span> =&gt; {},
        }

        <span class="tok-kw">if</span> (a.eqlZero()) {<span class="tok-comment">
            // 0^b = 0
            </span><span class="tok-kw">return</span> r.set(<span class="tok-number">0</span>);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.limbs.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> a.limbs[<span class="tok-number">0</span>] == <span class="tok-number">1</span>) {<span class="tok-comment">
            // 1^b = 1 and -1^b = ±1
            </span>r.set(<span class="tok-number">1</span>);
            r.positive = a.positive <span class="tok-kw">or</span> (b &amp; <span class="tok-number">1</span>) == <span class="tok-number">0</span>;
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Here a&gt;1 and b&gt;1
        </span><span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcPowLimbsBufferLen">calcPowLimbsBufferLen</a>(a.bitCountAbs(), b);
        <a href="std.debug.html#std.debug.assert">assert</a>(r.limbs.len &gt;= needed_limbs);
        <a href="std.debug.html#std.debug.assert">assert</a>(limbs_buffer.len &gt;= needed_limbs);

        <a href="std.math.big.int.html#std.math.big.int.llpow">llpow</a>(r.limbs, a.limbs, b, limbs_buffer);

        r.normalize(needed_limbs);
        r.positive = a.positive <span class="tok-kw">or</span> (b &amp; <span class="tok-number">1</span>) == <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// r = ⌊√a⌋</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r may alias a.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that `r` has enough limbs to store the result. Upper bound is</span>
    <span class="tok-comment">/// `(a.limbs.len - 1) / 2 + 1`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage.</span>
    <span class="tok-comment">/// The amount required is given by `calcSqrtLimbsBufferLen`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrt</span>(
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        a: <a href="std.math.big.int.Const.html">Const</a>,
        limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    ) <span class="tok-type">void</span> {<span class="tok-comment">
        // Brent and Zimmermann, Modern Computer Arithmetic, Algorithm 1.13 SqrtInt
        // https://members.loria.fr/PZimmermann/mca/pub226.html
        </span><span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> t = b: {
            <span class="tok-kw">const</span> start = buf_index;
            buf_index += a.limbs.len;
            <span class="tok-kw">break</span> :b <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">0</span>);
        };
        <span class="tok-kw">var</span> u = b: {
            <span class="tok-kw">const</span> start = buf_index;
            <span class="tok-kw">const</span> shift = (a.bitCountAbs() + <span class="tok-number">1</span>) / <span class="tok-number">2</span>;
            buf_index += <span class="tok-number">1</span> + ((shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
            <span class="tok-kw">var</span> m = <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">1</span>);
            m.shiftLeft(m.toConst(), shift);<span class="tok-comment"> // u must be &gt;= ⌊√a⌋, and should be as small as possible for efficiency
            </span><span class="tok-kw">break</span> :b m;
        };
        <span class="tok-kw">var</span> s = b: {
            <span class="tok-kw">const</span> start = buf_index;
            buf_index += u.limbs.len;
            <span class="tok-kw">break</span> :b u.toConst().toMutable(limbs_buffer[start..buf_index]);
        };
        <span class="tok-kw">var</span> rem = b: {
            <span class="tok-kw">const</span> start = buf_index;
            buf_index += s.limbs.len;
            <span class="tok-kw">break</span> :b <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs_buffer[start..buf_index], <span class="tok-number">0</span>);
        };

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            t.divFloor(&amp;rem, a, s.toConst(), limbs_buffer[buf_index..]);
            t.add(t.toConst(), s.toConst());
            u.shiftRight(t.toConst(), <span class="tok-number">1</span>);

            <span class="tok-kw">if</span> (u.toConst().order(s.toConst()).compare(.gte)) {
                r.copy(s.toConst());
                <span class="tok-kw">return</span>;
            }<span class="tok-comment">

            // Avoid copying u to s by swapping u and s
            </span><span class="tok-kw">const</span> tmp_s = s;
            s = u;
            u = tmp_s;
        }
    }

    <span class="tok-comment">/// rma may not alias x or y.</span>
    <span class="tok-comment">/// x and y may alias each other.</span>
    <span class="tok-comment">/// Asserts that `rma` has enough limbs to store the result. Upper bound is given by `calcGcdNoAliasLimbLen`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `limbs_buffer` is used for temporary storage during the operation.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcdNoAlias</span>(rma: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: <a href="std.math.big.int.Const.html">Const</a>, y: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != x.limbs.ptr);<span class="tok-comment"> // illegal aliasing
        </span><a href="std.debug.html#std.debug.assert">assert</a>(rma.limbs.ptr != y.limbs.ptr);<span class="tok-comment"> // illegal aliasing
        </span><span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.gcdLehmer">gcdLehmer</a>(rma, x, y, limbs_buffer);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">gcdLehmer</span>(result: *<a href="std.math.big.int.Mutable.html">Mutable</a>, xa: <a href="std.math.big.int.Const.html">Const</a>, ya: <a href="std.math.big.int.Const.html">Const</a>, limbs_buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) !<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> x = <span class="tok-kw">try</span> xa.toManaged(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> x.deinit();
        x.abs();

        <span class="tok-kw">var</span> y = <span class="tok-kw">try</span> ya.toManaged(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> y.deinit();
        y.abs();

        <span class="tok-kw">if</span> (x.toConst().order(y.toConst()) == .lt) {
            x.swap(&amp;y);
        }

        <span class="tok-kw">var</span> t_big = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> t_big.deinit();

        <span class="tok-kw">var</span> r = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> r.deinit();

        <span class="tok-kw">var</span> tmp_x = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(limbs_buffer.allocator);
        <span class="tok-kw">defer</span> tmp_x.deinit();

        <span class="tok-kw">while</span> (y.len() &gt; <span class="tok-number">1</span> <span class="tok-kw">and</span> !y.eqlZero()) {
            <a href="std.debug.html#std.debug.assert">assert</a>(x.isPositive() <span class="tok-kw">and</span> y.isPositive());
            <a href="std.debug.html#std.debug.assert">assert</a>(x.len() &gt;= y.len());

            <span class="tok-kw">var</span> xh: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = x.limbs[x.len() - <span class="tok-number">1</span>];
            <span class="tok-kw">var</span> yh: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-kw">if</span> (x.len() &gt; y.len()) <span class="tok-number">0</span> <span class="tok-kw">else</span> y.limbs[x.len() - <span class="tok-number">1</span>];

            <span class="tok-kw">var</span> A: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-number">1</span>;
            <span class="tok-kw">var</span> B: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> C: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> D: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a> = <span class="tok-number">1</span>;

            <span class="tok-kw">while</span> (yh + C != <span class="tok-number">0</span> <span class="tok-kw">and</span> yh + D != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> q = <span class="tok-builtin">@divFloor</span>(xh + A, yh + C);
                <span class="tok-kw">const</span> qp = <span class="tok-builtin">@divFloor</span>(xh + B, yh + D);
                <span class="tok-kw">if</span> (q != qp) {
                    <span class="tok-kw">break</span>;
                }

                <span class="tok-kw">var</span> t = A - q * C;
                A = C;
                C = t;
                t = B - q * D;
                B = D;
                D = t;

                t = xh - q * yh;
                xh = yh;
                yh = t;
            }

            <span class="tok-kw">if</span> (B == <span class="tok-number">0</span>) {<span class="tok-comment">
                // t_big = x % y, r is unused
                </span><span class="tok-kw">try</span> r.divTrunc(&amp;t_big, &amp;x, &amp;y);
                <a href="std.debug.html#std.debug.assert">assert</a>(t_big.isPositive());

                x.swap(&amp;y);
                y.swap(&amp;t_big);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> storage: [<span class="tok-number">8</span>]<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> Ap = <a href="std.math.big.int.html#std.math.big.int.fixedIntFromSignedDoubleLimb">fixedIntFromSignedDoubleLimb</a>(A, storage[<span class="tok-number">0</span>..<span class="tok-number">2</span>]).toManaged(limbs_buffer.allocator);
                <span class="tok-kw">const</span> Bp = <a href="std.math.big.int.html#std.math.big.int.fixedIntFromSignedDoubleLimb">fixedIntFromSignedDoubleLimb</a>(B, storage[<span class="tok-number">2</span>..<span class="tok-number">4</span>]).toManaged(limbs_buffer.allocator);
                <span class="tok-kw">const</span> Cp = <a href="std.math.big.int.html#std.math.big.int.fixedIntFromSignedDoubleLimb">fixedIntFromSignedDoubleLimb</a>(C, storage[<span class="tok-number">4</span>..<span class="tok-number">6</span>]).toManaged(limbs_buffer.allocator);
                <span class="tok-kw">const</span> Dp = <a href="std.math.big.int.html#std.math.big.int.fixedIntFromSignedDoubleLimb">fixedIntFromSignedDoubleLimb</a>(D, storage[<span class="tok-number">6</span>..<span class="tok-number">8</span>]).toManaged(limbs_buffer.allocator);<span class="tok-comment">

                // t_big = Ax + By
                </span><span class="tok-kw">try</span> r.mul(&amp;x, &amp;Ap);
                <span class="tok-kw">try</span> t_big.mul(&amp;y, &amp;Bp);
                <span class="tok-kw">try</span> t_big.add(&amp;r, &amp;t_big);<span class="tok-comment">

                // u = Cx + Dy, r as u
                </span><span class="tok-kw">try</span> tmp_x.copy(x.toConst());
                <span class="tok-kw">try</span> x.mul(&amp;tmp_x, &amp;Cp);
                <span class="tok-kw">try</span> r.mul(&amp;y, &amp;Dp);
                <span class="tok-kw">try</span> r.add(&amp;x, &amp;r);

                x.swap(&amp;t_big);
                y.swap(&amp;r);
            }
        }<span class="tok-comment">

        // euclidean algorithm
        </span><a href="std.debug.html#std.debug.assert">assert</a>(x.toConst().order(y.toConst()) != .lt);

        <span class="tok-kw">while</span> (!y.toConst().eqlZero()) {
            <span class="tok-kw">try</span> t_big.divTrunc(&amp;r, &amp;x, &amp;y);
            x.swap(&amp;y);
            y.swap(&amp;r);
        }

        result.copy(x.toConst());
    }<span class="tok-comment">

    // Truncates by default.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">div</span>(q: *<a href="std.math.big.int.Mutable.html">Mutable</a>, r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, x: *<a href="std.math.big.int.Mutable.html">Mutable</a>, y: *<a href="std.math.big.int.Mutable.html">Mutable</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(!y.eqlZero());<span class="tok-comment"> // division by zero
        </span><a href="std.debug.html#std.debug.assert">assert</a>(q != r);<span class="tok-comment"> // illegal aliasing

        </span><span class="tok-kw">const</span> q_positive = (x.positive == y.positive);
        <span class="tok-kw">const</span> r_positive = x.positive;

        <span class="tok-kw">if</span> (x.toConst().orderAbs(y.toConst()) == .lt) {<span class="tok-comment">
            // q may alias x so handle r first.
            </span>r.copy(x.toConst());
            r.positive = r_positive;

            q.set(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Handle trailing zero-words of divisor/dividend. These are not handled in the following
        // algorithms.
        // Note, there must be a non-zero limb for either.
        // const x_trailing = std.mem.indexOfScalar(Limb, x.limbs[0..x.len], 0).?;
        // const y_trailing = std.mem.indexOfScalar(Limb, y.limbs[0..y.len], 0).?;

        </span><span class="tok-kw">const</span> x_trailing = <span class="tok-kw">for</span> (x.limbs[<span class="tok-number">0</span>..x.len], <span class="tok-number">0</span>..) |xi, i| {
            <span class="tok-kw">if</span> (xi != <span class="tok-number">0</span>) <span class="tok-kw">break</span> i;
        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">const</span> y_trailing = <span class="tok-kw">for</span> (y.limbs[<span class="tok-number">0</span>..y.len], <span class="tok-number">0</span>..) |yi, i| {
            <span class="tok-kw">if</span> (yi != <span class="tok-number">0</span>) <span class="tok-kw">break</span> i;
        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">const</span> xy_trailing = <span class="tok-builtin">@min</span>(x_trailing, y_trailing);

        <span class="tok-kw">if</span> (y.len - xy_trailing == <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> divisor = y.limbs[y.len - <span class="tok-number">1</span>];<span class="tok-comment">

            // Optimization for small divisor. By using a half limb we can avoid requiring DoubleLimb
            // divisions in the hot code path. This may often require compiler_rt software-emulation.
            </span><span class="tok-kw">if</span> (divisor &lt; <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>)) {
                <a href="std.math.big.int.html#std.math.big.int.lldiv0p5">lldiv0p5</a>(q.limbs, &amp;r.limbs[<span class="tok-number">0</span>], x.limbs[xy_trailing..x.len], <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>, <span class="tok-builtin">@intCast</span>(divisor)));
            } <span class="tok-kw">else</span> {
                <a href="std.math.big.int.html#std.math.big.int.lldiv1">lldiv1</a>(q.limbs, &amp;r.limbs[<span class="tok-number">0</span>], x.limbs[xy_trailing..x.len], divisor);
            }

            q.normalize(x.len - xy_trailing);
            q.positive = q_positive;

            r.len = <span class="tok-number">1</span>;
            r.positive = r_positive;
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // Shrink x, y such that the trailing zero limbs shared between are removed.
            </span><span class="tok-kw">var</span> x0 = <a href="std.math.big.int.Mutable.html">Mutable</a>{
                .limbs = x.limbs[xy_trailing..],
                .len = x.len - xy_trailing,
                .positive = <span class="tok-null">true</span>,
            };

            <span class="tok-kw">var</span> y0 = <a href="std.math.big.int.Mutable.html">Mutable</a>{
                .limbs = y.limbs[xy_trailing..],
                .len = y.len - xy_trailing,
                .positive = <span class="tok-null">true</span>,
            };

            <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.divmod">divmod</a>(q, r, &amp;x0, &amp;y0);
            q.positive = q_positive;

            r.positive = r_positive;
        }

        <span class="tok-kw">if</span> (xy_trailing != <span class="tok-number">0</span> <span class="tok-kw">and</span> r.limbs[r.len - <span class="tok-number">1</span>] != <span class="tok-number">0</span>) {<span class="tok-comment">
            // Manually shift here since we know its limb aligned.
            </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.copyBackwards">copyBackwards</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, r.limbs[xy_trailing..], r.limbs[<span class="tok-number">0</span>..r.len]);
            <span class="tok-builtin">@memset</span>(r.limbs[<span class="tok-number">0</span>..xy_trailing], <span class="tok-number">0</span>);
            r.len += xy_trailing;
        }
    }

    <span class="tok-comment">/// Handbook of Applied Cryptography, 14.20</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// x = qy + r where 0 &lt;= r &lt; y</span>
    <span class="tok-comment">/// y is modified but returned intact.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">divmod</span>(
        q: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        r: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        x: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        y: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
    ) <span class="tok-type">void</span> {<span class="tok-comment">
        // 0.
        // Normalize so that y[t] &gt; b/2
        </span><span class="tok-kw">const</span> lz = <span class="tok-builtin">@clz</span>(y.limbs[y.len - <span class="tok-number">1</span>]);
        <span class="tok-kw">const</span> norm_shift = <span class="tok-kw">if</span> (lz == <span class="tok-number">0</span> <span class="tok-kw">and</span> y.toConst().isOdd())
            <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a><span class="tok-comment"> // Force an extra limb so that y is even.
        </span><span class="tok-kw">else</span>
            lz;

        x.shiftLeft(x.toConst(), norm_shift);
        y.shiftLeft(y.toConst(), norm_shift);

        <span class="tok-kw">const</span> n = x.len - <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> t = y.len - <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> shift = n - t;<span class="tok-comment">

        // 1.
        // for 0 &lt;= j &lt;= n - t, set q[j] to 0
        </span>q.len = shift + <span class="tok-number">1</span>;
        q.positive = <span class="tok-null">true</span>;
        <span class="tok-builtin">@memset</span>(q.limbs[<span class="tok-number">0</span>..q.len], <span class="tok-number">0</span>);<span class="tok-comment">

        // 2.
        // while x &gt;= y * b^(n - t):
        //    x -= y * b^(n - t)
        //    q[n - t] += 1
        // Note, this algorithm is performed only once if y[t] &gt; base/2 and y is even, which we
        // enforced in step 0. This means we can replace the while with an if.
        // Note, multiplication by b^(n - t) comes down to shifting to the right by n - t limbs.
        // We can also replace x &gt;= y * b^(n - t) by x/b^(n - t) &gt;= y, and use shifts for that.
        </span>{<span class="tok-comment">
            // x &gt;= y * b^(n - t) can be replaced by x/b^(n - t) &gt;= y.

            // 'divide' x by b^(n - t)
            </span><span class="tok-kw">var</span> tmp = <a href="std.math.big.int.Mutable.html">Mutable</a>{
                .limbs = x.limbs[shift..],
                .len = x.len - shift,
                .positive = <span class="tok-null">true</span>,
            };

            <span class="tok-kw">if</span> (tmp.toConst().order(y.toConst()) != .lt) {<span class="tok-comment">
                // Perform x -= y * b^(n - t)
                // Note, we can subtract y from x[n - t..] and get the result without shifting.
                // We can also re-use tmp which already contains the relevant part of x. Note that
                // this also edits x.
                // Due to the check above, this cannot underflow.
                </span>tmp.sub(tmp.toConst(), y.toConst());<span class="tok-comment">

                // tmp.sub normalized tmp, but we need to normalize x now.
                </span>x.limbs.len = tmp.limbs.len + shift;

                q.limbs[shift] += <span class="tok-number">1</span>;
            }
        }<span class="tok-comment">

        // 3.
        // for i from n down to t + 1, do
        </span><span class="tok-kw">var</span> i = n;
        <span class="tok-kw">while</span> (i &gt;= t + <span class="tok-number">1</span>) : (i -= <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> k = i - t - <span class="tok-number">1</span>;<span class="tok-comment">
            // 3.1.
            // if x_i == y_t:
            //   q[i - t - 1] = b - 1
            // else:
            //   q[i - t - 1] = (x[i] * b + x[i - 1]) / y[t]
            </span><span class="tok-kw">if</span> (x.limbs[i] == y.limbs[t]) {
                q.limbs[k] = <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> q0 = (<span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, x.limbs[i]) &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) | <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, x.limbs[i - <span class="tok-number">1</span>]);
                <span class="tok-kw">const</span> n0 = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, y.limbs[t]);
                q.limbs[k] = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@intCast</span>(q0 / n0));
            }<span class="tok-comment">

            // 3.2
            // while q[i - t - 1] * (y[t] * b + y[t - 1] &gt; x[i] * b * b + x[i - 1] + x[i - 2]:
            //   q[i - t - 1] -= 1
            // Note, if y[t] &gt; b / 2 this part is repeated no more than twice.

            // Extract from y.
            </span><span class="tok-kw">const</span> y0 = <span class="tok-kw">if</span> (t &gt; <span class="tok-number">0</span>) y.limbs[t - <span class="tok-number">1</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> y1 = y.limbs[t];<span class="tok-comment">

            // Extract from x.
            // Note, big endian.
            </span><span class="tok-kw">const</span> tmp0 = [_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{
                x.limbs[i],
                <span class="tok-kw">if</span> (i &gt;= <span class="tok-number">1</span>) x.limbs[i - <span class="tok-number">1</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>,
                <span class="tok-kw">if</span> (i &gt;= <span class="tok-number">2</span>) x.limbs[i - <span class="tok-number">2</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>,
            };

            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
                // Ad-hoc 2x1 multiplication with q[i - t - 1].
                // Note, big endian.
                </span><span class="tok-kw">var</span> tmp1 = [_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{ <span class="tok-number">0</span>, <span class="tok-null">undefined</span>, <span class="tok-null">undefined</span> };
                tmp1[<span class="tok-number">2</span>] = <a href="std.math.big.int.html#std.math.big.int.addMulLimbWithCarry">addMulLimbWithCarry</a>(<span class="tok-number">0</span>, y0, q.limbs[k], &amp;tmp1[<span class="tok-number">0</span>]);
                tmp1[<span class="tok-number">1</span>] = <a href="std.math.big.int.html#std.math.big.int.addMulLimbWithCarry">addMulLimbWithCarry</a>(<span class="tok-number">0</span>, y1, q.limbs[k], &amp;tmp1[<span class="tok-number">0</span>]);<span class="tok-comment">

                // Big-endian compare
                </span><span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.order">order</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, &amp;tmp1, &amp;tmp0) != .gt)
                    <span class="tok-kw">break</span>;

                q.limbs[k] -= <span class="tok-number">1</span>;
            }<span class="tok-comment">

            // 3.3.
            // x -= q[i - t - 1] * y * b^(i - t - 1)
            // Note, we multiply by a single limb here.
            // The shift doesn't need to be performed if we add the result of the first multiplication
            // to x[i - t - 1].
            </span><span class="tok-kw">const</span> underflow = <a href="std.math.big.int.html#std.math.big.int.llmulLimb">llmulLimb</a>(.sub, x.limbs[k..x.len], y.limbs[<span class="tok-number">0</span>..y.len], q.limbs[k]);<span class="tok-comment">

            // 3.4.
            // if x &lt; 0:
            //   x += y * b^(i - t - 1)
            //   q[i - t - 1] -= 1
            // Note, we check for x &lt; 0 using the underflow flag from the previous operation.
            </span><span class="tok-kw">if</span> (underflow) {<span class="tok-comment">
                // While we didn't properly set the signedness of x, this operation should 'flow' it back to positive.
                </span><a href="std.math.big.int.html#std.math.big.int.llaccum">llaccum</a>(.add, x.limbs[k..x.len], y.limbs[<span class="tok-number">0</span>..y.len]);
                q.limbs[k] -= <span class="tok-number">1</span>;
            }
        }

        x.normalize(x.len);
        q.normalize(q.len);<span class="tok-comment">

        // De-normalize r and y.
        </span>r.shiftRight(x.toConst(), norm_shift);
        y.shiftRight(y.toConst(), norm_shift);
    }

    <span class="tok-comment">/// Truncate an integer to a number of bits, following 2s-complement semantics.</span>
    <span class="tok-comment">/// `r` may alias `a`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts `r` has enough storage to compute the result.</span>
    <span class="tok-comment">/// The upper bound is `calcTwosCompLimbCount(a.len)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncate</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Handle 0-bit integers.
        </span><span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
            <span class="tok-builtin">@branchHint</span>(.unlikely);
            r.set(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">const</span> max_limbs = <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count);
        <span class="tok-kw">const</span> sign_bit = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@truncate</span>(bit_count - <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> mask = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) &gt;&gt; <span class="tok-builtin">@truncate</span>(-%bit_count);<span class="tok-comment">

        // Guess whether the result will have the same sign as `a`.
        //  * If the result will be signed zero, the guess is `true`.
        //  * If the result will be the minimum signed integer, the guess is `false`.
        //  * If the result will be unsigned zero, the guess is `a.positive`.
        //  * Otherwise the guess is correct.
        </span><span class="tok-kw">const</span> same_sign_guess = <span class="tok-kw">switch</span> (signedness) {
            .signed =&gt; max_limbs &gt; a.limbs.len <span class="tok-kw">or</span> a.limbs[max_limbs - <span class="tok-number">1</span>] &amp; sign_bit == <span class="tok-number">0</span>,
            .unsigned =&gt; a.positive,
        };

        <span class="tok-kw">const</span> abs_trunc_a: <a href="std.math.big.int.Const.html">Const</a> = .{
            .positive = <span class="tok-null">true</span>,
            .limbs = a.limbs[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(a.limbs[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(a.limbs.len, max_limbs)])],
        };
        <span class="tok-kw">if</span> (same_sign_guess <span class="tok-kw">or</span> abs_trunc_a.eqlZero()) {<span class="tok-comment">
            // One of the following is true:
            //  * The result is zero.
            //  * The result is non-zero and has the same sign as `a`.
            </span>r.copy(abs_trunc_a);
            <span class="tok-kw">if</span> (max_limbs &lt;= r.len) r.limbs[max_limbs - <span class="tok-number">1</span>] &amp;= mask;
            r.normalize(r.len);
            r.positive = a.positive <span class="tok-kw">or</span> r.eqlZero();
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // One of the following is true:
            //  * The result is the minimum signed integer.
            //  * The result is unsigned zero.
            //  * The result is non-zero and has the opposite sign as `a`.
            </span>r.addScalar(abs_trunc_a, -<span class="tok-number">1</span>);
            <a href="std.math.big.int.html#std.math.big.int.llnot">llnot</a>(r.limbs[<span class="tok-number">0</span>..r.len]);
            <span class="tok-builtin">@memset</span>(r.limbs[r.len..max_limbs], <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
            r.limbs[max_limbs - <span class="tok-number">1</span>] &amp;= mask;
            r.normalize(max_limbs);
            r.positive = <span class="tok-kw">switch</span> (signedness) {<span class="tok-comment">
                // The only value with the sign bit still set is the minimum signed integer.
                </span>.signed =&gt; !a.positive <span class="tok-kw">and</span> r.limbs[max_limbs - <span class="tok-number">1</span>] &amp; sign_bit == <span class="tok-number">0</span>,
                .unsigned =&gt; !a.positive <span class="tok-kw">or</span> r.eqlZero(),
            };
        }
    }

    <span class="tok-comment">/// Saturate an integer to a number of bits, following 2s-complement semantics.</span>
    <span class="tok-comment">/// r may alias a.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts `r` has enough storage to store the result.</span>
    <span class="tok-comment">/// The upper bound is `calcTwosCompLimbCount(a.len)`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">saturate</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, a: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!a.fitsInTwosComp(signedness, bit_count)) {
            r.setTwosCompIntLimit(<span class="tok-kw">if</span> (r.positive) .max <span class="tok-kw">else</span> .min, signedness, bit_count);
        }
    }

    <span class="tok-comment">/// Read the value of `x` from `buffer`.</span>
    <span class="tok-comment">/// Asserts that `buffer` is large enough to contain a value of bit-size `bit_count`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The contents of `buffer` are interpreted as if they were the contents of</span>
    <span class="tok-comment">/// @ptrCast(*[buffer.len]const u8, &amp;x). Byte ordering is determined by `endian`</span>
    <span class="tok-comment">/// and any required padding bits are expected on the MSB end.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readTwosComplement</span>(
        x: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        bit_count: <span class="tok-type">usize</span>,
        endian: <a href="std.builtin.Endian.html">Endian</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.readPackedTwosComplement">readPackedTwosComplement</a>(x, buffer, <span class="tok-number">0</span>, bit_count, endian, signedness);
    }

    <span class="tok-comment">/// Read the value of `x` from a packed memory `buffer`.</span>
    <span class="tok-comment">/// Asserts that `buffer` is large enough to contain a value of bit-size `bit_count`</span>
    <span class="tok-comment">/// at offset `bit_offset`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This is equivalent to loading the value of an integer with `bit_count` bits as</span>
    <span class="tok-comment">/// if it were a field in packed memory at the provided bit offset.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readPackedTwosComplement</span>(
        x: *<a href="std.math.big.int.Mutable.html">Mutable</a>,
        buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        bit_offset: <span class="tok-type">usize</span>,
        bit_count: <span class="tok-type">usize</span>,
        endian: <a href="std.builtin.Endian.html">Endian</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
    ) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
            x.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            x.len = <span class="tok-number">1</span>;
            x.positive = <span class="tok-null">true</span>;
            <span class="tok-kw">return</span>;
        }<span class="tok-comment">

        // Check whether the input is negative
        </span><span class="tok-kw">var</span> positive = <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (signedness == .signed) {
            <span class="tok-kw">const</span> total_bits = bit_offset + bit_count;
            <span class="tok-kw">const</span> last_byte = <span class="tok-kw">switch</span> (endian) {
                .little =&gt; ((total_bits + <span class="tok-number">7</span>) / <span class="tok-number">8</span>) - <span class="tok-number">1</span>,
                .big =&gt; buffer.len - ((total_bits + <span class="tok-number">7</span>) / <span class="tok-number">8</span>),
            };

            <span class="tok-kw">const</span> sign_bit = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>((total_bits - <span class="tok-number">1</span>) % <span class="tok-number">8</span>));
            positive = ((buffer[last_byte] &amp; sign_bit) == <span class="tok-number">0</span>);
        }<span class="tok-comment">

        // Copy all complete limbs
        </span><span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> limb_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> bit_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (limb_index &lt; bit_count / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) : (limb_index += <span class="tok-number">1</span>) {<span class="tok-comment">
            // Read one Limb of bits
            </span><span class="tok-kw">var</span> limb = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, buffer, bit_index + bit_offset, endian);
            bit_index += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>);<span class="tok-comment">

            // 2's complement (bitwise not, then add carry bit)
            </span><span class="tok-kw">if</span> (!positive) {
                <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(~limb, carry);
                limb = ov[<span class="tok-number">0</span>];
                carry = ov[<span class="tok-number">1</span>];
            }
            x.limbs[limb_index] = limb;
        }<span class="tok-comment">

        // Copy the remaining bits
        </span><span class="tok-kw">if</span> (bit_count != bit_index) {<span class="tok-comment">
            // Read all remaining bits
            </span><span class="tok-kw">var</span> limb = <span class="tok-kw">switch</span> (signedness) {
                .unsigned =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, buffer, bit_index + bit_offset, bit_count - bit_index, endian, .unsigned),
                .signed =&gt; b: {
                    <span class="tok-kw">const</span> SLimb = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                    <span class="tok-kw">const</span> limb = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(SLimb, buffer, bit_index + bit_offset, bit_count - bit_index, endian, .signed);
                    <span class="tok-kw">break</span> :b <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@bitCast</span>(limb));
                },
            };<span class="tok-comment">

            // 2's complement (bitwise not, then add carry bit)
            </span><span class="tok-kw">if</span> (!positive) {
                <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(~limb, carry);
                <a href="std.debug.html#std.debug.assert">assert</a>(ov[<span class="tok-number">1</span>] == <span class="tok-number">0</span>);
                limb = ov[<span class="tok-number">0</span>];
            }
            x.limbs[limb_index] = limb;

            limb_index += <span class="tok-number">1</span>;
        }

        x.positive = positive;
        x.len = limb_index;
        x.normalize(x.len);
    }

    <span class="tok-comment">/// Normalize a possible sequence of leading zeros.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// [1, 2, 3, 4, 0] -&gt; [1, 2, 3, 4]</span>
    <span class="tok-comment">/// [1, 2, 0, 0, 0] -&gt; [1, 2]</span>
    <span class="tok-comment">/// [0, 0, 0, 0, 0] -&gt; [0]</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(r: *<a href="std.math.big.int.Mutable.html">Mutable</a>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        r.len = <a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(r.limbs[<span class="tok-number">0</span>..length]);
    }
};

<span class="tok-comment">/// A arbitrary-precision big integer, with a fixed set of immutable limbs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Const = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Raw digits. These are:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// * Little-endian ordered</span>
    <span class="tok-comment">/// * limbs.len &gt;= 1</span>
    <span class="tok-comment">/// * Zero is represented as limbs.len == 1 with limbs[0] == 0.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Accessing limbs directly should be avoided.</span>
    limbs: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    positive: <span class="tok-type">bool</span>,

    <span class="tok-comment">/// The result is an independent resource which is managed by the caller.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toManaged</span>(self: <a href="std.math.big.int.Const.html">Const</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@max</span>(<a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.default_capacity">default_capacity</a>, self.limbs.len));
        <span class="tok-builtin">@memcpy</span>(limbs[<span class="tok-number">0</span>..self.limbs.len], self.limbs);
        <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html">Managed</a>{
            .allocator = allocator,
            .limbs = limbs,
            .metadata = <span class="tok-kw">if</span> (self.positive)
                self.limbs.len &amp; ~<a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>
            <span class="tok-kw">else</span>
                self.limbs.len | <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>,
        };
    }

    <span class="tok-comment">/// Asserts `limbs` is big enough to store the value.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMutable</span>(self: <a href="std.math.big.int.Const.html">Const</a>, limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
        <span class="tok-builtin">@memcpy</span>(limbs[<span class="tok-number">0</span>..self.limbs.len], self.limbs[<span class="tok-number">0</span>..self.limbs.len]);
        <span class="tok-kw">return</span> .{
            .limbs = limbs,
            .positive = self.positive,
            .len = self.limbs.len,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.limbs.len]) |limb| {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{x} &quot;</span>, .{limb});
        }
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;positive={}\n&quot;</span>, .{self.positive});
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: <a href="std.math.big.int.Const.html">Const</a>) <a href="std.math.big.int.Const.html">Const</a> {
        <span class="tok-kw">return</span> .{
            .limbs = self.limbs,
            .positive = <span class="tok-null">true</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: <a href="std.math.big.int.Const.html">Const</a>) <a href="std.math.big.int.Const.html">Const</a> {
        <span class="tok-kw">return</span> .{
            .limbs = self.limbs,
            .positive = !self.positive,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(self: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.limbs[<span class="tok-number">0</span>] &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEven</span>(self: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> !self.isOdd();
    }

    <span class="tok-comment">/// Returns the number of bits required to represent the absolute value of an integer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountAbs</span>(self: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> (self.limbs.len - <span class="tok-number">1</span>) * <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> + (<a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - <span class="tok-builtin">@clz</span>(self.limbs[self.limbs.len - <span class="tok-number">1</span>]));
    }

    <span class="tok-comment">/// Returns the number of bits required to represent the integer in twos-complement form.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If the integer is negative the value returned is the number of bits needed by a signed</span>
    <span class="tok-comment">/// integer to represent the value. If positive the value is the number of bits for an</span>
    <span class="tok-comment">/// unsigned integer. Any unsigned integer will fit in the signed integer with bitcount</span>
    <span class="tok-comment">/// one greater than the returned value.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// e.g. -127 returns 8 as it will fit in an i8. 127 returns 7 since it fits in a u7.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountTwosComp</span>(self: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> bits = self.bitCountAbs();<span class="tok-comment">

        // If the entire value has only one bit set (e.g. 0b100000000) then the negation in twos
        // complement requires one less bit.
        </span><span class="tok-kw">if</span> (!self.positive) block: {
            bits += <span class="tok-number">1</span>;

            <span class="tok-kw">if</span> (<span class="tok-builtin">@popCount</span>(self.limbs[self.limbs.len - <span class="tok-number">1</span>]) == <span class="tok-number">1</span>) {
                <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span> .. self.limbs.len - <span class="tok-number">1</span>]) |limb| {
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@popCount</span>(limb) != <span class="tok-number">0</span>) {
                        <span class="tok-kw">break</span> :block;
                    }
                }

                bits -= <span class="tok-number">1</span>;
            }
        }

        <span class="tok-kw">return</span> bits;
    }

    <span class="tok-comment">/// Returns the number of bits required to represent the integer in twos-complement form</span>
    <span class="tok-comment">/// with the given signedness.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountTwosCompForSignedness</span>(self: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.bitCountTwosComp() + <span class="tok-builtin">@intFromBool</span>(self.positive <span class="tok-kw">and</span> signedness == .signed);
    }

    <span class="tok-comment">/// @popCount with two's complement semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This returns the number of 1 bits set when the value would be represented in</span>
    <span class="tok-comment">/// two's complement with the given integer width (bit_count).</span>
    <span class="tok-comment">/// This includes the leading sign bit, which will be set for negative values.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that bit_count is enough to represent value in two's compliment</span>
    <span class="tok-comment">/// and that the final result fits in a usize.</span>
    <span class="tok-comment">/// Asserts that there are no trailing empty limbs on the most significant end,</span>
    <span class="tok-comment">/// i.e. that limb count matches `calcLimbLen()` and zero is not negative.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(self: <a href="std.math.big.int.Const.html">Const</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (self.positive) {
            <span class="tok-kw">for</span> (self.limbs) |limb| {
                sum += <span class="tok-builtin">@popCount</span>(limb);
            }
        } <span class="tok-kw">else</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.fitsInTwosComp(.signed, bit_count));
            <a href="std.debug.html#std.debug.assert">assert</a>(self.limbs[self.limbs.len - <span class="tok-number">1</span>] != <span class="tok-number">0</span>);

            <span class="tok-kw">var</span> remaining_bits = bit_count;
            <span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
            <span class="tok-kw">var</span> add_res: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;<span class="tok-comment">

            // All but the most significant limb.
            </span><span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span> .. self.limbs.len - <span class="tok-number">1</span>]) |limb| {
                <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(~limb, carry);
                add_res = ov[<span class="tok-number">0</span>];
                carry = ov[<span class="tok-number">1</span>];
                sum += <span class="tok-builtin">@popCount</span>(add_res);
                remaining_bits -= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;<span class="tok-comment"> // Asserted not to underflow by fitsInTwosComp
            </span>}<span class="tok-comment">

            // The most significant limb may have fewer than @bitSizeOf(Limb) meaningful bits,
            // which we can detect with @clz().
            // There may also be fewer limbs than needed to fill bit_count.
            </span><span class="tok-kw">const</span> limb = self.limbs[self.limbs.len - <span class="tok-number">1</span>];
            <span class="tok-kw">const</span> leading_zeroes = <span class="tok-builtin">@clz</span>(limb);<span class="tok-comment">
            // The most significant limb is asserted not to be all 0s (above),
            // so ~limb cannot be all 1s, and ~limb + 1 cannot overflow.
            </span>sum += <span class="tok-builtin">@popCount</span>(~limb + carry);
            sum -= leading_zeroes;<span class="tok-comment"> // All leading zeroes were flipped and added to sum, so undo those
            </span><span class="tok-kw">const</span> remaining_ones = remaining_bits - (<a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - leading_zeroes);<span class="tok-comment"> // All bits not covered by limbs
            </span>sum += remaining_ones;
        }
        <span class="tok-kw">return</span> sum;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fitsInTwosComp</span>(self: <a href="std.math.big.int.Const.html">Const</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.eqlZero()) {
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }
        <span class="tok-kw">if</span> (signedness == .unsigned <span class="tok-kw">and</span> !self.positive) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
        <span class="tok-kw">return</span> bit_count &gt;= self.bitCountTwosCompForSignedness(signedness);
    }

    <span class="tok-comment">/// Returns whether self can fit into an integer of the requested type.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fits</span>(self: <a href="std.math.big.int.Const.html">Const</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
        <span class="tok-kw">return</span> self.fitsInTwosComp(info.signedness, info.bits);
    }

    <span class="tok-comment">/// Returns the approximate size of the integer in the given base. Negative values accommodate for</span>
    <span class="tok-comment">/// the minus sign. This is used for determining the number of characters needed to print the</span>
    <span class="tok-comment">/// value. It is inexact and may exceed the given value by ~1-2 bytes.</span>
    <span class="tok-comment">/// TODO See if we can make this exact.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sizeInBaseUpperBound</span>(self: <a href="std.math.big.int.Const.html">Const</a>, base: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> bit_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromBool</span>(!self.positive)) + self.bitCountAbs();
        <span class="tok-kw">return</span> (bit_count / <a href="std.math.html">math</a>.<a href="std.math.log2.html#std.math.log2.log2">log2</a>(base)) + <span class="tok-number">2</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConvertError = <span class="tok-kw">error</span>{
        NegativeIntoUnsigned,
        TargetTooSmall,
    };

    <span class="tok-comment">/// Deprecated; use `toInt`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> to = <a href="std.math.big.int.Const.html#std.math.big.int.Const.toInt">toInt</a>;

    <span class="tok-comment">/// Convert self to integer type T.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if self cannot be narrowed into the requested type without truncation.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInt</span>(self: <a href="std.math.big.int.Const.html">Const</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>!T {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            .int =&gt; |info| {<span class="tok-comment">
                // Make sure -0 is handled correctly.
                </span><span class="tok-kw">if</span> (self.eqlZero()) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

                <span class="tok-kw">const</span> UT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);

                <span class="tok-kw">if</span> (!self.fitsInTwosComp(info.signedness, info.bits)) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TargetTooSmall;
                }

                <span class="tok-kw">var</span> r: UT = <span class="tok-number">0</span>;

                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(UT) &lt;= <span class="tok-builtin">@sizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) {
                    r = <span class="tok-builtin">@as</span>(UT, <span class="tok-builtin">@intCast</span>(self.limbs[<span class="tok-number">0</span>]));
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.limbs.len], <span class="tok-number">0</span>..) |_, ri| {
                        <span class="tok-kw">const</span> limb = self.limbs[self.limbs.len - ri - <span class="tok-number">1</span>];
                        r &lt;&lt;= <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
                        r |= limb;
                    }
                }

                <span class="tok-kw">if</span> (info.signedness == .unsigned) {
                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.positive) <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>(r)) <span class="tok-kw">else</span> <span class="tok-kw">error</span>.NegativeIntoUnsigned;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">if</span> (self.positive) {
                        <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(r);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">if</span> (<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(T, r)) |ok| {
                            <span class="tok-kw">return</span> -ok;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">return</span> <a href="std.math.html#std.math.minInt">minInt</a>(T);
                        }
                    }
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected int type, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>),
        }
    }

    <span class="tok-comment">/// Convert self to float type T.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toFloat</span>(self: <a href="std.math.big.int.Const.html">Const</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
        <span class="tok-kw">if</span> (self.limbs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

        <span class="tok-kw">const</span> base = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>) + <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> result: <span class="tok-type">f128</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = self.limbs.len;
        <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
            i -= <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> limb: <span class="tok-type">f128</span> = <span class="tok-builtin">@floatFromInt</span>(self.limbs[i]);
            result = <span class="tok-builtin">@mulAdd</span>(<span class="tok-type">f128</span>, base, result, limb);
        }
        <span class="tok-kw">if</span> (self.positive) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@floatCast</span>(result);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@floatCast</span>(-result);
        }
    }

    <span class="tok-comment">/// To allow `std.fmt.format` to work with this type.</span>
    <span class="tok-comment">/// If the absolute value of integer is greater than or equal to `pow(2, 64 * @sizeOf(usize) * 8)`,</span>
    <span class="tok-comment">/// this function will fail to print the string, printing &quot;(BigInt)&quot; instead of a number.</span>
    <span class="tok-comment">/// This is because the rendering algorithm requires reversing a string, which requires O(N) memory.</span>
    <span class="tok-comment">/// See `toString` and `toStringAlloc` for a way to print big integers without failure.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.math.big.int.Const.html">Const</a>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        out_stream: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        _ = options;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> base = <span class="tok-number">10</span>;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> case: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.Case.html">Case</a> = .lower;

        <span class="tok-kw">if</span> (fmt.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> <span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, fmt, <span class="tok-str">&quot;d&quot;</span>)) {
            base = <span class="tok-number">10</span>;
            case = .lower;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, fmt, <span class="tok-str">&quot;b&quot;</span>)) {
            base = <span class="tok-number">2</span>;
            case = .lower;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, fmt, <span class="tok-str">&quot;x&quot;</span>)) {
            base = <span class="tok-number">16</span>;
            case = .lower;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, fmt, <span class="tok-str">&quot;X&quot;</span>)) {
            base = <span class="tok-number">16</span>;
            case = .upper;
        } <span class="tok-kw">else</span> {
            <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.invalidFmtError">invalidFmtError</a>(fmt, self);
        }

        <span class="tok-kw">const</span> available_len = <span class="tok-number">64</span>;
        <span class="tok-kw">if</span> (self.limbs.len &gt; available_len)
            <span class="tok-kw">return</span> out_stream.writeAll(<span class="tok-str">&quot;(BigInt)&quot;</span>);

        <span class="tok-kw">var</span> limbs: [<a href="std.math.big.int.html#std.math.big.int.calcToStringLimbsBufferLen">calcToStringLimbsBufferLen</a>(available_len, base)]<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">const</span> biggest: <a href="std.math.big.int.Const.html">Const</a> = .{
            .limbs = &amp;([<span class="tok-number">1</span>]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{<span class="tok-kw">comptime</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)} ** available_len),
            .positive = <span class="tok-null">false</span>,
        };
        <span class="tok-kw">var</span> buf: [biggest.sizeInBaseUpperBound(base)]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> len = self.toString(&amp;buf, base, case, &amp;limbs);
        <span class="tok-kw">return</span> out_stream.writeAll(buf[<span class="tok-number">0</span>..len]);
    }

    <span class="tok-comment">/// Converts self to a string in the requested base.</span>
    <span class="tok-comment">/// Caller owns returned memory.</span>
    <span class="tok-comment">/// Asserts that `base` is in the range [2, 36].</span>
    <span class="tok-comment">/// See also `toString`, a lower level function than this.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toStringAlloc</span>(self: <a href="std.math.big.int.Const.html">Const</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base: <span class="tok-type">u8</span>, case: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.Case.html">Case</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-type">u8</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(base &gt;= <span class="tok-number">2</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(base &lt;= <span class="tok-number">36</span>);

        <span class="tok-kw">if</span> (self.eqlZero()) {
            <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-str">&quot;0&quot;</span>);
        }
        <span class="tok-kw">const</span> string = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, self.sizeInBaseUpperBound(base));
        <span class="tok-kw">errdefer</span> allocator.free(string);

        <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcToStringLimbsBufferLen">calcToStringLimbsBufferLen</a>(self.limbs.len, base));
        <span class="tok-kw">defer</span> allocator.free(limbs);

        <span class="tok-kw">return</span> allocator.realloc(string, self.toString(string, base, case, limbs));
    }

    <span class="tok-comment">/// Converts self to a string in the requested base.</span>
    <span class="tok-comment">/// Asserts that `base` is in the range [2, 36].</span>
    <span class="tok-comment">/// `string` is a caller-provided slice of at least `sizeInBaseUpperBound` bytes,</span>
    <span class="tok-comment">/// where the result is written to.</span>
    <span class="tok-comment">/// Returns the length of the string.</span>
    <span class="tok-comment">/// `limbs_buffer` is caller-provided memory for `toString` to use as a working area. It must have</span>
    <span class="tok-comment">/// length of at least `calcToStringLimbsBufferLen`.</span>
    <span class="tok-comment">/// In the case of power-of-two base, `limbs_buffer` is ignored.</span>
    <span class="tok-comment">/// See also `toStringAlloc`, a higher level function than this.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toString</span>(self: <a href="std.math.big.int.Const.html">Const</a>, string: []<span class="tok-type">u8</span>, base: <span class="tok-type">u8</span>, case: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.Case.html">Case</a>, limbs_buffer: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">usize</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(base &gt;= <span class="tok-number">2</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(base &lt;= <span class="tok-number">36</span>);

        <span class="tok-kw">if</span> (self.eqlZero()) {
            string[<span class="tok-number">0</span>] = <span class="tok-str">'0'</span>;
            <span class="tok-kw">return</span> <span class="tok-number">1</span>;
        }

        <span class="tok-kw">var</span> digits_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;<span class="tok-comment">

        // Power of two: can do a single pass and use masks to extract digits.
        </span><span class="tok-kw">if</span> (<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(base)) {
            <span class="tok-kw">const</span> base_shift = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int">log2_int</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, base);

            outer: <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.limbs.len]) |limb| {
                <span class="tok-kw">var</span> shift: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (shift &lt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) : (shift += base_shift) {
                    <span class="tok-kw">const</span> r = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>((limb &gt;&gt; <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@intCast</span>(shift))) &amp; <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, base - <span class="tok-number">1</span>)));
                    <span class="tok-kw">const</span> ch = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.digitToChar">digitToChar</a>(r, case);
                    string[digits_len] = ch;
                    digits_len += <span class="tok-number">1</span>;<span class="tok-comment">
                    // If we hit the end, it must be all zeroes from here.
                    </span><span class="tok-kw">if</span> (digits_len == string.len) <span class="tok-kw">break</span> :outer;
                }
            }<span class="tok-comment">

            // Always will have a non-zero digit somewhere.
            </span><span class="tok-kw">while</span> (string[digits_len - <span class="tok-number">1</span>] == <span class="tok-str">'0'</span>) {
                digits_len -= <span class="tok-number">1</span>;
            }
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // Non power-of-two: batch divisions per word size.
            // We use a HalfLimb here so the division uses the faster lldiv0p5 over lldiv1 codepath.
            </span><span class="tok-kw">const</span> digits_per_limb = <a href="std.math.html">math</a>.<a href="std.math.log.html#std.math.log.log">log</a>(<a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>, base, <a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>));
            <span class="tok-kw">var</span> limb_base: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">1</span>;
            <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (j &lt; digits_per_limb) : (j += <span class="tok-number">1</span>) {
                limb_base *= base;
            }
            <span class="tok-kw">const</span> b: <a href="std.math.big.int.Const.html">Const</a> = .{ .limbs = &amp;[_]<a href="std.math.big.html#std.math.big.Limb">Limb</a>{limb_base}, .positive = <span class="tok-null">true</span> };

            <span class="tok-kw">var</span> q: <a href="std.math.big.int.Mutable.html">Mutable</a> = .{
                .limbs = limbs_buffer[<span class="tok-number">0</span> .. self.limbs.len + <span class="tok-number">2</span>],
                .positive = <span class="tok-null">true</span>,<span class="tok-comment"> // Make absolute by ignoring self.positive.
                </span>.len = self.limbs.len,
            };
            <span class="tok-builtin">@memcpy</span>(q.limbs[<span class="tok-number">0</span>..self.limbs.len], self.limbs);

            <span class="tok-kw">var</span> r: <a href="std.math.big.int.Mutable.html">Mutable</a> = .{
                .limbs = limbs_buffer[q.limbs.len..][<span class="tok-number">0</span>..self.limbs.len],
                .positive = <span class="tok-null">true</span>,
                .len = <span class="tok-number">1</span>,
            };
            r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;

            <span class="tok-kw">const</span> rest_of_the_limbs_buf = limbs_buffer[q.limbs.len + r.limbs.len ..];

            <span class="tok-kw">while</span> (q.len &gt;= <span class="tok-number">2</span>) {<span class="tok-comment">
                // Passing an allocator here would not be helpful since this division is destroying
                // information, not creating it. [TODO citation needed]
                </span>q.divTrunc(&amp;r, q.toConst(), b, rest_of_the_limbs_buf);

                <span class="tok-kw">var</span> r_word = r.limbs[<span class="tok-number">0</span>];
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (i &lt; digits_per_limb) : (i += <span class="tok-number">1</span>) {
                    <span class="tok-kw">const</span> ch = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.digitToChar">digitToChar</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(r_word % base)), case);
                    r_word /= base;
                    string[digits_len] = ch;
                    digits_len += <span class="tok-number">1</span>;
                }
            }

            {
                <a href="std.debug.html#std.debug.assert">assert</a>(q.len == <span class="tok-number">1</span>);

                <span class="tok-kw">var</span> r_word = q.limbs[<span class="tok-number">0</span>];
                <span class="tok-kw">while</span> (r_word != <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> ch = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.digitToChar">digitToChar</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(r_word % base)), case);
                    r_word /= base;
                    string[digits_len] = ch;
                    digits_len += <span class="tok-number">1</span>;
                }
            }
        }

        <span class="tok-kw">if</span> (!self.positive) {
            string[digits_len] = <span class="tok-str">'-'</span>;
            digits_len += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">const</span> s = string[<span class="tok-number">0</span>..digits_len];
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.reverse">reverse</a>(<span class="tok-type">u8</span>, s);
        <span class="tok-kw">return</span> s.len;
    }

    <span class="tok-comment">/// Write the value of `x` into `buffer`</span>
    <span class="tok-comment">/// Asserts that `buffer` is large enough to store the value.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `buffer` is filled so that its contents match what would be observed via</span>
    <span class="tok-comment">/// @ptrCast(*[buffer.len]const u8, &amp;x). Byte ordering is determined by `endian`,</span>
    <span class="tok-comment">/// and any required padding bits are added on the MSB end.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeTwosComplement</span>(x: <a href="std.math.big.int.Const.html">Const</a>, buffer: []<span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Const.html#std.math.big.int.Const.writePackedTwosComplement">writePackedTwosComplement</a>(x, buffer, <span class="tok-number">0</span>, <span class="tok-number">8</span> * buffer.len, endian);
    }

    <span class="tok-comment">/// Write the value of `x` to a packed memory `buffer`.</span>
    <span class="tok-comment">/// Asserts that `buffer` is large enough to contain a value of bit-size `bit_count`</span>
    <span class="tok-comment">/// at offset `bit_offset`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This is equivalent to storing the value of an integer with `bit_count` bits as</span>
    <span class="tok-comment">/// if it were a field in packed memory at the provided bit offset.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePackedTwosComplement</span>(x: <a href="std.math.big.int.Const.html">Const</a>, buffer: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, bit_count: <span class="tok-type">usize</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(x.fitsInTwosComp(<span class="tok-kw">if</span> (x.positive) .unsigned <span class="tok-kw">else</span> .signed, bit_count));<span class="tok-comment">

        // Copy all complete limbs
        </span><span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> limb_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> bit_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (limb_index &lt; bit_count / <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) : (limb_index += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> limb: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-kw">if</span> (limb_index &lt; x.limbs.len) x.limbs[limb_index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;<span class="tok-comment">

            // 2's complement (bitwise not, then add carry bit)
            </span><span class="tok-kw">if</span> (!x.positive) {
                <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(~limb, carry);
                limb = ov[<span class="tok-number">0</span>];
                carry = ov[<span class="tok-number">1</span>];
            }<span class="tok-comment">

            // Write one Limb of bits
            </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, buffer, bit_index + bit_offset, limb, endian);
            bit_index += <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>);
        }<span class="tok-comment">

        // Copy the remaining bits
        </span><span class="tok-kw">if</span> (bit_count != bit_index) {
            <span class="tok-kw">var</span> limb: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-kw">if</span> (limb_index &lt; x.limbs.len) x.limbs[limb_index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;<span class="tok-comment">

            // 2's complement (bitwise not, then add carry bit)
            </span><span class="tok-kw">if</span> (!x.positive) limb = ~limb +% carry;<span class="tok-comment">

            // Write all remaining bits
            </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeVarPackedInt">writeVarPackedInt</a>(buffer, bit_index + bit_offset, bit_count - bit_index, limb, endian);
        }
    }

    <span class="tok-comment">/// Returns `math.Order.lt`, `math.Order.eq`, `math.Order.gt` if</span>
    <span class="tok-comment">/// `|a| &lt; |b|`, `|a| == |b|`, or `|a| &gt; |b|` respectively.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderAbs</span>(a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
        <span class="tok-kw">if</span> (a.limbs.len &lt; b.limbs.len) {
            <span class="tok-kw">return</span> .lt;
        }
        <span class="tok-kw">if</span> (a.limbs.len &gt; b.limbs.len) {
            <span class="tok-kw">return</span> .gt;
        }

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = a.limbs.len - <span class="tok-number">1</span>;
        <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) : (i -= <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (a.limbs[i] != b.limbs[i]) {
                <span class="tok-kw">break</span>;
            }
        }

        <span class="tok-kw">if</span> (a.limbs[i] &lt; b.limbs[i]) {
            <span class="tok-kw">return</span> .lt;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.limbs[i] &gt; b.limbs[i]) {
            <span class="tok-kw">return</span> .gt;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> .eq;
        }
    }

    <span class="tok-comment">/// Returns `math.Order.lt`, `math.Order.eq`, `math.Order.gt` if `a &lt; b`, `a == b` or `a &gt; b` respectively.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
        <span class="tok-kw">if</span> (a.positive != b.positive) {
            <span class="tok-kw">if</span> (<a href="std.math.big.int.Const.html#std.math.big.int.Const.eqlZero">eqlZero</a>(a) <span class="tok-kw">and</span> <a href="std.math.big.int.Const.html#std.math.big.int.Const.eqlZero">eqlZero</a>(b)) {
                <span class="tok-kw">return</span> .eq;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a.positive) .gt <span class="tok-kw">else</span> .lt;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> r = <a href="std.math.big.int.Const.html#std.math.big.int.Const.orderAbs">orderAbs</a>(a, b);
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a.positive) r <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (r) {
                .lt =&gt; <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>.<a href="#">gt</a>,
                .eq =&gt; <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>.<a href="#">eq</a>,
                .gt =&gt; <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>.<a href="#">lt</a>,
            };
        }
    }

    <span class="tok-comment">/// Same as `order` but the right-hand operand is a primitive integer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderAgainstScalar</span>(lhs: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {<span class="tok-comment">
        // Normally we could just determine the number of limbs needed with calcLimbLen,
        // but that is not comptime-known when scalar is not a comptime_int.  Instead, we
        // use calcTwosCompLimbCount for a non-comptime_int scalar, which can be pessimistic
        // in the case that scalar happens to be small in magnitude within its type, but it
        // is well worth being able to use the stack and not needing an allocator passed in.
        // Note that Mutable.init still sets len to calcLimbLen(scalar) in any case.
        </span><span class="tok-kw">const</span> limb_len = <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(scalar))) {
            .<span class="tok-type">comptime_int</span> =&gt; <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(scalar),
            .int =&gt; |info| <a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(info.bits),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected scalar to be an int&quot;</span>),
        };
        <span class="tok-kw">var</span> limbs: [limb_len]<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> rhs = <a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(&amp;limbs, scalar);
        <span class="tok-kw">return</span> <a href="std.math.big.int.Const.html#std.math.big.int.Const.order">order</a>(lhs, rhs.toConst());
    }

    <span class="tok-comment">/// Returns true if `a == 0`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(a: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">var</span> d: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (a.limbs) |limb| d |= limb;
        <span class="tok-kw">return</span> d == <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Returns true if `|a| == |b|`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlAbs</span>(a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Const.html#std.math.big.int.Const.orderAbs">orderAbs</a>(a, b) == .eq;
    }

    <span class="tok-comment">/// Returns true if `a == b`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Const.html#std.math.big.int.Const.order">order</a>(a, b) == .eq;
    }

    <span class="tok-comment">/// Returns the number of leading zeros in twos-complement form.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clz</span>(a: <a href="std.math.big.int.Const.html">Const</a>, bits: <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.html#std.math.big.Limb">Limb</a> {<span class="tok-comment">
        // Limbs are stored in little-endian order but we need to iterate big-endian.
        </span><span class="tok-kw">if</span> (!a.positive <span class="tok-kw">and</span> !a.eqlZero()) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> total_limb_lz: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = a.limbs.len;
        <span class="tok-kw">const</span> bits_per_limb = <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>);
        <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
            i -= <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> this_limb_lz = <span class="tok-builtin">@clz</span>(a.limbs[i]);
            total_limb_lz += this_limb_lz;
            <span class="tok-kw">if</span> (this_limb_lz != bits_per_limb) <span class="tok-kw">break</span>;
        }
        <span class="tok-kw">const</span> total_limb_bits = a.limbs.len * bits_per_limb;
        <span class="tok-kw">return</span> total_limb_lz + bits - total_limb_bits;
    }

    <span class="tok-comment">/// Returns the number of trailing zeros in twos-complement form.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ctz</span>(a: <a href="std.math.big.int.Const.html">Const</a>, bits: <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.html#std.math.big.Limb">Limb</a> {<span class="tok-comment">
        // Limbs are stored in little-endian order. Converting a negative number to twos-complement
        // flips all bits above the lowest set bit, which does not affect the trailing zero count.
        </span><span class="tok-kw">if</span> (a.eqlZero()) <span class="tok-kw">return</span> bits;
        <span class="tok-kw">var</span> result: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (a.limbs) |limb| {
            <span class="tok-kw">const</span> limb_tz = <span class="tok-builtin">@ctz</span>(limb);
            result += limb_tz;
            <span class="tok-kw">if</span> (limb_tz != <span class="tok-builtin">@bitSizeOf</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <span class="tok-kw">break</span>;
        }
        <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(result, bits);
    }
};

<span class="tok-comment">/// An arbitrary-precision big integer along with an allocator which manages the memory.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Memory is allocated as needed to ensure operations never overflow. The range</span>
<span class="tok-comment">/// is bounded only by available memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> sign_bit: <span class="tok-type">usize</span> = <span class="tok-number">1</span> &lt;&lt; (<span class="tok-builtin">@typeInfo</span>(<span class="tok-type">usize</span>).int.bits - <span class="tok-number">1</span>);

    <span class="tok-comment">/// Default number of limbs to allocate on creation of a `Managed`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_capacity = <span class="tok-number">4</span>;

    <span class="tok-comment">/// Allocator used by the Managed when requesting memory.</span>
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,

    <span class="tok-comment">/// Raw digits. These are:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// * Little-endian ordered</span>
    <span class="tok-comment">/// * limbs.len &gt;= 1</span>
    <span class="tok-comment">/// * Zero is represent as Managed.len() == 1 with limbs[0] == 0.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Accessing limbs directly should be avoided.</span>
    limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,

    <span class="tok-comment">/// High bit is the sign bit. If set, Managed is negative, else Managed is positive.</span>
    <span class="tok-comment">/// The remaining bits represent the number of limbs used by Managed.</span>
    metadata: <span class="tok-type">usize</span>,

    <span class="tok-comment">/// Creates a new `Managed`. `default_capacity` limbs will be allocated immediately.</span>
    <span class="tok-comment">/// The integer value after initializing is `0`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(allocator, <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.default_capacity">default_capacity</a>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMutable</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
        <span class="tok-kw">return</span> .{
            .limbs = self.limbs,
            .positive = self.isPositive(),
            .len = self.len(),
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.big.int.Const.html">Const</a> {
        <span class="tok-kw">return</span> .{
            .limbs = self.limbs[<span class="tok-number">0</span>..self.len()],
            .positive = self.isPositive(),
        };
    }

    <span class="tok-comment">/// Creates a new `Managed` with value `value`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This is identical to an `init`, followed by a `set`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initSet</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, value: <span class="tok-kw">anytype</span>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">var</span> s = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.init">init</a>(allocator);
        <span class="tok-kw">errdefer</span> s.deinit();
        <span class="tok-kw">try</span> s.set(value);
        <span class="tok-kw">return</span> s;
    }

    <span class="tok-comment">/// Creates a new Managed with a specific capacity. If capacity &lt; default_capacity then the</span>
    <span class="tok-comment">/// default capacity will be used instead.</span>
    <span class="tok-comment">/// The integer value after initializing is `0`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initCapacity</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, capacity: <span class="tok-type">usize</span>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html">Managed</a>{
            .allocator = allocator,
            .metadata = <span class="tok-number">1</span>,
            .limbs = block: {
                <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@max</span>(<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.default_capacity">default_capacity</a>, capacity));
                limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
                <span class="tok-kw">break</span> :block limbs;
            },
        };
    }

    <span class="tok-comment">/// Returns the number of limbs currently in use.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.metadata &amp; ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }

    <span class="tok-comment">/// Returns whether an Managed is positive.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isPositive</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.metadata &amp; <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a> == <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Sets the sign of an Managed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setSign</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, positive: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (positive) {
            self.metadata &amp;= ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
        } <span class="tok-kw">else</span> {
            self.metadata |= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
        }
    }

    <span class="tok-comment">/// Sets the length of an Managed.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If setLen is used, then the Managed must be normalized to suit.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLen</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        self.metadata &amp;= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
        self.metadata |= new_len;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setMetadata</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, positive: <span class="tok-type">bool</span>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        self.metadata = <span class="tok-kw">if</span> (positive) length &amp; ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a> <span class="tok-kw">else</span> length | <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }

    <span class="tok-comment">/// Ensures an Managed has enough space allocated for capacity limbs. If the Managed does not have</span>
    <span class="tok-comment">/// sufficient capacity, the exact amount will be allocated. This occurs even if the requested</span>
    <span class="tok-comment">/// capacity is only greater than the current capacity by one limb.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureCapacity</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (capacity &lt;= self.limbs.len) {
            <span class="tok-kw">return</span>;
        }
        self.limbs = <span class="tok-kw">try</span> self.allocator.realloc(self.limbs, capacity);
    }

    <span class="tok-comment">/// Frees all associated memory.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        self.allocator.free(self.limbs);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-comment">/// Returns a `Managed` with the same value. The returned `Managed` is a deep copy and</span>
    <span class="tok-comment">/// can be modified separately from the original, and its resources are managed</span>
    <span class="tok-comment">/// separately from the original.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(other: <a href="std.math.big.int.Managed.html">Managed</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> other.cloneWithDifferentAllocator(other.allocator);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithDifferentAllocator</span>(other: <a href="std.math.big.int.Managed.html">Managed</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.math.big.int.Managed.html">Managed</a> {
        <span class="tok-kw">return</span> <a href="std.math.big.int.Managed.html">Managed</a>{
            .allocator = allocator,
            .metadata = other.metadata,
            .limbs = block: {
                <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, other.len());
                <span class="tok-builtin">@memcpy</span>(limbs, other.limbs[<span class="tok-number">0</span>..other.len()]);
                <span class="tok-kw">break</span> :block limbs;
            },
        };
    }

    <span class="tok-comment">/// Copies the value of the integer to an existing `Managed` so that they both have the same value.</span>
    <span class="tok-comment">/// Extra memory will be allocated if the receiver does not have enough capacity.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, other: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.limbs.ptr == other.limbs.ptr) <span class="tok-kw">return</span>;

        <span class="tok-kw">try</span> self.ensureCapacity(other.limbs.len);
        <span class="tok-builtin">@memcpy</span>(self.limbs[<span class="tok-number">0</span>..other.limbs.len], other.limbs[<span class="tok-number">0</span>..other.limbs.len]);
        self.setMetadata(other.positive, other.limbs.len);
    }

    <span class="tok-comment">/// Efficiently swap a `Managed` with another. This swaps the limb pointers and a full copy is not</span>
    <span class="tok-comment">/// performed. The address of the limbs field will not be the same after this function.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, other: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.math.big.int.Managed.html">Managed</a>, self, other);
    }

    <span class="tok-comment">/// Debugging tool: prints the state to stderr.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">for</span> (self.limbs[<span class="tok-number">0</span>..self.len()]) |limb| {
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{x} &quot;</span>, .{limb});
        }
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;capacity={} positive={}\n&quot;</span>, .{ self.limbs.len, self.isPositive() });
    }

    <span class="tok-comment">/// Negate the sign.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negate</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        self.metadata ^= <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }

    <span class="tok-comment">/// Make positive.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abs</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">void</span> {
        self.metadata &amp;= ~<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.sign_bit">sign_bit</a>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.limbs[<span class="tok-number">0</span>] &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEven</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> !self.isOdd();
    }

    <span class="tok-comment">/// Returns the number of bits required to represent the absolute value of an integer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountAbs</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.toConst().bitCountAbs();
    }

    <span class="tok-comment">/// Returns the number of bits required to represent the integer in twos-complement form.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If the integer is negative the value returned is the number of bits needed by a signed</span>
    <span class="tok-comment">/// integer to represent the value. If positive the value is the number of bits for an</span>
    <span class="tok-comment">/// unsigned integer. Any unsigned integer will fit in the signed integer with bitcount</span>
    <span class="tok-comment">/// one greater than the returned value.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// e.g. -127 returns 8 as it will fit in an i8. 127 returns 7 since it fits in a u7.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitCountTwosComp</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.toConst().bitCountTwosComp();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fitsInTwosComp</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.toConst().fitsInTwosComp(signedness, bit_count);
    }

    <span class="tok-comment">/// Returns whether self can fit into an integer of the requested type.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fits</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.toConst().fits(T);
    }

    <span class="tok-comment">/// Returns the approximate size of the integer in the given base. Negative values accommodate for</span>
    <span class="tok-comment">/// the minus sign. This is used for determining the number of characters needed to print the</span>
    <span class="tok-comment">/// value. It is inexact and may exceed the given value by ~1-2 bytes.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sizeInBaseUpperBound</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, base: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> self.toConst().sizeInBaseUpperBound(base);
    }

    <span class="tok-comment">/// Sets an Managed to value. Value must be an primitive integer type.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> self.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(value));
        <span class="tok-kw">var</span> m = self.toMutable();
        m.set(value);
        self.setMetadata(m.positive, m.len);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ConvertError = <a href="std.math.big.int.Const.html">Const</a>.<a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>;

    <span class="tok-comment">/// Deprecated; use `toInt`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> to = <a href="std.math.big.int.Managed.html#std.math.big.int.Managed.toInt">toInt</a>;

    <span class="tok-comment">/// Convert self to integer type T.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if self cannot be narrowed into the requested type without truncation.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInt</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.math.big.int.Const.html#std.math.big.int.Const.ConvertError">ConvertError</a>!T {
        <span class="tok-kw">return</span> self.toConst().toInt(T);
    }

    <span class="tok-comment">/// Convert self to float type T.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toFloat</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
        <span class="tok-kw">return</span> self.toConst().toFloat(T);
    }

    <span class="tok-comment">/// Set self from the string representation `value`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `value` must contain only digits &lt;= `base` and is case insensitive.  Base prefixes are</span>
    <span class="tok-comment">/// not allowed (e.g. 0x43 should simply be 43).  Underscores in the input string are</span>
    <span class="tok-comment">/// ignored and can be used as digit separators.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated or `value` has invalid digits for the</span>
    <span class="tok-comment">/// requested base.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// self's allocator is used for temporary storage to boost multiplication performance.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setString</span>(self: *<a href="std.math.big.int.Managed.html">Managed</a>, base: <span class="tok-type">u8</span>, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (base &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> base &gt; <span class="tok-number">36</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBase;
        <span class="tok-kw">try</span> self.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcSetStringLimbCount">calcSetStringLimbCount</a>(base, value.len));
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> self.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcSetStringLimbsBufferLen">calcSetStringLimbsBufferLen</a>(base, value.len));
        <span class="tok-kw">defer</span> self.allocator.free(limbs_buffer);
        <span class="tok-kw">var</span> m = self.toMutable();
        <span class="tok-kw">try</span> m.setString(base, value, limbs_buffer, self.allocator);
        self.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// Set self to either bound of a 2s-complement integer.</span>
    <span class="tok-comment">/// Note: The result is still sign-magnitude, not twos complement! In order to convert the</span>
    <span class="tok-comment">/// result to twos complement, it is sufficient to take the absolute value.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setTwosCompIntLimit</span>(
        r: *<a href="std.math.big.int.Managed.html">Managed</a>,
        limit: <a href="std.math.big.int.TwosCompIntLimit.html">TwosCompIntLimit</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.setTwosCompIntLimit(limit, signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// Converts self to a string in the requested base. Memory is allocated from the provided</span>
    <span class="tok-comment">/// allocator and not the one present in self.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toString</span>(self: <a href="std.math.big.int.Managed.html">Managed</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, base: <span class="tok-type">u8</span>, case: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.Case.html">Case</a>) ![]<span class="tok-type">u8</span> {
        <span class="tok-kw">if</span> (base &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> base &gt; <span class="tok-number">36</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidBase;
        <span class="tok-kw">return</span> self.toConst().toStringAlloc(allocator, base, case);
    }

    <span class="tok-comment">/// To allow `std.fmt.format` to work with `Managed`.</span>
    <span class="tok-comment">/// If the absolute value of integer is greater than or equal to `pow(2, 64 * @sizeOf(usize) * 8)`,</span>
    <span class="tok-comment">/// this function will fail to print the string, printing &quot;(BigInt)&quot; instead of a number.</span>
    <span class="tok-comment">/// This is because the rendering algorithm requires reversing a string, which requires O(N) memory.</span>
    <span class="tok-comment">/// See `toString` and `toStringAlloc` for a way to print big integers without failure.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.math.big.int.Managed.html">Managed</a>,
        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        out_stream: <span class="tok-kw">anytype</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">return</span> self.toConst().format(fmt, options, out_stream);
    }

    <span class="tok-comment">/// Returns math.Order.lt, math.Order.eq, math.Order.gt if |a| &lt; |b|, |a| ==</span>
    <span class="tok-comment">/// |b| or |a| &gt; |b| respectively.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderAbs</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
        <span class="tok-kw">return</span> a.toConst().orderAbs(b.toConst());
    }

    <span class="tok-comment">/// Returns math.Order.lt, math.Order.eq, math.Order.gt if a &lt; b, a == b or a &gt; b</span>
    <span class="tok-comment">/// respectively.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
        <span class="tok-kw">return</span> a.toConst().order(b.toConst());
    }

    <span class="tok-comment">/// Returns true if a == 0.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlZero</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> a.toConst().eqlZero();
    }

    <span class="tok-comment">/// Returns true if |a| == |b|.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlAbs</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> a.toConst().eqlAbs(b.toConst());
    }

    <span class="tok-comment">/// Returns true if a == b.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <a href="std.math.big.int.Managed.html">Managed</a>, b: <a href="std.math.big.int.Managed.html">Managed</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> a.toConst().eql(b.toConst());
    }

    <span class="tok-comment">/// Normalize a possible sequence of leading zeros.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// [1, 2, 3, 4, 0] -&gt; [1, 2, 3, 4]</span>
    <span class="tok-comment">/// [1, 2, 0, 0, 0] -&gt; [1, 2]</span>
    <span class="tok-comment">/// [0, 0, 0, 0, 0] -&gt; [0]</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, length: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(length &gt; <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(length &lt;= r.limbs.len);

        <span class="tok-kw">var</span> j = length;
        <span class="tok-kw">while</span> (j &gt; <span class="tok-number">0</span>) : (j -= <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (r.limbs[j - <span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
                <span class="tok-kw">break</span>;
            }
        }<span class="tok-comment">

        // Handle zero
        </span>r.setLen(<span class="tok-kw">if</span> (j != <span class="tok-number">0</span>) j <span class="tok-kw">else</span> <span class="tok-number">1</span>);
    }

    <span class="tok-comment">/// r = a + scalar</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addScalar</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, scalar: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureAddScalarCapacity(a.toConst(), scalar);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.addScalar(a.toConst(), scalar);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a + b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureAddCapacity(a.toConst(), b.toConst());
        <span class="tok-kw">var</span> m = r.toMutable();
        m.add(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a + b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWrap</span>(
        r: *<a href="std.math.big.int.Managed.html">Managed</a>,
        a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        <span class="tok-kw">const</span> wrapped = m.addWrap(a.toConst(), b.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
        <span class="tok-kw">return</span> wrapped;
    }

    <span class="tok-comment">/// r = a + b with 2s-complement saturating semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSat</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.addSat(a.toConst(), b.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a - b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.len(), b.len()) + <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.sub(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a - b with 2s-complement wrapping semantics. Returns whether any overflow occurred.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWrap</span>(
        r: *<a href="std.math.big.int.Managed.html">Managed</a>,
        a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        <span class="tok-kw">const</span> wrapped = m.subWrap(a.toConst(), b.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
        <span class="tok-kw">return</span> wrapped;
    }

    <span class="tok-comment">/// r = a - b with 2s-complement saturating semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// r, a and b may be aliases.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subSat</span>(
        r: *<a href="std.math.big.int.Managed.html">Managed</a>,
        a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.subSat(a.toConst(), b.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// rma = a * b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma's allocator is used for temporary storage to speed up the multiplication.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> alias_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr)
            alias_count += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr)
            alias_count += <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> rma.ensureMulCapacity(a.toConst(), b.toConst());
        <span class="tok-kw">var</span> m = rma.toMutable();
        <span class="tok-kw">if</span> (alias_count == <span class="tok-number">0</span>) {
            m.mulNoAlias(a.toConst(), b.toConst(), rma.allocator);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> limb_count = <a href="std.math.big.int.html#std.math.big.int.calcMulLimbsBufferLen">calcMulLimbsBufferLen</a>(a.len(), b.len(), alias_count);
            <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, limb_count);
            <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);
            m.mul(a.toConst(), b.toConst(), limbs_buffer, rma.allocator);
        }
        rma.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// rma = a * b with 2s-complement wrapping semantics.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma's allocator is used for temporary storage to speed up the multiplication.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulWrap</span>(
        rma: *<a href="std.math.big.int.Managed.html">Managed</a>,
        a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>,
        signedness: <a href="std.builtin.Signedness.html">Signedness</a>,
        bit_count: <span class="tok-type">usize</span>,
    ) !<span class="tok-type">void</span> {
        <span class="tok-kw">var</span> alias_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr)
            alias_count += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (rma.limbs.ptr == b.limbs.ptr)
            alias_count += <span class="tok-number">1</span>;

        <span class="tok-kw">try</span> rma.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = rma.toMutable();
        <span class="tok-kw">if</span> (alias_count == <span class="tok-number">0</span>) {
            m.mulWrapNoAlias(a.toConst(), b.toConst(), signedness, bit_count, rma.allocator);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> limb_count = <a href="std.math.big.int.html#std.math.big.int.calcMulWrapLimbsBufferLen">calcMulWrapLimbsBufferLen</a>(bit_count, a.len(), b.len(), alias_count);
            <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, limb_count);
            <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);
            m.mulWrap(a.toConst(), b.toConst(), signedness, bit_count, limbs_buffer, rma.allocator);
        }
        rma.setMetadata(m.positive, m.len);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTwosCompCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureAddScalarCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, scalar: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.limbs.len, <a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(scalar)) + <span class="tok-number">1</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureAddCapacity</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.limbs.len, b.limbs.len) + <span class="tok-number">1</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureMulCapacity</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: <a href="std.math.big.int.Const.html">Const</a>, b: <a href="std.math.big.int.Const.html">Const</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> rma.ensureCapacity(a.limbs.len + b.limbs.len + <span class="tok-number">1</span>);
    }

    <span class="tok-comment">/// q = a / b (rem r)</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a / b are floored (rounded towards 0).</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divFloor</span>(q: *<a href="std.math.big.int.Managed.html">Managed</a>, r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> q.ensureCapacity(a.len());
        <span class="tok-kw">try</span> r.ensureCapacity(b.len());
        <span class="tok-kw">var</span> mq = q.toMutable();
        <span class="tok-kw">var</span> mr = r.toMutable();
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> q.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a.len(), b.len()));
        <span class="tok-kw">defer</span> q.allocator.free(limbs_buffer);
        mq.divFloor(&amp;mr, a.toConst(), b.toConst(), limbs_buffer);
        q.setMetadata(mq.positive, mq.len);
        r.setMetadata(mr.positive, mr.len);
    }

    <span class="tok-comment">/// q = a / b (rem r)</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a / b are truncated (rounded towards -inf).</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns an error if memory could not be allocated.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divTrunc</span>(q: *<a href="std.math.big.int.Managed.html">Managed</a>, r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> q.ensureCapacity(a.len());
        <span class="tok-kw">try</span> r.ensureCapacity(b.len());
        <span class="tok-kw">var</span> mq = q.toMutable();
        <span class="tok-kw">var</span> mr = r.toMutable();
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> q.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.math.big.int.html#std.math.big.int.calcDivLimbsBufferLen">calcDivLimbsBufferLen</a>(a.len(), b.len()));
        <span class="tok-kw">defer</span> q.allocator.free(limbs_buffer);
        mq.divTrunc(&amp;mr, a.toConst(), b.toConst(), limbs_buffer);
        q.setMetadata(mq.positive, mq.len);
        r.setMetadata(mr.positive, mr.len);
    }

    <span class="tok-comment">/// r = a &lt;&lt; shift, in other words, r = a * 2^shift</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeft</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(a.len() + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.shiftLeft(a.toConst(), shift);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a &lt;&lt;| shift with 2s-complement saturating semantics.</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftSat</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.shiftLeftSat(a.toConst(), shift, signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a &gt;&gt; shift</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRight</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, shift: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (a.len() &lt;= shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) {<span class="tok-comment">
            // Shifting negative numbers converges to -1 instead of 0
            </span><span class="tok-kw">if</span> (a.isPositive()) {
                r.metadata = <span class="tok-number">1</span>;
                r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> {
                r.metadata = <span class="tok-number">1</span>;
                r.setSign(<span class="tok-null">false</span>);
                r.limbs[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">try</span> r.ensureCapacity(a.len() - (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.shiftRight(a.toConst(), shift);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = ~a under 2s-complement wrapping semantics.</span>
    <span class="tok-comment">/// r and a may alias.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitNotWrap</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureTwosCompCapacity(bit_count);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.bitNotWrap(a.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a | b</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// a and b are zero-extended to the longer of a or b.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOr</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<span class="tok-builtin">@max</span>(a.len(), b.len()));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.bitOr(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a &amp; b</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAnd</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> cap = <span class="tok-kw">if</span> (a.len() &gt;= b.len())
            <span class="tok-kw">if</span> (b.isPositive()) b.len() <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.isPositive()) a.len() <span class="tok-kw">else</span> a.len() + <span class="tok-number">1</span>
        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a.isPositive()) a.len() <span class="tok-kw">else</span> <span class="tok-kw">if</span> (b.isPositive()) b.len() <span class="tok-kw">else</span> b.len() + <span class="tok-number">1</span>;

        <span class="tok-kw">try</span> r.ensureCapacity(cap);
        <span class="tok-kw">var</span> m = r.toMutable();
        m.bitAnd(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a ^ b</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitXor</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> cap = <span class="tok-builtin">@max</span>(a.len(), b.len()) + <span class="tok-builtin">@intFromBool</span>(a.isPositive() != b.isPositive());
        <span class="tok-kw">try</span> r.ensureCapacity(cap);

        <span class="tok-kw">var</span> m = r.toMutable();
        m.bitXor(a.toConst(), b.toConst());
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// rma may alias x or y.</span>
    <span class="tok-comment">/// x and y may alias each other.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// rma's allocator is used for temporary storage to boost multiplication performance.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gcd</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, x: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, y: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> rma.ensureCapacity(<span class="tok-builtin">@min</span>(x.len(), y.len()));
        <span class="tok-kw">var</span> m = rma.toMutable();
        <span class="tok-kw">var</span> limbs_buffer = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>).init(rma.allocator);
        <span class="tok-kw">defer</span> limbs_buffer.deinit();
        <span class="tok-kw">try</span> m.gcd(x.toConst(), y.toConst(), &amp;limbs_buffer);
        rma.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = a * a</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqr</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> needed_limbs = <span class="tok-number">2</span> * a.len() + <span class="tok-number">1</span>;

        <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) {
            <span class="tok-kw">var</span> m = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(rma.allocator, needed_limbs);
            <span class="tok-kw">errdefer</span> m.deinit();
            <span class="tok-kw">var</span> m_mut = m.toMutable();
            m_mut.sqrNoAlias(a.toConst(), rma.allocator);
            m.setMetadata(m_mut.positive, m_mut.len);

            rma.deinit();
            rma.swap(&amp;m);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> rma.ensureCapacity(needed_limbs);
            <span class="tok-kw">var</span> rma_mut = rma.toMutable();
            rma_mut.sqrNoAlias(a.toConst(), rma.allocator);
            rma.setMetadata(rma_mut.positive, rma_mut.len);
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, b: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcPowLimbsBufferLen">calcPowLimbsBufferLen</a>(a.bitCountAbs(), b);

        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, needed_limbs);
        <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);

        <span class="tok-kw">if</span> (rma.limbs.ptr == a.limbs.ptr) {
            <span class="tok-kw">var</span> m = <span class="tok-kw">try</span> <a href="std.math.big.int.Managed.html">Managed</a>.<a href="std.math.big.int.Managed.html#std.math.big.int.Managed.initCapacity">initCapacity</a>(rma.allocator, needed_limbs);
            <span class="tok-kw">errdefer</span> m.deinit();
            <span class="tok-kw">var</span> m_mut = m.toMutable();
            m_mut.pow(a.toConst(), b, limbs_buffer);
            m.setMetadata(m_mut.positive, m_mut.len);

            rma.deinit();
            rma.swap(&amp;m);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> rma.ensureCapacity(needed_limbs);
            <span class="tok-kw">var</span> rma_mut = rma.toMutable();
            rma_mut.pow(a.toConst(), b, limbs_buffer);
            rma.setMetadata(rma_mut.positive, rma_mut.len);
        }
    }

    <span class="tok-comment">/// r = ⌊√a⌋</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sqrt</span>(rma: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> bit_count = a.bitCountAbs();

        <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> rma.set(<span class="tok-number">0</span>);
            rma.setMetadata(a.isPositive(), rma.len());
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">if</span> (!a.isPositive()) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SqrtOfNegativeNumber;
        }

        <span class="tok-kw">const</span> needed_limbs = <a href="std.math.big.int.html#std.math.big.int.calcSqrtLimbsBufferLen">calcSqrtLimbsBufferLen</a>(bit_count);
        <span class="tok-kw">const</span> limbs_buffer = <span class="tok-kw">try</span> rma.allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, needed_limbs);
        <span class="tok-kw">defer</span> rma.allocator.free(limbs_buffer);

        <span class="tok-kw">try</span> rma.ensureCapacity((a.len() - <span class="tok-number">1</span>) / <span class="tok-number">2</span> + <span class="tok-number">1</span>);
        <span class="tok-kw">var</span> m = rma.toMutable();
        m.sqrt(a.toConst(), limbs_buffer);
        rma.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = truncate(Int(signedness, bit_count), a)</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncate</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.truncate(a.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = saturate(Int(signedness, bit_count), a)</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">saturate</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, signedness: <a href="std.builtin.Signedness.html">Signedness</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.saturate(a.toConst(), signedness, bit_count);
        r.setMetadata(m.positive, m.len);
    }

    <span class="tok-comment">/// r = @popCount(a) with 2s-complement semantics.</span>
    <span class="tok-comment">/// r and a may be aliases.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popCount</span>(r: *<a href="std.math.big.int.Managed.html">Managed</a>, a: *<span class="tok-kw">const</span> <a href="std.math.big.int.Managed.html">Managed</a>, bit_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> r.ensureCapacity(<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bit_count));
        <span class="tok-kw">var</span> m = r.toMutable();
        m.popCount(a.toConst(), bit_count);
        r.setMetadata(m.positive, m.len);
    }
};

<span class="tok-comment">/// Different operators which can be used in accumulation style functions</span>
<span class="tok-comment">/// (llmulacc, llmulaccKaratsuba, llmulaccLong, llmulLimb). In all these functions,</span>
<span class="tok-comment">/// a computed value is accumulated with an existing result.</span>
<span class="tok-kw">const</span> AccOp = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// The computed value is added to the result.</span>
    add,

    <span class="tok-comment">/// The computed value is subtracted from the result.</span>
    sub,
};

<span class="tok-comment">/// Knuth 4.3.1, Algorithm M.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// r = r (op) a * b</span>
<span class="tok-comment">/// r MUST NOT alias any of a or b.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The result is computed modulo `r.len`. When `r.len &gt;= a.len + b.len`, no overflow occurs.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llmulacc</span>(<span class="tok-kw">comptime</span> op: <a href="std.math.big.int.AccOp.html">AccOp</a>, opt_allocator: ?<a href="std.mem.Allocator.html">Allocator</a>, r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= b.len);<span class="tok-comment">

    // Order greatest first.
    </span><span class="tok-kw">var</span> x = a;
    <span class="tok-kw">var</span> y = b;
    <span class="tok-kw">if</span> (a.len &lt; b.len) {
        x = b;
        y = a;
    }

    k_mul: {
        <span class="tok-kw">if</span> (y.len &gt; <span class="tok-number">48</span>) {
            <span class="tok-kw">if</span> (opt_allocator) |allocator| {
                <a href="std.math.big.int.html#std.math.big.int.llmulaccKaratsuba">llmulaccKaratsuba</a>(op, allocator, r, x, y) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                    <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">break</span> :k_mul,<span class="tok-comment"> // handled below
                </span>};
                <span class="tok-kw">return</span>;
            }
        }
    }

    <a href="std.math.big.int.html#std.math.big.int.llmulaccLong">llmulaccLong</a>(op, r, x, y);
}

<span class="tok-comment">/// Knuth 4.3.1, Algorithm M.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// r = r (op) a * b</span>
<span class="tok-comment">/// r MUST NOT alias any of a or b.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The result is computed modulo `r.len`. When `r.len &gt;= a.len + b.len`, no overflow occurs.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llmulaccKaratsuba</span>(
    <span class="tok-kw">comptime</span> op: <a href="std.math.big.int.AccOp.html">AccOp</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>,
    b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>,
) <span class="tok-kw">error</span>{OutOfMemory}!<span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= b.len);<span class="tok-comment">

    // Classical karatsuba algorithm:
    // a = a1 * B + a0
    // b = b1 * B + b0
    // Where a0, b0 &lt; B
    //
    // We then have:
    // ab = a * b
    //    = (a1 * B + a0) * (b1 * B + b0)
    //    = a1 * b1 * B * B + a1 * B * b0 + a0 * b1 * B + a0 * b0
    //    = a1 * b1 * B * B + (a1 * b0 + a0 * b1) * B + a0 * b0
    //
    // Note that:
    // a1 * b0 + a0 * b1
    //    = (a1 + a0)(b1 + b0) - a1 * b1 - a0 * b0
    //    = (a0 - a1)(b1 - b0) + a1 * b1 + a0 * b0
    //
    // This yields:
    // ab = p2 * B^2 + (p0 + p1 + p2) * B + p0
    //
    // Where:
    // p0 = a0 * b0
    // p1 = (a0 - a1)(b1 - b0)
    // p2 = a1 * b1
    //
    // Note, (a0 - a1) and (b1 - b0) produce values -B &lt; x &lt; B, and so we need to mind the sign here.
    // We also have:
    // 0 &lt;= p0 &lt;= 2B
    // -2B &lt;= p1 &lt;= 2B
    //
    // Note, when B is a multiple of the limb size, multiplies by B amount to shifts or
    // slices of a limbs array.
    //
    // This function computes the result of the multiplication modulo r.len. This means:
    // - p2 and p1 only need to be computed modulo r.len - B.
    // - In the case of p2, p2 * B^2 needs to be added modulo r.len - 2 * B.

    </span><span class="tok-kw">const</span> split = b.len / <span class="tok-number">2</span>;<span class="tok-comment"> // B

    </span><span class="tok-kw">const</span> limbs_after_split = r.len - split;<span class="tok-comment"> // Limbs to compute for p1 and p2.
    </span><span class="tok-kw">const</span> limbs_after_split2 = r.len - split * <span class="tok-number">2</span>;<span class="tok-comment"> // Limbs to add for p2 * B^2.

    // For a0 and b0 we need the full range.
    </span><span class="tok-kw">const</span> a0 = a[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(a[<span class="tok-number">0</span>..split])];
    <span class="tok-kw">const</span> b0 = b[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(b[<span class="tok-number">0</span>..split])];<span class="tok-comment">

    // For a1 and b1 we only need `limbs_after_split` limbs.
    </span><span class="tok-kw">const</span> a1 = blk: {
        <span class="tok-kw">var</span> a1 = a[split..];
        a1.len = <span class="tok-builtin">@min</span>(<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(a1), limbs_after_split);
        <span class="tok-kw">break</span> :blk a1;
    };

    <span class="tok-kw">const</span> b1 = blk: {
        <span class="tok-kw">var</span> b1 = b[split..];
        b1.len = <span class="tok-builtin">@min</span>(<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(b1), limbs_after_split);
        <span class="tok-kw">break</span> :blk b1;
    };<span class="tok-comment">

    // Note that the above slices relative to `split` work because we have a.len &gt; b.len.

    // We need some temporary memory to store intermediate results.
    // Note, we can reduce the amount of temporaries we need by reordering the computation here:
    // ab = p2 * B^2 + (p0 + p1 + p2) * B + p0
    //    = p2 * B^2 + (p0 * B + p1 * B + p2 * B) + p0
    //    = (p2 * B^2 + p2 * B) + (p0 * B + p0) + p1 * B

    // Allocate at least enough memory to be able to multiply the upper two segments of a and b, assuming
    // no overflow.
    </span><span class="tok-kw">const</span> tmp = <span class="tok-kw">try</span> allocator.alloc(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a.len - split + b.len - split);
    <span class="tok-kw">defer</span> allocator.free(tmp);<span class="tok-comment">

    // Compute p2.
    // Note, we don't need to compute all of p2, just enough limbs to satisfy r.
    </span><span class="tok-kw">const</span> p2_limbs = <span class="tok-builtin">@min</span>(limbs_after_split, a1.len + b1.len);

    <span class="tok-builtin">@memset</span>(tmp[<span class="tok-number">0</span>..p2_limbs], <span class="tok-number">0</span>);
    <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, allocator, tmp[<span class="tok-number">0</span>..p2_limbs], a1[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(a1.len, p2_limbs)], b1[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(b1.len, p2_limbs)]);
    <span class="tok-kw">const</span> p2 = tmp[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(tmp[<span class="tok-number">0</span>..p2_limbs])];<span class="tok-comment">

    // Add p2 * B to the result.
    </span><a href="std.math.big.int.html#std.math.big.int.llaccum">llaccum</a>(op, r[split..], p2);<span class="tok-comment">

    // Add p2 * B^2 to the result if required.
    </span><span class="tok-kw">if</span> (limbs_after_split2 &gt; <span class="tok-number">0</span>) {
        <a href="std.math.big.int.html#std.math.big.int.llaccum">llaccum</a>(op, r[split * <span class="tok-number">2</span> ..], p2[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(p2.len, limbs_after_split2)]);
    }<span class="tok-comment">

    // Compute p0.
    // Since a0.len, b0.len &lt;= split and r.len &gt;= split * 2, the full width of p0 needs to be computed.
    </span><span class="tok-kw">const</span> p0_limbs = a0.len + b0.len;
    <span class="tok-builtin">@memset</span>(tmp[<span class="tok-number">0</span>..p0_limbs], <span class="tok-number">0</span>);
    <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, allocator, tmp[<span class="tok-number">0</span>..p0_limbs], a0, b0);
    <span class="tok-kw">const</span> p0 = tmp[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(tmp[<span class="tok-number">0</span>..p0_limbs])];<span class="tok-comment">

    // Add p0 to the result.
    </span><a href="std.math.big.int.html#std.math.big.int.llaccum">llaccum</a>(op, r, p0);<span class="tok-comment">

    // Add p0 * B to the result. In this case, we may not need all of it.
    </span><a href="std.math.big.int.html#std.math.big.int.llaccum">llaccum</a>(op, r[split..], p0[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(limbs_after_split, p0.len)]);<span class="tok-comment">

    // Finally, compute and add p1.
    // From now on we only need `limbs_after_split` limbs for a0 and b0, since the result of the
    // following computation will be added * B.
    </span><span class="tok-kw">const</span> a0x = a0[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(a0.len, limbs_after_split)];
    <span class="tok-kw">const</span> b0x = b0[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(b0.len, limbs_after_split)];

    <span class="tok-kw">const</span> j0_sign = <a href="std.math.big.int.html#std.math.big.int.llcmp">llcmp</a>(a0x, a1);
    <span class="tok-kw">const</span> j1_sign = <a href="std.math.big.int.html#std.math.big.int.llcmp">llcmp</a>(b1, b0x);

    <span class="tok-kw">if</span> (j0_sign * j1_sign == <span class="tok-number">0</span>) {<span class="tok-comment">
        // p1 is zero, we don't need to do any computation at all.
        </span><span class="tok-kw">return</span>;
    }

    <span class="tok-builtin">@memset</span>(tmp, <span class="tok-number">0</span>);<span class="tok-comment">

    // p1 is nonzero, so compute the intermediary terms j0 = a0 - a1 and j1 = b1 - b0.
    // Note that in this case, we again need some storage for intermediary results
    // j0 and j1. Since we have tmp.len &gt;= 2B, we can store both
    // intermediaries in the already allocated array.
    </span><span class="tok-kw">const</span> j0 = tmp[<span class="tok-number">0</span> .. a.len - split];
    <span class="tok-kw">const</span> j1 = tmp[a.len - split ..];<span class="tok-comment">

    // Ensure that no subtraction overflows.
    </span><span class="tok-kw">if</span> (j0_sign == <span class="tok-number">1</span>) {<span class="tok-comment">
        // a0 &gt; a1.
        </span>_ = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(j0, a0x, a1);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // a0 &lt; a1.
        </span>_ = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(j0, a1, a0x);
    }

    <span class="tok-kw">if</span> (j1_sign == <span class="tok-number">1</span>) {<span class="tok-comment">
        // b1 &gt; b0.
        </span>_ = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(j1, b1, b0x);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // b1 &gt; b0.
        </span>_ = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(j1, b0x, b1);
    }

    <span class="tok-kw">if</span> (j0_sign * j1_sign == <span class="tok-number">1</span>) {<span class="tok-comment">
        // If j0 and j1 are both positive, we now have:
        // p1 = j0 * j1
        // If j0 and j1 are both negative, we now have:
        // p1 = -j0 * -j1 = j0 * j1
        // In this case we can add p1 to the result using llmulacc.
        </span><a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(op, allocator, r[split..], j0[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(j0)], j1[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(j1)]);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // In this case either j0 or j1 is negative, an we have:
        // p1 = -(j0 * j1)
        // Now we need to subtract instead of accumulate.
        </span><span class="tok-kw">const</span> inverted_op = <span class="tok-kw">if</span> (op == .add) .sub <span class="tok-kw">else</span> .add;
        <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(inverted_op, allocator, r[split..], j0[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(j0)], j1[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(j1)]);
    }
}

<span class="tok-comment">/// r = r (op) a.</span>
<span class="tok-comment">/// The result is computed modulo `r.len`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llaccum</span>(<span class="tok-kw">comptime</span> op: <a href="std.math.big.int.AccOp.html">AccOp</a>, r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <span class="tok-kw">if</span> (op == .sub) {
        _ = <a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r, r, a);
        <span class="tok-kw">return</span>;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(r.len != <span class="tok-number">0</span> <span class="tok-kw">and</span> a.len != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> carry: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (i &lt; a.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@addWithOverflow</span>(r[i], a[i]);
        r[i] = ov1[<span class="tok-number">0</span>];
        <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@addWithOverflow</span>(r[i], carry);
        r[i] = ov2[<span class="tok-number">0</span>];
        carry = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, ov1[<span class="tok-number">1</span>]) + ov2[<span class="tok-number">1</span>];
    }

    <span class="tok-kw">while</span> ((carry != <span class="tok-number">0</span>) <span class="tok-kw">and</span> i &lt; r.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(r[i], carry);
        r[i] = ov[<span class="tok-number">0</span>];
        carry = ov[<span class="tok-number">1</span>];
    }
}

<span class="tok-comment">/// Returns -1, 0, 1 if |a| &lt; |b|, |a| == |b| or |a| &gt; |b| respectively for limbs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">llcmp</span>(a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">i8</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <span class="tok-kw">const</span> a_len = <a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(a);
    <span class="tok-kw">const</span> b_len = <a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(b);
    <span class="tok-kw">if</span> (a_len &lt; b_len) {
        <span class="tok-kw">return</span> -<span class="tok-number">1</span>;
    }
    <span class="tok-kw">if</span> (a_len &gt; b_len) {
        <span class="tok-kw">return</span> <span class="tok-number">1</span>;
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = a_len - <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) : (i -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (a[i] != b[i]) {
            <span class="tok-kw">break</span>;
        }
    }

    <span class="tok-kw">if</span> (a[i] &lt; b[i]) {
        <span class="tok-kw">return</span> -<span class="tok-number">1</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a[i] &gt; b[i]) {
        <span class="tok-kw">return</span> <span class="tok-number">1</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    }
}

<span class="tok-comment">/// r = r (op) y * xi</span>
<span class="tok-comment">/// The result is computed modulo `r.len`. When `r.len &gt;= a.len + b.len`, no overflow occurs.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llmulaccLong</span>(<span class="tok-kw">comptime</span> op: <a href="std.math.big.int.AccOp.html">AccOp</a>, r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= b.len);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
        _ = <a href="std.math.big.int.html#std.math.big.int.llmulLimb">llmulLimb</a>(op, r[i..], a, b[i]);
    }
}

<span class="tok-comment">/// r = r (op) y * xi</span>
<span class="tok-comment">/// The result is computed modulo `r.len`.</span>
<span class="tok-comment">/// Returns whether the operation overflowed.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llmulLimb</span>(<span class="tok-kw">comptime</span> op: <a href="std.math.big.int.AccOp.html">AccOp</a>, acc: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, y: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, xi: <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">bool</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <span class="tok-kw">if</span> (xi == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">const</span> split = <span class="tok-builtin">@min</span>(y.len, acc.len);
    <span class="tok-kw">var</span> a_lo = acc[<span class="tok-number">0</span>..split];
    <span class="tok-kw">var</span> a_hi = acc[split..];

    <span class="tok-kw">switch</span> (op) {
        .add =&gt; {
            <span class="tok-kw">var</span> carry: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (j &lt; a_lo.len) : (j += <span class="tok-number">1</span>) {
                a_lo[j] = <a href="std.math.big.int.html#std.math.big.int.addMulLimbWithCarry">addMulLimbWithCarry</a>(a_lo[j], y[j], xi, &amp;carry);
            }

            j = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> ((carry != <span class="tok-number">0</span>) <span class="tok-kw">and</span> (j &lt; a_hi.len)) : (j += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(a_hi[j], carry);
                a_hi[j] = ov[<span class="tok-number">0</span>];
                carry = ov[<span class="tok-number">1</span>];
            }

            <span class="tok-kw">return</span> carry != <span class="tok-number">0</span>;
        },
        .sub =&gt; {
            <span class="tok-kw">var</span> borrow: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (j &lt; a_lo.len) : (j += <span class="tok-number">1</span>) {
                a_lo[j] = <a href="std.math.big.int.html#std.math.big.int.subMulLimbWithBorrow">subMulLimbWithBorrow</a>(a_lo[j], y[j], xi, &amp;borrow);
            }

            j = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> ((borrow != <span class="tok-number">0</span>) <span class="tok-kw">and</span> (j &lt; a_hi.len)) : (j += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> ov = <span class="tok-builtin">@subWithOverflow</span>(a_hi[j], borrow);
                a_hi[j] = ov[<span class="tok-number">0</span>];
                borrow = ov[<span class="tok-number">1</span>];
            }

            <span class="tok-kw">return</span> borrow != <span class="tok-number">0</span>;
        },
    }
}

<span class="tok-comment">/// returns the min length the limb could be.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llnormalize</span>(a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">usize</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <span class="tok-kw">var</span> j = a.len;
    <span class="tok-kw">while</span> (j &gt; <span class="tok-number">0</span>) : (j -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (a[j - <span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span>;
        }
    }<span class="tok-comment">

    // Handle zero
    </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (j != <span class="tok-number">0</span>) j <span class="tok-kw">else</span> <span class="tok-number">1</span>;
}

<span class="tok-comment">/// Knuth 4.3.1, Algorithm S.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llsubcarry</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.html#std.math.big.Limb">Limb</a> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len != <span class="tok-number">0</span> <span class="tok-kw">and</span> b.len != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= b.len);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> borrow: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(a[i], b[i]);
        r[i] = ov1[<span class="tok-number">0</span>];
        <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@subWithOverflow</span>(r[i], borrow);
        r[i] = ov2[<span class="tok-number">0</span>];
        borrow = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, ov1[<span class="tok-number">1</span>]) + ov2[<span class="tok-number">1</span>];
    }

    <span class="tok-kw">while</span> (i &lt; a.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov = <span class="tok-builtin">@subWithOverflow</span>(a[i], borrow);
        r[i] = ov[<span class="tok-number">0</span>];
        borrow = ov[<span class="tok-number">1</span>];
    }

    <span class="tok-kw">return</span> borrow;
}

<span class="tok-kw">fn</span> <span class="tok-fn">llsub</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt; b.len <span class="tok-kw">or</span> (a.len == b.len <span class="tok-kw">and</span> a[a.len - <span class="tok-number">1</span>] &gt;= b[b.len - <span class="tok-number">1</span>]));
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.math.big.int.html#std.math.big.int.llsubcarry">llsubcarry</a>(r, a, b) == <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Knuth 4.3.1, Algorithm A.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">lladdcarry</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.html#std.math.big.Limb">Limb</a> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len != <span class="tok-number">0</span> <span class="tok-kw">and</span> b.len != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= b.len);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> carry: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@addWithOverflow</span>(a[i], b[i]);
        r[i] = ov1[<span class="tok-number">0</span>];
        <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@addWithOverflow</span>(r[i], carry);
        r[i] = ov2[<span class="tok-number">0</span>];
        carry = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, ov1[<span class="tok-number">1</span>]) + ov2[<span class="tok-number">1</span>];
    }

    <span class="tok-kw">while</span> (i &lt; a.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(a[i], carry);
        r[i] = ov[<span class="tok-number">0</span>];
        carry = ov[<span class="tok-number">1</span>];
    }

    <span class="tok-kw">return</span> carry;
}

<span class="tok-kw">fn</span> <span class="tok-fn">lladd</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len + <span class="tok-number">1</span>);
    r[a.len] = <a href="std.math.big.int.html#std.math.big.int.lladdcarry">lladdcarry</a>(r, a, b);
}

<span class="tok-comment">/// Knuth 4.3.1, Exercise 16.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">lldiv1</span>(quo: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, rem: *<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt; <span class="tok-number">1</span> <span class="tok-kw">or</span> a[<span class="tok-number">0</span>] &gt;= b);
    <a href="std.debug.html#std.debug.assert">assert</a>(quo.len &gt;= a.len);

    rem.* = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (a, <span class="tok-number">0</span>..) |_, ri| {
        <span class="tok-kw">const</span> i = a.len - ri - <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> pdiv = ((<span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, rem.*) &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) | a[i]);

        <span class="tok-kw">if</span> (pdiv == <span class="tok-number">0</span>) {
            quo[i] = <span class="tok-number">0</span>;
            rem.* = <span class="tok-number">0</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pdiv &lt; b) {
            quo[i] = <span class="tok-number">0</span>;
            rem.* = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(pdiv));
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pdiv == b) {
            quo[i] = <span class="tok-number">1</span>;
            rem.* = <span class="tok-number">0</span>;
        } <span class="tok-kw">else</span> {
            quo[i] = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@divTrunc</span>(pdiv, b)));
            rem.* = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(pdiv - (quo[i] *% b)));
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">lldiv0p5</span>(quo: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, rem: *<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: <a href="std.math.big.html#std.math.big.HalfLimb">HalfLimb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt; <span class="tok-number">1</span> <span class="tok-kw">or</span> a[<span class="tok-number">0</span>] &gt;= b);
    <a href="std.debug.html#std.debug.assert">assert</a>(quo.len &gt;= a.len);

    rem.* = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (a, <span class="tok-number">0</span>..) |_, ri| {
        <span class="tok-kw">const</span> i = a.len - ri - <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> ai_high = a[i] &gt;&gt; <a href="std.math.big.int.html#std.math.big.int.half_limb_bits">half_limb_bits</a>;
        <span class="tok-kw">const</span> ai_low = a[i] &amp; ((<span class="tok-number">1</span> &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.half_limb_bits">half_limb_bits</a>) - <span class="tok-number">1</span>);<span class="tok-comment">

        // Split the division into two divisions acting on half a limb each. Carry remainder.
        </span><span class="tok-kw">const</span> ai_high_with_carry = (rem.* &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.half_limb_bits">half_limb_bits</a>) | ai_high;
        <span class="tok-kw">const</span> ai_high_quo = ai_high_with_carry / b;
        rem.* = ai_high_with_carry % b;

        <span class="tok-kw">const</span> ai_low_with_carry = (rem.* &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.half_limb_bits">half_limb_bits</a>) | ai_low;
        <span class="tok-kw">const</span> ai_low_quo = ai_low_with_carry / b;
        rem.* = ai_low_with_carry % b;

        quo[i] = (ai_high_quo &lt;&lt; <a href="std.math.big.int.html#std.math.big.int.half_limb_bits">half_limb_bits</a>) | ai_low_quo;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">llshl</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> interior_limb_shift = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@truncate</span>(shift));<span class="tok-comment">

    // We only need the extra limb if the shift of the last element overflows.
    // This is useful for the implementation of `shiftLeftSat`.
    </span><span class="tok-kw">if</span> (a[a.len - <span class="tok-number">1</span>] &lt;&lt; interior_limb_shift &gt;&gt; interior_limb_shift != a[a.len - <span class="tok-number">1</span>]) {
        <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>) + <span class="tok-number">1</span>);
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len + (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));
    }

    <span class="tok-kw">const</span> limb_shift = shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> + <span class="tok-number">1</span>;

    <span class="tok-kw">var</span> carry: <a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; a.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> src_i = a.len - i - <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> dst_i = src_i + limb_shift;

        <span class="tok-kw">const</span> src_digit = a[src_i];
        r[dst_i] = carry | <span class="tok-builtin">@call</span>(.always_inline, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>, .{
            <a href="std.math.big.html#std.math.big.Limb">Limb</a>,
            src_digit,
            <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@intCast</span>(interior_limb_shift)),
        });
        carry = (src_digit &lt;&lt; interior_limb_shift);
    }

    r[limb_shift - <span class="tok-number">1</span>] = carry;
    <span class="tok-builtin">@memset</span>(r[<span class="tok-number">0</span> .. limb_shift - <span class="tok-number">1</span>], <span class="tok-number">0</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">llshr</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, shift: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= <span class="tok-number">1</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len - (shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));

    <span class="tok-kw">const</span> limb_shift = shift / <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>;
    <span class="tok-kw">const</span> interior_limb_shift = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Log2Limb">Log2Limb</a>, <span class="tok-builtin">@truncate</span>(shift));

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; a.len - limb_shift) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> dst_i = i;
        <span class="tok-kw">const</span> src_i = dst_i + limb_shift;

        <span class="tok-kw">const</span> src_digit = a[src_i];
        <span class="tok-kw">const</span> src_digit_next = <span class="tok-kw">if</span> (src_i + <span class="tok-number">1</span> &lt; a.len) a[src_i + <span class="tok-number">1</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> carry = <span class="tok-builtin">@call</span>(.always_inline, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>, .{
            <a href="std.math.big.html#std.math.big.Limb">Limb</a>,
            src_digit_next,
            <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a> - <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@intCast</span>(interior_limb_shift)),
        });
        r[dst_i] = carry | (src_digit &gt;&gt; interior_limb_shift);
    }
}<span class="tok-comment">

// r = ~r
</span><span class="tok-kw">fn</span> <span class="tok-fn">llnot</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);

    <span class="tok-kw">for</span> (r) |*elem| {
        elem.* = ~elem.*;
    }
}<span class="tok-comment">

// r = a | b with 2s complement semantics.
// r may alias.
// a and b must not be 0.
// Returns `true` when the result is positive.
// When b is positive, r requires at least `a.len` limbs of storage.
// When b is negative, r requires at least `b.len` limbs of storage.
</span><span class="tok-kw">fn</span> <span class="tok-fn">llsignedor</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, a_positive: <span class="tok-type">bool</span>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b_positive: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= b.len);

    <span class="tok-kw">if</span> (a_positive <span class="tok-kw">and</span> b_positive) {<span class="tok-comment">
        // Trivial case, result is positive.
        </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
            r[i] = a[i] | b[i];
        }
        <span class="tok-kw">while</span> (i &lt; a.len) : (i += <span class="tok-number">1</span>) {
            r[i] = a[i];
        }

        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!a_positive <span class="tok-kw">and</span> b_positive) {<span class="tok-comment">
        // Result is negative.
        // r = (--a) | b
        //   = ~(-a - 1) | b
        //   = ~(-a - 1) | ~~b
        //   = ~((-a - 1) &amp; ~b)
        //   = -(((-a - 1) &amp; ~b) + 1)

        </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> a_borrow: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> r_carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;

        <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(a[i], a_borrow);
            a_borrow = ov1[<span class="tok-number">1</span>];
            <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@addWithOverflow</span>(ov1[<span class="tok-number">0</span>] &amp; ~b[i], r_carry);
            r[i] = ov2[<span class="tok-number">0</span>];
            r_carry = ov2[<span class="tok-number">1</span>];
        }<span class="tok-comment">

        // In order for r_carry to be nonzero at this point, ~b[i] would need to be
        // all ones, which would require b[i] to be zero. This cannot be when
        // b is normalized, so there cannot be a carry here.
        // Also, x &amp; ~b can only clear bits, so (x &amp; ~b) &lt;= x, meaning (-a - 1) + 1 never overflows.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(r_carry == <span class="tok-number">0</span>);<span class="tok-comment">

        // With b = 0, we get (-a - 1) &amp; ~0 = -a - 1.
        // Note, if a_borrow is zero we do not need to compute anything for
        // the higher limbs so we can early return here.
        </span><span class="tok-kw">while</span> (i &lt; a.len <span class="tok-kw">and</span> a_borrow == <span class="tok-number">1</span>) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@subWithOverflow</span>(a[i], a_borrow);
            r[i] = ov[<span class="tok-number">0</span>];
            a_borrow = ov[<span class="tok-number">1</span>];
        }

        <a href="std.debug.html#std.debug.assert">assert</a>(a_borrow == <span class="tok-number">0</span>);<span class="tok-comment"> // a was 0.

        </span><span class="tok-kw">return</span> <span class="tok-null">false</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a_positive <span class="tok-kw">and</span> !b_positive) {<span class="tok-comment">
        // Result is negative.
        // r = a | (--b)
        //   = a | ~(-b - 1)
        //   = ~~a | ~(-b - 1)
        //   = ~(~a &amp; (-b - 1))
        //   = -((~a &amp; (-b - 1)) + 1)

        </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> b_borrow: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> r_carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;

        <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(b[i], b_borrow);
            b_borrow = ov1[<span class="tok-number">1</span>];
            <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@addWithOverflow</span>(~a[i] &amp; ov1[<span class="tok-number">0</span>], r_carry);
            r[i] = ov2[<span class="tok-number">0</span>];
            r_carry = ov2[<span class="tok-number">1</span>];
        }<span class="tok-comment">

        // b is at least 1, so this should never underflow.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(b_borrow == <span class="tok-number">0</span>);<span class="tok-comment"> // b was 0

        // x &amp; ~a can only clear bits, so (x &amp; ~a) &lt;= x, meaning (-b - 1) + 1 never overflows.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(r_carry == <span class="tok-number">0</span>);<span class="tok-comment">

        // With b = 0 and b_borrow = 0, we get ~a &amp; (0 - 0) = ~a &amp; 0 = 0.
        // Omit setting the upper bytes, just deal with those when calling llsignedor.

        </span><span class="tok-kw">return</span> <span class="tok-null">false</span>;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // Result is negative.
        // r = (--a) | (--b)
        //   = ~(-a - 1) | ~(-b - 1)
        //   = ~((-a - 1) &amp; (-b - 1))
        //   = -(~(~((-a - 1) &amp; (-b - 1))) + 1)
        //   = -((-a - 1) &amp; (-b - 1) + 1)

        </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> a_borrow: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> b_borrow: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> r_carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;

        <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(a[i], a_borrow);
            a_borrow = ov1[<span class="tok-number">1</span>];
            <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@subWithOverflow</span>(b[i], b_borrow);
            b_borrow = ov2[<span class="tok-number">1</span>];
            <span class="tok-kw">const</span> ov3 = <span class="tok-builtin">@addWithOverflow</span>(ov1[<span class="tok-number">0</span>] &amp; ov2[<span class="tok-number">0</span>], r_carry);
            r[i] = ov3[<span class="tok-number">0</span>];
            r_carry = ov3[<span class="tok-number">1</span>];
        }<span class="tok-comment">

        // b is at least 1, so this should never underflow.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(b_borrow == <span class="tok-number">0</span>);<span class="tok-comment"> // b was 0

        // Can never overflow because in order for b_limb to be maxInt(Limb),
        // b_borrow would need to equal 1.

        // x &amp; y can only clear bits, meaning x &amp; y &lt;= x and x &amp; y &lt;= y. This implies that
        // for x = a - 1 and y = b - 1, the +1 term would never cause an overflow.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(r_carry == <span class="tok-number">0</span>);<span class="tok-comment">

        // With b = 0 and b_borrow = 0 we get (-a - 1) &amp; (0 - 0) = (-a - 1) &amp; 0 = 0.
        // Omit setting the upper bytes, just deal with those when calling llsignedor.
        </span><span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
}<span class="tok-comment">

// r = a &amp; b with 2s complement semantics.
// r may alias.
// a and b must not be 0.
// Returns `true` when the result is positive.
// We assume `a.len &gt;= b.len` here, so:
// 1. when b is positive, r requires at least `b.len` limbs of storage,
// 2. when b is negative but a is positive, r requires at least `a.len` limbs of storage,
// 3. when both a and b are negative, r requires at least `a.len + 1` limbs of storage.
</span><span class="tok-kw">fn</span> <span class="tok-fn">llsignedand</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, a_positive: <span class="tok-type">bool</span>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b_positive: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len != <span class="tok-number">0</span> <span class="tok-kw">and</span> b.len != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= b.len);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= <span class="tok-kw">if</span> (b_positive) b.len <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a_positive) a.len <span class="tok-kw">else</span> a.len + <span class="tok-number">1</span>);

    <span class="tok-kw">if</span> (a_positive <span class="tok-kw">and</span> b_positive) {<span class="tok-comment">
        // Trivial case, result is positive.
        </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
            r[i] = a[i] &amp; b[i];
        }<span class="tok-comment">

        // With b = 0 we have a &amp; 0 = 0, so the upper bytes are zero.
        // Omit setting them here and simply discard them whenever
        // llsignedand is called.

        </span><span class="tok-kw">return</span> <span class="tok-null">true</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!a_positive <span class="tok-kw">and</span> b_positive) {<span class="tok-comment">
        // Result is positive.
        // r = (--a) &amp; b
        //   = ~(-a - 1) &amp; b

        </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> a_borrow: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;

        <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@subWithOverflow</span>(a[i], a_borrow);
            a_borrow = ov[<span class="tok-number">1</span>];
            r[i] = ~ov[<span class="tok-number">0</span>] &amp; b[i];
        }<span class="tok-comment">

        // With b = 0 we have ~(a - 1) &amp; 0 = 0, so the upper bytes are zero.
        // Omit setting them here and simply discard them whenever
        // llsignedand is called.

        </span><span class="tok-kw">return</span> <span class="tok-null">true</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a_positive <span class="tok-kw">and</span> !b_positive) {<span class="tok-comment">
        // Result is positive.
        // r = a &amp; (--b)
        //   = a &amp; ~(-b - 1)

        </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> b_borrow: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;

        <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@subWithOverflow</span>(b[i], b_borrow);
            b_borrow = ov[<span class="tok-number">1</span>];
            r[i] = a[i] &amp; ~ov[<span class="tok-number">0</span>];
        }

        <a href="std.debug.html#std.debug.assert">assert</a>(b_borrow == <span class="tok-number">0</span>);<span class="tok-comment"> // b was 0

        // With b = 0 and b_borrow = 0 we have a &amp; ~(0 - 0) = a &amp; ~0 = a, so
        // the upper bytes are the same as those of a.

        </span><span class="tok-kw">while</span> (i &lt; a.len) : (i += <span class="tok-number">1</span>) {
            r[i] = a[i];
        }

        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // Result is negative.
        // r = (--a) &amp; (--b)
        //   = ~(-a - 1) &amp; ~(-b - 1)
        //   = ~((-a - 1) | (-b - 1))
        //   = -(((-a - 1) | (-b - 1)) + 1)

        </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> a_borrow: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> b_borrow: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">var</span> r_carry: <span class="tok-type">u1</span> = <span class="tok-number">1</span>;

        <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(a[i], a_borrow);
            a_borrow = ov1[<span class="tok-number">1</span>];
            <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@subWithOverflow</span>(b[i], b_borrow);
            b_borrow = ov2[<span class="tok-number">1</span>];
            <span class="tok-kw">const</span> ov3 = <span class="tok-builtin">@addWithOverflow</span>(ov1[<span class="tok-number">0</span>] | ov2[<span class="tok-number">0</span>], r_carry);
            r[i] = ov3[<span class="tok-number">0</span>];
            r_carry = ov3[<span class="tok-number">1</span>];
        }<span class="tok-comment">

        // b is at least 1, so this should never underflow.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(b_borrow == <span class="tok-number">0</span>);<span class="tok-comment"> // b was 0

        // With b = 0 and b_borrow = 0 we get (-a - 1) | (0 - 0) = (-a - 1) | 0 = -a - 1.
        </span><span class="tok-kw">while</span> (i &lt; a.len) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(a[i], a_borrow);
            a_borrow = ov1[<span class="tok-number">1</span>];
            <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@addWithOverflow</span>(ov1[<span class="tok-number">0</span>], r_carry);
            r[i] = ov2[<span class="tok-number">0</span>];
            r_carry = ov2[<span class="tok-number">1</span>];
        }

        <a href="std.debug.html#std.debug.assert">assert</a>(a_borrow == <span class="tok-number">0</span>);<span class="tok-comment"> // a was 0.

        // The final addition can overflow here, so we need to keep that in mind.
        </span>r[i] = r_carry;

        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
}<span class="tok-comment">

// r = a ^ b with 2s complement semantics.
// r may alias.
// a and b must not be -0.
// Returns `true` when the result is positive.
// If the sign of a and b is equal, then r requires at least `@max(a.len, b.len)` limbs are required.
// Otherwise, r requires at least `@max(a.len, b.len) + 1` limbs.
</span><span class="tok-kw">fn</span> <span class="tok-fn">llsignedxor</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, a_positive: <span class="tok-type">bool</span>, b: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b_positive: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len != <span class="tok-number">0</span> <span class="tok-kw">and</span> b.len != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= a.len);
    <a href="std.debug.html#std.debug.assert">assert</a>(a.len &gt;= b.len);<span class="tok-comment">

    // If a and b are positive, the result is positive and r = a ^ b.
    // If a negative, b positive, result is negative and we have
    // r = --(--a ^ b)
    //   = --(~(-a - 1) ^ b)
    //   = -(~(~(-a - 1) ^ b) + 1)
    //   = -(((-a - 1) ^ b) + 1)
    // Same if a is positive and b is negative, sides switched.
    // If both a and b are negative, the result is positive and we have
    // r = (--a) ^ (--b)
    //   = ~(-a - 1) ^ ~(-b - 1)
    //   = (-a - 1) ^ (-b - 1)
    // These operations can be made more generic as follows:
    // - If a is negative, subtract 1 from |a| before the xor.
    // - If b is negative, subtract 1 from |b| before the xor.
    // - if the result is supposed to be negative, add 1.

    </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> a_borrow = <span class="tok-builtin">@intFromBool</span>(!a_positive);
    <span class="tok-kw">var</span> b_borrow = <span class="tok-builtin">@intFromBool</span>(!b_positive);
    <span class="tok-kw">var</span> r_carry = <span class="tok-builtin">@intFromBool</span>(a_positive != b_positive);

    <span class="tok-kw">while</span> (i &lt; b.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(a[i], a_borrow);
        a_borrow = ov1[<span class="tok-number">1</span>];
        <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@subWithOverflow</span>(b[i], b_borrow);
        b_borrow = ov2[<span class="tok-number">1</span>];
        <span class="tok-kw">const</span> ov3 = <span class="tok-builtin">@addWithOverflow</span>(ov1[<span class="tok-number">0</span>] ^ ov2[<span class="tok-number">0</span>], r_carry);
        r[i] = ov3[<span class="tok-number">0</span>];
        r_carry = ov3[<span class="tok-number">1</span>];
    }

    <span class="tok-kw">while</span> (i &lt; a.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> ov1 = <span class="tok-builtin">@subWithOverflow</span>(a[i], a_borrow);
        a_borrow = ov1[<span class="tok-number">1</span>];
        <span class="tok-kw">const</span> ov2 = <span class="tok-builtin">@addWithOverflow</span>(ov1[<span class="tok-number">0</span>], r_carry);
        r[i] = ov2[<span class="tok-number">0</span>];
        r_carry = ov2[<span class="tok-number">1</span>];
    }<span class="tok-comment">

    // If both inputs don't share the same sign, an extra limb is required.
    </span><span class="tok-kw">if</span> (a_positive != b_positive) {
        r[i] = r_carry;
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(r_carry == <span class="tok-number">0</span>);
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(a_borrow == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(b_borrow == <span class="tok-number">0</span>);

    <span class="tok-kw">return</span> a_positive == b_positive;
}

<span class="tok-comment">/// r MUST NOT alias x.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llsquareBasecase</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, x: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<a href="std.math.big.int.html#std.math.big.int.debug_safety">debug_safety</a>);

    <span class="tok-kw">const</span> x_norm = x;
    <a href="std.debug.html#std.debug.assert">assert</a>(r.len &gt;= <span class="tok-number">2</span> * x_norm.len + <span class="tok-number">1</span>);<span class="tok-comment">

    // Compute the square of a N-limb bigint with only (N^2 + N)/2
    // multiplications by exploiting the symmetry of the coefficients around the
    // diagonal:
    //
    //           a   b   c *
    //           a   b   c =
    // -------------------
    //          ca  cb  cc +
    //      ba  bb  bc     +
    //  aa  ab  ac
    //
    // Note that:
    //  - Each mixed-product term appears twice for each column,
    //  - Squares are always in the 2k (0 &lt;= k &lt; N) column

    </span><span class="tok-kw">for</span> (x_norm, <span class="tok-number">0</span>..) |v, i| {<span class="tok-comment">
        // Accumulate all the x[i]*x[j] (with x!=j) products
        </span><span class="tok-kw">const</span> overflow = <a href="std.math.big.int.html#std.math.big.int.llmulLimb">llmulLimb</a>(.add, r[<span class="tok-number">2</span> * i + <span class="tok-number">1</span> ..], x_norm[i + <span class="tok-number">1</span> ..], v);
        <a href="std.debug.html#std.debug.assert">assert</a>(!overflow);
    }<span class="tok-comment">

    // Each product appears twice, multiply by 2
    </span><a href="std.math.big.int.html#std.math.big.int.llshl">llshl</a>(r, r[<span class="tok-number">0</span> .. <span class="tok-number">2</span> * x_norm.len], <span class="tok-number">1</span>);

    <span class="tok-kw">for</span> (x_norm, <span class="tok-number">0</span>..) |v, i| {<span class="tok-comment">
        // Compute and add the squares
        </span><span class="tok-kw">const</span> overflow = <a href="std.math.big.int.html#std.math.big.int.llmulLimb">llmulLimb</a>(.add, r[<span class="tok-number">2</span> * i ..], x[i..][<span class="tok-number">0</span>..<span class="tok-number">1</span>], v);
        <a href="std.debug.html#std.debug.assert">assert</a>(!overflow);
    }
}

<span class="tok-comment">/// Knuth 4.6.3</span>
<span class="tok-kw">fn</span> <span class="tok-fn">llpow</span>(r: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>, a: []<span class="tok-kw">const</span> <a href="std.math.big.html#std.math.big.Limb">Limb</a>, b: <span class="tok-type">u32</span>, tmp_limbs: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> tmp1: []<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> tmp2: []<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;<span class="tok-comment">

    // Multiplication requires no aliasing between the operand and the result
    // variable, use the output limbs and another temporary set to overcome this
    // limitation.
    // The initial assignment makes the result end in `r` so an extra memory
    // copy is saved, each 1 flips the index twice so it's only the zeros that
    // matter.
    </span><span class="tok-kw">const</span> b_leading_zeros = <span class="tok-builtin">@clz</span>(b);
    <span class="tok-kw">const</span> exp_zeros = <span class="tok-builtin">@popCount</span>(~b) - b_leading_zeros;
    <span class="tok-kw">if</span> (exp_zeros &amp; <span class="tok-number">1</span> != <span class="tok-number">0</span>) {
        tmp1 = tmp_limbs;
        tmp2 = r;
    } <span class="tok-kw">else</span> {
        tmp1 = r;
        tmp2 = tmp_limbs;
    }

    <span class="tok-builtin">@memcpy</span>(tmp1[<span class="tok-number">0</span>..a.len], a);
    <span class="tok-builtin">@memset</span>(tmp1[a.len..], <span class="tok-number">0</span>);<span class="tok-comment">

    // Scan the exponent as a binary number, from left to right, dropping the
    // most significant bit set.
    // Square the result if the current bit is zero, square and multiply by a if
    // it is one.
    </span><span class="tok-kw">const</span> exp_bits = <span class="tok-number">32</span> - <span class="tok-number">1</span> - b_leading_zeros;
    <span class="tok-kw">var</span> exp = b &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u5</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-number">1</span> + b_leading_zeros));

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; exp_bits) : (i += <span class="tok-number">1</span>) {<span class="tok-comment">
        // Square
        </span><span class="tok-builtin">@memset</span>(tmp2, <span class="tok-number">0</span>);
        <a href="std.math.big.int.html#std.math.big.int.llsquareBasecase">llsquareBasecase</a>(tmp2, tmp1[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(tmp1)]);
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>([]<a href="std.math.big.html#std.math.big.Limb">Limb</a>, &amp;tmp1, &amp;tmp2);<span class="tok-comment">
        // Multiply by a
        </span><span class="tok-kw">const</span> ov = <span class="tok-builtin">@shlWithOverflow</span>(exp, <span class="tok-number">1</span>);
        exp = ov[<span class="tok-number">0</span>];
        <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
            <span class="tok-builtin">@memset</span>(tmp2, <span class="tok-number">0</span>);
            <a href="std.math.big.int.html#std.math.big.int.llmulacc">llmulacc</a>(.add, <span class="tok-null">null</span>, tmp2, tmp1[<span class="tok-number">0</span>..<a href="std.math.big.int.html#std.math.big.int.llnormalize">llnormalize</a>(tmp1)], a);
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>([]<a href="std.math.big.html#std.math.big.Limb">Limb</a>, &amp;tmp1, &amp;tmp2);
        }
    }
}<span class="tok-comment">

// Storage must live for the lifetime of the returned value
</span><span class="tok-kw">fn</span> <span class="tok-fn">fixedIntFromSignedDoubleLimb</span>(A: <a href="std.math.big.html#std.math.big.SignedDoubleLimb">SignedDoubleLimb</a>, storage: []<a href="std.math.big.html#std.math.big.Limb">Limb</a>) <a href="std.math.big.int.Mutable.html">Mutable</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(storage.len &gt;= <span class="tok-number">2</span>);

    <span class="tok-kw">const</span> A_is_positive = A &gt;= <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> Au = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.DoubleLimb">DoubleLimb</a>, <span class="tok-builtin">@intCast</span>(<span class="tok-kw">if</span> (A &lt; <span class="tok-number">0</span>) -A <span class="tok-kw">else</span> A));
    storage[<span class="tok-number">0</span>] = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(Au));
    storage[<span class="tok-number">1</span>] = <span class="tok-builtin">@as</span>(<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(Au &gt;&gt; <a href="std.math.big.int.html#std.math.big.int.limb_bits">limb_bits</a>));
    <span class="tok-kw">return</span> .{
        .limbs = storage[<span class="tok-number">0</span>..<span class="tok-number">2</span>],
        .positive = A_is_positive,
        .len = <span class="tok-number">2</span>,
    };
}

<span class="tok-kw">test</span> {
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;int_test.zig&quot;</span>);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
