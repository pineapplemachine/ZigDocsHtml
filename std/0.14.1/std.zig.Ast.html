<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.Ast.html" class="active">Ast</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.Ast" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zig.Ast</span><a href="#src.zig-std.zig.Ast">[src]</a></h1><div class="tldDocs"><p>Abstract Syntax Tree for Zig source code.
For Zig syntax, the root node is at nodes[0] and contains the list of
sub-nodes.
For Zon syntax, the root node is at nodes[0] and contains lhs as the node
index of the main expression.
Reference to externally-owned data.</p>
</div><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.zig.Ast.full.html">std.zig.Ast.full</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.zig.Ast.Location.html">std.zig.Ast.Location</a></li><li><a href="std.zig.Ast.Span.html">std.zig.Ast.Span</a></li><li><a href="std.zig.Ast.Mode.html">std.zig.Ast.Mode</a></li><li><a href="std.zig.render.Fixups.html">std.zig.render.Fixups</a></li><li><a href="std.zig.Ast.Error.html">std.zig.Ast.Error</a></li><li><a href="std.zig.Ast.Node.html">std.zig.Ast.Node</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.zig.Ast.TokenIndex" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">TokenIndex</span><a href="#src.zig-std.zig.Ast.TokenIndex">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.TokenIndex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TokenIndex = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.ByteOffset" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">ByteOffset</span><a href="#src.zig-std.zig.Ast.ByteOffset">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.ByteOffset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ByteOffset = <span class="tok-type">u32</span></code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.TokenList" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">TokenList</span><a href="#src.zig-std.zig.Ast.TokenList">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.TokenList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TokenList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<span class="tok-kw">struct</span> {
    tag: <a href="std.zig.tokenizer.Token.html">Token</a>.<a href="std.zig.tokenizer.Token.Tag.html">Tag</a>,
    start: <a href="std.zig.Ast.html#std.zig.Ast.ByteOffset">ByteOffset</a>,
})</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.NodeList" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">NodeList</span><a href="#src.zig-std.zig.Ast.NodeList">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.NodeList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NodeList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.Ast.Node.html">Node</a>)</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre><div class="fieldDocs"><p>Reference to externally-owned data.</p>
</div></div><div><pre><code>tokens: <a href="std.zig.Ast.html#std.zig.Ast.TokenList">TokenList</a>.<a href="#">Slice</a></code></pre></div><div><pre><code>nodes: <a href="std.zig.Ast.html#std.zig.Ast.NodeList">NodeList</a>.<a href="#">Slice</a></code></pre><div class="fieldDocs"><p>The root AST node is assumed to be index 0. Since there can be no
references to the root node, this means 0 is available to indicate null.</p>
</div></div><div><pre><code>extra_data: []<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>mode: <a href="std.zig.Ast.Mode.html">Mode</a> = .zig</code></pre></div><div><pre><code>errors: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Error.html">Error</a></code></pre></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.zig.Ast.RenderError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RenderError</span><a href="#src.zig-std.zig.Ast.RenderError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory</dt><dd><p>Ran out of memory allocating call stack frames to complete rendering, or
ran out of memory allocating space in the output buffer.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.RenderError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenderError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Ran out of memory allocating call stack frames to complete rendering, or</span>
    <span class="tok-comment">/// ran out of memory allocating space in the output buffer.</span>
    OutOfMemory,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.zig.Ast.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.zig.Ast.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(tree: *<a href="std.zig.Ast.html">Ast</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: *<a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(tree: *<a href="std.zig.Ast.html">Ast</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    tree.tokens.deinit(gpa);
    tree.nodes.deinit(gpa);
    gpa.free(tree.extra_data);
    gpa.free(tree.errors);
    tree.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.parse" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parse</span><a href="#src.zig-std.zig.Ast.parse">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.zig.Ast.Mode.html">Mode</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.Ast.html">Ast</a></code></pre></div><div class="tldDocs"><p>Result should be freed with tree.deinit() when there are
no more references to any of the tokens or nodes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <a href="std.zig.Ast.Mode.html">Mode</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.parse">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.zig.Ast.Mode.html">Mode</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.Ast.html">Ast</a> {
    <span class="tok-kw">var</span> tokens = <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenList">TokenList</a>{};
    <span class="tok-kw">defer</span> tokens.deinit(gpa);<span class="tok-comment">

    // Empirically, the zig std lib has an 8:1 ratio of source bytes to token count.
    </span><span class="tok-kw">const</span> estimated_token_count = source.len / <span class="tok-number">8</span>;
    <span class="tok-kw">try</span> tokens.ensureTotalCapacity(gpa, estimated_token_count);

    <span class="tok-kw">var</span> tokenizer = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.tokenizer.Tokenizer.html">Tokenizer</a>.<a href="std.zig.tokenizer.Tokenizer.html#std.zig.tokenizer.Tokenizer.init">init</a>(source);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> token = tokenizer.next();
        <span class="tok-kw">try</span> tokens.append(gpa, .{
            .tag = token.tag,
            .start = <span class="tok-builtin">@intCast</span>(token.loc.start),
        });
        <span class="tok-kw">if</span> (token.tag == .eof) <span class="tok-kw">break</span>;
    }

    <span class="tok-kw">var</span> parser: <a href="std.zig.Parse.html">Parse</a> = .{
        .source = source,
        .gpa = gpa,
        .token_tags = tokens.items(.tag),
        .token_starts = tokens.items(.start),
        .errors = .{},
        .nodes = .{},
        .extra_data = .{},
        .scratch = .{},
        .tok_i = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">defer</span> parser.errors.deinit(gpa);
    <span class="tok-kw">defer</span> parser.nodes.deinit(gpa);
    <span class="tok-kw">defer</span> parser.extra_data.deinit(gpa);
    <span class="tok-kw">defer</span> parser.scratch.deinit(gpa);<span class="tok-comment">

    // Empirically, Zig source code has a 2:1 ratio of tokens to AST nodes.
    // Make sure at least 1 so we can use appendAssumeCapacity on the root node below.
    </span><span class="tok-kw">const</span> estimated_node_count = (tokens.len + <span class="tok-number">2</span>) / <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> parser.nodes.ensureTotalCapacity(gpa, estimated_node_count);

    <span class="tok-kw">switch</span> (mode) {
        .zig =&gt; <span class="tok-kw">try</span> parser.parseRoot(),
        .zon =&gt; <span class="tok-kw">try</span> parser.parseZon(),
    }

    <span class="tok-kw">const</span> extra_data = <span class="tok-kw">try</span> parser.extra_data.toOwnedSlice(gpa);
    <span class="tok-kw">errdefer</span> gpa.free(extra_data);
    <span class="tok-kw">const</span> errors = <span class="tok-kw">try</span> parser.errors.toOwnedSlice(gpa);
    <span class="tok-kw">errdefer</span> gpa.free(errors);<span class="tok-comment">

    // TODO experiment with compacting the MultiArrayList slices here
    </span><span class="tok-kw">return</span> <a href="std.zig.Ast.html">Ast</a>{
        .source = source,
        .mode = mode,
        .tokens = tokens.toOwnedSlice(),
        .nodes = parser.nodes.toOwnedSlice(),
        .extra_data = extra_data,
        .errors = errors,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.render" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">render</span><a href="#src.zig-std.zig.Ast.render">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">render</span>(tree: <a href="std.zig.Ast.html">Ast</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.zig.Ast.html#std.zig.Ast.RenderError">RenderError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p><code>gpa</code> is used for allocating the resulting formatted source code.
Caller owns the returned slice of bytes, allocated with <code>gpa</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.render">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">render</span>(tree: <a href="std.zig.Ast.html">Ast</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.zig.Ast.html#std.zig.Ast.RenderError">RenderError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> buffer = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(gpa);
    <span class="tok-kw">defer</span> buffer.deinit();

    <span class="tok-kw">try</span> tree.renderToArrayList(&amp;buffer, .{});
    <span class="tok-kw">return</span> buffer.toOwnedSlice();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.renderToArrayList" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renderToArrayList</span><a href="#src.zig-std.zig.Ast.renderToArrayList">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToArrayList</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), fixups: <a href="std.zig.render.Fixups.html">Fixups</a>) <a href="std.zig.Ast.html#std.zig.Ast.RenderError">RenderError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>fixups: <a href="std.zig.render.Fixups.html">Fixups</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.renderToArrayList">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToArrayList</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), fixups: <a href="std.zig.render.Fixups.html">Fixups</a>) <a href="std.zig.Ast.html#std.zig.Ast.RenderError">RenderError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./render.zig&quot;</span>).renderTree(buffer, tree, fixups);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.errorOffset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">errorOffset</span><a href="#src.zig-std.zig.Ast.errorOffset">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorOffset</span>(tree: <a href="std.zig.Ast.html">Ast</a>, parse_error: <a href="std.zig.Ast.Error.html">Error</a>) <span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Returns an extra offset for column and byte offset of errors that
should point after the token in the error message.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>parse_error: <a href="std.zig.Ast.Error.html">Error</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.errorOffset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorOffset</span>(tree: <a href="std.zig.Ast.html">Ast</a>, parse_error: <a href="std.zig.Ast.Error.html">Error</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (parse_error.token_is_prev)
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(tree.tokenSlice(parse_error.token).len))
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.tokenLocation" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tokenLocation</span><a href="#src.zig-std.zig.Ast.tokenLocation">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenLocation</span>(self: <a href="std.zig.Ast.html">Ast</a>, start_offset: <a href="std.zig.Ast.html#std.zig.Ast.ByteOffset">ByteOffset</a>, token_index: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Location.html">Location</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>start_offset: <a href="std.zig.Ast.html#std.zig.Ast.ByteOffset">ByteOffset</a></code></pre></div><div><pre><code>token_index: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.tokenLocation">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenLocation</span>(self: <a href="std.zig.Ast.html">Ast</a>, start_offset: <a href="std.zig.Ast.html#std.zig.Ast.ByteOffset">ByteOffset</a>, token_index: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Location.html">Location</a> {
    <span class="tok-kw">var</span> loc = <a href="std.zig.Ast.Location.html">Location</a>{
        .line = <span class="tok-number">0</span>,
        .column = <span class="tok-number">0</span>,
        .line_start = start_offset,
        .line_end = self.source.len,
    };
    <span class="tok-kw">const</span> token_start = self.tokens.items(.start)[token_index];<span class="tok-comment">

    // Scan to by line until we go past the token start
    </span><span class="tok-kw">while</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(<span class="tok-type">u8</span>, self.source, loc.line_start, <span class="tok-str">'\n'</span>)) |i| {
        <span class="tok-kw">if</span> (i &gt;= token_start) {
            <span class="tok-kw">break</span>;<span class="tok-comment"> // Went past
        </span>}
        loc.line += <span class="tok-number">1</span>;
        loc.line_start = i + <span class="tok-number">1</span>;
    }

    <span class="tok-kw">const</span> offset = loc.line_start;
    <span class="tok-kw">for</span> (self.source[offset..], <span class="tok-number">0</span>..) |c, i| {
        <span class="tok-kw">if</span> (i + offset == token_start) {
            loc.line_end = i + offset;
            <span class="tok-kw">while</span> (loc.line_end &lt; self.source.len <span class="tok-kw">and</span> self.source[loc.line_end] != <span class="tok-str">'\n'</span>) {
                loc.line_end += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span> loc;
        }
        <span class="tok-kw">if</span> (c == <span class="tok-str">'\n'</span>) {
            loc.line += <span class="tok-number">1</span>;
            loc.column = <span class="tok-number">0</span>;
            loc.line_start = i + <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            loc.column += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> loc;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.tokenSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tokenSlice</span><a href="#src.zig-std.zig.Ast.tokenSlice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenSlice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, token_index: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>token_index: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.tokenSlice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenSlice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, token_index: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> token_tag = token_tags[token_index];<span class="tok-comment">

    // Many tokens can be determined entirely by their tag.
    </span><span class="tok-kw">if</span> (token_tag.lexeme()) |lexeme| {
        <span class="tok-kw">return</span> lexeme;
    }<span class="tok-comment">

    // For some tokens, re-tokenization is needed to find the end.
    </span><span class="tok-kw">var</span> tokenizer: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.tokenizer.Tokenizer.html">Tokenizer</a> = .{
        .buffer = tree.source,
        .index = token_starts[token_index],
    };
    <span class="tok-kw">const</span> token = tokenizer.next();
    <a href="std.debug.html#std.debug.assert">assert</a>(token.tag == token_tag);
    <span class="tok-kw">return</span> tree.source[token.loc.start..token.loc.end];
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.extraData" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">extraData</span><a href="#src.zig-std.zig.Ast.extraData">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extraData</span>(tree: <a href="std.zig.Ast.html">Ast</a>, index: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.extraData">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extraData</span>(tree: <a href="std.zig.Ast.html">Ast</a>, index: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">const</span> fields = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(T);
    <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields, <span class="tok-number">0</span>..) |field, i| {
        <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(field.<span class="tok-type">type</span> == <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>);
        <span class="tok-builtin">@field</span>(result, field.name) = tree.extra_data[index + i];
    }
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.rootDecls" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rootDecls</span><a href="#src.zig-std.zig.Ast.rootDecls">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rootDecls</span>(tree: <a href="std.zig.Ast.html">Ast</a>) []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.rootDecls">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rootDecls</span>(tree: <a href="std.zig.Ast.html">Ast</a>) []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> {
    <span class="tok-kw">const</span> nodes_data = tree.nodes.items(.data);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.mode) {
        .zig =&gt; tree.extra_data[nodes_data[<span class="tok-number">0</span>].lhs..nodes_data[<span class="tok-number">0</span>].rhs],
        .zon =&gt; (&amp;nodes_data[<span class="tok-number">0</span>].lhs)[<span class="tok-number">0</span>..<span class="tok-number">1</span>],
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.renderError" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renderError</span><a href="#src.zig-std.zig.Ast.renderError">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderError</span>(tree: <a href="std.zig.Ast.html">Ast</a>, parse_error: <a href="std.zig.Ast.Error.html">Error</a>, stream: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>parse_error: <a href="std.zig.Ast.Error.html">Error</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.renderError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderError</span>(tree: <a href="std.zig.Ast.html">Ast</a>, parse_error: <a href="std.zig.Ast.Error.html">Error</a>, stream: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">switch</span> (parse_error.tag) {
        .asterisk_after_ptr_deref =&gt; {<span class="tok-comment">
            // Note that the token will point at the `.*` but ideally the source
            // location would point to the `*` after the `.*`.
            </span><span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;'.*' cannot be followed by '*'. Are you missing a space?&quot;</span>);
        },
        .chained_comparison_operators =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;comparison operators cannot be chained&quot;</span>);
        },
        .decl_between_fields =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;declarations are not allowed between container fields&quot;</span>);
        },
        .expected_block =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected block, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_block_or_assignment =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected block or assignment, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_block_or_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected block or expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_block_or_field =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected block or field, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_container_members =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected test, comptime, var decl, or container field, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token].symbol(),
            });
        },
        .expected_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_expr_or_assignment =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected expression or assignment, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_expr_or_var_decl =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected expression or var decl, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_fn =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected function, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_inlinable =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected 'while' or 'for', found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_labelable =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected 'while', 'for', 'inline', or '{{', found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_param_list =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected parameter list, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_prefix_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected prefix expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_primary_type_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected primary type expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_pub_item =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected function or variable declaration after pub&quot;</span>);
        },
        .expected_return_type =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected return type expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_semi_or_else =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ';' or 'else' after statement&quot;</span>);
        },
        .expected_semi_or_lbrace =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ';' or block after function prototype&quot;</span>);
        },
        .expected_statement =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected statement, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token].symbol(),
            });
        },
        .expected_suffix_op =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected pointer dereference, optional unwrap, or field access, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_type_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected type expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_var_decl =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected variable declaration, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_var_decl_or_fn =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected variable declaration or function, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_loop_payload =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected loop payload, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_container =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected a struct, enum or union, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .extern_fn_body =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extern functions have no body&quot;</span>);
        },
        .extra_addrspace_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra addrspace qualifier&quot;</span>);
        },
        .extra_align_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra align qualifier&quot;</span>);
        },
        .extra_allowzero_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra allowzero qualifier&quot;</span>);
        },
        .extra_const_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra const qualifier&quot;</span>);
        },
        .extra_volatile_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra volatile qualifier&quot;</span>);
        },
        .ptr_mod_on_array_child_type =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;pointer modifier '{s}' not allowed on array child type&quot;</span>, .{
                token_tags[parse_error.token].symbol(),
            });
        },
        .invalid_bit_range =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;bit range not allowed on slices and arrays&quot;</span>);
        },
        .same_line_doc_comment =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;same line documentation comment&quot;</span>);
        },
        .unattached_doc_comment =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;unattached documentation comment&quot;</span>);
        },
        .test_doc_comment =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;documentation comments cannot be attached to tests&quot;</span>);
        },
        .comptime_doc_comment =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;documentation comments cannot be attached to comptime blocks&quot;</span>);
        },
        .varargs_nonfinal =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;function prototype has parameter after varargs&quot;</span>);
        },
        .expected_continue_expr =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ':' before while continue expression&quot;</span>);
        },

        .expected_semi_after_decl =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ';' after declaration&quot;</span>);
        },
        .expected_semi_after_stmt =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ';' after statement&quot;</span>);
        },
        .expected_comma_after_field =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after field&quot;</span>);
        },
        .expected_comma_after_arg =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after argument&quot;</span>);
        },
        .expected_comma_after_param =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after parameter&quot;</span>);
        },
        .expected_comma_after_initializer =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after initializer&quot;</span>);
        },
        .expected_comma_after_switch_prong =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after switch prong&quot;</span>);
        },
        .expected_comma_after_for_operand =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after for operand&quot;</span>);
        },
        .expected_comma_after_capture =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after for capture&quot;</span>);
        },
        .expected_initializer =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected field initializer&quot;</span>);
        },
        .mismatched_binary_op_whitespace =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;binary operator `{s}` has whitespace on one side, but not the other.&quot;</span>, .{token_tags[parse_error.token].lexeme().?});
        },
        .invalid_ampersand_ampersand =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;ambiguous use of '&amp;&amp;'; use 'and' for logical AND, or change whitespace to ' &amp; &amp;' for bitwise AND&quot;</span>);
        },
        .c_style_container =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;'{s} {s}' is invalid&quot;</span>, .{
                parse_error.extra.expected_tag.symbol(), tree.tokenSlice(parse_error.token),
            });
        },
        .zig_style_container =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;to declare a container do 'const {s} = {s}'&quot;</span>, .{
                tree.tokenSlice(parse_error.token), parse_error.extra.expected_tag.symbol(),
            });
        },
        .previous_field =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;field before declarations here&quot;</span>);
        },
        .next_field =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;field after declarations here&quot;</span>);
        },
        .expected_var_const =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected 'var' or 'const' before variable declaration&quot;</span>);
        },
        .wrong_equal_var_decl =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;variable initialized with '==' instead of '='&quot;</span>);
        },
        .var_const_decl =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;use 'var' or 'const' to declare variable&quot;</span>);
        },
        .extra_for_capture =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra capture in for loop&quot;</span>);
        },
        .for_input_not_captured =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;for input is not captured&quot;</span>);
        },

        .invalid_byte =&gt; {
            <span class="tok-kw">const</span> tok_slice = tree.source[tree.tokens.items(.start)[parse_error.token]..];
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;{s} contains invalid byte: '{'}'&quot;</span>, .{
                <span class="tok-kw">switch</span> (tok_slice[<span class="tok-number">0</span>]) {
                    <span class="tok-str">'\''</span> =&gt; <span class="tok-str">&quot;character literal&quot;</span>,
                    <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\\'</span> =&gt; <span class="tok-str">&quot;string literal&quot;</span>,
                    <span class="tok-str">'/'</span> =&gt; <span class="tok-str">&quot;comment&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                },
                <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.fmtEscapes">fmtEscapes</a>(tok_slice[parse_error.extra.offset..][<span class="tok-number">0</span>..<span class="tok-number">1</span>]),
            });
        },

        .expected_token =&gt; {
            <span class="tok-kw">const</span> found_tag = token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)];
            <span class="tok-kw">const</span> expected_symbol = parse_error.extra.expected_tag.symbol();
            <span class="tok-kw">switch</span> (found_tag) {
                .invalid =&gt; <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected '{s}', found invalid bytes&quot;</span>, .{
                    expected_symbol,
                }),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected '{s}', found '{s}'&quot;</span>, .{
                    expected_symbol, found_tag.symbol(),
                }),
            }
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.firstToken" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">firstToken</span><a href="#src.zig-std.zig.Ast.firstToken">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstToken</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.firstToken">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstToken</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> {
    <span class="tok-kw">const</span> tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> end_offset: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> n = node;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (tags[n]) {
        .root =&gt; <span class="tok-kw">return</span> <span class="tok-number">0</span>,

        .test_decl,
        .@&quot;errdefer&quot;,
        .@&quot;defer&quot;,
        .bool_not,
        .negation,
        .bit_not,
        .negation_wrap,
        .address_of,
        .@&quot;try&quot;,
        .@&quot;await&quot;,
        .optional_type,
        .@&quot;switch&quot;,
        .switch_comma,
        .if_simple,
        .@&quot;if&quot;,
        .@&quot;suspend&quot;,
        .@&quot;resume&quot;,
        .@&quot;continue&quot;,
        .@&quot;break&quot;,
        .@&quot;return&quot;,
        .anyframe_type,
        .identifier,
        .anyframe_literal,
        .char_literal,
        .number_literal,
        .unreachable_literal,
        .string_literal,
        .multiline_string_literal,
        .grouped_expression,
        .builtin_call_two,
        .builtin_call_two_comma,
        .builtin_call,
        .builtin_call_comma,
        .error_set_decl,
        .@&quot;comptime&quot;,
        .@&quot;nosuspend&quot;,
        .asm_simple,
        .@&quot;asm&quot;,
        .array_type,
        .array_type_sentinel,
        .error_value,
        =&gt; <span class="tok-kw">return</span> main_tokens[n] - end_offset,

        .array_init_dot,
        .array_init_dot_comma,
        .array_init_dot_two,
        .array_init_dot_two_comma,
        .struct_init_dot,
        .struct_init_dot_comma,
        .struct_init_dot_two,
        .struct_init_dot_two_comma,
        .enum_literal,
        =&gt; <span class="tok-kw">return</span> main_tokens[n] - <span class="tok-number">1</span> - end_offset,

        .@&quot;catch&quot;,
        .field_access,
        .unwrap_optional,
        .equal_equal,
        .bang_equal,
        .less_than,
        .greater_than,
        .less_or_equal,
        .greater_or_equal,
        .assign_mul,
        .assign_div,
        .assign_mod,
        .assign_add,
        .assign_sub,
        .assign_shl,
        .assign_shl_sat,
        .assign_shr,
        .assign_bit_and,
        .assign_bit_xor,
        .assign_bit_or,
        .assign_mul_wrap,
        .assign_add_wrap,
        .assign_sub_wrap,
        .assign_mul_sat,
        .assign_add_sat,
        .assign_sub_sat,
        .assign,
        .merge_error_sets,
        .mul,
        .div,
        .mod,
        .array_mult,
        .mul_wrap,
        .mul_sat,
        .add,
        .sub,
        .array_cat,
        .add_wrap,
        .sub_wrap,
        .add_sat,
        .sub_sat,
        .shl,
        .shl_sat,
        .shr,
        .bit_and,
        .bit_xor,
        .bit_or,
        .@&quot;orelse&quot;,
        .bool_and,
        .bool_or,
        .slice_open,
        .slice,
        .slice_sentinel,
        .deref,
        .array_access,
        .array_init_one,
        .array_init_one_comma,
        .array_init,
        .array_init_comma,
        .struct_init_one,
        .struct_init_one_comma,
        .struct_init,
        .struct_init_comma,
        .call_one,
        .call_one_comma,
        .call,
        .call_comma,
        .switch_range,
        .for_range,
        .error_union,
        =&gt; n = datas[n].lhs,

        .assign_destructure =&gt; {
            <span class="tok-kw">const</span> extra_idx = datas[n].lhs;
            <span class="tok-kw">const</span> lhs_len = tree.extra_data[extra_idx];
            <a href="std.debug.html#std.debug.assert">assert</a>(lhs_len &gt; <span class="tok-number">0</span>);
            n = tree.extra_data[extra_idx + <span class="tok-number">1</span>];
        },

        .fn_decl,
        .fn_proto_simple,
        .fn_proto_multi,
        .fn_proto_one,
        .fn_proto,
        =&gt; {
            <span class="tok-kw">var</span> i = main_tokens[n];<span class="tok-comment"> // fn token
            </span><span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
                i -= <span class="tok-number">1</span>;
                <span class="tok-kw">switch</span> (token_tags[i]) {
                    .keyword_extern,
                    .keyword_export,
                    .keyword_pub,
                    .keyword_inline,
                    .keyword_noinline,
                    .string_literal,
                    =&gt; <span class="tok-kw">continue</span>,

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> i + <span class="tok-number">1</span> - end_offset,
                }
            }
            <span class="tok-kw">return</span> i - end_offset;
        },

        .@&quot;usingnamespace&quot; =&gt; {
            <span class="tok-kw">const</span> main_token = main_tokens[n];
            <span class="tok-kw">if</span> (main_token &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[main_token - <span class="tok-number">1</span>] == .keyword_pub) {
                end_offset += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span> main_token - end_offset;
        },

        .async_call_one,
        .async_call_one_comma,
        .async_call,
        .async_call_comma,
        =&gt; {
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // async token
            </span>n = datas[n].lhs;
        },

        .container_field_init,
        .container_field_align,
        .container_field,
        =&gt; {
            <span class="tok-kw">const</span> name_token = main_tokens[n];
            <span class="tok-kw">if</span> (name_token &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[name_token - <span class="tok-number">1</span>] == .keyword_comptime) {
                end_offset += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span> name_token - end_offset;
        },

        .global_var_decl,
        .local_var_decl,
        .simple_var_decl,
        .aligned_var_decl,
        =&gt; {
            <span class="tok-kw">var</span> i = main_tokens[n];<span class="tok-comment"> // mut token
            </span><span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
                i -= <span class="tok-number">1</span>;
                <span class="tok-kw">switch</span> (token_tags[i]) {
                    .keyword_extern,
                    .keyword_export,
                    .keyword_comptime,
                    .keyword_pub,
                    .keyword_threadlocal,
                    .string_literal,
                    =&gt; <span class="tok-kw">continue</span>,

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> i + <span class="tok-number">1</span> - end_offset,
                }
            }
            <span class="tok-kw">return</span> i - end_offset;
        },

        .block,
        .block_semicolon,
        .block_two,
        .block_two_semicolon,
        =&gt; {<span class="tok-comment">
            // Look for a label.
            </span><span class="tok-kw">const</span> lbrace = main_tokens[n];
            <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span>
                token_tags[lbrace - <span class="tok-number">2</span>] == .identifier)
            {
                end_offset += <span class="tok-number">2</span>;
            }
            <span class="tok-kw">return</span> lbrace - end_offset;
        },

        .container_decl,
        .container_decl_trailing,
        .container_decl_two,
        .container_decl_two_trailing,
        .container_decl_arg,
        .container_decl_arg_trailing,
        .tagged_union,
        .tagged_union_trailing,
        .tagged_union_two,
        .tagged_union_two_trailing,
        .tagged_union_enum_tag,
        .tagged_union_enum_tag_trailing,
        =&gt; {
            <span class="tok-kw">const</span> main_token = main_tokens[n];
            <span class="tok-kw">switch</span> (token_tags[main_token -| <span class="tok-number">1</span>]) {
                .keyword_packed, .keyword_extern =&gt; end_offset += <span class="tok-number">1</span>,
                <span class="tok-kw">else</span> =&gt; {},
            }
            <span class="tok-kw">return</span> main_token - end_offset;
        },

        .ptr_type_aligned,
        .ptr_type_sentinel,
        .ptr_type,
        .ptr_type_bit_range,
        =&gt; <span class="tok-kw">return</span> main_tokens[n] - end_offset,

        .switch_case_one =&gt; {
            <span class="tok-kw">if</span> (datas[n].lhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] - <span class="tok-number">1</span> - end_offset;<span class="tok-comment"> // else token
            </span>} <span class="tok-kw">else</span> {
                n = datas[n].lhs;
            }
        },
        .switch_case_inline_one =&gt; {
            <span class="tok-kw">if</span> (datas[n].lhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] - <span class="tok-number">2</span> - end_offset;<span class="tok-comment"> // else token
            </span>} <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <a href="std.zig.Ast.html#std.zig.Ast.firstToken">firstToken</a>(tree, datas[n].lhs) - <span class="tok-number">1</span>;
            }
        },
        .switch_case =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.end - extra.start &gt; <span class="tok-number">0</span>);
            n = tree.extra_data[extra.start];
        },
        .switch_case_inline =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.end - extra.start &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> <a href="std.zig.Ast.html#std.zig.Ast.firstToken">firstToken</a>(tree, tree.extra_data[extra.start]) - <span class="tok-number">1</span>;
        },

        .asm_output, .asm_input =&gt; {
            <a href="std.debug.html#std.debug.assert">assert</a>(token_tags[main_tokens[n] - <span class="tok-number">1</span>] == .l_bracket);
            <span class="tok-kw">return</span> main_tokens[n] - <span class="tok-number">1</span> - end_offset;
        },

        .while_simple,
        .while_cont,
        .@&quot;while&quot;,
        .for_simple,
        .@&quot;for&quot;,
        =&gt; {<span class="tok-comment">
            // Look for a label and inline.
            </span><span class="tok-kw">const</span> main_token = main_tokens[n];
            <span class="tok-kw">var</span> result = main_token;
            <span class="tok-kw">if</span> (token_tags[result -| <span class="tok-number">1</span>] == .keyword_inline) {
                result -= <span class="tok-number">1</span>;
            }
            <span class="tok-kw">if</span> (token_tags[result -| <span class="tok-number">1</span>] == .colon) {
                result -|= <span class="tok-number">2</span>;
            }
            <span class="tok-kw">return</span> result - end_offset;
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.lastToken" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lastToken</span><a href="#src.zig-std.zig.Ast.lastToken">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastToken</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.lastToken">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastToken</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> {
    <span class="tok-kw">const</span> tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> n = node;
    <span class="tok-kw">var</span> end_offset: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (tags[n]) {
        .root =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, <span class="tok-builtin">@intCast</span>(tree.tokens.len - <span class="tok-number">1</span>)),

        .@&quot;usingnamespace&quot;,
        .bool_not,
        .negation,
        .bit_not,
        .negation_wrap,
        .address_of,
        .@&quot;try&quot;,
        .@&quot;await&quot;,
        .optional_type,
        .@&quot;resume&quot;,
        .@&quot;nosuspend&quot;,
        .@&quot;comptime&quot;,
        =&gt; n = datas[n].lhs,

        .test_decl,
        .@&quot;errdefer&quot;,
        .@&quot;defer&quot;,
        .@&quot;catch&quot;,
        .equal_equal,
        .bang_equal,
        .less_than,
        .greater_than,
        .less_or_equal,
        .greater_or_equal,
        .assign_mul,
        .assign_div,
        .assign_mod,
        .assign_add,
        .assign_sub,
        .assign_shl,
        .assign_shl_sat,
        .assign_shr,
        .assign_bit_and,
        .assign_bit_xor,
        .assign_bit_or,
        .assign_mul_wrap,
        .assign_add_wrap,
        .assign_sub_wrap,
        .assign_mul_sat,
        .assign_add_sat,
        .assign_sub_sat,
        .assign,
        .assign_destructure,
        .merge_error_sets,
        .mul,
        .div,
        .mod,
        .array_mult,
        .mul_wrap,
        .mul_sat,
        .add,
        .sub,
        .array_cat,
        .add_wrap,
        .sub_wrap,
        .add_sat,
        .sub_sat,
        .shl,
        .shl_sat,
        .shr,
        .bit_and,
        .bit_xor,
        .bit_or,
        .@&quot;orelse&quot;,
        .bool_and,
        .bool_or,
        .anyframe_type,
        .error_union,
        .if_simple,
        .while_simple,
        .for_simple,
        .fn_proto_simple,
        .fn_proto_multi,
        .ptr_type_aligned,
        .ptr_type_sentinel,
        .ptr_type,
        .ptr_type_bit_range,
        .array_type,
        .switch_case_one,
        .switch_case_inline_one,
        .switch_case,
        .switch_case_inline,
        .switch_range,
        =&gt; n = datas[n].rhs,

        .for_range =&gt; <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
            n = datas[n].rhs;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> main_tokens[n] + end_offset;
        },

        .field_access,
        .unwrap_optional,
        .grouped_expression,
        .multiline_string_literal,
        .error_set_decl,
        .asm_simple,
        .asm_output,
        .asm_input,
        .error_value,
        =&gt; <span class="tok-kw">return</span> datas[n].rhs + end_offset,

        .anyframe_literal,
        .char_literal,
        .number_literal,
        .unreachable_literal,
        .identifier,
        .deref,
        .enum_literal,
        .string_literal,
        =&gt; <span class="tok-kw">return</span> main_tokens[n] + end_offset,

        .@&quot;return&quot; =&gt; <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
            n = datas[n].lhs;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> main_tokens[n] + end_offset;
        },

        .call, .async_call =&gt; {
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
            </span><span class="tok-kw">const</span> params = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <span class="tok-kw">if</span> (params.end - params.start == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
            n = tree.extra_data[params.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
        </span>},
        .tagged_union_enum_tag =&gt; {
            <span class="tok-kw">const</span> members = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <span class="tok-kw">if</span> (members.end - members.start == <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">4</span>;<span class="tok-comment"> // for the rparen + rparen + lbrace + rbrace
                </span>n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
                </span>n = tree.extra_data[members.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
            </span>}
        },
        .call_comma,
        .async_call_comma,
        .tagged_union_enum_tag_trailing,
        =&gt; {
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // for the comma/semicolon + rparen/rbrace
            </span><span class="tok-kw">const</span> params = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(params.end &gt; params.start);
            n = tree.extra_data[params.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
        </span>},
        .@&quot;switch&quot; =&gt; {
            <span class="tok-kw">const</span> cases = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <span class="tok-kw">if</span> (cases.end - cases.start == <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">3</span>;<span class="tok-comment"> // rparen, lbrace, rbrace
                </span>n = datas[n].lhs;<span class="tok-comment"> // condition expression
            </span>} <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
                </span>n = tree.extra_data[cases.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last case
            </span>}
        },
        .container_decl_arg =&gt; {
            <span class="tok-kw">const</span> members = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <span class="tok-kw">if</span> (members.end - members.start == <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">3</span>;<span class="tok-comment"> // for the rparen + lbrace + rbrace
                </span>n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
                </span>n = tree.extra_data[members.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
            </span>}
        },
        .@&quot;asm&quot; =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.Asm.html">Asm</a>);
            <span class="tok-kw">return</span> extra.rparen + end_offset;
        },
        .array_init,
        .struct_init,
        =&gt; {
            <span class="tok-kw">const</span> elements = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(elements.end - elements.start &gt; <span class="tok-number">0</span>);
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
            </span>n = tree.extra_data[elements.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last element
        </span>},
        .array_init_comma,
        .struct_init_comma,
        .container_decl_arg_trailing,
        .switch_comma,
        =&gt; {
            <span class="tok-kw">const</span> members = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(members.end - members.start &gt; <span class="tok-number">0</span>);
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // for the comma + rbrace
            </span>n = tree.extra_data[members.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
        </span>},
        .array_init_dot,
        .struct_init_dot,
        .block,
        .container_decl,
        .tagged_union,
        .builtin_call,
        =&gt; {
            <a href="std.debug.html#std.debug.assert">assert</a>(datas[n].rhs - datas[n].lhs &gt; <span class="tok-number">0</span>);
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
            </span>n = tree.extra_data[datas[n].rhs - <span class="tok-number">1</span>];<span class="tok-comment"> // last statement
        </span>},
        .array_init_dot_comma,
        .struct_init_dot_comma,
        .block_semicolon,
        .container_decl_trailing,
        .tagged_union_trailing,
        .builtin_call_comma,
        =&gt; {
            <a href="std.debug.html#std.debug.assert">assert</a>(datas[n].rhs - datas[n].lhs &gt; <span class="tok-number">0</span>);
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // for the comma/semicolon + rbrace/rparen
            </span>n = tree.extra_data[datas[n].rhs - <span class="tok-number">1</span>];<span class="tok-comment"> // last member
        </span>},
        .call_one,
        .async_call_one,
        .array_access,
        =&gt; {
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen/rbracket
            </span><span class="tok-kw">if</span> (datas[n].rhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
            n = datas[n].rhs;
        },
        .array_init_dot_two,
        .block_two,
        .builtin_call_two,
        .struct_init_dot_two,
        .container_decl_two,
        .tagged_union_two,
        =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen/rbrace
                </span>n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen/rbrace
                </span>n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">switch</span> (tags[n]) {
                    .array_init_dot_two,
                    .block_two,
                    .struct_init_dot_two,
                    =&gt; end_offset += <span class="tok-number">1</span>,<span class="tok-comment"> // rbrace
                    </span>.builtin_call_two =&gt; end_offset += <span class="tok-number">2</span>,<span class="tok-comment"> // lparen/lbrace + rparen/rbrace
                    </span>.container_decl_two =&gt; {
                        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">2</span>;<span class="tok-comment"> // lbrace + rbrace
                        </span><span class="tok-kw">while</span> (token_tags[main_tokens[n] + i] == .container_doc_comment) i += <span class="tok-number">1</span>;
                        end_offset += i;
                    },
                    .tagged_union_two =&gt; {
                        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;<span class="tok-comment"> // (enum) {}
                        </span><span class="tok-kw">while</span> (token_tags[main_tokens[n] + i] == .container_doc_comment) i += <span class="tok-number">1</span>;
                        end_offset += i;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .array_init_dot_two_comma,
        .builtin_call_two_comma,
        .block_two_semicolon,
        .struct_init_dot_two_comma,
        .container_decl_two_trailing,
        .tagged_union_two_trailing,
        =&gt; {
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // for the comma/semicolon + rbrace/rparen
            </span><span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">unreachable</span>;
            }
        },
        .simple_var_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // from mut token to name
                </span><span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .aligned_var_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // from mut token to name
                </span><span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .global_var_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.GlobalVarDecl.html">GlobalVarDecl</a>);
                <span class="tok-kw">if</span> (extra.section_node != <span class="tok-number">0</span>) {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                    </span>n = extra.section_node;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.align_node != <span class="tok-number">0</span>) {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                    </span>n = extra.align_node;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.type_node != <span class="tok-number">0</span>) {
                    n = extra.type_node;
                } <span class="tok-kw">else</span> {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // from mut token to name
                    </span><span class="tok-kw">return</span> main_tokens[n] + end_offset;
                }
            }
        },
        .local_var_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.LocalVarDecl.html">LocalVarDecl</a>);
                <span class="tok-kw">if</span> (extra.align_node != <span class="tok-number">0</span>) {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                    </span>n = extra.align_node;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.type_node != <span class="tok-number">0</span>) {
                    n = extra.type_node;
                } <span class="tok-kw">else</span> {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // from mut token to name
                    </span><span class="tok-kw">return</span> main_tokens[n] + end_offset;
                }
            }
        },
        .container_field_init =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .container_field_align =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .container_field =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ContainerField.html">ContainerField</a>);
            <span class="tok-kw">if</span> (extra.value_expr != <span class="tok-number">0</span>) {
                n = extra.value_expr;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.align_expr != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>n = extra.align_expr;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },

        .array_init_one,
        .struct_init_one,
        =&gt; {
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // rbrace
            </span><span class="tok-kw">if</span> (datas[n].rhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            } <span class="tok-kw">else</span> {
                n = datas[n].rhs;
            }
        },
        .slice_open,
        .call_one_comma,
        .async_call_one_comma,
        .array_init_one_comma,
        .struct_init_one_comma,
        =&gt; {
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // ellipsis2 + rbracket, or comma + rparen
            </span>n = datas[n].rhs;
            <a href="std.debug.html#std.debug.assert">assert</a>(n != <span class="tok-number">0</span>);
        },
        .slice =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.Slice.html">Slice</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.end != <span class="tok-number">0</span>);<span class="tok-comment"> // should have used slice_open
            </span>end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // rbracket
            </span>n = extra.end;
        },
        .slice_sentinel =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SliceSentinel.html">SliceSentinel</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.sentinel != <span class="tok-number">0</span>);<span class="tok-comment"> // should have used slice
            </span>end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // rbracket
            </span>n = extra.sentinel;
        },

        .@&quot;continue&quot;, .@&quot;break&quot; =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> datas[n].lhs + end_offset;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .fn_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> {
                n = datas[n].lhs;
            }
        },
        .fn_proto_one =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.FnProtoOne.html">FnProtoOne</a>);<span class="tok-comment">
            // addrspace, linksection, callconv, align can appear in any order, so we
            // find the last one here.
            </span><span class="tok-kw">var</span> max_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = datas[n].rhs;
            <span class="tok-kw">var</span> max_start = token_starts[main_tokens[max_node]];
            <span class="tok-kw">var</span> max_offset: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (extra.align_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.align_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.align_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.addrspace_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.addrspace_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.addrspace_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.section_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.section_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.section_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.callconv_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.callconv_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.callconv_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            n = max_node;
            end_offset += max_offset;
        },
        .fn_proto =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.FnProto.html">FnProto</a>);<span class="tok-comment">
            // addrspace, linksection, callconv, align can appear in any order, so we
            // find the last one here.
            </span><span class="tok-kw">var</span> max_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = datas[n].rhs;
            <span class="tok-kw">var</span> max_start = token_starts[main_tokens[max_node]];
            <span class="tok-kw">var</span> max_offset: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (extra.align_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.align_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.align_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.addrspace_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.addrspace_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.addrspace_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.section_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.section_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.section_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.callconv_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.callconv_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.callconv_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            n = max_node;
            end_offset += max_offset;
        },
        .while_cont =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.WhileCont.html">WhileCont</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.then_expr != <span class="tok-number">0</span>);
            n = extra.then_expr;
        },
        .@&quot;while&quot; =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.While.html">While</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.else_expr != <span class="tok-number">0</span>);
            n = extra.else_expr;
        },
        .@&quot;if&quot; =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.If.html">If</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.else_expr != <span class="tok-number">0</span>);
            n = extra.else_expr;
        },
        .@&quot;for&quot; =&gt; {
            <span class="tok-kw">const</span> extra = <span class="tok-builtin">@as</span>(<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.For.html">For</a>, <span class="tok-builtin">@bitCast</span>(datas[n].rhs));
            n = tree.extra_data[datas[n].lhs + extra.inputs + <span class="tok-builtin">@intFromBool</span>(extra.has_else)];
        },
        .@&quot;suspend&quot; =&gt; {
            <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .array_type_sentinel =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ArrayTypeSentinel.html">ArrayTypeSentinel</a>);
            n = extra.elem_type;
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.tokensOnSameLine" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tokensOnSameLine</span><a href="#src.zig-std.zig.Ast.tokensOnSameLine">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokensOnSameLine</span>(tree: <a href="std.zig.Ast.html">Ast</a>, token1: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, token2: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>token1: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div><div><pre><code>token2: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.tokensOnSameLine">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokensOnSameLine</span>(tree: <a href="std.zig.Ast.html">Ast</a>, token1: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, token2: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> source = tree.source[token_starts[token1]..token_starts[token2]];
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, source, <span class="tok-str">'\n'</span>) == <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.getNodeSource" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getNodeSource</span><a href="#src.zig-std.zig.Ast.getNodeSource">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getNodeSource</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.getNodeSource">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getNodeSource</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> first_token = tree.firstToken(node);
    <span class="tok-kw">const</span> last_token = tree.lastToken(node);
    <span class="tok-kw">const</span> start = token_starts[first_token];
    <span class="tok-kw">const</span> end = token_starts[last_token] + tree.tokenSlice(last_token).len;
    <span class="tok-kw">return</span> tree.source[start..end];
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.globalVarDecl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">globalVarDecl</span><a href="#src.zig-std.zig.Ast.globalVarDecl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">globalVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.globalVarDecl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">globalVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .global_var_decl);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.GlobalVarDecl.html">GlobalVarDecl</a>);
    <span class="tok-kw">return</span> tree.fullVarDeclComponents(.{
        .type_node = extra.type_node,
        .align_node = extra.align_node,
        .addrspace_node = extra.addrspace_node,
        .section_node = extra.section_node,
        .init_node = data.rhs,
        .mut_token = tree.nodes.items(.main_token)[node],
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.localVarDecl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">localVarDecl</span><a href="#src.zig-std.zig.Ast.localVarDecl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">localVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.localVarDecl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">localVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .local_var_decl);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.LocalVarDecl.html">LocalVarDecl</a>);
    <span class="tok-kw">return</span> tree.fullVarDeclComponents(.{
        .type_node = extra.type_node,
        .align_node = extra.align_node,
        .addrspace_node = <span class="tok-number">0</span>,
        .section_node = <span class="tok-number">0</span>,
        .init_node = data.rhs,
        .mut_token = tree.nodes.items(.main_token)[node],
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.simpleVarDecl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">simpleVarDecl</span><a href="#src.zig-std.zig.Ast.simpleVarDecl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">simpleVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.simpleVarDecl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">simpleVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .simple_var_decl);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullVarDeclComponents(.{
        .type_node = data.lhs,
        .align_node = <span class="tok-number">0</span>,
        .addrspace_node = <span class="tok-number">0</span>,
        .section_node = <span class="tok-number">0</span>,
        .init_node = data.rhs,
        .mut_token = tree.nodes.items(.main_token)[node],
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.alignedVarDecl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignedVarDecl</span><a href="#src.zig-std.zig.Ast.alignedVarDecl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignedVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.alignedVarDecl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignedVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .aligned_var_decl);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullVarDeclComponents(.{
        .type_node = <span class="tok-number">0</span>,
        .align_node = data.lhs,
        .addrspace_node = <span class="tok-number">0</span>,
        .section_node = <span class="tok-number">0</span>,
        .init_node = data.rhs,
        .mut_token = tree.nodes.items(.main_token)[node],
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.assignDestructure" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">assignDestructure</span><a href="#src.zig-std.zig.Ast.assignDestructure">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assignDestructure</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.AssignDestructure.html">AssignDestructure</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.assignDestructure">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assignDestructure</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.AssignDestructure.html">AssignDestructure</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> variable_count = tree.extra_data[data.lhs];
    <span class="tok-kw">return</span> tree.fullAssignDestructureComponents(.{
        .variables = tree.extra_data[data.lhs + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..variable_count],
        .equal_token = tree.nodes.items(.main_token)[node],
        .value_expr = data.rhs,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.ifSimple" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ifSimple</span><a href="#src.zig-std.zig.Ast.ifSimple">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ifSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.ifSimple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ifSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .if_simple);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullIfComponents(.{
        .cond_expr = data.lhs,
        .then_expr = data.rhs,
        .else_expr = <span class="tok-number">0</span>,
        .if_token = tree.nodes.items(.main_token)[node],
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.ifFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ifFull</span><a href="#src.zig-std.zig.Ast.ifFull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ifFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.ifFull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ifFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .@&quot;if&quot;);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.If.html">If</a>);
    <span class="tok-kw">return</span> tree.fullIfComponents(.{
        .cond_expr = data.lhs,
        .then_expr = extra.then_expr,
        .else_expr = extra.else_expr,
        .if_token = tree.nodes.items(.main_token)[node],
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.containerField" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containerField</span><a href="#src.zig-std.zig.Ast.containerField">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerField</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.containerField">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerField</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_field);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ContainerField.html">ContainerField</a>);
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerFieldComponents(.{
        .main_token = main_token,
        .type_expr = data.lhs,
        .align_expr = extra.align_expr,
        .value_expr = extra.value_expr,
        .tuple_like = tree.tokens.items(.tag)[main_token] != .identifier <span class="tok-kw">or</span>
            tree.tokens.items(.tag)[main_token + <span class="tok-number">1</span>] != .colon,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.containerFieldInit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containerFieldInit</span><a href="#src.zig-std.zig.Ast.containerFieldInit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerFieldInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.containerFieldInit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerFieldInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_field_init);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerFieldComponents(.{
        .main_token = main_token,
        .type_expr = data.lhs,
        .align_expr = <span class="tok-number">0</span>,
        .value_expr = data.rhs,
        .tuple_like = tree.tokens.items(.tag)[main_token] != .identifier <span class="tok-kw">or</span>
            tree.tokens.items(.tag)[main_token + <span class="tok-number">1</span>] != .colon,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.containerFieldAlign" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containerFieldAlign</span><a href="#src.zig-std.zig.Ast.containerFieldAlign">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerFieldAlign</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.containerFieldAlign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerFieldAlign</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_field_align);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerFieldComponents(.{
        .main_token = main_token,
        .type_expr = data.lhs,
        .align_expr = data.rhs,
        .value_expr = <span class="tok-number">0</span>,
        .tuple_like = tree.tokens.items(.tag)[main_token] != .identifier <span class="tok-kw">or</span>
            tree.tokens.items(.tag)[main_token + <span class="tok-number">1</span>] != .colon,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fnProtoSimple" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fnProtoSimple</span><a href="#src.zig-std.zig.Ast.fnProtoSimple">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fnProtoSimple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .fn_proto_simple);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer[<span class="tok-number">0</span>] = data.lhs;
    <span class="tok-kw">const</span> params = <span class="tok-kw">if</span> (data.lhs == <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> tree.fullFnProtoComponents(.{
        .proto_node = node,
        .fn_token = tree.nodes.items(.main_token)[node],
        .return_type = data.rhs,
        .params = params,
        .align_expr = <span class="tok-number">0</span>,
        .addrspace_expr = <span class="tok-number">0</span>,
        .section_expr = <span class="tok-number">0</span>,
        .callconv_expr = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fnProtoMulti" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fnProtoMulti</span><a href="#src.zig-std.zig.Ast.fnProtoMulti">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoMulti</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fnProtoMulti">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoMulti</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .fn_proto_multi);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> params_range = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">const</span> params = tree.extra_data[params_range.start..params_range.end];
    <span class="tok-kw">return</span> tree.fullFnProtoComponents(.{
        .proto_node = node,
        .fn_token = tree.nodes.items(.main_token)[node],
        .return_type = data.rhs,
        .params = params,
        .align_expr = <span class="tok-number">0</span>,
        .addrspace_expr = <span class="tok-number">0</span>,
        .section_expr = <span class="tok-number">0</span>,
        .callconv_expr = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fnProtoOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fnProtoOne</span><a href="#src.zig-std.zig.Ast.fnProtoOne">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fnProtoOne">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .fn_proto_one);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.FnProtoOne.html">FnProtoOne</a>);
    buffer[<span class="tok-number">0</span>] = extra.param;
    <span class="tok-kw">const</span> params = <span class="tok-kw">if</span> (extra.param == <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> tree.fullFnProtoComponents(.{
        .proto_node = node,
        .fn_token = tree.nodes.items(.main_token)[node],
        .return_type = data.rhs,
        .params = params,
        .align_expr = extra.align_expr,
        .addrspace_expr = extra.addrspace_expr,
        .section_expr = extra.section_expr,
        .callconv_expr = extra.callconv_expr,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fnProto" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fnProto</span><a href="#src.zig-std.zig.Ast.fnProto">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProto</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fnProto">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProto</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .fn_proto);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.FnProto.html">FnProto</a>);
    <span class="tok-kw">const</span> params = tree.extra_data[extra.params_start..extra.params_end];
    <span class="tok-kw">return</span> tree.fullFnProtoComponents(.{
        .proto_node = node,
        .fn_token = tree.nodes.items(.main_token)[node],
        .return_type = data.rhs,
        .params = params,
        .align_expr = extra.align_expr,
        .addrspace_expr = extra.addrspace_expr,
        .section_expr = extra.section_expr,
        .callconv_expr = extra.callconv_expr,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.structInitOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">structInitOne</span><a href="#src.zig-std.zig.Ast.structInitOne">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.structInitOne">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .struct_init_one <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .struct_init_one_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer[<span class="tok-number">0</span>] = data.rhs;
    <span class="tok-kw">const</span> fields = <span class="tok-kw">if</span> (data.rhs == <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .fields = fields,
            .type_expr = data.lhs,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.structInitDotTwo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">structInitDotTwo</span><a href="#src.zig-std.zig.Ast.structInitDotTwo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitDotTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.structInitDotTwo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitDotTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .struct_init_dot_two <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .struct_init_dot_two_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{ data.lhs, data.rhs };
    <span class="tok-kw">const</span> fields = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>]
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data.lhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
    <span class="tok-kw">else</span>
        buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .fields = fields,
            .type_expr = <span class="tok-number">0</span>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.structInitDot" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">structInitDot</span><a href="#src.zig-std.zig.Ast.structInitDot">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitDot</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.structInitDot">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitDot</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .struct_init_dot <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .struct_init_dot_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .fields = tree.extra_data[data.lhs..data.rhs],
            .type_expr = <span class="tok-number">0</span>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.structInit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">structInit</span><a href="#src.zig-std.zig.Ast.structInit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.structInit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .struct_init <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .struct_init_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> fields_range = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .fields = tree.extra_data[fields_range.start..fields_range.end],
            .type_expr = data.lhs,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.arrayInitOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayInitOne</span><a href="#src.zig-std.zig.Ast.arrayInitOne">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.arrayInitOne">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_init_one <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .array_init_one_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer[<span class="tok-number">0</span>] = data.rhs;
    <span class="tok-kw">const</span> elements = <span class="tok-kw">if</span> (data.rhs == <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .elements = elements,
            .type_expr = data.lhs,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.arrayInitDotTwo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayInitDotTwo</span><a href="#src.zig-std.zig.Ast.arrayInitDotTwo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitDotTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.arrayInitDotTwo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitDotTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_init_dot_two <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .array_init_dot_two_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{ data.lhs, data.rhs };
    <span class="tok-kw">const</span> elements = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>]
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data.lhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
    <span class="tok-kw">else</span>
        buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .elements = elements,
            .type_expr = <span class="tok-number">0</span>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.arrayInitDot" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayInitDot</span><a href="#src.zig-std.zig.Ast.arrayInitDot">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitDot</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.arrayInitDot">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitDot</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_init_dot <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .array_init_dot_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .elements = tree.extra_data[data.lhs..data.rhs],
            .type_expr = <span class="tok-number">0</span>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.arrayInit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayInit</span><a href="#src.zig-std.zig.Ast.arrayInit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.arrayInit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_init <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .array_init_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> elem_range = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .elements = tree.extra_data[elem_range.start..elem_range.end],
            .type_expr = data.lhs,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.arrayType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayType</span><a href="#src.zig-std.zig.Ast.arrayType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.arrayType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_type);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbracket = tree.nodes.items(.main_token)[node],
            .elem_count = data.lhs,
            .sentinel = <span class="tok-number">0</span>,
            .elem_type = data.rhs,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.arrayTypeSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayTypeSentinel</span><a href="#src.zig-std.zig.Ast.arrayTypeSentinel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayTypeSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.arrayTypeSentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayTypeSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_type_sentinel);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ArrayTypeSentinel.html">ArrayTypeSentinel</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(extra.sentinel != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbracket = tree.nodes.items(.main_token)[node],
            .elem_count = data.lhs,
            .sentinel = extra.sentinel,
            .elem_type = extra.elem_type,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.ptrTypeAligned" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ptrTypeAligned</span><a href="#src.zig-std.zig.Ast.ptrTypeAligned">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeAligned</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.ptrTypeAligned">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeAligned</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .ptr_type_aligned);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullPtrTypeComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .align_node = data.lhs,
        .addrspace_node = <span class="tok-number">0</span>,
        .sentinel = <span class="tok-number">0</span>,
        .bit_range_start = <span class="tok-number">0</span>,
        .bit_range_end = <span class="tok-number">0</span>,
        .child_type = data.rhs,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.ptrTypeSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ptrTypeSentinel</span><a href="#src.zig-std.zig.Ast.ptrTypeSentinel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.ptrTypeSentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .ptr_type_sentinel);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullPtrTypeComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .align_node = <span class="tok-number">0</span>,
        .addrspace_node = <span class="tok-number">0</span>,
        .sentinel = data.lhs,
        .bit_range_start = <span class="tok-number">0</span>,
        .bit_range_end = <span class="tok-number">0</span>,
        .child_type = data.rhs,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.ptrType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ptrType</span><a href="#src.zig-std.zig.Ast.ptrType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.ptrType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .ptr_type);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.PtrType.html">PtrType</a>);
    <span class="tok-kw">return</span> tree.fullPtrTypeComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .align_node = extra.align_node,
        .addrspace_node = extra.addrspace_node,
        .sentinel = extra.sentinel,
        .bit_range_start = <span class="tok-number">0</span>,
        .bit_range_end = <span class="tok-number">0</span>,
        .child_type = data.rhs,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.ptrTypeBitRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ptrTypeBitRange</span><a href="#src.zig-std.zig.Ast.ptrTypeBitRange">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeBitRange</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.ptrTypeBitRange">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeBitRange</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .ptr_type_bit_range);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.PtrTypeBitRange.html">PtrTypeBitRange</a>);
    <span class="tok-kw">return</span> tree.fullPtrTypeComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .align_node = extra.align_node,
        .addrspace_node = extra.addrspace_node,
        .sentinel = extra.sentinel,
        .bit_range_start = extra.bit_range_start,
        .bit_range_end = extra.bit_range_end,
        .child_type = data.rhs,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.sliceOpen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sliceOpen</span><a href="#src.zig-std.zig.Ast.sliceOpen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceOpen</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.sliceOpen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceOpen</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .slice_open);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .sliced = data.lhs,
            .lbracket = tree.nodes.items(.main_token)[node],
            .start = data.rhs,
            .end = <span class="tok-number">0</span>,
            .sentinel = <span class="tok-number">0</span>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.slice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">slice</span><a href="#src.zig-std.zig.Ast.slice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.slice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .slice);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.Slice.html">Slice</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .sliced = data.lhs,
            .lbracket = tree.nodes.items(.main_token)[node],
            .start = extra.start,
            .end = extra.end,
            .sentinel = <span class="tok-number">0</span>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.sliceSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sliceSentinel</span><a href="#src.zig-std.zig.Ast.sliceSentinel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.sliceSentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .slice_sentinel);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SliceSentinel.html">SliceSentinel</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .sliced = data.lhs,
            .lbracket = tree.nodes.items(.main_token)[node],
            .start = extra.start,
            .end = extra.end,
            .sentinel = extra.sentinel,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.containerDeclTwo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containerDeclTwo</span><a href="#src.zig-std.zig.Ast.containerDeclTwo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.containerDeclTwo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_decl_two <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .container_decl_two_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{ data.lhs, data.rhs };
    <span class="tok-kw">const</span> members = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>]
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data.lhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
    <span class="tok-kw">else</span>
        buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .enum_token = <span class="tok-null">null</span>,
        .members = members,
        .arg = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.containerDecl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containerDecl</span><a href="#src.zig-std.zig.Ast.containerDecl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.containerDecl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_decl <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .container_decl_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .enum_token = <span class="tok-null">null</span>,
        .members = tree.extra_data[data.lhs..data.rhs],
        .arg = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.containerDeclArg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containerDeclArg</span><a href="#src.zig-std.zig.Ast.containerDeclArg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclArg</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.containerDeclArg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclArg</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_decl_arg <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .container_decl_arg_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> members_range = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .enum_token = <span class="tok-null">null</span>,
        .members = tree.extra_data[members_range.start..members_range.end],
        .arg = data.lhs,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.containerDeclRoot" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containerDeclRoot</span><a href="#src.zig-std.zig.Ast.containerDeclRoot">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclRoot</span>(tree: <a href="std.zig.Ast.html">Ast</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.containerDeclRoot">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclRoot</span>(tree: <a href="std.zig.Ast.html">Ast</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <span class="tok-kw">return</span> .{
        .layout_token = <span class="tok-null">null</span>,
        .ast = .{
            .main_token = <span class="tok-null">undefined</span>,
            .enum_token = <span class="tok-null">null</span>,
            .members = tree.rootDecls(),
            .arg = <span class="tok-number">0</span>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.taggedUnionTwo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">taggedUnionTwo</span><a href="#src.zig-std.zig.Ast.taggedUnionTwo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnionTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.taggedUnionTwo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnionTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .tagged_union_two <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .tagged_union_two_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{ data.lhs, data.rhs };
    <span class="tok-kw">const</span> members = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>]
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data.lhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
    <span class="tok-kw">else</span>
        buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = main_token,
        .enum_token = main_token + <span class="tok-number">2</span>,<span class="tok-comment"> // union lparen enum
        </span>.members = members,
        .arg = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.taggedUnion" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">taggedUnion</span><a href="#src.zig-std.zig.Ast.taggedUnion">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnion</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.taggedUnion">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnion</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .tagged_union <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .tagged_union_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = main_token,
        .enum_token = main_token + <span class="tok-number">2</span>,<span class="tok-comment"> // union lparen enum
        </span>.members = tree.extra_data[data.lhs..data.rhs],
        .arg = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.taggedUnionEnumTag" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">taggedUnionEnumTag</span><a href="#src.zig-std.zig.Ast.taggedUnionEnumTag">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnionEnumTag</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.taggedUnionEnumTag">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnionEnumTag</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .tagged_union_enum_tag <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .tagged_union_enum_tag_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> members_range = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = main_token,
        .enum_token = main_token + <span class="tok-number">2</span>,<span class="tok-comment"> // union lparen enum
        </span>.members = tree.extra_data[members_range.start..members_range.end],
        .arg = data.lhs,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.switchFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">switchFull</span><a href="#src.zig-std.zig.Ast.switchFull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.switchFull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a> {
    <span class="tok-kw">const</span> data = &amp;tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">const</span> switch_token: TokenIndex, <span class="tok-kw">const</span> label_token: ?TokenIndex = <span class="tok-kw">switch</span> (tree.tokens.items(.tag)[main_token]) {
        .identifier =&gt; .{ main_token + <span class="tok-number">2</span>, main_token },
        .keyword_switch =&gt; .{ main_token, <span class="tok-null">null</span> },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .switch_token = switch_token,
            .condition = data.lhs,
            .cases = tree.extra_data[extra.start..extra.end],
        },
        .label_token = label_token,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.switchCaseOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">switchCaseOne</span><a href="#src.zig-std.zig.Ast.switchCaseOne">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchCaseOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.switchCaseOne">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchCaseOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a> {
    <span class="tok-kw">const</span> data = &amp;tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> values: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = &amp;data.lhs;
    <span class="tok-kw">return</span> tree.fullSwitchCaseComponents(.{
        .values = <span class="tok-kw">if</span> (data.lhs == <span class="tok-number">0</span>) values[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> values[<span class="tok-number">0</span>..<span class="tok-number">1</span>],
        .arrow_token = tree.nodes.items(.main_token)[node],
        .target_expr = data.rhs,
    }, node);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.switchCase" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">switchCase</span><a href="#src.zig-std.zig.Ast.switchCase">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchCase</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.switchCase">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchCase</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> tree.fullSwitchCaseComponents(.{
        .values = tree.extra_data[extra.start..extra.end],
        .arrow_token = tree.nodes.items(.main_token)[node],
        .target_expr = data.rhs,
    }, node);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.asmSimple" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">asmSimple</span><a href="#src.zig-std.zig.Ast.asmSimple">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.asmSimple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullAsmComponents(.{
        .asm_token = tree.nodes.items(.main_token)[node],
        .template = data.lhs,
        .items = &amp;.{},
        .rparen = data.rhs,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.asmFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">asmFull</span><a href="#src.zig-std.zig.Ast.asmFull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.asmFull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.Asm.html">Asm</a>);
    <span class="tok-kw">return</span> tree.fullAsmComponents(.{
        .asm_token = tree.nodes.items(.main_token)[node],
        .template = data.lhs,
        .items = tree.extra_data[extra.items_start..extra.items_end],
        .rparen = extra.rparen,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.whileSimple" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">whileSimple</span><a href="#src.zig-std.zig.Ast.whileSimple">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.whileSimple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullWhileComponents(.{
        .while_token = tree.nodes.items(.main_token)[node],
        .cond_expr = data.lhs,
        .cont_expr = <span class="tok-number">0</span>,
        .then_expr = data.rhs,
        .else_expr = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.whileCont" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">whileCont</span><a href="#src.zig-std.zig.Ast.whileCont">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileCont</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.whileCont">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileCont</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.WhileCont.html">WhileCont</a>);
    <span class="tok-kw">return</span> tree.fullWhileComponents(.{
        .while_token = tree.nodes.items(.main_token)[node],
        .cond_expr = data.lhs,
        .cont_expr = extra.cont_expr,
        .then_expr = extra.then_expr,
        .else_expr = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.whileFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">whileFull</span><a href="#src.zig-std.zig.Ast.whileFull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.whileFull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.While.html">While</a>);
    <span class="tok-kw">return</span> tree.fullWhileComponents(.{
        .while_token = tree.nodes.items(.main_token)[node],
        .cond_expr = data.lhs,
        .cont_expr = extra.cont_expr,
        .then_expr = extra.then_expr,
        .else_expr = extra.else_expr,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.forSimple" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">forSimple</span><a href="#src.zig-std.zig.Ast.forSimple">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.forSimple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a> {
    <span class="tok-kw">const</span> data = &amp;tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> inputs: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = &amp;data.lhs;
    <span class="tok-kw">return</span> tree.fullForComponents(.{
        .for_token = tree.nodes.items(.main_token)[node],
        .inputs = inputs[<span class="tok-number">0</span>..<span class="tok-number">1</span>],
        .then_expr = data.rhs,
        .else_expr = <span class="tok-number">0</span>,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.forFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">forFull</span><a href="#src.zig-std.zig.Ast.forFull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.forFull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = <span class="tok-builtin">@as</span>(<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.For.html">For</a>, <span class="tok-builtin">@bitCast</span>(data.rhs));
    <span class="tok-kw">const</span> inputs = tree.extra_data[data.lhs..][<span class="tok-number">0</span>..extra.inputs];
    <span class="tok-kw">const</span> then_expr = tree.extra_data[data.lhs + extra.inputs];
    <span class="tok-kw">const</span> else_expr = <span class="tok-kw">if</span> (extra.has_else) tree.extra_data[data.lhs + extra.inputs + <span class="tok-number">1</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> tree.fullForComponents(.{
        .for_token = tree.nodes.items(.main_token)[node],
        .inputs = inputs,
        .then_expr = then_expr,
        .else_expr = else_expr,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.callOne" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">callOne</span><a href="#src.zig-std.zig.Ast.callOne">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.callOne">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{data.rhs};
    <span class="tok-kw">const</span> params = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">return</span> tree.fullCallComponents(.{
        .lparen = tree.nodes.items(.main_token)[node],
        .fn_expr = data.lhs,
        .params = params,
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.callFull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">callFull</span><a href="#src.zig-std.zig.Ast.callFull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.callFull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> tree.fullCallComponents(.{
        .lparen = tree.nodes.items(.main_token)[node],
        .fn_expr = data.lhs,
        .params = tree.extra_data[extra.start..extra.end],
    });
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullVarDecl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullVarDecl</span><a href="#src.zig-std.zig.Ast.fullVarDecl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullVarDecl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .global_var_decl =&gt; tree.globalVarDecl(node),
        .local_var_decl =&gt; tree.localVarDecl(node),
        .aligned_var_decl =&gt; tree.alignedVarDecl(node),
        .simple_var_decl =&gt; tree.simpleVarDecl(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullIf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullIf</span><a href="#src.zig-std.zig.Ast.fullIf">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullIf</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullIf">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullIf</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .if_simple =&gt; tree.ifSimple(node),
        .@&quot;if&quot; =&gt; tree.ifFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullWhile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullWhile</span><a href="#src.zig-std.zig.Ast.fullWhile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullWhile</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullWhile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullWhile</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .while_simple =&gt; tree.whileSimple(node),
        .while_cont =&gt; tree.whileCont(node),
        .@&quot;while&quot; =&gt; tree.whileFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullFor" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullFor</span><a href="#src.zig-std.zig.Ast.fullFor">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullFor</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullFor">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullFor</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .for_simple =&gt; tree.forSimple(node),
        .@&quot;for&quot; =&gt; tree.forFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullContainerField" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullContainerField</span><a href="#src.zig-std.zig.Ast.fullContainerField">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullContainerField</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullContainerField">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullContainerField</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .container_field_init =&gt; tree.containerFieldInit(node),
        .container_field_align =&gt; tree.containerFieldAlign(node),
        .container_field =&gt; tree.containerField(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullFnProto" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullFnProto</span><a href="#src.zig-std.zig.Ast.fullFnProto">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullFnProto</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullFnProto">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullFnProto</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .fn_proto =&gt; tree.fnProto(node),
        .fn_proto_multi =&gt; tree.fnProtoMulti(node),
        .fn_proto_one =&gt; tree.fnProtoOne(buffer, node),
        .fn_proto_simple =&gt; tree.fnProtoSimple(buffer, node),
        .fn_decl =&gt; tree.fullFnProto(buffer, tree.nodes.items(.data)[node].lhs),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullStructInit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullStructInit</span><a href="#src.zig-std.zig.Ast.fullStructInit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullStructInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullStructInit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullStructInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .struct_init_one, .struct_init_one_comma =&gt; tree.structInitOne(buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>], node),
        .struct_init_dot_two, .struct_init_dot_two_comma =&gt; tree.structInitDotTwo(buffer, node),
        .struct_init_dot, .struct_init_dot_comma =&gt; tree.structInitDot(node),
        .struct_init, .struct_init_comma =&gt; tree.structInit(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullArrayInit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullArrayInit</span><a href="#src.zig-std.zig.Ast.fullArrayInit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullArrayInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullArrayInit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullArrayInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .array_init_one, .array_init_one_comma =&gt; tree.arrayInitOne(buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>], node),
        .array_init_dot_two, .array_init_dot_two_comma =&gt; tree.arrayInitDotTwo(buffer, node),
        .array_init_dot, .array_init_dot_comma =&gt; tree.arrayInitDot(node),
        .array_init, .array_init_comma =&gt; tree.arrayInit(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullArrayType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullArrayType</span><a href="#src.zig-std.zig.Ast.fullArrayType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullArrayType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullArrayType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullArrayType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .array_type =&gt; tree.arrayType(node),
        .array_type_sentinel =&gt; tree.arrayTypeSentinel(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullPtrType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullPtrType</span><a href="#src.zig-std.zig.Ast.fullPtrType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullPtrType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullPtrType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullPtrType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .ptr_type_aligned =&gt; tree.ptrTypeAligned(node),
        .ptr_type_sentinel =&gt; tree.ptrTypeSentinel(node),
        .ptr_type =&gt; tree.ptrType(node),
        .ptr_type_bit_range =&gt; tree.ptrTypeBitRange(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullSlice</span><a href="#src.zig-std.zig.Ast.fullSlice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSlice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullSlice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSlice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .slice_open =&gt; tree.sliceOpen(node),
        .slice =&gt; tree.slice(node),
        .slice_sentinel =&gt; tree.sliceSentinel(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullContainerDecl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullContainerDecl</span><a href="#src.zig-std.zig.Ast.fullContainerDecl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullContainerDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullContainerDecl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullContainerDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .root =&gt; tree.containerDeclRoot(),
        .container_decl, .container_decl_trailing =&gt; tree.containerDecl(node),
        .container_decl_arg, .container_decl_arg_trailing =&gt; tree.containerDeclArg(node),
        .container_decl_two, .container_decl_two_trailing =&gt; tree.containerDeclTwo(buffer, node),
        .tagged_union, .tagged_union_trailing =&gt; tree.taggedUnion(node),
        .tagged_union_enum_tag, .tagged_union_enum_tag_trailing =&gt; tree.taggedUnionEnumTag(node),
        .tagged_union_two, .tagged_union_two_trailing =&gt; tree.taggedUnionTwo(buffer, node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullSwitch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullSwitch</span><a href="#src.zig-std.zig.Ast.fullSwitch">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSwitch</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullSwitch">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSwitch</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .@&quot;switch&quot;, .switch_comma =&gt; tree.switchFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullSwitchCase" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullSwitchCase</span><a href="#src.zig-std.zig.Ast.fullSwitchCase">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSwitchCase</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullSwitchCase">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSwitchCase</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .switch_case_one, .switch_case_inline_one =&gt; tree.switchCaseOne(node),
        .switch_case, .switch_case_inline =&gt; tree.switchCase(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullAsm" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullAsm</span><a href="#src.zig-std.zig.Ast.fullAsm">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullAsm</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullAsm">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullAsm</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .asm_simple =&gt; tree.asmSimple(node),
        .@&quot;asm&quot; =&gt; tree.asmFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.fullCall" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fullCall</span><a href="#src.zig-std.zig.Ast.fullCall">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullCall</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div><div><pre><code>node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.fullCall">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullCall</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .call, .call_comma, .async_call, .async_call_comma =&gt; tree.callFull(node),
        .call_one, .call_one_comma, .async_call_one, .async_call_one_comma =&gt; tree.callOne(buffer, node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.nodeToSpan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nodeToSpan</span><a href="#src.zig-std.zig.Ast.nodeToSpan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nodeToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, node: <span class="tok-type">u32</span>) <a href="std.zig.Ast.Span.html">Span</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>node: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.nodeToSpan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nodeToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, node: <span class="tok-type">u32</span>) <a href="std.zig.Ast.Span.html">Span</a> {
    <span class="tok-kw">return</span> <a href="std.zig.Ast.html#std.zig.Ast.tokensToSpan">tokensToSpan</a>(
        tree,
        tree.firstToken(node),
        tree.lastToken(node),
        tree.nodes.items(.main_token)[node],
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.tokenToSpan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tokenToSpan</span><a href="#src.zig-std.zig.Ast.tokenToSpan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Span.html">Span</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.tokenToSpan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Span.html">Span</a> {
    <span class="tok-kw">return</span> <a href="std.zig.Ast.html#std.zig.Ast.tokensToSpan">tokensToSpan</a>(tree, token, token, token);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.Ast.tokensToSpan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tokensToSpan</span><a href="#src.zig-std.zig.Ast.tokensToSpan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokensToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, start: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, end: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, main: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Span.html">Span</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a></code></pre></div><div><pre><code>start: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div><div><pre><code>end: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div><div><pre><code>main: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.tokensToSpan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokensToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, start: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, end: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, main: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Span.html">Span</a> {
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">var</span> start_tok = start;
    <span class="tok-kw">var</span> end_tok = end;

    <span class="tok-kw">if</span> (tree.tokensOnSameLine(start, end)) {<span class="tok-comment">
        // do nothing
    </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (tree.tokensOnSameLine(start, main)) {
        end_tok = main;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (tree.tokensOnSameLine(main, end)) {
        start_tok = main;
    } <span class="tok-kw">else</span> {
        start_tok = main;
        end_tok = main;
    }
    <span class="tok-kw">const</span> start_off = token_starts[start_tok];
    <span class="tok-kw">const</span> end_off = token_starts[end_tok] + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(tree.tokenSlice(end_tok).len));
    <span class="tok-kw">return</span> <a href="std.zig.Ast.Span.html">Span</a>{ .start = start_off, .end = end_off, .main = token_starts[main] };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.Ast">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Abstract Syntax Tree for Zig source code.</span>
<span class="tok-comment">//! For Zig syntax, the root node is at nodes[0] and contains the list of</span>
<span class="tok-comment">//! sub-nodes.</span>
<span class="tok-comment">//! For Zon syntax, the root node is at nodes[0] and contains lhs as the node</span>
<span class="tok-comment">//! index of the main expression.</span>

<span class="tok-comment">/// Reference to externally-owned data.</span>
source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

tokens: <a href="std.zig.Ast.html#std.zig.Ast.TokenList">TokenList</a>.<a href="#">Slice</a>,
<span class="tok-comment">/// The root AST node is assumed to be index 0. Since there can be no</span>
<span class="tok-comment">/// references to the root node, this means 0 is available to indicate null.</span>
nodes: <a href="std.zig.Ast.html#std.zig.Ast.NodeList">NodeList</a>.<a href="#">Slice</a>,
extra_data: []<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
mode: <a href="std.zig.Ast.Mode.html">Mode</a> = .zig,

errors: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Error.html">Error</a>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TokenIndex = <span class="tok-type">u32</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ByteOffset = <span class="tok-type">u32</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TokenList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<span class="tok-kw">struct</span> {
    tag: <a href="std.zig.tokenizer.Token.html">Token</a>.<a href="std.zig.tokenizer.Token.Tag.html">Tag</a>,
    start: <a href="std.zig.Ast.html#std.zig.Ast.ByteOffset">ByteOffset</a>,
});
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> NodeList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.Ast.Node.html">Node</a>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Location = <span class="tok-kw">struct</span> {
    line: <span class="tok-type">usize</span>,
    column: <span class="tok-type">usize</span>,
    line_start: <span class="tok-type">usize</span>,
    line_end: <span class="tok-type">usize</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Span = <span class="tok-kw">struct</span> {
    start: <span class="tok-type">u32</span>,
    end: <span class="tok-type">u32</span>,
    main: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(tree: *<a href="std.zig.Ast.html">Ast</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    tree.tokens.deinit(gpa);
    tree.nodes.deinit(gpa);
    gpa.free(tree.extra_data);
    gpa.free(tree.errors);
    tree.* = <span class="tok-null">undefined</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenderError = <span class="tok-kw">error</span>{
    <span class="tok-comment">/// Ran out of memory allocating call stack frames to complete rendering, or</span>
    <span class="tok-comment">/// ran out of memory allocating space in the output buffer.</span>
    OutOfMemory,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Mode = <span class="tok-kw">enum</span> { zig, zon };

<span class="tok-comment">/// Result should be freed with tree.deinit() when there are</span>
<span class="tok-comment">/// no more references to any of the tokens or nodes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, source: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.zig.Ast.Mode.html">Mode</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.Ast.html">Ast</a> {
    <span class="tok-kw">var</span> tokens = <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenList">TokenList</a>{};
    <span class="tok-kw">defer</span> tokens.deinit(gpa);<span class="tok-comment">

    // Empirically, the zig std lib has an 8:1 ratio of source bytes to token count.
    </span><span class="tok-kw">const</span> estimated_token_count = source.len / <span class="tok-number">8</span>;
    <span class="tok-kw">try</span> tokens.ensureTotalCapacity(gpa, estimated_token_count);

    <span class="tok-kw">var</span> tokenizer = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.tokenizer.Tokenizer.html">Tokenizer</a>.<a href="std.zig.tokenizer.Tokenizer.html#std.zig.tokenizer.Tokenizer.init">init</a>(source);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> token = tokenizer.next();
        <span class="tok-kw">try</span> tokens.append(gpa, .{
            .tag = token.tag,
            .start = <span class="tok-builtin">@intCast</span>(token.loc.start),
        });
        <span class="tok-kw">if</span> (token.tag == .eof) <span class="tok-kw">break</span>;
    }

    <span class="tok-kw">var</span> parser: <a href="std.zig.Parse.html">Parse</a> = .{
        .source = source,
        .gpa = gpa,
        .token_tags = tokens.items(.tag),
        .token_starts = tokens.items(.start),
        .errors = .{},
        .nodes = .{},
        .extra_data = .{},
        .scratch = .{},
        .tok_i = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">defer</span> parser.errors.deinit(gpa);
    <span class="tok-kw">defer</span> parser.nodes.deinit(gpa);
    <span class="tok-kw">defer</span> parser.extra_data.deinit(gpa);
    <span class="tok-kw">defer</span> parser.scratch.deinit(gpa);<span class="tok-comment">

    // Empirically, Zig source code has a 2:1 ratio of tokens to AST nodes.
    // Make sure at least 1 so we can use appendAssumeCapacity on the root node below.
    </span><span class="tok-kw">const</span> estimated_node_count = (tokens.len + <span class="tok-number">2</span>) / <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> parser.nodes.ensureTotalCapacity(gpa, estimated_node_count);

    <span class="tok-kw">switch</span> (mode) {
        .zig =&gt; <span class="tok-kw">try</span> parser.parseRoot(),
        .zon =&gt; <span class="tok-kw">try</span> parser.parseZon(),
    }

    <span class="tok-kw">const</span> extra_data = <span class="tok-kw">try</span> parser.extra_data.toOwnedSlice(gpa);
    <span class="tok-kw">errdefer</span> gpa.free(extra_data);
    <span class="tok-kw">const</span> errors = <span class="tok-kw">try</span> parser.errors.toOwnedSlice(gpa);
    <span class="tok-kw">errdefer</span> gpa.free(errors);<span class="tok-comment">

    // TODO experiment with compacting the MultiArrayList slices here
    </span><span class="tok-kw">return</span> <a href="std.zig.Ast.html">Ast</a>{
        .source = source,
        .mode = mode,
        .tokens = tokens.toOwnedSlice(),
        .nodes = parser.nodes.toOwnedSlice(),
        .extra_data = extra_data,
        .errors = errors,
    };
}

<span class="tok-comment">/// `gpa` is used for allocating the resulting formatted source code.</span>
<span class="tok-comment">/// Caller owns the returned slice of bytes, allocated with `gpa`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">render</span>(tree: <a href="std.zig.Ast.html">Ast</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.zig.Ast.html#std.zig.Ast.RenderError">RenderError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> buffer = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(gpa);
    <span class="tok-kw">defer</span> buffer.deinit();

    <span class="tok-kw">try</span> tree.renderToArrayList(&amp;buffer, .{});
    <span class="tok-kw">return</span> buffer.toOwnedSlice();
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fixups = <a href="std.zig.render.html">private_render</a>.<a href="std.zig.render.Fixups.html">Fixups</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderToArrayList</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>), fixups: <a href="std.zig.render.Fixups.html">Fixups</a>) <a href="std.zig.Ast.html#std.zig.Ast.RenderError">RenderError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./render.zig&quot;</span>).renderTree(buffer, tree, fixups);
}

<span class="tok-comment">/// Returns an extra offset for column and byte offset of errors that</span>
<span class="tok-comment">/// should point after the token in the error message.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorOffset</span>(tree: <a href="std.zig.Ast.html">Ast</a>, parse_error: <a href="std.zig.Ast.Error.html">Error</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (parse_error.token_is_prev)
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(tree.tokenSlice(parse_error.token).len))
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenLocation</span>(self: <a href="std.zig.Ast.html">Ast</a>, start_offset: <a href="std.zig.Ast.html#std.zig.Ast.ByteOffset">ByteOffset</a>, token_index: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Location.html">Location</a> {
    <span class="tok-kw">var</span> loc = <a href="std.zig.Ast.Location.html">Location</a>{
        .line = <span class="tok-number">0</span>,
        .column = <span class="tok-number">0</span>,
        .line_start = start_offset,
        .line_end = self.source.len,
    };
    <span class="tok-kw">const</span> token_start = self.tokens.items(.start)[token_index];<span class="tok-comment">

    // Scan to by line until we go past the token start
    </span><span class="tok-kw">while</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(<span class="tok-type">u8</span>, self.source, loc.line_start, <span class="tok-str">'\n'</span>)) |i| {
        <span class="tok-kw">if</span> (i &gt;= token_start) {
            <span class="tok-kw">break</span>;<span class="tok-comment"> // Went past
        </span>}
        loc.line += <span class="tok-number">1</span>;
        loc.line_start = i + <span class="tok-number">1</span>;
    }

    <span class="tok-kw">const</span> offset = loc.line_start;
    <span class="tok-kw">for</span> (self.source[offset..], <span class="tok-number">0</span>..) |c, i| {
        <span class="tok-kw">if</span> (i + offset == token_start) {
            loc.line_end = i + offset;
            <span class="tok-kw">while</span> (loc.line_end &lt; self.source.len <span class="tok-kw">and</span> self.source[loc.line_end] != <span class="tok-str">'\n'</span>) {
                loc.line_end += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span> loc;
        }
        <span class="tok-kw">if</span> (c == <span class="tok-str">'\n'</span>) {
            loc.line += <span class="tok-number">1</span>;
            loc.column = <span class="tok-number">0</span>;
            loc.line_start = i + <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            loc.column += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> loc;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenSlice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, token_index: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> token_tag = token_tags[token_index];<span class="tok-comment">

    // Many tokens can be determined entirely by their tag.
    </span><span class="tok-kw">if</span> (token_tag.lexeme()) |lexeme| {
        <span class="tok-kw">return</span> lexeme;
    }<span class="tok-comment">

    // For some tokens, re-tokenization is needed to find the end.
    </span><span class="tok-kw">var</span> tokenizer: <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.tokenizer.Tokenizer.html">Tokenizer</a> = .{
        .buffer = tree.source,
        .index = token_starts[token_index],
    };
    <span class="tok-kw">const</span> token = tokenizer.next();
    <a href="std.debug.html#std.debug.assert">assert</a>(token.tag == token_tag);
    <span class="tok-kw">return</span> tree.source[token.loc.start..token.loc.end];
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extraData</span>(tree: <a href="std.zig.Ast.html">Ast</a>, index: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">const</span> fields = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(T);
    <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields, <span class="tok-number">0</span>..) |field, i| {
        <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(field.<span class="tok-type">type</span> == <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>);
        <span class="tok-builtin">@field</span>(result, field.name) = tree.extra_data[index + i];
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rootDecls</span>(tree: <a href="std.zig.Ast.html">Ast</a>) []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> {
    <span class="tok-kw">const</span> nodes_data = tree.nodes.items(.data);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.mode) {
        .zig =&gt; tree.extra_data[nodes_data[<span class="tok-number">0</span>].lhs..nodes_data[<span class="tok-number">0</span>].rhs],
        .zon =&gt; (&amp;nodes_data[<span class="tok-number">0</span>].lhs)[<span class="tok-number">0</span>..<span class="tok-number">1</span>],
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renderError</span>(tree: <a href="std.zig.Ast.html">Ast</a>, parse_error: <a href="std.zig.Ast.Error.html">Error</a>, stream: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">switch</span> (parse_error.tag) {
        .asterisk_after_ptr_deref =&gt; {<span class="tok-comment">
            // Note that the token will point at the `.*` but ideally the source
            // location would point to the `*` after the `.*`.
            </span><span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;'.*' cannot be followed by '*'. Are you missing a space?&quot;</span>);
        },
        .chained_comparison_operators =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;comparison operators cannot be chained&quot;</span>);
        },
        .decl_between_fields =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;declarations are not allowed between container fields&quot;</span>);
        },
        .expected_block =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected block, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_block_or_assignment =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected block or assignment, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_block_or_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected block or expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_block_or_field =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected block or field, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_container_members =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected test, comptime, var decl, or container field, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token].symbol(),
            });
        },
        .expected_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_expr_or_assignment =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected expression or assignment, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_expr_or_var_decl =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected expression or var decl, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_fn =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected function, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_inlinable =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected 'while' or 'for', found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_labelable =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected 'while', 'for', 'inline', or '{{', found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_param_list =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected parameter list, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_prefix_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected prefix expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_primary_type_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected primary type expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_pub_item =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected function or variable declaration after pub&quot;</span>);
        },
        .expected_return_type =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected return type expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_semi_or_else =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ';' or 'else' after statement&quot;</span>);
        },
        .expected_semi_or_lbrace =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ';' or block after function prototype&quot;</span>);
        },
        .expected_statement =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected statement, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token].symbol(),
            });
        },
        .expected_suffix_op =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected pointer dereference, optional unwrap, or field access, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_type_expr =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected type expression, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_var_decl =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected variable declaration, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_var_decl_or_fn =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected variable declaration or function, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_loop_payload =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected loop payload, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .expected_container =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected a struct, enum or union, found '{s}'&quot;</span>, .{
                token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)].symbol(),
            });
        },
        .extern_fn_body =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extern functions have no body&quot;</span>);
        },
        .extra_addrspace_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra addrspace qualifier&quot;</span>);
        },
        .extra_align_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra align qualifier&quot;</span>);
        },
        .extra_allowzero_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra allowzero qualifier&quot;</span>);
        },
        .extra_const_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra const qualifier&quot;</span>);
        },
        .extra_volatile_qualifier =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra volatile qualifier&quot;</span>);
        },
        .ptr_mod_on_array_child_type =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;pointer modifier '{s}' not allowed on array child type&quot;</span>, .{
                token_tags[parse_error.token].symbol(),
            });
        },
        .invalid_bit_range =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;bit range not allowed on slices and arrays&quot;</span>);
        },
        .same_line_doc_comment =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;same line documentation comment&quot;</span>);
        },
        .unattached_doc_comment =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;unattached documentation comment&quot;</span>);
        },
        .test_doc_comment =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;documentation comments cannot be attached to tests&quot;</span>);
        },
        .comptime_doc_comment =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;documentation comments cannot be attached to comptime blocks&quot;</span>);
        },
        .varargs_nonfinal =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;function prototype has parameter after varargs&quot;</span>);
        },
        .expected_continue_expr =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ':' before while continue expression&quot;</span>);
        },

        .expected_semi_after_decl =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ';' after declaration&quot;</span>);
        },
        .expected_semi_after_stmt =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ';' after statement&quot;</span>);
        },
        .expected_comma_after_field =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after field&quot;</span>);
        },
        .expected_comma_after_arg =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after argument&quot;</span>);
        },
        .expected_comma_after_param =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after parameter&quot;</span>);
        },
        .expected_comma_after_initializer =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after initializer&quot;</span>);
        },
        .expected_comma_after_switch_prong =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after switch prong&quot;</span>);
        },
        .expected_comma_after_for_operand =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after for operand&quot;</span>);
        },
        .expected_comma_after_capture =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected ',' after for capture&quot;</span>);
        },
        .expected_initializer =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected field initializer&quot;</span>);
        },
        .mismatched_binary_op_whitespace =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;binary operator `{s}` has whitespace on one side, but not the other.&quot;</span>, .{token_tags[parse_error.token].lexeme().?});
        },
        .invalid_ampersand_ampersand =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;ambiguous use of '&amp;&amp;'; use 'and' for logical AND, or change whitespace to ' &amp; &amp;' for bitwise AND&quot;</span>);
        },
        .c_style_container =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;'{s} {s}' is invalid&quot;</span>, .{
                parse_error.extra.expected_tag.symbol(), tree.tokenSlice(parse_error.token),
            });
        },
        .zig_style_container =&gt; {
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;to declare a container do 'const {s} = {s}'&quot;</span>, .{
                tree.tokenSlice(parse_error.token), parse_error.extra.expected_tag.symbol(),
            });
        },
        .previous_field =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;field before declarations here&quot;</span>);
        },
        .next_field =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;field after declarations here&quot;</span>);
        },
        .expected_var_const =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;expected 'var' or 'const' before variable declaration&quot;</span>);
        },
        .wrong_equal_var_decl =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;variable initialized with '==' instead of '='&quot;</span>);
        },
        .var_const_decl =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;use 'var' or 'const' to declare variable&quot;</span>);
        },
        .extra_for_capture =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;extra capture in for loop&quot;</span>);
        },
        .for_input_not_captured =&gt; {
            <span class="tok-kw">return</span> stream.writeAll(<span class="tok-str">&quot;for input is not captured&quot;</span>);
        },

        .invalid_byte =&gt; {
            <span class="tok-kw">const</span> tok_slice = tree.source[tree.tokens.items(.start)[parse_error.token]..];
            <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;{s} contains invalid byte: '{'}'&quot;</span>, .{
                <span class="tok-kw">switch</span> (tok_slice[<span class="tok-number">0</span>]) {
                    <span class="tok-str">'\''</span> =&gt; <span class="tok-str">&quot;character literal&quot;</span>,
                    <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\\'</span> =&gt; <span class="tok-str">&quot;string literal&quot;</span>,
                    <span class="tok-str">'/'</span> =&gt; <span class="tok-str">&quot;comment&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                },
                <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.html#std.zig.fmtEscapes">fmtEscapes</a>(tok_slice[parse_error.extra.offset..][<span class="tok-number">0</span>..<span class="tok-number">1</span>]),
            });
        },

        .expected_token =&gt; {
            <span class="tok-kw">const</span> found_tag = token_tags[parse_error.token + <span class="tok-builtin">@intFromBool</span>(parse_error.token_is_prev)];
            <span class="tok-kw">const</span> expected_symbol = parse_error.extra.expected_tag.symbol();
            <span class="tok-kw">switch</span> (found_tag) {
                .invalid =&gt; <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected '{s}', found invalid bytes&quot;</span>, .{
                    expected_symbol,
                }),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> stream.print(<span class="tok-str">&quot;expected '{s}', found '{s}'&quot;</span>, .{
                    expected_symbol, found_tag.symbol(),
                }),
            }
        },
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstToken</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> {
    <span class="tok-kw">const</span> tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> end_offset: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> n = node;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (tags[n]) {
        .root =&gt; <span class="tok-kw">return</span> <span class="tok-number">0</span>,

        .test_decl,
        .@&quot;errdefer&quot;,
        .@&quot;defer&quot;,
        .bool_not,
        .negation,
        .bit_not,
        .negation_wrap,
        .address_of,
        .@&quot;try&quot;,
        .@&quot;await&quot;,
        .optional_type,
        .@&quot;switch&quot;,
        .switch_comma,
        .if_simple,
        .@&quot;if&quot;,
        .@&quot;suspend&quot;,
        .@&quot;resume&quot;,
        .@&quot;continue&quot;,
        .@&quot;break&quot;,
        .@&quot;return&quot;,
        .anyframe_type,
        .identifier,
        .anyframe_literal,
        .char_literal,
        .number_literal,
        .unreachable_literal,
        .string_literal,
        .multiline_string_literal,
        .grouped_expression,
        .builtin_call_two,
        .builtin_call_two_comma,
        .builtin_call,
        .builtin_call_comma,
        .error_set_decl,
        .@&quot;comptime&quot;,
        .@&quot;nosuspend&quot;,
        .asm_simple,
        .@&quot;asm&quot;,
        .array_type,
        .array_type_sentinel,
        .error_value,
        =&gt; <span class="tok-kw">return</span> main_tokens[n] - end_offset,

        .array_init_dot,
        .array_init_dot_comma,
        .array_init_dot_two,
        .array_init_dot_two_comma,
        .struct_init_dot,
        .struct_init_dot_comma,
        .struct_init_dot_two,
        .struct_init_dot_two_comma,
        .enum_literal,
        =&gt; <span class="tok-kw">return</span> main_tokens[n] - <span class="tok-number">1</span> - end_offset,

        .@&quot;catch&quot;,
        .field_access,
        .unwrap_optional,
        .equal_equal,
        .bang_equal,
        .less_than,
        .greater_than,
        .less_or_equal,
        .greater_or_equal,
        .assign_mul,
        .assign_div,
        .assign_mod,
        .assign_add,
        .assign_sub,
        .assign_shl,
        .assign_shl_sat,
        .assign_shr,
        .assign_bit_and,
        .assign_bit_xor,
        .assign_bit_or,
        .assign_mul_wrap,
        .assign_add_wrap,
        .assign_sub_wrap,
        .assign_mul_sat,
        .assign_add_sat,
        .assign_sub_sat,
        .assign,
        .merge_error_sets,
        .mul,
        .div,
        .mod,
        .array_mult,
        .mul_wrap,
        .mul_sat,
        .add,
        .sub,
        .array_cat,
        .add_wrap,
        .sub_wrap,
        .add_sat,
        .sub_sat,
        .shl,
        .shl_sat,
        .shr,
        .bit_and,
        .bit_xor,
        .bit_or,
        .@&quot;orelse&quot;,
        .bool_and,
        .bool_or,
        .slice_open,
        .slice,
        .slice_sentinel,
        .deref,
        .array_access,
        .array_init_one,
        .array_init_one_comma,
        .array_init,
        .array_init_comma,
        .struct_init_one,
        .struct_init_one_comma,
        .struct_init,
        .struct_init_comma,
        .call_one,
        .call_one_comma,
        .call,
        .call_comma,
        .switch_range,
        .for_range,
        .error_union,
        =&gt; n = datas[n].lhs,

        .assign_destructure =&gt; {
            <span class="tok-kw">const</span> extra_idx = datas[n].lhs;
            <span class="tok-kw">const</span> lhs_len = tree.extra_data[extra_idx];
            <a href="std.debug.html#std.debug.assert">assert</a>(lhs_len &gt; <span class="tok-number">0</span>);
            n = tree.extra_data[extra_idx + <span class="tok-number">1</span>];
        },

        .fn_decl,
        .fn_proto_simple,
        .fn_proto_multi,
        .fn_proto_one,
        .fn_proto,
        =&gt; {
            <span class="tok-kw">var</span> i = main_tokens[n];<span class="tok-comment"> // fn token
            </span><span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
                i -= <span class="tok-number">1</span>;
                <span class="tok-kw">switch</span> (token_tags[i]) {
                    .keyword_extern,
                    .keyword_export,
                    .keyword_pub,
                    .keyword_inline,
                    .keyword_noinline,
                    .string_literal,
                    =&gt; <span class="tok-kw">continue</span>,

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> i + <span class="tok-number">1</span> - end_offset,
                }
            }
            <span class="tok-kw">return</span> i - end_offset;
        },

        .@&quot;usingnamespace&quot; =&gt; {
            <span class="tok-kw">const</span> main_token = main_tokens[n];
            <span class="tok-kw">if</span> (main_token &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[main_token - <span class="tok-number">1</span>] == .keyword_pub) {
                end_offset += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span> main_token - end_offset;
        },

        .async_call_one,
        .async_call_one_comma,
        .async_call,
        .async_call_comma,
        =&gt; {
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // async token
            </span>n = datas[n].lhs;
        },

        .container_field_init,
        .container_field_align,
        .container_field,
        =&gt; {
            <span class="tok-kw">const</span> name_token = main_tokens[n];
            <span class="tok-kw">if</span> (name_token &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[name_token - <span class="tok-number">1</span>] == .keyword_comptime) {
                end_offset += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span> name_token - end_offset;
        },

        .global_var_decl,
        .local_var_decl,
        .simple_var_decl,
        .aligned_var_decl,
        =&gt; {
            <span class="tok-kw">var</span> i = main_tokens[n];<span class="tok-comment"> // mut token
            </span><span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
                i -= <span class="tok-number">1</span>;
                <span class="tok-kw">switch</span> (token_tags[i]) {
                    .keyword_extern,
                    .keyword_export,
                    .keyword_comptime,
                    .keyword_pub,
                    .keyword_threadlocal,
                    .string_literal,
                    =&gt; <span class="tok-kw">continue</span>,

                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> i + <span class="tok-number">1</span> - end_offset,
                }
            }
            <span class="tok-kw">return</span> i - end_offset;
        },

        .block,
        .block_semicolon,
        .block_two,
        .block_two_semicolon,
        =&gt; {<span class="tok-comment">
            // Look for a label.
            </span><span class="tok-kw">const</span> lbrace = main_tokens[n];
            <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span>
                token_tags[lbrace - <span class="tok-number">2</span>] == .identifier)
            {
                end_offset += <span class="tok-number">2</span>;
            }
            <span class="tok-kw">return</span> lbrace - end_offset;
        },

        .container_decl,
        .container_decl_trailing,
        .container_decl_two,
        .container_decl_two_trailing,
        .container_decl_arg,
        .container_decl_arg_trailing,
        .tagged_union,
        .tagged_union_trailing,
        .tagged_union_two,
        .tagged_union_two_trailing,
        .tagged_union_enum_tag,
        .tagged_union_enum_tag_trailing,
        =&gt; {
            <span class="tok-kw">const</span> main_token = main_tokens[n];
            <span class="tok-kw">switch</span> (token_tags[main_token -| <span class="tok-number">1</span>]) {
                .keyword_packed, .keyword_extern =&gt; end_offset += <span class="tok-number">1</span>,
                <span class="tok-kw">else</span> =&gt; {},
            }
            <span class="tok-kw">return</span> main_token - end_offset;
        },

        .ptr_type_aligned,
        .ptr_type_sentinel,
        .ptr_type,
        .ptr_type_bit_range,
        =&gt; <span class="tok-kw">return</span> main_tokens[n] - end_offset,

        .switch_case_one =&gt; {
            <span class="tok-kw">if</span> (datas[n].lhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] - <span class="tok-number">1</span> - end_offset;<span class="tok-comment"> // else token
            </span>} <span class="tok-kw">else</span> {
                n = datas[n].lhs;
            }
        },
        .switch_case_inline_one =&gt; {
            <span class="tok-kw">if</span> (datas[n].lhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] - <span class="tok-number">2</span> - end_offset;<span class="tok-comment"> // else token
            </span>} <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <a href="std.zig.Ast.html#std.zig.Ast.firstToken">firstToken</a>(tree, datas[n].lhs) - <span class="tok-number">1</span>;
            }
        },
        .switch_case =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.end - extra.start &gt; <span class="tok-number">0</span>);
            n = tree.extra_data[extra.start];
        },
        .switch_case_inline =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.end - extra.start &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> <a href="std.zig.Ast.html#std.zig.Ast.firstToken">firstToken</a>(tree, tree.extra_data[extra.start]) - <span class="tok-number">1</span>;
        },

        .asm_output, .asm_input =&gt; {
            <a href="std.debug.html#std.debug.assert">assert</a>(token_tags[main_tokens[n] - <span class="tok-number">1</span>] == .l_bracket);
            <span class="tok-kw">return</span> main_tokens[n] - <span class="tok-number">1</span> - end_offset;
        },

        .while_simple,
        .while_cont,
        .@&quot;while&quot;,
        .for_simple,
        .@&quot;for&quot;,
        =&gt; {<span class="tok-comment">
            // Look for a label and inline.
            </span><span class="tok-kw">const</span> main_token = main_tokens[n];
            <span class="tok-kw">var</span> result = main_token;
            <span class="tok-kw">if</span> (token_tags[result -| <span class="tok-number">1</span>] == .keyword_inline) {
                result -= <span class="tok-number">1</span>;
            }
            <span class="tok-kw">if</span> (token_tags[result -| <span class="tok-number">1</span>] == .colon) {
                result -|= <span class="tok-number">2</span>;
            }
            <span class="tok-kw">return</span> result - end_offset;
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastToken</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> {
    <span class="tok-kw">const</span> tags = tree.nodes.items(.tag);
    <span class="tok-kw">const</span> datas = tree.nodes.items(.data);
    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> n = node;
    <span class="tok-kw">var</span> end_offset: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (tags[n]) {
        .root =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, <span class="tok-builtin">@intCast</span>(tree.tokens.len - <span class="tok-number">1</span>)),

        .@&quot;usingnamespace&quot;,
        .bool_not,
        .negation,
        .bit_not,
        .negation_wrap,
        .address_of,
        .@&quot;try&quot;,
        .@&quot;await&quot;,
        .optional_type,
        .@&quot;resume&quot;,
        .@&quot;nosuspend&quot;,
        .@&quot;comptime&quot;,
        =&gt; n = datas[n].lhs,

        .test_decl,
        .@&quot;errdefer&quot;,
        .@&quot;defer&quot;,
        .@&quot;catch&quot;,
        .equal_equal,
        .bang_equal,
        .less_than,
        .greater_than,
        .less_or_equal,
        .greater_or_equal,
        .assign_mul,
        .assign_div,
        .assign_mod,
        .assign_add,
        .assign_sub,
        .assign_shl,
        .assign_shl_sat,
        .assign_shr,
        .assign_bit_and,
        .assign_bit_xor,
        .assign_bit_or,
        .assign_mul_wrap,
        .assign_add_wrap,
        .assign_sub_wrap,
        .assign_mul_sat,
        .assign_add_sat,
        .assign_sub_sat,
        .assign,
        .assign_destructure,
        .merge_error_sets,
        .mul,
        .div,
        .mod,
        .array_mult,
        .mul_wrap,
        .mul_sat,
        .add,
        .sub,
        .array_cat,
        .add_wrap,
        .sub_wrap,
        .add_sat,
        .sub_sat,
        .shl,
        .shl_sat,
        .shr,
        .bit_and,
        .bit_xor,
        .bit_or,
        .@&quot;orelse&quot;,
        .bool_and,
        .bool_or,
        .anyframe_type,
        .error_union,
        .if_simple,
        .while_simple,
        .for_simple,
        .fn_proto_simple,
        .fn_proto_multi,
        .ptr_type_aligned,
        .ptr_type_sentinel,
        .ptr_type,
        .ptr_type_bit_range,
        .array_type,
        .switch_case_one,
        .switch_case_inline_one,
        .switch_case,
        .switch_case_inline,
        .switch_range,
        =&gt; n = datas[n].rhs,

        .for_range =&gt; <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
            n = datas[n].rhs;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> main_tokens[n] + end_offset;
        },

        .field_access,
        .unwrap_optional,
        .grouped_expression,
        .multiline_string_literal,
        .error_set_decl,
        .asm_simple,
        .asm_output,
        .asm_input,
        .error_value,
        =&gt; <span class="tok-kw">return</span> datas[n].rhs + end_offset,

        .anyframe_literal,
        .char_literal,
        .number_literal,
        .unreachable_literal,
        .identifier,
        .deref,
        .enum_literal,
        .string_literal,
        =&gt; <span class="tok-kw">return</span> main_tokens[n] + end_offset,

        .@&quot;return&quot; =&gt; <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
            n = datas[n].lhs;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> main_tokens[n] + end_offset;
        },

        .call, .async_call =&gt; {
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
            </span><span class="tok-kw">const</span> params = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <span class="tok-kw">if</span> (params.end - params.start == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
            n = tree.extra_data[params.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
        </span>},
        .tagged_union_enum_tag =&gt; {
            <span class="tok-kw">const</span> members = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <span class="tok-kw">if</span> (members.end - members.start == <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">4</span>;<span class="tok-comment"> // for the rparen + rparen + lbrace + rbrace
                </span>n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
                </span>n = tree.extra_data[members.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
            </span>}
        },
        .call_comma,
        .async_call_comma,
        .tagged_union_enum_tag_trailing,
        =&gt; {
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // for the comma/semicolon + rparen/rbrace
            </span><span class="tok-kw">const</span> params = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(params.end &gt; params.start);
            n = tree.extra_data[params.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
        </span>},
        .@&quot;switch&quot; =&gt; {
            <span class="tok-kw">const</span> cases = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <span class="tok-kw">if</span> (cases.end - cases.start == <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">3</span>;<span class="tok-comment"> // rparen, lbrace, rbrace
                </span>n = datas[n].lhs;<span class="tok-comment"> // condition expression
            </span>} <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
                </span>n = tree.extra_data[cases.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last case
            </span>}
        },
        .container_decl_arg =&gt; {
            <span class="tok-kw">const</span> members = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <span class="tok-kw">if</span> (members.end - members.start == <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">3</span>;<span class="tok-comment"> // for the rparen + lbrace + rbrace
                </span>n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
                </span>n = tree.extra_data[members.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
            </span>}
        },
        .@&quot;asm&quot; =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.Asm.html">Asm</a>);
            <span class="tok-kw">return</span> extra.rparen + end_offset;
        },
        .array_init,
        .struct_init,
        =&gt; {
            <span class="tok-kw">const</span> elements = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(elements.end - elements.start &gt; <span class="tok-number">0</span>);
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
            </span>n = tree.extra_data[elements.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last element
        </span>},
        .array_init_comma,
        .struct_init_comma,
        .container_decl_arg_trailing,
        .switch_comma,
        =&gt; {
            <span class="tok-kw">const</span> members = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(members.end - members.start &gt; <span class="tok-number">0</span>);
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // for the comma + rbrace
            </span>n = tree.extra_data[members.end - <span class="tok-number">1</span>];<span class="tok-comment"> // last parameter
        </span>},
        .array_init_dot,
        .struct_init_dot,
        .block,
        .container_decl,
        .tagged_union,
        .builtin_call,
        =&gt; {
            <a href="std.debug.html#std.debug.assert">assert</a>(datas[n].rhs - datas[n].lhs &gt; <span class="tok-number">0</span>);
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rbrace
            </span>n = tree.extra_data[datas[n].rhs - <span class="tok-number">1</span>];<span class="tok-comment"> // last statement
        </span>},
        .array_init_dot_comma,
        .struct_init_dot_comma,
        .block_semicolon,
        .container_decl_trailing,
        .tagged_union_trailing,
        .builtin_call_comma,
        =&gt; {
            <a href="std.debug.html#std.debug.assert">assert</a>(datas[n].rhs - datas[n].lhs &gt; <span class="tok-number">0</span>);
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // for the comma/semicolon + rbrace/rparen
            </span>n = tree.extra_data[datas[n].rhs - <span class="tok-number">1</span>];<span class="tok-comment"> // last member
        </span>},
        .call_one,
        .async_call_one,
        .array_access,
        =&gt; {
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen/rbracket
            </span><span class="tok-kw">if</span> (datas[n].rhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
            n = datas[n].rhs;
        },
        .array_init_dot_two,
        .block_two,
        .builtin_call_two,
        .struct_init_dot_two,
        .container_decl_two,
        .tagged_union_two,
        =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen/rbrace
                </span>n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen/rbrace
                </span>n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">switch</span> (tags[n]) {
                    .array_init_dot_two,
                    .block_two,
                    .struct_init_dot_two,
                    =&gt; end_offset += <span class="tok-number">1</span>,<span class="tok-comment"> // rbrace
                    </span>.builtin_call_two =&gt; end_offset += <span class="tok-number">2</span>,<span class="tok-comment"> // lparen/lbrace + rparen/rbrace
                    </span>.container_decl_two =&gt; {
                        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">2</span>;<span class="tok-comment"> // lbrace + rbrace
                        </span><span class="tok-kw">while</span> (token_tags[main_tokens[n] + i] == .container_doc_comment) i += <span class="tok-number">1</span>;
                        end_offset += i;
                    },
                    .tagged_union_two =&gt; {
                        <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;<span class="tok-comment"> // (enum) {}
                        </span><span class="tok-kw">while</span> (token_tags[main_tokens[n] + i] == .container_doc_comment) i += <span class="tok-number">1</span>;
                        end_offset += i;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .array_init_dot_two_comma,
        .builtin_call_two_comma,
        .block_two_semicolon,
        .struct_init_dot_two_comma,
        .container_decl_two_trailing,
        .tagged_union_two_trailing,
        =&gt; {
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // for the comma/semicolon + rbrace/rparen
            </span><span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">unreachable</span>;
            }
        },
        .simple_var_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // from mut token to name
                </span><span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .aligned_var_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // from mut token to name
                </span><span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .global_var_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.GlobalVarDecl.html">GlobalVarDecl</a>);
                <span class="tok-kw">if</span> (extra.section_node != <span class="tok-number">0</span>) {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                    </span>n = extra.section_node;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.align_node != <span class="tok-number">0</span>) {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                    </span>n = extra.align_node;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.type_node != <span class="tok-number">0</span>) {
                    n = extra.type_node;
                } <span class="tok-kw">else</span> {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // from mut token to name
                    </span><span class="tok-kw">return</span> main_tokens[n] + end_offset;
                }
            }
        },
        .local_var_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.LocalVarDecl.html">LocalVarDecl</a>);
                <span class="tok-kw">if</span> (extra.align_node != <span class="tok-number">0</span>) {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                    </span>n = extra.align_node;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.type_node != <span class="tok-number">0</span>) {
                    n = extra.type_node;
                } <span class="tok-kw">else</span> {
                    end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // from mut token to name
                    </span><span class="tok-kw">return</span> main_tokens[n] + end_offset;
                }
            }
        },
        .container_field_init =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .container_field_align =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .container_field =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ContainerField.html">ContainerField</a>);
            <span class="tok-kw">if</span> (extra.value_expr != <span class="tok-number">0</span>) {
                n = extra.value_expr;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.align_expr != <span class="tok-number">0</span>) {
                end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>n = extra.align_expr;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },

        .array_init_one,
        .struct_init_one,
        =&gt; {
            end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // rbrace
            </span><span class="tok-kw">if</span> (datas[n].rhs == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            } <span class="tok-kw">else</span> {
                n = datas[n].rhs;
            }
        },
        .slice_open,
        .call_one_comma,
        .async_call_one_comma,
        .array_init_one_comma,
        .struct_init_one_comma,
        =&gt; {
            end_offset += <span class="tok-number">2</span>;<span class="tok-comment"> // ellipsis2 + rbracket, or comma + rparen
            </span>n = datas[n].rhs;
            <a href="std.debug.html#std.debug.assert">assert</a>(n != <span class="tok-number">0</span>);
        },
        .slice =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.Slice.html">Slice</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.end != <span class="tok-number">0</span>);<span class="tok-comment"> // should have used slice_open
            </span>end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // rbracket
            </span>n = extra.end;
        },
        .slice_sentinel =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SliceSentinel.html">SliceSentinel</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.sentinel != <span class="tok-number">0</span>);<span class="tok-comment"> // should have used slice
            </span>end_offset += <span class="tok-number">1</span>;<span class="tok-comment"> // rbracket
            </span>n = extra.sentinel;
        },

        .@&quot;continue&quot;, .@&quot;break&quot; =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> datas[n].lhs + end_offset;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .fn_decl =&gt; {
            <span class="tok-kw">if</span> (datas[n].rhs != <span class="tok-number">0</span>) {
                n = datas[n].rhs;
            } <span class="tok-kw">else</span> {
                n = datas[n].lhs;
            }
        },
        .fn_proto_one =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.FnProtoOne.html">FnProtoOne</a>);<span class="tok-comment">
            // addrspace, linksection, callconv, align can appear in any order, so we
            // find the last one here.
            </span><span class="tok-kw">var</span> max_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = datas[n].rhs;
            <span class="tok-kw">var</span> max_start = token_starts[main_tokens[max_node]];
            <span class="tok-kw">var</span> max_offset: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (extra.align_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.align_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.align_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.addrspace_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.addrspace_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.addrspace_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.section_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.section_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.section_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.callconv_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.callconv_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.callconv_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            n = max_node;
            end_offset += max_offset;
        },
        .fn_proto =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.FnProto.html">FnProto</a>);<span class="tok-comment">
            // addrspace, linksection, callconv, align can appear in any order, so we
            // find the last one here.
            </span><span class="tok-kw">var</span> max_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = datas[n].rhs;
            <span class="tok-kw">var</span> max_start = token_starts[main_tokens[max_node]];
            <span class="tok-kw">var</span> max_offset: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (extra.align_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.align_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.align_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.addrspace_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.addrspace_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.addrspace_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.section_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.section_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.section_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            <span class="tok-kw">if</span> (extra.callconv_expr != <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> start = token_starts[main_tokens[extra.callconv_expr]];
                <span class="tok-kw">if</span> (start &gt; max_start) {
                    max_node = extra.callconv_expr;
                    max_start = start;
                    max_offset = <span class="tok-number">1</span>;<span class="tok-comment"> // for the rparen
                </span>}
            }
            n = max_node;
            end_offset += max_offset;
        },
        .while_cont =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.WhileCont.html">WhileCont</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.then_expr != <span class="tok-number">0</span>);
            n = extra.then_expr;
        },
        .@&quot;while&quot; =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.While.html">While</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.else_expr != <span class="tok-number">0</span>);
            n = extra.else_expr;
        },
        .@&quot;if&quot; =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.If.html">If</a>);
            <a href="std.debug.html#std.debug.assert">assert</a>(extra.else_expr != <span class="tok-number">0</span>);
            n = extra.else_expr;
        },
        .@&quot;for&quot; =&gt; {
            <span class="tok-kw">const</span> extra = <span class="tok-builtin">@as</span>(<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.For.html">For</a>, <span class="tok-builtin">@bitCast</span>(datas[n].rhs));
            n = tree.extra_data[datas[n].lhs + extra.inputs + <span class="tok-builtin">@intFromBool</span>(extra.has_else)];
        },
        .@&quot;suspend&quot; =&gt; {
            <span class="tok-kw">if</span> (datas[n].lhs != <span class="tok-number">0</span>) {
                n = datas[n].lhs;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> main_tokens[n] + end_offset;
            }
        },
        .array_type_sentinel =&gt; {
            <span class="tok-kw">const</span> extra = tree.extraData(datas[n].rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ArrayTypeSentinel.html">ArrayTypeSentinel</a>);
            n = extra.elem_type;
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokensOnSameLine</span>(tree: <a href="std.zig.Ast.html">Ast</a>, token1: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, token2: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> source = tree.source[token_starts[token1]..token_starts[token2]];
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, source, <span class="tok-str">'\n'</span>) == <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getNodeSource</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">const</span> first_token = tree.firstToken(node);
    <span class="tok-kw">const</span> last_token = tree.lastToken(node);
    <span class="tok-kw">const</span> start = token_starts[first_token];
    <span class="tok-kw">const</span> end = token_starts[last_token] + tree.tokenSlice(last_token).len;
    <span class="tok-kw">return</span> tree.source[start..end];
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">globalVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .global_var_decl);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.GlobalVarDecl.html">GlobalVarDecl</a>);
    <span class="tok-kw">return</span> tree.fullVarDeclComponents(.{
        .type_node = extra.type_node,
        .align_node = extra.align_node,
        .addrspace_node = extra.addrspace_node,
        .section_node = extra.section_node,
        .init_node = data.rhs,
        .mut_token = tree.nodes.items(.main_token)[node],
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">localVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .local_var_decl);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.LocalVarDecl.html">LocalVarDecl</a>);
    <span class="tok-kw">return</span> tree.fullVarDeclComponents(.{
        .type_node = extra.type_node,
        .align_node = extra.align_node,
        .addrspace_node = <span class="tok-number">0</span>,
        .section_node = <span class="tok-number">0</span>,
        .init_node = data.rhs,
        .mut_token = tree.nodes.items(.main_token)[node],
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">simpleVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .simple_var_decl);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullVarDeclComponents(.{
        .type_node = data.lhs,
        .align_node = <span class="tok-number">0</span>,
        .addrspace_node = <span class="tok-number">0</span>,
        .section_node = <span class="tok-number">0</span>,
        .init_node = data.rhs,
        .mut_token = tree.nodes.items(.main_token)[node],
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignedVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .aligned_var_decl);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullVarDeclComponents(.{
        .type_node = <span class="tok-number">0</span>,
        .align_node = data.lhs,
        .addrspace_node = <span class="tok-number">0</span>,
        .section_node = <span class="tok-number">0</span>,
        .init_node = data.rhs,
        .mut_token = tree.nodes.items(.main_token)[node],
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assignDestructure</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.AssignDestructure.html">AssignDestructure</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> variable_count = tree.extra_data[data.lhs];
    <span class="tok-kw">return</span> tree.fullAssignDestructureComponents(.{
        .variables = tree.extra_data[data.lhs + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..variable_count],
        .equal_token = tree.nodes.items(.main_token)[node],
        .value_expr = data.rhs,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ifSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .if_simple);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullIfComponents(.{
        .cond_expr = data.lhs,
        .then_expr = data.rhs,
        .else_expr = <span class="tok-number">0</span>,
        .if_token = tree.nodes.items(.main_token)[node],
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ifFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .@&quot;if&quot;);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.If.html">If</a>);
    <span class="tok-kw">return</span> tree.fullIfComponents(.{
        .cond_expr = data.lhs,
        .then_expr = extra.then_expr,
        .else_expr = extra.else_expr,
        .if_token = tree.nodes.items(.main_token)[node],
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerField</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_field);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ContainerField.html">ContainerField</a>);
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerFieldComponents(.{
        .main_token = main_token,
        .type_expr = data.lhs,
        .align_expr = extra.align_expr,
        .value_expr = extra.value_expr,
        .tuple_like = tree.tokens.items(.tag)[main_token] != .identifier <span class="tok-kw">or</span>
            tree.tokens.items(.tag)[main_token + <span class="tok-number">1</span>] != .colon,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerFieldInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_field_init);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerFieldComponents(.{
        .main_token = main_token,
        .type_expr = data.lhs,
        .align_expr = <span class="tok-number">0</span>,
        .value_expr = data.rhs,
        .tuple_like = tree.tokens.items(.tag)[main_token] != .identifier <span class="tok-kw">or</span>
            tree.tokens.items(.tag)[main_token + <span class="tok-number">1</span>] != .colon,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerFieldAlign</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_field_align);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerFieldComponents(.{
        .main_token = main_token,
        .type_expr = data.lhs,
        .align_expr = data.rhs,
        .value_expr = <span class="tok-number">0</span>,
        .tuple_like = tree.tokens.items(.tag)[main_token] != .identifier <span class="tok-kw">or</span>
            tree.tokens.items(.tag)[main_token + <span class="tok-number">1</span>] != .colon,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .fn_proto_simple);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer[<span class="tok-number">0</span>] = data.lhs;
    <span class="tok-kw">const</span> params = <span class="tok-kw">if</span> (data.lhs == <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> tree.fullFnProtoComponents(.{
        .proto_node = node,
        .fn_token = tree.nodes.items(.main_token)[node],
        .return_type = data.rhs,
        .params = params,
        .align_expr = <span class="tok-number">0</span>,
        .addrspace_expr = <span class="tok-number">0</span>,
        .section_expr = <span class="tok-number">0</span>,
        .callconv_expr = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoMulti</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .fn_proto_multi);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> params_range = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">const</span> params = tree.extra_data[params_range.start..params_range.end];
    <span class="tok-kw">return</span> tree.fullFnProtoComponents(.{
        .proto_node = node,
        .fn_token = tree.nodes.items(.main_token)[node],
        .return_type = data.rhs,
        .params = params,
        .align_expr = <span class="tok-number">0</span>,
        .addrspace_expr = <span class="tok-number">0</span>,
        .section_expr = <span class="tok-number">0</span>,
        .callconv_expr = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProtoOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .fn_proto_one);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.FnProtoOne.html">FnProtoOne</a>);
    buffer[<span class="tok-number">0</span>] = extra.param;
    <span class="tok-kw">const</span> params = <span class="tok-kw">if</span> (extra.param == <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> tree.fullFnProtoComponents(.{
        .proto_node = node,
        .fn_token = tree.nodes.items(.main_token)[node],
        .return_type = data.rhs,
        .params = params,
        .align_expr = extra.align_expr,
        .addrspace_expr = extra.addrspace_expr,
        .section_expr = extra.section_expr,
        .callconv_expr = extra.callconv_expr,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnProto</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .fn_proto);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.FnProto.html">FnProto</a>);
    <span class="tok-kw">const</span> params = tree.extra_data[extra.params_start..extra.params_end];
    <span class="tok-kw">return</span> tree.fullFnProtoComponents(.{
        .proto_node = node,
        .fn_token = tree.nodes.items(.main_token)[node],
        .return_type = data.rhs,
        .params = params,
        .align_expr = extra.align_expr,
        .addrspace_expr = extra.addrspace_expr,
        .section_expr = extra.section_expr,
        .callconv_expr = extra.callconv_expr,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .struct_init_one <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .struct_init_one_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer[<span class="tok-number">0</span>] = data.rhs;
    <span class="tok-kw">const</span> fields = <span class="tok-kw">if</span> (data.rhs == <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .fields = fields,
            .type_expr = data.lhs,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitDotTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .struct_init_dot_two <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .struct_init_dot_two_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{ data.lhs, data.rhs };
    <span class="tok-kw">const</span> fields = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>]
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data.lhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
    <span class="tok-kw">else</span>
        buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .fields = fields,
            .type_expr = <span class="tok-number">0</span>,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInitDot</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .struct_init_dot <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .struct_init_dot_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .fields = tree.extra_data[data.lhs..data.rhs],
            .type_expr = <span class="tok-number">0</span>,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .struct_init <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .struct_init_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> fields_range = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .fields = tree.extra_data[fields_range.start..fields_range.end],
            .type_expr = data.lhs,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_init_one <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .array_init_one_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer[<span class="tok-number">0</span>] = data.rhs;
    <span class="tok-kw">const</span> elements = <span class="tok-kw">if</span> (data.rhs == <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .elements = elements,
            .type_expr = data.lhs,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitDotTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_init_dot_two <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .array_init_dot_two_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{ data.lhs, data.rhs };
    <span class="tok-kw">const</span> elements = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>]
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data.lhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
    <span class="tok-kw">else</span>
        buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .elements = elements,
            .type_expr = <span class="tok-number">0</span>,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInitDot</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_init_dot <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .array_init_dot_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .elements = tree.extra_data[data.lhs..data.rhs],
            .type_expr = <span class="tok-number">0</span>,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_init <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .array_init_comma);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> elem_range = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbrace = tree.nodes.items(.main_token)[node],
            .elements = tree.extra_data[elem_range.start..elem_range.end],
            .type_expr = data.lhs,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_type);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbracket = tree.nodes.items(.main_token)[node],
            .elem_count = data.lhs,
            .sentinel = <span class="tok-number">0</span>,
            .elem_type = data.rhs,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayTypeSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .array_type_sentinel);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.ArrayTypeSentinel.html">ArrayTypeSentinel</a>);
    <a href="std.debug.html#std.debug.assert">assert</a>(extra.sentinel != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .lbracket = tree.nodes.items(.main_token)[node],
            .elem_count = data.lhs,
            .sentinel = extra.sentinel,
            .elem_type = extra.elem_type,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeAligned</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .ptr_type_aligned);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullPtrTypeComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .align_node = data.lhs,
        .addrspace_node = <span class="tok-number">0</span>,
        .sentinel = <span class="tok-number">0</span>,
        .bit_range_start = <span class="tok-number">0</span>,
        .bit_range_end = <span class="tok-number">0</span>,
        .child_type = data.rhs,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .ptr_type_sentinel);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullPtrTypeComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .align_node = <span class="tok-number">0</span>,
        .addrspace_node = <span class="tok-number">0</span>,
        .sentinel = data.lhs,
        .bit_range_start = <span class="tok-number">0</span>,
        .bit_range_end = <span class="tok-number">0</span>,
        .child_type = data.rhs,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .ptr_type);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.PtrType.html">PtrType</a>);
    <span class="tok-kw">return</span> tree.fullPtrTypeComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .align_node = extra.align_node,
        .addrspace_node = extra.addrspace_node,
        .sentinel = extra.sentinel,
        .bit_range_start = <span class="tok-number">0</span>,
        .bit_range_end = <span class="tok-number">0</span>,
        .child_type = data.rhs,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeBitRange</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .ptr_type_bit_range);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.PtrTypeBitRange.html">PtrTypeBitRange</a>);
    <span class="tok-kw">return</span> tree.fullPtrTypeComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .align_node = extra.align_node,
        .addrspace_node = extra.addrspace_node,
        .sentinel = extra.sentinel,
        .bit_range_start = extra.bit_range_start,
        .bit_range_end = extra.bit_range_end,
        .child_type = data.rhs,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceOpen</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .slice_open);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> .{
        .ast = .{
            .sliced = data.lhs,
            .lbracket = tree.nodes.items(.main_token)[node],
            .start = data.rhs,
            .end = <span class="tok-number">0</span>,
            .sentinel = <span class="tok-number">0</span>,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .slice);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.Slice.html">Slice</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .sliced = data.lhs,
            .lbracket = tree.nodes.items(.main_token)[node],
            .start = extra.start,
            .end = extra.end,
            .sentinel = <span class="tok-number">0</span>,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceSentinel</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .slice_sentinel);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SliceSentinel.html">SliceSentinel</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .sliced = data.lhs,
            .lbracket = tree.nodes.items(.main_token)[node],
            .start = extra.start,
            .end = extra.end,
            .sentinel = extra.sentinel,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_decl_two <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .container_decl_two_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{ data.lhs, data.rhs };
    <span class="tok-kw">const</span> members = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>]
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data.lhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
    <span class="tok-kw">else</span>
        buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .enum_token = <span class="tok-null">null</span>,
        .members = members,
        .arg = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_decl <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .container_decl_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .enum_token = <span class="tok-null">null</span>,
        .members = tree.extra_data[data.lhs..data.rhs],
        .arg = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclArg</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .container_decl_arg <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .container_decl_arg_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> members_range = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = tree.nodes.items(.main_token)[node],
        .enum_token = <span class="tok-null">null</span>,
        .members = tree.extra_data[members_range.start..members_range.end],
        .arg = data.lhs,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containerDeclRoot</span>(tree: <a href="std.zig.Ast.html">Ast</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <span class="tok-kw">return</span> .{
        .layout_token = <span class="tok-null">null</span>,
        .ast = .{
            .main_token = <span class="tok-null">undefined</span>,
            .enum_token = <span class="tok-null">null</span>,
            .members = tree.rootDecls(),
            .arg = <span class="tok-number">0</span>,
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnionTwo</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .tagged_union_two <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .tagged_union_two_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{ data.lhs, data.rhs };
    <span class="tok-kw">const</span> members = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>]
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data.lhs != <span class="tok-number">0</span>)
        buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>]
    <span class="tok-kw">else</span>
        buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = main_token,
        .enum_token = main_token + <span class="tok-number">2</span>,<span class="tok-comment"> // union lparen enum
        </span>.members = members,
        .arg = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnion</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .tagged_union <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .tagged_union_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = main_token,
        .enum_token = main_token + <span class="tok-number">2</span>,<span class="tok-comment"> // union lparen enum
        </span>.members = tree.extra_data[data.lhs..data.rhs],
        .arg = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">taggedUnionEnumTag</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(tree.nodes.items(.tag)[node] == .tagged_union_enum_tag <span class="tok-kw">or</span>
        tree.nodes.items(.tag)[node] == .tagged_union_enum_tag_trailing);
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> members_range = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">return</span> tree.fullContainerDeclComponents(.{
        .main_token = main_token,
        .enum_token = main_token + <span class="tok-number">2</span>,<span class="tok-comment"> // union lparen enum
        </span>.members = tree.extra_data[members_range.start..members_range.end],
        .arg = data.lhs,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a> {
    <span class="tok-kw">const</span> data = &amp;tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[node];
    <span class="tok-kw">const</span> switch_token: TokenIndex, <span class="tok-kw">const</span> label_token: ?TokenIndex = <span class="tok-kw">switch</span> (tree.tokens.items(.tag)[main_token]) {
        .identifier =&gt; .{ main_token + <span class="tok-number">2</span>, main_token },
        .keyword_switch =&gt; .{ main_token, <span class="tok-null">null</span> },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> .{
        .ast = .{
            .switch_token = switch_token,
            .condition = data.lhs,
            .cases = tree.extra_data[extra.start..extra.end],
        },
        .label_token = label_token,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchCaseOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a> {
    <span class="tok-kw">const</span> data = &amp;tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> values: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = &amp;data.lhs;
    <span class="tok-kw">return</span> tree.fullSwitchCaseComponents(.{
        .values = <span class="tok-kw">if</span> (data.lhs == <span class="tok-number">0</span>) values[<span class="tok-number">0</span>..<span class="tok-number">0</span>] <span class="tok-kw">else</span> values[<span class="tok-number">0</span>..<span class="tok-number">1</span>],
        .arrow_token = tree.nodes.items(.main_token)[node],
        .target_expr = data.rhs,
    }, node);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">switchCase</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.lhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> tree.fullSwitchCaseComponents(.{
        .values = tree.extra_data[extra.start..extra.end],
        .arrow_token = tree.nodes.items(.main_token)[node],
        .target_expr = data.rhs,
    }, node);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullAsmComponents(.{
        .asm_token = tree.nodes.items(.main_token)[node],
        .template = data.lhs,
        .items = &amp;.{},
        .rparen = data.rhs,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.Asm.html">Asm</a>);
    <span class="tok-kw">return</span> tree.fullAsmComponents(.{
        .asm_token = tree.nodes.items(.main_token)[node],
        .template = data.lhs,
        .items = tree.extra_data[extra.items_start..extra.items_end],
        .rparen = extra.rparen,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">return</span> tree.fullWhileComponents(.{
        .while_token = tree.nodes.items(.main_token)[node],
        .cond_expr = data.lhs,
        .cont_expr = <span class="tok-number">0</span>,
        .then_expr = data.rhs,
        .else_expr = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileCont</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.WhileCont.html">WhileCont</a>);
    <span class="tok-kw">return</span> tree.fullWhileComponents(.{
        .while_token = tree.nodes.items(.main_token)[node],
        .cond_expr = data.lhs,
        .cont_expr = extra.cont_expr,
        .then_expr = extra.then_expr,
        .else_expr = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">whileFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.While.html">While</a>);
    <span class="tok-kw">return</span> tree.fullWhileComponents(.{
        .while_token = tree.nodes.items(.main_token)[node],
        .cond_expr = data.lhs,
        .cont_expr = extra.cont_expr,
        .then_expr = extra.then_expr,
        .else_expr = extra.else_expr,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forSimple</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a> {
    <span class="tok-kw">const</span> data = &amp;tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> inputs: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a> = &amp;data.lhs;
    <span class="tok-kw">return</span> tree.fullForComponents(.{
        .for_token = tree.nodes.items(.main_token)[node],
        .inputs = inputs[<span class="tok-number">0</span>..<span class="tok-number">1</span>],
        .then_expr = data.rhs,
        .else_expr = <span class="tok-number">0</span>,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = <span class="tok-builtin">@as</span>(<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.For.html">For</a>, <span class="tok-builtin">@bitCast</span>(data.rhs));
    <span class="tok-kw">const</span> inputs = tree.extra_data[data.lhs..][<span class="tok-number">0</span>..extra.inputs];
    <span class="tok-kw">const</span> then_expr = tree.extra_data[data.lhs + extra.inputs];
    <span class="tok-kw">const</span> else_expr = <span class="tok-kw">if</span> (extra.has_else) tree.extra_data[data.lhs + extra.inputs + <span class="tok-number">1</span>] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> tree.fullForComponents(.{
        .for_token = tree.nodes.items(.main_token)[node],
        .inputs = inputs,
        .then_expr = then_expr,
        .else_expr = else_expr,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callOne</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    buffer.* = .{data.rhs};
    <span class="tok-kw">const</span> params = <span class="tok-kw">if</span> (data.rhs != <span class="tok-number">0</span>) buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>] <span class="tok-kw">else</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];
    <span class="tok-kw">return</span> tree.fullCallComponents(.{
        .lparen = tree.nodes.items(.main_token)[node],
        .fn_expr = data.lhs,
        .params = params,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callFull</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a> {
    <span class="tok-kw">const</span> data = tree.nodes.items(.data)[node];
    <span class="tok-kw">const</span> extra = tree.extraData(data.rhs, <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.SubRange.html">SubRange</a>);
    <span class="tok-kw">return</span> tree.fullCallComponents(.{
        .lparen = tree.nodes.items(.main_token)[node],
        .fn_expr = data.lhs,
        .params = tree.extra_data[extra.start..extra.end],
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullVarDeclComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a>.<a href="std.zig.Ast.full.VarDecl.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> = .{
        .ast = info,
        .visib_token = <span class="tok-null">null</span>,
        .extern_export_token = <span class="tok-null">null</span>,
        .lib_name = <span class="tok-null">null</span>,
        .threadlocal_token = <span class="tok-null">null</span>,
        .comptime_token = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">var</span> i = info.mut_token;
    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        <span class="tok-kw">switch</span> (token_tags[i]) {
            .keyword_extern, .keyword_export =&gt; result.extern_export_token = i,
            .keyword_comptime =&gt; result.comptime_token = i,
            .keyword_pub =&gt; result.visib_token = i,
            .keyword_threadlocal =&gt; result.threadlocal_token = i,
            .string_literal =&gt; result.lib_name = i,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullAssignDestructureComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.AssignDestructure.html">AssignDestructure</a>.<a href="std.zig.Ast.full.AssignDestructure.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.AssignDestructure.html">AssignDestructure</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.AssignDestructure.html">AssignDestructure</a> = .{
        .comptime_token = <span class="tok-null">null</span>,
        .ast = info,
    };
    <span class="tok-kw">const</span> first_variable_token = tree.firstToken(info.variables[<span class="tok-number">0</span>]);
    <span class="tok-kw">const</span> maybe_comptime_token = <span class="tok-kw">switch</span> (node_tags[info.variables[<span class="tok-number">0</span>]]) {
        .global_var_decl,
        .local_var_decl,
        .aligned_var_decl,
        .simple_var_decl,
        =&gt; first_variable_token,
        <span class="tok-kw">else</span> =&gt; first_variable_token - <span class="tok-number">1</span>,
    };
    <span class="tok-kw">if</span> (token_tags[maybe_comptime_token] == .keyword_comptime) {
        result.comptime_token = maybe_comptime_token;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullIfComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a>.<a href="std.zig.Ast.full.If.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a> = .{
        .ast = info,
        .payload_token = <span class="tok-null">null</span>,
        .error_token = <span class="tok-null">null</span>,
        .else_token = <span class="tok-null">undefined</span>,
    };<span class="tok-comment">
    // if (cond_expr) |x|
    //              ^ ^
    </span><span class="tok-kw">const</span> payload_pipe = tree.lastToken(info.cond_expr) + <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (token_tags[payload_pipe] == .pipe) {
        result.payload_token = payload_pipe + <span class="tok-number">1</span>;
    }
    <span class="tok-kw">if</span> (info.else_expr != <span class="tok-number">0</span>) {<span class="tok-comment">
        // then_expr else |x|
        //           ^    ^
        </span>result.else_token = tree.lastToken(info.then_expr) + <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (token_tags[result.else_token + <span class="tok-number">1</span>] == .pipe) {
            result.error_token = result.else_token + <span class="tok-number">2</span>;
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullContainerFieldComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a>.<a href="std.zig.Ast.full.ContainerField.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> = .{
        .ast = info,
        .comptime_token = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">if</span> (info.main_token &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[info.main_token - <span class="tok-number">1</span>] == .keyword_comptime) {<span class="tok-comment">
        // comptime type = init,
        // ^        ^
        // comptime name: type = init,
        // ^        ^
        </span>result.comptime_token = info.main_token - <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullFnProtoComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a>.<a href="std.zig.Ast.full.FnProto.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> = .{
        .ast = info,
        .visib_token = <span class="tok-null">null</span>,
        .extern_export_inline_token = <span class="tok-null">null</span>,
        .lib_name = <span class="tok-null">null</span>,
        .name_token = <span class="tok-null">null</span>,
        .lparen = <span class="tok-null">undefined</span>,
    };
    <span class="tok-kw">var</span> i = info.fn_token;
    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        <span class="tok-kw">switch</span> (token_tags[i]) {
            .keyword_extern,
            .keyword_export,
            .keyword_inline,
            .keyword_noinline,
            =&gt; result.extern_export_inline_token = i,
            .keyword_pub =&gt; result.visib_token = i,
            .string_literal =&gt; result.lib_name = i,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
        }
    }
    <span class="tok-kw">const</span> after_fn_token = info.fn_token + <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (token_tags[after_fn_token] == .identifier) {
        result.name_token = after_fn_token;
        result.lparen = after_fn_token + <span class="tok-number">1</span>;
    } <span class="tok-kw">else</span> {
        result.lparen = after_fn_token;
    }
    <a href="std.debug.html#std.debug.assert">assert</a>(token_tags[result.lparen] == .l_paren);

    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullPtrTypeComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a>.<a href="std.zig.Ast.full.PtrType.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> size: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Pointer.html">Pointer</a>.<a href="std.builtin.Type.Pointer.Size.html">Size</a> = <span class="tok-kw">switch</span> (token_tags[info.main_token]) {
        .asterisk,
        .asterisk_asterisk,
        =&gt; .one,
        .l_bracket =&gt; <span class="tok-kw">switch</span> (token_tags[info.main_token + <span class="tok-number">1</span>]) {
            .asterisk =&gt; <span class="tok-kw">if</span> (token_tags[info.main_token + <span class="tok-number">2</span>] == .identifier) .c <span class="tok-kw">else</span> .many,
            <span class="tok-kw">else</span> =&gt; .slice,
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> = .{
        .size = size,
        .allowzero_token = <span class="tok-null">null</span>,
        .const_token = <span class="tok-null">null</span>,
        .volatile_token = <span class="tok-null">null</span>,
        .ast = info,
    };<span class="tok-comment">
    // We need to be careful that we don't iterate over any sub-expressions
    // here while looking for modifiers as that could result in false
    // positives. Therefore, start after a sentinel if there is one and
    // skip over any align node and bit range nodes.
    </span><span class="tok-kw">var</span> i = <span class="tok-kw">if</span> (info.sentinel != <span class="tok-number">0</span>) tree.lastToken(info.sentinel) + <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (size) {
        .many, .c =&gt; info.main_token + <span class="tok-number">1</span>,
        <span class="tok-kw">else</span> =&gt; info.main_token,
    };
    <span class="tok-kw">const</span> end = tree.firstToken(info.child_type);
    <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">switch</span> (token_tags[i]) {
            .keyword_allowzero =&gt; result.allowzero_token = i,
            .keyword_const =&gt; result.const_token = i,
            .keyword_volatile =&gt; result.volatile_token = i,
            .keyword_align =&gt; {
                <a href="std.debug.html#std.debug.assert">assert</a>(info.align_node != <span class="tok-number">0</span>);
                <span class="tok-kw">if</span> (info.bit_range_end != <span class="tok-number">0</span>) {
                    <a href="std.debug.html#std.debug.assert">assert</a>(info.bit_range_start != <span class="tok-number">0</span>);
                    i = tree.lastToken(info.bit_range_end) + <span class="tok-number">1</span>;
                } <span class="tok-kw">else</span> {
                    i = tree.lastToken(info.align_node) + <span class="tok-number">1</span>;
                }
            },
            <span class="tok-kw">else</span> =&gt; {},
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullContainerDeclComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a>.<a href="std.zig.Ast.full.ContainerDecl.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> = .{
        .ast = info,
        .layout_token = <span class="tok-null">null</span>,
    };

    <span class="tok-kw">if</span> (info.main_token == <span class="tok-number">0</span>) <span class="tok-kw">return</span> result;

    <span class="tok-kw">switch</span> (token_tags[info.main_token - <span class="tok-number">1</span>]) {
        .keyword_extern, .keyword_packed =&gt; result.layout_token = info.main_token - <span class="tok-number">1</span>,
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullSwitchComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a>.<a href="std.zig.Ast.full.Switch.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> tok_i = info.switch_token -| <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a> = .{
        .ast = info,
        .label_token = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">if</span> (token_tags[tok_i] == .colon <span class="tok-kw">and</span>
        token_tags[tok_i -| <span class="tok-number">1</span>] == .identifier)
    {
        result.label_token = tok_i - <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullSwitchCaseComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a>.<a href="std.zig.Ast.full.SwitchCase.Components.html">Components</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a> = .{
        .ast = info,
        .payload_token = <span class="tok-null">null</span>,
        .inline_token = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">if</span> (token_tags[info.arrow_token + <span class="tok-number">1</span>] == .pipe) {
        result.payload_token = info.arrow_token + <span class="tok-number">2</span>;
    }
    <span class="tok-kw">switch</span> (node_tags[node]) {
        .switch_case_inline, .switch_case_inline_one =&gt; result.inline_token = <a href="std.zig.Ast.html#std.zig.Ast.firstToken">firstToken</a>(tree, node),
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullAsmComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a>.<a href="std.zig.Ast.full.Asm.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a> = .{
        .ast = info,
        .volatile_token = <span class="tok-null">null</span>,
        .inputs = &amp;.{},
        .outputs = &amp;.{},
        .first_clobber = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">if</span> (token_tags[info.asm_token + <span class="tok-number">1</span>] == .keyword_volatile) {
        result.volatile_token = info.asm_token + <span class="tok-number">1</span>;
    }
    <span class="tok-kw">const</span> outputs_end: <span class="tok-type">usize</span> = <span class="tok-kw">for</span> (info.items, <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">switch</span> (node_tags[item]) {
            .asm_output =&gt; <span class="tok-kw">continue</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> i,
        }
    } <span class="tok-kw">else</span> info.items.len;

    result.outputs = info.items[<span class="tok-number">0</span>..outputs_end];
    result.inputs = info.items[outputs_end..];

    <span class="tok-kw">if</span> (info.items.len == <span class="tok-number">0</span>) {<span class="tok-comment">
        // asm (&quot;foo&quot; ::: &quot;a&quot;, &quot;b&quot;);
        </span><span class="tok-kw">const</span> template_token = tree.lastToken(info.template);
        <span class="tok-kw">if</span> (token_tags[template_token + <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span>
            token_tags[template_token + <span class="tok-number">2</span>] == .colon <span class="tok-kw">and</span>
            token_tags[template_token + <span class="tok-number">3</span>] == .colon <span class="tok-kw">and</span>
            token_tags[template_token + <span class="tok-number">4</span>] == .string_literal)
        {
            result.first_clobber = template_token + <span class="tok-number">4</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (result.inputs.len != <span class="tok-number">0</span>) {<span class="tok-comment">
        // asm (&quot;foo&quot; :: [_] &quot;&quot; (y) : &quot;a&quot;, &quot;b&quot;);
        </span><span class="tok-kw">const</span> last_input = result.inputs[result.inputs.len - <span class="tok-number">1</span>];
        <span class="tok-kw">const</span> rparen = tree.lastToken(last_input);
        <span class="tok-kw">var</span> i = rparen + <span class="tok-number">1</span>;<span class="tok-comment">
        // Allow a (useless) comma right after the closing parenthesis.
        </span><span class="tok-kw">if</span> (token_tags[i] == .comma) i += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (token_tags[i] == .colon <span class="tok-kw">and</span>
            token_tags[i + <span class="tok-number">1</span>] == .string_literal)
        {
            result.first_clobber = i + <span class="tok-number">1</span>;
        }
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // asm (&quot;foo&quot; : [_] &quot;&quot; (x) :: &quot;a&quot;, &quot;b&quot;);
        </span><span class="tok-kw">const</span> last_output = result.outputs[result.outputs.len - <span class="tok-number">1</span>];
        <span class="tok-kw">const</span> rparen = tree.lastToken(last_output);
        <span class="tok-kw">var</span> i = rparen + <span class="tok-number">1</span>;<span class="tok-comment">
        // Allow a (useless) comma right after the closing parenthesis.
        </span><span class="tok-kw">if</span> (token_tags[i] == .comma) i += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (token_tags[i] == .colon <span class="tok-kw">and</span>
            token_tags[i + <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span>
            token_tags[i + <span class="tok-number">2</span>] == .string_literal)
        {
            result.first_clobber = i + <span class="tok-number">2</span>;
        }
    }

    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullWhileComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a>.<a href="std.zig.Ast.full.While.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> = .{
        .ast = info,
        .inline_token = <span class="tok-null">null</span>,
        .label_token = <span class="tok-null">null</span>,
        .payload_token = <span class="tok-null">null</span>,
        .else_token = <span class="tok-null">undefined</span>,
        .error_token = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">var</span> tok_i = info.while_token -| <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (token_tags[tok_i] == .keyword_inline) {
        result.inline_token = tok_i;
        tok_i -|= <span class="tok-number">1</span>;
    }
    <span class="tok-kw">if</span> (token_tags[tok_i] == .colon <span class="tok-kw">and</span>
        token_tags[tok_i -| <span class="tok-number">1</span>] == .identifier)
    {
        result.label_token = tok_i - <span class="tok-number">1</span>;
    }
    <span class="tok-kw">const</span> last_cond_token = tree.lastToken(info.cond_expr);
    <span class="tok-kw">if</span> (token_tags[last_cond_token + <span class="tok-number">2</span>] == .pipe) {
        result.payload_token = last_cond_token + <span class="tok-number">3</span>;
    }
    <span class="tok-kw">if</span> (info.else_expr != <span class="tok-number">0</span>) {<span class="tok-comment">
        // then_expr else |x|
        //           ^    ^
        </span>result.else_token = tree.lastToken(info.then_expr) + <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (token_tags[result.else_token + <span class="tok-number">1</span>] == .pipe) {
            result.error_token = result.else_token + <span class="tok-number">2</span>;
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullForComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a>.<a href="std.zig.Ast.full.For.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a> = .{
        .ast = info,
        .inline_token = <span class="tok-null">null</span>,
        .label_token = <span class="tok-null">null</span>,
        .payload_token = <span class="tok-null">undefined</span>,
        .else_token = <span class="tok-null">undefined</span>,
    };
    <span class="tok-kw">var</span> tok_i = info.for_token -| <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (token_tags[tok_i] == .keyword_inline) {
        result.inline_token = tok_i;
        tok_i -|= <span class="tok-number">1</span>;
    }
    <span class="tok-kw">if</span> (token_tags[tok_i] == .colon <span class="tok-kw">and</span>
        token_tags[tok_i -| <span class="tok-number">1</span>] == .identifier)
    {
        result.label_token = tok_i - <span class="tok-number">1</span>;
    }
    <span class="tok-kw">const</span> last_cond_token = tree.lastToken(info.inputs[info.inputs.len - <span class="tok-number">1</span>]);
    result.payload_token = last_cond_token + <span class="tok-number">3</span> + <span class="tok-builtin">@intFromBool</span>(token_tags[last_cond_token + <span class="tok-number">1</span>] == .comma);
    <span class="tok-kw">if</span> (info.else_expr != <span class="tok-number">0</span>) {
        result.else_token = tree.lastToken(info.then_expr) + <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">fullCallComponents</span>(tree: <a href="std.zig.Ast.html">Ast</a>, info: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a>.<a href="std.zig.Ast.full.Call.Components.html">Components</a>) <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a> {
    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);
    <span class="tok-kw">var</span> result: <a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a> = .{
        .ast = info,
        .async_token = <span class="tok-null">null</span>,
    };
    <span class="tok-kw">const</span> first_token = tree.firstToken(info.fn_expr);
    <span class="tok-kw">if</span> (first_token != <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[first_token - <span class="tok-number">1</span>] == .keyword_async) {
        result.async_token = first_token - <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullVarDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.VarDecl.html">VarDecl</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .global_var_decl =&gt; tree.globalVarDecl(node),
        .local_var_decl =&gt; tree.localVarDecl(node),
        .aligned_var_decl =&gt; tree.alignedVarDecl(node),
        .simple_var_decl =&gt; tree.simpleVarDecl(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullIf</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.If.html">If</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .if_simple =&gt; tree.ifSimple(node),
        .@&quot;if&quot; =&gt; tree.ifFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullWhile</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.While.html">While</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .while_simple =&gt; tree.whileSimple(node),
        .while_cont =&gt; tree.whileCont(node),
        .@&quot;while&quot; =&gt; tree.whileFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullFor</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.For.html">For</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .for_simple =&gt; tree.forSimple(node),
        .@&quot;for&quot; =&gt; tree.forFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullContainerField</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .container_field_init =&gt; tree.containerFieldInit(node),
        .container_field_align =&gt; tree.containerFieldAlign(node),
        .container_field =&gt; tree.containerField(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullFnProto</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.FnProto.html">FnProto</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .fn_proto =&gt; tree.fnProto(node),
        .fn_proto_multi =&gt; tree.fnProtoMulti(node),
        .fn_proto_one =&gt; tree.fnProtoOne(buffer, node),
        .fn_proto_simple =&gt; tree.fnProtoSimple(buffer, node),
        .fn_decl =&gt; tree.fullFnProto(buffer, tree.nodes.items(.data)[node].lhs),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullStructInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.StructInit.html">StructInit</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .struct_init_one, .struct_init_one_comma =&gt; tree.structInitOne(buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>], node),
        .struct_init_dot_two, .struct_init_dot_two_comma =&gt; tree.structInitDotTwo(buffer, node),
        .struct_init_dot, .struct_init_dot_comma =&gt; tree.structInitDot(node),
        .struct_init, .struct_init_comma =&gt; tree.structInit(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullArrayInit</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayInit.html">ArrayInit</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .array_init_one, .array_init_one_comma =&gt; tree.arrayInitOne(buffer[<span class="tok-number">0</span>..<span class="tok-number">1</span>], node),
        .array_init_dot_two, .array_init_dot_two_comma =&gt; tree.arrayInitDotTwo(buffer, node),
        .array_init_dot, .array_init_dot_comma =&gt; tree.arrayInitDot(node),
        .array_init, .array_init_comma =&gt; tree.arrayInit(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullArrayType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ArrayType.html">ArrayType</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .array_type =&gt; tree.arrayType(node),
        .array_type_sentinel =&gt; tree.arrayTypeSentinel(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullPtrType</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.PtrType.html">PtrType</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .ptr_type_aligned =&gt; tree.ptrTypeAligned(node),
        .ptr_type_sentinel =&gt; tree.ptrTypeSentinel(node),
        .ptr_type =&gt; tree.ptrType(node),
        .ptr_type_bit_range =&gt; tree.ptrTypeBitRange(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSlice</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Slice.html">Slice</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .slice_open =&gt; tree.sliceOpen(node),
        .slice =&gt; tree.slice(node),
        .slice_sentinel =&gt; tree.sliceSentinel(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullContainerDecl</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">2</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.ContainerDecl.html">ContainerDecl</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .root =&gt; tree.containerDeclRoot(),
        .container_decl, .container_decl_trailing =&gt; tree.containerDecl(node),
        .container_decl_arg, .container_decl_arg_trailing =&gt; tree.containerDeclArg(node),
        .container_decl_two, .container_decl_two_trailing =&gt; tree.containerDeclTwo(buffer, node),
        .tagged_union, .tagged_union_trailing =&gt; tree.taggedUnion(node),
        .tagged_union_enum_tag, .tagged_union_enum_tag_trailing =&gt; tree.taggedUnionEnumTag(node),
        .tagged_union_two, .tagged_union_two_trailing =&gt; tree.taggedUnionTwo(buffer, node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSwitch</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Switch.html">Switch</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .@&quot;switch&quot;, .switch_comma =&gt; tree.switchFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullSwitchCase</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.SwitchCase.html">SwitchCase</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .switch_case_one, .switch_case_inline_one =&gt; tree.switchCaseOne(node),
        .switch_case, .switch_case_inline =&gt; tree.switchCase(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullAsm</span>(tree: <a href="std.zig.Ast.html">Ast</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Asm.html">Asm</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .asm_simple =&gt; tree.asmSimple(node),
        .@&quot;asm&quot; =&gt; tree.asmFull(node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullCall</span>(tree: <a href="std.zig.Ast.html">Ast</a>, buffer: *[<span class="tok-number">1</span>]<a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>, node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>) ?<a href="std.zig.Ast.full.html">full</a>.<a href="std.zig.Ast.full.Call.html">Call</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tree.nodes.items(.tag)[node]) {
        .call, .call_comma, .async_call, .async_call_comma =&gt; tree.callFull(node),
        .call_one, .call_one_comma, .async_call_one, .async_call_one_comma =&gt; tree.callOne(buffer, node),
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}

<span class="tok-comment">/// Fully assembled AST node information.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> full = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> VarDecl = <span class="tok-kw">struct</span> {
        visib_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        extern_export_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        lib_name: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        threadlocal_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        comptime_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        ast: <a href="std.zig.Ast.full.VarDecl.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            mut_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            type_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            align_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            addrspace_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            section_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            init_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstToken</span>(var_decl: <a href="std.zig.Ast.full.VarDecl.html">VarDecl</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> {
            <span class="tok-kw">return</span> var_decl.visib_token <span class="tok-kw">orelse</span>
                var_decl.extern_export_token <span class="tok-kw">orelse</span>
                var_decl.threadlocal_token <span class="tok-kw">orelse</span>
                var_decl.comptime_token <span class="tok-kw">orelse</span>
                var_decl.ast.mut_token;
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AssignDestructure = <span class="tok-kw">struct</span> {
        comptime_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        ast: <a href="std.zig.Ast.full.AssignDestructure.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            variables: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            equal_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            value_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> If = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Points to the first token after the `|`. Will either be an identifier or</span>
        <span class="tok-comment">/// a `*` (with an identifier immediately after it).</span>
        payload_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Points to the identifier after the `|`.</span>
        error_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Populated only if else_expr != 0.</span>
        else_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        ast: <a href="std.zig.Ast.full.If.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            if_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            cond_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            then_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            else_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> While = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.While.Components.html">Components</a>,
        inline_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        label_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        payload_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        error_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Populated only if else_expr != 0.</span>
        else_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            while_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            cond_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            cont_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            then_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            else_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> For = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.For.Components.html">Components</a>,
        inline_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        label_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        payload_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Populated only if else_expr != 0.</span>
        else_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            for_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            inputs: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            then_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            else_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ContainerField = <span class="tok-kw">struct</span> {
        comptime_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        ast: <a href="std.zig.Ast.full.ContainerField.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            main_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            type_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            align_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            value_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            tuple_like: <span class="tok-type">bool</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstToken</span>(cf: <a href="std.zig.Ast.full.ContainerField.html">ContainerField</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> {
            <span class="tok-kw">return</span> cf.comptime_token <span class="tok-kw">orelse</span> cf.ast.main_token;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convertToNonTupleLike</span>(cf: *<a href="std.zig.Ast.full.ContainerField.html">ContainerField</a>, nodes: <a href="std.zig.Ast.html#std.zig.Ast.NodeList">NodeList</a>.<a href="#">Slice</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!cf.ast.tuple_like) <span class="tok-kw">return</span>;
            <span class="tok-kw">if</span> (nodes.items(.tag)[cf.ast.type_expr] != .identifier) <span class="tok-kw">return</span>;

            cf.ast.type_expr = <span class="tok-number">0</span>;
            cf.ast.tuple_like = <span class="tok-null">false</span>;
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnProto = <span class="tok-kw">struct</span> {
        visib_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        extern_export_inline_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        lib_name: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        name_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        lparen: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        ast: <a href="std.zig.Ast.full.FnProto.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            proto_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            fn_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            return_type: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            params: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            align_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            addrspace_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            section_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            callconv_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Param = <span class="tok-kw">struct</span> {
            first_doc_comment: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            name_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            comptime_noalias: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            anytype_ellipsis3: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            type_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">firstToken</span>(fn_proto: <a href="std.zig.Ast.full.FnProto.html">FnProto</a>) <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> {
            <span class="tok-kw">return</span> fn_proto.visib_token <span class="tok-kw">orelse</span>
                fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span>
                fn_proto.ast.fn_token;
        }

        <span class="tok-comment">/// Abstracts over the fact that anytype and ... are not included</span>
        <span class="tok-comment">/// in the params slice, since they are simple identifiers and</span>
        <span class="tok-comment">/// not sub-expressions.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>,
            fn_proto: *<span class="tok-kw">const</span> <a href="std.zig.Ast.full.FnProto.html">FnProto</a>,
            param_i: <span class="tok-type">usize</span>,
            tok_i: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            tok_flag: <span class="tok-type">bool</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.zig.Ast.full.FnProto.Iterator.html">Iterator</a>) ?<a href="std.zig.Ast.full.FnProto.Param.html">Param</a> {
                <span class="tok-kw">const</span> token_tags = it.tree.tokens.items(.tag);
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">var</span> first_doc_comment: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-null">null</span>;
                    <span class="tok-kw">var</span> comptime_noalias: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-null">null</span>;
                    <span class="tok-kw">var</span> name_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a> = <span class="tok-null">null</span>;
                    <span class="tok-kw">if</span> (!it.tok_flag) {
                        <span class="tok-kw">if</span> (it.param_i &gt;= it.fn_proto.ast.params.len) {
                            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                        }
                        <span class="tok-kw">const</span> param_type = it.fn_proto.ast.params[it.param_i];
                        <span class="tok-kw">var</span> tok_i = it.tree.firstToken(param_type) - <span class="tok-number">1</span>;
                        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (tok_i -= <span class="tok-number">1</span>) <span class="tok-kw">switch</span> (token_tags[tok_i]) {
                            .colon =&gt; <span class="tok-kw">continue</span>,
                            .identifier =&gt; name_token = tok_i,
                            .doc_comment =&gt; first_doc_comment = tok_i,
                            .keyword_comptime, .keyword_noalias =&gt; comptime_noalias = tok_i,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
                        };
                        it.param_i += <span class="tok-number">1</span>;
                        it.tok_i = it.tree.lastToken(param_type) + <span class="tok-number">1</span>;<span class="tok-comment">
                        // Look for anytype and ... params afterwards.
                        </span><span class="tok-kw">if</span> (token_tags[it.tok_i] == .comma) {
                            it.tok_i += <span class="tok-number">1</span>;
                        }
                        it.tok_flag = <span class="tok-null">true</span>;
                        <span class="tok-kw">return</span> <a href="std.zig.Ast.full.FnProto.Param.html">Param</a>{
                            .first_doc_comment = first_doc_comment,
                            .comptime_noalias = comptime_noalias,
                            .name_token = name_token,
                            .anytype_ellipsis3 = <span class="tok-null">null</span>,
                            .type_expr = param_type,
                        };
                    }
                    <span class="tok-kw">if</span> (token_tags[it.tok_i] == .comma) {
                        it.tok_i += <span class="tok-number">1</span>;
                    }
                    <span class="tok-kw">if</span> (token_tags[it.tok_i] == .r_paren) {
                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    }
                    <span class="tok-kw">if</span> (token_tags[it.tok_i] == .doc_comment) {
                        first_doc_comment = it.tok_i;
                        <span class="tok-kw">while</span> (token_tags[it.tok_i] == .doc_comment) {
                            it.tok_i += <span class="tok-number">1</span>;
                        }
                    }
                    <span class="tok-kw">switch</span> (token_tags[it.tok_i]) {
                        .ellipsis3 =&gt; {
                            it.tok_flag = <span class="tok-null">false</span>;<span class="tok-comment"> // Next iteration should return null.
                            </span><span class="tok-kw">return</span> <a href="std.zig.Ast.full.FnProto.Param.html">Param</a>{
                                .first_doc_comment = first_doc_comment,
                                .comptime_noalias = <span class="tok-null">null</span>,
                                .name_token = <span class="tok-null">null</span>,
                                .anytype_ellipsis3 = it.tok_i,
                                .type_expr = <span class="tok-number">0</span>,
                            };
                        },
                        .keyword_noalias, .keyword_comptime =&gt; {
                            comptime_noalias = it.tok_i;
                            it.tok_i += <span class="tok-number">1</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; {},
                    }
                    <span class="tok-kw">if</span> (token_tags[it.tok_i] == .identifier <span class="tok-kw">and</span>
                        token_tags[it.tok_i + <span class="tok-number">1</span>] == .colon)
                    {
                        name_token = it.tok_i;
                        it.tok_i += <span class="tok-number">2</span>;
                    }
                    <span class="tok-kw">if</span> (token_tags[it.tok_i] == .keyword_anytype) {
                        it.tok_i += <span class="tok-number">1</span>;
                        <span class="tok-kw">return</span> <a href="std.zig.Ast.full.FnProto.Param.html">Param</a>{
                            .first_doc_comment = first_doc_comment,
                            .comptime_noalias = comptime_noalias,
                            .name_token = name_token,
                            .anytype_ellipsis3 = it.tok_i - <span class="tok-number">1</span>,
                            .type_expr = <span class="tok-number">0</span>,
                        };
                    }
                    it.tok_flag = <span class="tok-null">false</span>;
                }
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterate</span>(fn_proto: *<span class="tok-kw">const</span> <a href="std.zig.Ast.full.FnProto.html">FnProto</a>, tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>) <a href="std.zig.Ast.full.FnProto.Iterator.html">Iterator</a> {
            <span class="tok-kw">return</span> .{
                .tree = tree,
                .fn_proto = fn_proto,
                .param_i = <span class="tok-number">0</span>,
                .tok_i = fn_proto.lparen + <span class="tok-number">1</span>,
                .tok_flag = <span class="tok-null">true</span>,
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructInit = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.StructInit.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            lbrace: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            fields: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            type_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayInit = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.ArrayInit.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            lbrace: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            elements: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            type_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayType = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.ArrayType.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            lbracket: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            elem_count: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            sentinel: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            elem_type: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtrType = <span class="tok-kw">struct</span> {
        size: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Pointer.html">Pointer</a>.<a href="std.builtin.Type.Pointer.Size.html">Size</a>,
        allowzero_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        const_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        volatile_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        ast: <a href="std.zig.Ast.full.PtrType.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            main_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            align_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            addrspace_node: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            sentinel: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            bit_range_start: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            bit_range_end: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            child_type: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.Slice.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            sliced: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            lbracket: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            start: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            end: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            sentinel: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ContainerDecl = <span class="tok-kw">struct</span> {
        layout_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        ast: <a href="std.zig.Ast.full.ContainerDecl.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            main_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            <span class="tok-comment">/// Populated when main_token is Keyword_union.</span>
            enum_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            members: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            arg: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Switch = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.Switch.Components.html">Components</a>,
        label_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            switch_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            condition: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            cases: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SwitchCase = <span class="tok-kw">struct</span> {
        inline_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        <span class="tok-comment">/// Points to the first token after the `|`. Will either be an identifier or</span>
        <span class="tok-comment">/// a `*` (with an identifier immediately after it).</span>
        payload_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        ast: <a href="std.zig.Ast.full.SwitchCase.Components.html">Components</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            <span class="tok-comment">/// If empty, this is an else case</span>
            values: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            arrow_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            target_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Asm = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.Asm.Components.html">Components</a>,
        volatile_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        first_clobber: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        outputs: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        inputs: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            asm_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            template: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            items: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            rparen: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Call = <span class="tok-kw">struct</span> {
        ast: <a href="std.zig.Ast.full.Call.Components.html">Components</a>,
        async_token: ?<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Components = <span class="tok-kw">struct</span> {
            lparen: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
            fn_expr: <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
            params: []<span class="tok-kw">const</span> <a href="std.zig.Ast.Node.html">Node</a>.<a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        };
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">struct</span> {
    tag: <a href="std.zig.Ast.Error.Tag.html">Tag</a>,
    is_note: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    <span class="tok-comment">/// True if `token` points to the token before the token causing an issue.</span>
    token_is_prev: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    extra: <span class="tok-kw">union</span> {
        none: <span class="tok-type">void</span>,
        expected_tag: <a href="std.zig.tokenizer.Token.html">Token</a>.<a href="std.zig.tokenizer.Token.Tag.html">Tag</a>,
        offset: <span class="tok-type">usize</span>,
    } = .{ .none = {} },

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span> {
        asterisk_after_ptr_deref,
        chained_comparison_operators,
        decl_between_fields,
        expected_block,
        expected_block_or_assignment,
        expected_block_or_expr,
        expected_block_or_field,
        expected_container_members,
        expected_expr,
        expected_expr_or_assignment,
        expected_expr_or_var_decl,
        expected_fn,
        expected_inlinable,
        expected_labelable,
        expected_param_list,
        expected_prefix_expr,
        expected_primary_type_expr,
        expected_pub_item,
        expected_return_type,
        expected_semi_or_else,
        expected_semi_or_lbrace,
        expected_statement,
        expected_suffix_op,
        expected_type_expr,
        expected_var_decl,
        expected_var_decl_or_fn,
        expected_loop_payload,
        expected_container,
        extern_fn_body,
        extra_addrspace_qualifier,
        extra_align_qualifier,
        extra_allowzero_qualifier,
        extra_const_qualifier,
        extra_volatile_qualifier,
        ptr_mod_on_array_child_type,
        invalid_bit_range,
        same_line_doc_comment,
        unattached_doc_comment,
        test_doc_comment,
        comptime_doc_comment,
        varargs_nonfinal,
        expected_continue_expr,
        expected_semi_after_decl,
        expected_semi_after_stmt,
        expected_comma_after_field,
        expected_comma_after_arg,
        expected_comma_after_param,
        expected_comma_after_initializer,
        expected_comma_after_switch_prong,
        expected_comma_after_for_operand,
        expected_comma_after_capture,
        expected_initializer,
        mismatched_binary_op_whitespace,
        invalid_ampersand_ampersand,
        c_style_container,
        expected_var_const,
        wrong_equal_var_decl,
        var_const_decl,
        extra_for_capture,
        for_input_not_captured,

        zig_style_container,
        previous_field,
        next_field,

        <span class="tok-comment">/// `expected_tag` is populated.</span>
        expected_token,

        <span class="tok-comment">/// `offset` is populated</span>
        invalid_byte,
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
    tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a>,
    main_token: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    data: <a href="std.zig.Ast.Node.Data.html">Data</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-type">u32</span>;

    <span class="tok-kw">comptime</span> {<span class="tok-comment">
        // Goal is to keep this under one byte for efficiency.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.zig.Ast.Node.Tag.html">Tag</a>) == <span class="tok-number">1</span>);
    }

    <span class="tok-comment">/// Note: The FooComma/FooSemicolon variants exist to ease the implementation of</span>
    <span class="tok-comment">/// Ast.lastToken()</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// sub_list[lhs...rhs]</span>
        root,
        <span class="tok-comment">/// `usingnamespace lhs;`. rhs unused. main_token is `usingnamespace`.</span>
        @&quot;usingnamespace&quot;,
        <span class="tok-comment">/// lhs is test name token (must be string literal or identifier), if any.</span>
        <span class="tok-comment">/// rhs is the body node.</span>
        test_decl,
        <span class="tok-comment">/// lhs is the index into extra_data.</span>
        <span class="tok-comment">/// rhs is the initialization expression, if any.</span>
        <span class="tok-comment">/// main_token is `var` or `const`.</span>
        global_var_decl,
        <span class="tok-comment">/// `var a: x align(y) = rhs`</span>
        <span class="tok-comment">/// lhs is the index into extra_data.</span>
        <span class="tok-comment">/// main_token is `var` or `const`.</span>
        local_var_decl,
        <span class="tok-comment">/// `var a: lhs = rhs`. lhs and rhs may be unused.</span>
        <span class="tok-comment">/// Can be local or global.</span>
        <span class="tok-comment">/// main_token is `var` or `const`.</span>
        simple_var_decl,
        <span class="tok-comment">/// `var a align(lhs) = rhs`. lhs and rhs may be unused.</span>
        <span class="tok-comment">/// Can be local or global.</span>
        <span class="tok-comment">/// main_token is `var` or `const`.</span>
        aligned_var_decl,
        <span class="tok-comment">/// lhs is the identifier token payload if any,</span>
        <span class="tok-comment">/// rhs is the deferred expression.</span>
        @&quot;errdefer&quot;,
        <span class="tok-comment">/// lhs is unused.</span>
        <span class="tok-comment">/// rhs is the deferred expression.</span>
        @&quot;defer&quot;,
        <span class="tok-comment">/// lhs catch rhs</span>
        <span class="tok-comment">/// lhs catch |err| rhs</span>
        <span class="tok-comment">/// main_token is the `catch` keyword.</span>
        <span class="tok-comment">/// payload is determined by looking at the next token after the `catch` keyword.</span>
        @&quot;catch&quot;,
        <span class="tok-comment">/// `lhs.a`. main_token is the dot. rhs is the identifier token index.</span>
        field_access,
        <span class="tok-comment">/// `lhs.?`. main_token is the dot. rhs is the `?` token index.</span>
        unwrap_optional,
        <span class="tok-comment">/// `lhs == rhs`. main_token is op.</span>
        equal_equal,
        <span class="tok-comment">/// `lhs != rhs`. main_token is op.</span>
        bang_equal,
        <span class="tok-comment">/// `lhs &lt; rhs`. main_token is op.</span>
        less_than,
        <span class="tok-comment">/// `lhs &gt; rhs`. main_token is op.</span>
        greater_than,
        <span class="tok-comment">/// `lhs &lt;= rhs`. main_token is op.</span>
        less_or_equal,
        <span class="tok-comment">/// `lhs &gt;= rhs`. main_token is op.</span>
        greater_or_equal,
        <span class="tok-comment">/// `lhs *= rhs`. main_token is op.</span>
        assign_mul,
        <span class="tok-comment">/// `lhs /= rhs`. main_token is op.</span>
        assign_div,
        <span class="tok-comment">/// `lhs %= rhs`. main_token is op.</span>
        assign_mod,
        <span class="tok-comment">/// `lhs += rhs`. main_token is op.</span>
        assign_add,
        <span class="tok-comment">/// `lhs -= rhs`. main_token is op.</span>
        assign_sub,
        <span class="tok-comment">/// `lhs &lt;&lt;= rhs`. main_token is op.</span>
        assign_shl,
        <span class="tok-comment">/// `lhs &lt;&lt;|= rhs`. main_token is op.</span>
        assign_shl_sat,
        <span class="tok-comment">/// `lhs &gt;&gt;= rhs`. main_token is op.</span>
        assign_shr,
        <span class="tok-comment">/// `lhs &amp;= rhs`. main_token is op.</span>
        assign_bit_and,
        <span class="tok-comment">/// `lhs ^= rhs`. main_token is op.</span>
        assign_bit_xor,
        <span class="tok-comment">/// `lhs |= rhs`. main_token is op.</span>
        assign_bit_or,
        <span class="tok-comment">/// `lhs *%= rhs`. main_token is op.</span>
        assign_mul_wrap,
        <span class="tok-comment">/// `lhs +%= rhs`. main_token is op.</span>
        assign_add_wrap,
        <span class="tok-comment">/// `lhs -%= rhs`. main_token is op.</span>
        assign_sub_wrap,
        <span class="tok-comment">/// `lhs *|= rhs`. main_token is op.</span>
        assign_mul_sat,
        <span class="tok-comment">/// `lhs +|= rhs`. main_token is op.</span>
        assign_add_sat,
        <span class="tok-comment">/// `lhs -|= rhs`. main_token is op.</span>
        assign_sub_sat,
        <span class="tok-comment">/// `lhs = rhs`. main_token is op.</span>
        assign,
        <span class="tok-comment">/// `a, b, ... = rhs`. main_token is op. lhs is index into `extra_data`</span>
        <span class="tok-comment">/// of an lhs elem count followed by an array of that many `Node.Index`,</span>
        <span class="tok-comment">/// with each node having one of the following types:</span>
        <span class="tok-comment">/// * `global_var_decl`</span>
        <span class="tok-comment">/// * `local_var_decl`</span>
        <span class="tok-comment">/// * `simple_var_decl`</span>
        <span class="tok-comment">/// * `aligned_var_decl`</span>
        <span class="tok-comment">/// * Any expression node</span>
        <span class="tok-comment">/// The first 3 types correspond to a `var` or `const` lhs node (note</span>
        <span class="tok-comment">/// that their `rhs` is always 0). An expression node corresponds to a</span>
        <span class="tok-comment">/// standard assignment LHS (which must be evaluated as an lvalue).</span>
        <span class="tok-comment">/// There may be a preceding `comptime` token, which does not create a</span>
        <span class="tok-comment">/// corresponding `comptime` node so must be manually detected.</span>
        assign_destructure,
        <span class="tok-comment">/// `lhs || rhs`. main_token is the `||`.</span>
        merge_error_sets,
        <span class="tok-comment">/// `lhs * rhs`. main_token is the `*`.</span>
        mul,
        <span class="tok-comment">/// `lhs / rhs`. main_token is the `/`.</span>
        div,
        <span class="tok-comment">/// `lhs % rhs`. main_token is the `%`.</span>
        mod,
        <span class="tok-comment">/// `lhs ** rhs`. main_token is the `**`.</span>
        array_mult,
        <span class="tok-comment">/// `lhs *% rhs`. main_token is the `*%`.</span>
        mul_wrap,
        <span class="tok-comment">/// `lhs *| rhs`. main_token is the `*|`.</span>
        mul_sat,
        <span class="tok-comment">/// `lhs + rhs`. main_token is the `+`.</span>
        add,
        <span class="tok-comment">/// `lhs - rhs`. main_token is the `-`.</span>
        sub,
        <span class="tok-comment">/// `lhs ++ rhs`. main_token is the `++`.</span>
        array_cat,
        <span class="tok-comment">/// `lhs +% rhs`. main_token is the `+%`.</span>
        add_wrap,
        <span class="tok-comment">/// `lhs -% rhs`. main_token is the `-%`.</span>
        sub_wrap,
        <span class="tok-comment">/// `lhs +| rhs`. main_token is the `+|`.</span>
        add_sat,
        <span class="tok-comment">/// `lhs -| rhs`. main_token is the `-|`.</span>
        sub_sat,
        <span class="tok-comment">/// `lhs &lt;&lt; rhs`. main_token is the `&lt;&lt;`.</span>
        shl,
        <span class="tok-comment">/// `lhs &lt;&lt;| rhs`. main_token is the `&lt;&lt;|`.</span>
        shl_sat,
        <span class="tok-comment">/// `lhs &gt;&gt; rhs`. main_token is the `&gt;&gt;`.</span>
        shr,
        <span class="tok-comment">/// `lhs &amp; rhs`. main_token is the `&amp;`.</span>
        bit_and,
        <span class="tok-comment">/// `lhs ^ rhs`. main_token is the `^`.</span>
        bit_xor,
        <span class="tok-comment">/// `lhs | rhs`. main_token is the `|`.</span>
        bit_or,
        <span class="tok-comment">/// `lhs orelse rhs`. main_token is the `orelse`.</span>
        @&quot;orelse&quot;,
        <span class="tok-comment">/// `lhs and rhs`. main_token is the `and`.</span>
        bool_and,
        <span class="tok-comment">/// `lhs or rhs`. main_token is the `or`.</span>
        bool_or,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        bool_not,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        negation,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        bit_not,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        negation_wrap,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        address_of,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        @&quot;try&quot;,
        <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
        @&quot;await&quot;,
        <span class="tok-comment">/// `?lhs`. rhs unused. main_token is the `?`.</span>
        optional_type,
        <span class="tok-comment">/// `[lhs]rhs`.</span>
        array_type,
        <span class="tok-comment">/// `[lhs:a]b`. `ArrayTypeSentinel[rhs]`.</span>
        array_type_sentinel,
        <span class="tok-comment">/// `[*]align(lhs) rhs`. lhs can be omitted.</span>
        <span class="tok-comment">/// `*align(lhs) rhs`. lhs can be omitted.</span>
        <span class="tok-comment">/// `[]rhs`.</span>
        <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
        <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
        <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
        <span class="tok-comment">/// pointer type and may require special handling.</span>
        ptr_type_aligned,
        <span class="tok-comment">/// `[*:lhs]rhs`. lhs can be omitted.</span>
        <span class="tok-comment">/// `*rhs`.</span>
        <span class="tok-comment">/// `[:lhs]rhs`.</span>
        <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
        <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
        <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
        <span class="tok-comment">/// pointer type and may require special handling.</span>
        ptr_type_sentinel,
        <span class="tok-comment">/// lhs is index into ptr_type. rhs is the element type expression.</span>
        <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
        <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
        <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
        <span class="tok-comment">/// pointer type and may require special handling.</span>
        ptr_type,
        <span class="tok-comment">/// lhs is index into ptr_type_bit_range. rhs is the element type expression.</span>
        <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
        <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
        <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
        <span class="tok-comment">/// pointer type and may require special handling.</span>
        ptr_type_bit_range,
        <span class="tok-comment">/// `lhs[rhs..]`</span>
        <span class="tok-comment">/// main_token is the lbracket.</span>
        slice_open,
        <span class="tok-comment">/// `lhs[b..c]`. rhs is index into Slice</span>
        <span class="tok-comment">/// main_token is the lbracket.</span>
        <a href="std.zig.Ast.html#std.zig.Ast.slice">slice</a>,
        <span class="tok-comment">/// `lhs[b..c :d]`. rhs is index into SliceSentinel. Slice end &quot;c&quot; can be omitted.</span>
        <span class="tok-comment">/// main_token is the lbracket.</span>
        slice_sentinel,
        <span class="tok-comment">/// `lhs.*`. rhs is unused.</span>
        deref,
        <span class="tok-comment">/// `lhs[rhs]`.</span>
        array_access,
        <span class="tok-comment">/// `lhs{rhs}`. rhs can be omitted.</span>
        array_init_one,
        <span class="tok-comment">/// `lhs{rhs,}`. rhs can *not* be omitted</span>
        array_init_one_comma,
        <span class="tok-comment">/// `.{lhs, rhs}`. lhs and rhs can be omitted.</span>
        array_init_dot_two,
        <span class="tok-comment">/// Same as `array_init_dot_two` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        array_init_dot_two_comma,
        <span class="tok-comment">/// `.{a, b}`. `sub_list[lhs..rhs]`.</span>
        array_init_dot,
        <span class="tok-comment">/// Same as `array_init_dot` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        array_init_dot_comma,
        <span class="tok-comment">/// `lhs{a, b}`. `sub_range_list[rhs]`. lhs can be omitted which means `.{a, b}`.</span>
        array_init,
        <span class="tok-comment">/// Same as `array_init` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        array_init_comma,
        <span class="tok-comment">/// `lhs{.a = rhs}`. rhs can be omitted making it empty.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        struct_init_one,
        <span class="tok-comment">/// `lhs{.a = rhs,}`. rhs can *not* be omitted.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        struct_init_one_comma,
        <span class="tok-comment">/// `.{.a = lhs, .b = rhs}`. lhs and rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        <span class="tok-comment">/// No trailing comma before the rbrace.</span>
        struct_init_dot_two,
        <span class="tok-comment">/// Same as `struct_init_dot_two` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        struct_init_dot_two_comma,
        <span class="tok-comment">/// `.{.a = b, .c = d}`. `sub_list[lhs..rhs]`.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        struct_init_dot,
        <span class="tok-comment">/// Same as `struct_init_dot` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        struct_init_dot_comma,
        <span class="tok-comment">/// `lhs{.a = b, .c = d}`. `sub_range_list[rhs]`.</span>
        <span class="tok-comment">/// lhs can be omitted which means `.{.a = b, .c = d}`.</span>
        <span class="tok-comment">/// main_token is the lbrace.</span>
        struct_init,
        <span class="tok-comment">/// Same as `struct_init` except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace.</span>
        struct_init_comma,
        <span class="tok-comment">/// `lhs(rhs)`. rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the lparen.</span>
        call_one,
        <span class="tok-comment">/// `lhs(rhs,)`. rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the lparen.</span>
        call_one_comma,
        <span class="tok-comment">/// `async lhs(rhs)`. rhs can be omitted.</span>
        async_call_one,
        <span class="tok-comment">/// `async lhs(rhs,)`.</span>
        async_call_one_comma,
        <span class="tok-comment">/// `lhs(a, b, c)`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// main_token is the `(`.</span>
        call,
        <span class="tok-comment">/// `lhs(a, b, c,)`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// main_token is the `(`.</span>
        call_comma,
        <span class="tok-comment">/// `async lhs(a, b, c)`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// main_token is the `(`.</span>
        async_call,
        <span class="tok-comment">/// `async lhs(a, b, c,)`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// main_token is the `(`.</span>
        async_call_comma,
        <span class="tok-comment">/// `switch(lhs) {}`. `SubRange[rhs]`.</span>
        <span class="tok-comment">/// `main_token` is the identifier of a preceding label, if any; otherwise `switch`.</span>
        @&quot;switch&quot;,
        <span class="tok-comment">/// Same as switch except there is known to be a trailing comma</span>
        <span class="tok-comment">/// before the final rbrace</span>
        switch_comma,
        <span class="tok-comment">/// `lhs =&gt; rhs`. If lhs is omitted it means `else`.</span>
        <span class="tok-comment">/// main_token is the `=&gt;`</span>
        switch_case_one,
        <span class="tok-comment">/// Same ast `switch_case_one` but the case is inline</span>
        switch_case_inline_one,
        <span class="tok-comment">/// `a, b, c =&gt; rhs`. `SubRange[lhs]`.</span>
        <span class="tok-comment">/// main_token is the `=&gt;`</span>
        switch_case,
        <span class="tok-comment">/// Same ast `switch_case` but the case is inline</span>
        switch_case_inline,
        <span class="tok-comment">/// `lhs...rhs`.</span>
        switch_range,
        <span class="tok-comment">/// `while (lhs) rhs`.</span>
        <span class="tok-comment">/// `while (lhs) |x| rhs`.</span>
        while_simple,
        <span class="tok-comment">/// `while (lhs) : (a) b`. `WhileCont[rhs]`.</span>
        <span class="tok-comment">/// `while (lhs) : (a) b`. `WhileCont[rhs]`.</span>
        while_cont,
        <span class="tok-comment">/// `while (lhs) : (a) b else c`. `While[rhs]`.</span>
        <span class="tok-comment">/// `while (lhs) |x| : (a) b else c`. `While[rhs]`.</span>
        <span class="tok-comment">/// `while (lhs) |x| : (a) b else |y| c`. `While[rhs]`.</span>
        <span class="tok-comment">/// The cont expression part `: (a)` may be omitted.</span>
        @&quot;while&quot;,
        <span class="tok-comment">/// `for (lhs) rhs`.</span>
        for_simple,
        <span class="tok-comment">/// `for (lhs[0..inputs]) lhs[inputs + 1] else lhs[inputs + 2]`. `For[rhs]`.</span>
        @&quot;for&quot;,
        <span class="tok-comment">/// `lhs..rhs`. rhs can be omitted.</span>
        for_range,
        <span class="tok-comment">/// `if (lhs) rhs`.</span>
        <span class="tok-comment">/// `if (lhs) |a| rhs`.</span>
        if_simple,
        <span class="tok-comment">/// `if (lhs) a else b`. `If[rhs]`.</span>
        <span class="tok-comment">/// `if (lhs) |x| a else b`. `If[rhs]`.</span>
        <span class="tok-comment">/// `if (lhs) |x| a else |y| b`. `If[rhs]`.</span>
        @&quot;if&quot;,
        <span class="tok-comment">/// `suspend lhs`. lhs can be omitted. rhs is unused.</span>
        @&quot;suspend&quot;,
        <span class="tok-comment">/// `resume lhs`. rhs is unused.</span>
        @&quot;resume&quot;,
        <span class="tok-comment">/// `continue :lhs rhs`</span>
        <span class="tok-comment">/// both lhs and rhs may be omitted.</span>
        @&quot;continue&quot;,
        <span class="tok-comment">/// `break :lhs rhs`</span>
        <span class="tok-comment">/// both lhs and rhs may be omitted.</span>
        @&quot;break&quot;,
        <span class="tok-comment">/// `return lhs`. lhs can be omitted. rhs is unused.</span>
        @&quot;return&quot;,
        <span class="tok-comment">/// `fn (a: lhs) rhs`. lhs can be omitted.</span>
        <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
        <span class="tok-comment">/// main_token is the `fn` keyword.</span>
        <span class="tok-comment">/// extern function declarations use this tag.</span>
        fn_proto_simple,
        <span class="tok-comment">/// `fn (a: b, c: d) rhs`. `sub_range_list[lhs]`.</span>
        <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
        <span class="tok-comment">/// main_token is the `fn` keyword.</span>
        <span class="tok-comment">/// extern function declarations use this tag.</span>
        fn_proto_multi,
        <span class="tok-comment">/// `fn (a: b) addrspace(e) linksection(f) callconv(g) rhs`. `FnProtoOne[lhs]`.</span>
        <span class="tok-comment">/// zero or one parameters.</span>
        <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
        <span class="tok-comment">/// main_token is the `fn` keyword.</span>
        <span class="tok-comment">/// extern function declarations use this tag.</span>
        fn_proto_one,
        <span class="tok-comment">/// `fn (a: b, c: d) addrspace(e) linksection(f) callconv(g) rhs`. `FnProto[lhs]`.</span>
        <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
        <span class="tok-comment">/// main_token is the `fn` keyword.</span>
        <span class="tok-comment">/// extern function declarations use this tag.</span>
        fn_proto,
        <span class="tok-comment">/// lhs is the fn_proto.</span>
        <span class="tok-comment">/// rhs is the function body block.</span>
        <span class="tok-comment">/// Note that extern function declarations use the fn_proto tags rather</span>
        <span class="tok-comment">/// than this one.</span>
        fn_decl,
        <span class="tok-comment">/// `anyframe-&gt;rhs`. main_token is `anyframe`. `lhs` is arrow token index.</span>
        anyframe_type,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        anyframe_literal,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        char_literal,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        number_literal,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        unreachable_literal,
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        <span class="tok-comment">/// Most identifiers will not have explicit AST nodes, however for expressions</span>
        <span class="tok-comment">/// which could be one of many different kinds of AST nodes, there will be an</span>
        <span class="tok-comment">/// identifier AST node for it.</span>
        identifier,
        <span class="tok-comment">/// lhs is the dot token index, rhs unused, main_token is the identifier.</span>
        enum_literal,
        <span class="tok-comment">/// main_token is the string literal token</span>
        <span class="tok-comment">/// Both lhs and rhs unused.</span>
        string_literal,
        <span class="tok-comment">/// main_token is the first token index (redundant with lhs)</span>
        <span class="tok-comment">/// lhs is the first token index; rhs is the last token index.</span>
        <span class="tok-comment">/// Could be a series of multiline_string_literal_line tokens, or a single</span>
        <span class="tok-comment">/// string_literal token.</span>
        multiline_string_literal,
        <span class="tok-comment">/// `(lhs)`. main_token is the `(`; rhs is the token index of the `)`.</span>
        grouped_expression,
        <span class="tok-comment">/// `@a(lhs, rhs)`. lhs and rhs may be omitted.</span>
        <span class="tok-comment">/// main_token is the builtin token.</span>
        builtin_call_two,
        <span class="tok-comment">/// Same as builtin_call_two but there is known to be a trailing comma before the rparen.</span>
        builtin_call_two_comma,
        <span class="tok-comment">/// `@a(b, c)`. `sub_list[lhs..rhs]`.</span>
        <span class="tok-comment">/// main_token is the builtin token.</span>
        builtin_call,
        <span class="tok-comment">/// Same as builtin_call but there is known to be a trailing comma before the rparen.</span>
        builtin_call_comma,
        <span class="tok-comment">/// `error{a, b}`.</span>
        <span class="tok-comment">/// rhs is the rbrace, lhs is unused.</span>
        error_set_decl,
        <span class="tok-comment">/// `struct {}`, `union {}`, `opaque {}`, `enum {}`. `extra_data[lhs..rhs]`.</span>
        <span class="tok-comment">/// main_token is `struct`, `union`, `opaque`, `enum` keyword.</span>
        container_decl,
        <span class="tok-comment">/// Same as ContainerDecl but there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        container_decl_trailing,
        <span class="tok-comment">/// `struct {lhs, rhs}`, `union {lhs, rhs}`, `opaque {lhs, rhs}`, `enum {lhs, rhs}`.</span>
        <span class="tok-comment">/// lhs or rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is `struct`, `union`, `opaque`, `enum` keyword.</span>
        container_decl_two,
        <span class="tok-comment">/// Same as ContainerDeclTwo except there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        container_decl_two_trailing,
        <span class="tok-comment">/// `struct(lhs)` / `union(lhs)` / `enum(lhs)`. `SubRange[rhs]`.</span>
        container_decl_arg,
        <span class="tok-comment">/// Same as container_decl_arg but there is known to be a trailing</span>
        <span class="tok-comment">/// comma or semicolon before the rbrace.</span>
        container_decl_arg_trailing,
        <span class="tok-comment">/// `union(enum) {}`. `sub_list[lhs..rhs]`.</span>
        <span class="tok-comment">/// Note that tagged unions with explicitly provided enums are represented</span>
        <span class="tok-comment">/// by `container_decl_arg`.</span>
        tagged_union,
        <span class="tok-comment">/// Same as tagged_union but there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        tagged_union_trailing,
        <span class="tok-comment">/// `union(enum) {lhs, rhs}`. lhs or rhs may be omitted.</span>
        <span class="tok-comment">/// Note that tagged unions with explicitly provided enums are represented</span>
        <span class="tok-comment">/// by `container_decl_arg`.</span>
        tagged_union_two,
        <span class="tok-comment">/// Same as tagged_union_two but there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        tagged_union_two_trailing,
        <span class="tok-comment">/// `union(enum(lhs)) {}`. `SubRange[rhs]`.</span>
        tagged_union_enum_tag,
        <span class="tok-comment">/// Same as tagged_union_enum_tag but there is known to be a trailing comma</span>
        <span class="tok-comment">/// or semicolon before the rbrace.</span>
        tagged_union_enum_tag_trailing,
        <span class="tok-comment">/// `a: lhs = rhs,`. lhs and rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the field name identifier.</span>
        <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
        container_field_init,
        <span class="tok-comment">/// `a: lhs align(rhs),`. rhs can be omitted.</span>
        <span class="tok-comment">/// main_token is the field name identifier.</span>
        <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
        container_field_align,
        <span class="tok-comment">/// `a: lhs align(c) = d,`. `container_field_list[rhs]`.</span>
        <span class="tok-comment">/// main_token is the field name identifier.</span>
        <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
        container_field,
        <span class="tok-comment">/// `comptime lhs`. rhs unused.</span>
        @&quot;comptime&quot;,
        <span class="tok-comment">/// `nosuspend lhs`. rhs unused.</span>
        @&quot;nosuspend&quot;,
        <span class="tok-comment">/// `{lhs rhs}`. rhs or lhs can be omitted.</span>
        <span class="tok-comment">/// main_token points at the lbrace.</span>
        block_two,
        <span class="tok-comment">/// Same as block_two but there is known to be a semicolon before the rbrace.</span>
        block_two_semicolon,
        <span class="tok-comment">/// `{}`. `sub_list[lhs..rhs]`.</span>
        <span class="tok-comment">/// main_token points at the lbrace.</span>
        block,
        <span class="tok-comment">/// Same as block but there is known to be a semicolon before the rbrace.</span>
        block_semicolon,
        <span class="tok-comment">/// `asm(lhs)`. rhs is the token index of the rparen.</span>
        asm_simple,
        <span class="tok-comment">/// `asm(lhs, a)`. `Asm[rhs]`.</span>
        @&quot;asm&quot;,
        <span class="tok-comment">/// `[a] &quot;b&quot; (c)`. lhs is 0, rhs is token index of the rparen.</span>
        <span class="tok-comment">/// `[a] &quot;b&quot; (-&gt; lhs)`. rhs is token index of the rparen.</span>
        <span class="tok-comment">/// main_token is `a`.</span>
        asm_output,
        <span class="tok-comment">/// `[a] &quot;b&quot; (lhs)`. rhs is token index of the rparen.</span>
        <span class="tok-comment">/// main_token is `a`.</span>
        asm_input,
        <span class="tok-comment">/// `error.a`. lhs is token index of `.`. rhs is token index of `a`.</span>
        error_value,
        <span class="tok-comment">/// `lhs!rhs`. main_token is the `!`.</span>
        error_union,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isContainerField</span>(tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {
                .container_field_init,
                .container_field_align,
                .container_field,
                =&gt; <span class="tok-null">true</span>,

                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        rhs: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LocalVarDecl = <span class="tok-kw">struct</span> {
        type_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        align_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayTypeSentinel = <span class="tok-kw">struct</span> {
        sentinel: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        elem_type: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtrType = <span class="tok-kw">struct</span> {
        sentinel: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        align_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        addrspace_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtrTypeBitRange = <span class="tok-kw">struct</span> {
        sentinel: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        align_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        addrspace_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        bit_range_start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        bit_range_end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SubRange = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Index into sub_list.</span>
        start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Index into sub_list.</span>
        end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> If = <span class="tok-kw">struct</span> {
        then_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        else_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ContainerField = <span class="tok-kw">struct</span> {
        align_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        value_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GlobalVarDecl = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Populated if there is an explicit type ascription.</span>
        type_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if align(A) is present.</span>
        align_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if addrspace(A) is present.</span>
        addrspace_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if linksection(A) is present.</span>
        section_node: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">struct</span> {
        start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceSentinel = <span class="tok-kw">struct</span> {
        start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// May be 0 if the slice is &quot;open&quot;</span>
        end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        sentinel: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> While = <span class="tok-kw">struct</span> {
        cont_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        then_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        else_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WhileCont = <span class="tok-kw">struct</span> {
        cont_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        then_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> For = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        inputs: <span class="tok-type">u31</span>,
        has_else: <span class="tok-type">bool</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnProtoOne = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Populated if there is exactly 1 parameter. Otherwise there are 0 parameters.</span>
        param: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if align(A) is present.</span>
        align_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if addrspace(A) is present.</span>
        addrspace_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if linksection(A) is present.</span>
        section_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if callconv(A) is present.</span>
        callconv_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnProto = <span class="tok-kw">struct</span> {
        params_start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        params_end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if align(A) is present.</span>
        align_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if addrspace(A) is present.</span>
        addrspace_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if linksection(A) is present.</span>
        section_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Populated if callconv(A) is present.</span>
        callconv_expr: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Asm = <span class="tok-kw">struct</span> {
        items_start: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        items_end: <a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Index</a>,
        <span class="tok-comment">/// Needed to make lastToken() work.</span>
        rparen: <a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>,
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nodeToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, node: <span class="tok-type">u32</span>) <a href="std.zig.Ast.Span.html">Span</a> {
    <span class="tok-kw">return</span> <a href="std.zig.Ast.html#std.zig.Ast.tokensToSpan">tokensToSpan</a>(
        tree,
        tree.firstToken(node),
        tree.lastToken(node),
        tree.nodes.items(.main_token)[node],
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, token: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Span.html">Span</a> {
    <span class="tok-kw">return</span> <a href="std.zig.Ast.html#std.zig.Ast.tokensToSpan">tokensToSpan</a>(tree, token, token, token);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokensToSpan</span>(tree: *<span class="tok-kw">const</span> <a href="std.zig.Ast.html">Ast</a>, start: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, end: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>, main: <a href="std.zig.Ast.html">Ast</a>.<a href="std.zig.Ast.html#std.zig.Ast.TokenIndex">TokenIndex</a>) <a href="std.zig.Ast.Span.html">Span</a> {
    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);
    <span class="tok-kw">var</span> start_tok = start;
    <span class="tok-kw">var</span> end_tok = end;

    <span class="tok-kw">if</span> (tree.tokensOnSameLine(start, end)) {<span class="tok-comment">
        // do nothing
    </span>} <span class="tok-kw">else</span> <span class="tok-kw">if</span> (tree.tokensOnSameLine(start, main)) {
        end_tok = main;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (tree.tokensOnSameLine(main, end)) {
        start_tok = main;
    } <span class="tok-kw">else</span> {
        start_tok = main;
        end_tok = main;
    }
    <span class="tok-kw">const</span> start_off = token_starts[start_tok];
    <span class="tok-kw">const</span> end_off = token_starts[end_tok] + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(tree.tokenSlice(end_tok).len));
    <span class="tok-kw">return</span> <a href="std.zig.Ast.Span.html">Span</a>{ .start = start_off, .end = end_off, .main = token_starts[main] };
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> Token = <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.tokenizer.Token.html">Token</a>;
<span class="tok-kw">const</span> Ast = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> Parse = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Parse.zig&quot;</span>);
<span class="tok-kw">const</span> private_render = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;./render.zig&quot;</span>);

<span class="tok-kw">test</span> {
    _ = <a href="std.zig.Parse.html">Parse</a>;
    _ = <a href="std.zig.render.html">private_render</a>;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
