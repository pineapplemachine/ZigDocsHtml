<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.debug.html" class="active">debug</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.debug" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.debug</span><a href="#src.zig-std.debug">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.debug.simple_panic.html">std.debug.simple_panic</a></li><li><a href="std.debug.no_panic.html">std.debug.no_panic</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.debug.MemoryAccessor.html">std.debug.MemoryAccessor</a></li><li><a href="std.debug.FixedBufferReader.html">std.debug.FixedBufferReader</a></li><li><a href="std.debug.Dwarf.html">std.debug.Dwarf</a></li><li><a href="std.debug.Pdb.html">std.debug.Pdb</a></li><li><a href="std.debug.SelfInfo.html">std.debug.SelfInfo</a></li><li><a href="std.debug.Info.html">std.debug.Info</a></li><li><a href="std.debug.Coverage.html">std.debug.Coverage</a></li><li><a href="std.debug.SourceLocation.html">std.debug.SourceLocation</a></li><li><a href="std.debug.Symbol.html">std.debug.Symbol</a></li><li><a href="std.debug.StackIterator.html">std.debug.StackIterator</a></li><li><a href="std.debug.SafetyLock.html">std.debug.SafetyLock</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.debug.FullPanic" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">FullPanic</span><a href="#src.zig-std.debug.FullPanic">[src]</a></h2><div class="tldDocs"><p>A fully-featured panic handler namespace which lowers all panics to calls to <code>panicFn</code>.
Safety panics will use formatted printing to provide a meaningful error message.
The signature of <code>panicFn</code> should match that of <code><a href="std.debug.html#std.debug.defaultPanic">defaultPanic</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>panicFn: <span class="tok-kw">fn</span> ([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ?<span class="tok-type">usize</span>) <span class="tok-type">noreturn</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.debug.FullPanic.call" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">call</span><a href="#src.zig-std.debug.FullPanic.call">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.call">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> call = panicFn</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.debug.FullPanic.sentinelMismatch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sentinelMismatch</span><a href="#src.zig-std.debug.FullPanic.sentinelMismatch">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sentinelMismatch</span>(expected: <span class="tok-kw">anytype</span>, found: <span class="tok-builtin">@TypeOf</span>(expected)) <span class="tok-type">noreturn</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>found: <span class="tok-builtin">@TypeOf</span>(expected)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.sentinelMismatch">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sentinelMismatch</span>(expected: <span class="tok-kw">anytype</span>, found: <span class="tok-builtin">@TypeOf</span>(expected)) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;sentinel mismatch: expected {any}, found {any}&quot;</span>, .{
        expected, found,
    });
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.unwrapError" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unwrapError</span><a href="#src.zig-std.debug.FullPanic.unwrapError">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrapError</span>(err: <span class="tok-type">anyerror</span>) <span class="tok-type">noreturn</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>err: <span class="tok-type">anyerror</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.unwrapError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrapError</span>(err: <span class="tok-type">anyerror</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;attempt to unwrap error: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.outOfBounds" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">outOfBounds</span><a href="#src.zig-std.debug.FullPanic.outOfBounds">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">outOfBounds</span>(index: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.outOfBounds">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">outOfBounds</span>(index: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;index out of bounds: index {d}, len {d}&quot;</span>, .{ index, len });
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.startGreaterThanEnd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">startGreaterThanEnd</span><a href="#src.zig-std.debug.FullPanic.startGreaterThanEnd">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startGreaterThanEnd</span>(start: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>start: <span class="tok-type">usize</span></code></pre></div><div><pre><code>end: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.startGreaterThanEnd">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startGreaterThanEnd</span>(start: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;start index {d} is larger than end index {d}&quot;</span>, .{ start, end });
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.inactiveUnionField" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inactiveUnionField</span><a href="#src.zig-std.debug.FullPanic.inactiveUnionField">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inactiveUnionField</span>(active: <span class="tok-kw">anytype</span>, accessed: <span class="tok-builtin">@TypeOf</span>(active)) <span class="tok-type">noreturn</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>accessed: <span class="tok-builtin">@TypeOf</span>(active)</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.inactiveUnionField">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inactiveUnionField</span>(active: <span class="tok-kw">anytype</span>, accessed: <span class="tok-builtin">@TypeOf</span>(active)) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;access of union field '{s}' while field '{s}' is active&quot;</span>, .{
        <span class="tok-builtin">@tagName</span>(accessed), <span class="tok-builtin">@tagName</span>(active),
    });
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.sliceCastLenRemainder" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sliceCastLenRemainder</span><a href="#src.zig-std.debug.FullPanic.sliceCastLenRemainder">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceCastLenRemainder</span>(src_len: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>src_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.sliceCastLenRemainder">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceCastLenRemainder</span>(src_len: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;slice length '{d}' does not divide exactly into destination elements&quot;</span>, .{src_len});
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.reachedUnreachable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reachedUnreachable</span><a href="#src.zig-std.debug.FullPanic.reachedUnreachable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reachedUnreachable</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.reachedUnreachable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reachedUnreachable</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;reached unreachable code&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.unwrapNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unwrapNull</span><a href="#src.zig-std.debug.FullPanic.unwrapNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrapNull</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.unwrapNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrapNull</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;attempt to use null value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.castToNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">castToNull</span><a href="#src.zig-std.debug.FullPanic.castToNull">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castToNull</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.castToNull">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castToNull</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;cast causes pointer to be null&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.incorrectAlignment" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">incorrectAlignment</span><a href="#src.zig-std.debug.FullPanic.incorrectAlignment">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">incorrectAlignment</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.incorrectAlignment">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">incorrectAlignment</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;incorrect alignment&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.invalidErrorCode" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">invalidErrorCode</span><a href="#src.zig-std.debug.FullPanic.invalidErrorCode">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">invalidErrorCode</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.invalidErrorCode">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">invalidErrorCode</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;invalid error code&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.castTruncatedData" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">castTruncatedData</span><a href="#src.zig-std.debug.FullPanic.castTruncatedData">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castTruncatedData</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.castTruncatedData">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castTruncatedData</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer cast truncated bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.negativeToUnsigned" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">negativeToUnsigned</span><a href="#src.zig-std.debug.FullPanic.negativeToUnsigned">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negativeToUnsigned</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.negativeToUnsigned">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negativeToUnsigned</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;attempt to cast negative value to unsigned integer&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.integerOverflow" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">integerOverflow</span><a href="#src.zig-std.debug.FullPanic.integerOverflow">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">integerOverflow</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.integerOverflow">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">integerOverflow</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer overflow&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.shlOverflow" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shlOverflow</span><a href="#src.zig-std.debug.FullPanic.shlOverflow">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shlOverflow</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.shlOverflow">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shlOverflow</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;left shift overflowed bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.shrOverflow" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrOverflow</span><a href="#src.zig-std.debug.FullPanic.shrOverflow">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrOverflow</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.shrOverflow">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrOverflow</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;right shift overflowed bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.divideByZero" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">divideByZero</span><a href="#src.zig-std.debug.FullPanic.divideByZero">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divideByZero</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.divideByZero">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divideByZero</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;division by zero&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.exactDivisionRemainder" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">exactDivisionRemainder</span><a href="#src.zig-std.debug.FullPanic.exactDivisionRemainder">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exactDivisionRemainder</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.exactDivisionRemainder">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exactDivisionRemainder</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;exact division produced remainder&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.integerPartOutOfBounds" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">integerPartOutOfBounds</span><a href="#src.zig-std.debug.FullPanic.integerPartOutOfBounds">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">integerPartOutOfBounds</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.integerPartOutOfBounds">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">integerPartOutOfBounds</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer part of floating point value out of bounds&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.corruptSwitch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">corruptSwitch</span><a href="#src.zig-std.debug.FullPanic.corruptSwitch">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">corruptSwitch</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.corruptSwitch">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">corruptSwitch</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;switch on corrupt value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.shiftRhsTooBig" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shiftRhsTooBig</span><a href="#src.zig-std.debug.FullPanic.shiftRhsTooBig">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRhsTooBig</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.shiftRhsTooBig">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRhsTooBig</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;shift amount is greater than the type size&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.invalidEnumValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">invalidEnumValue</span><a href="#src.zig-std.debug.FullPanic.invalidEnumValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">invalidEnumValue</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.invalidEnumValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">invalidEnumValue</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;invalid enum value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.forLenMismatch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">forLenMismatch</span><a href="#src.zig-std.debug.FullPanic.forLenMismatch">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forLenMismatch</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.forLenMismatch">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forLenMismatch</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;for loop over objects with non-equal lengths&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.memcpyLenMismatch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">memcpyLenMismatch</span><a href="#src.zig-std.debug.FullPanic.memcpyLenMismatch">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memcpyLenMismatch</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.memcpyLenMismatch">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memcpyLenMismatch</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;@memcpy arguments have non-equal lengths&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.memcpyAlias" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">memcpyAlias</span><a href="#src.zig-std.debug.FullPanic.memcpyAlias">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memcpyAlias</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.memcpyAlias">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memcpyAlias</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;@memcpy arguments alias&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.FullPanic.noreturnReturned" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">noreturnReturned</span><a href="#src.zig-std.debug.FullPanic.noreturnReturned">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noreturnReturned</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.FullPanic.noreturnReturned">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noreturnReturned</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;'noreturn' function returned&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.FullPanic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">FullPanic</span>(<span class="tok-kw">comptime</span> panicFn: <span class="tok-kw">fn</span> ([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ?<span class="tok-type">usize</span>) <span class="tok-type">noreturn</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> call = panicFn;
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sentinelMismatch</span>(expected: <span class="tok-kw">anytype</span>, found: <span class="tok-builtin">@TypeOf</span>(expected)) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;sentinel mismatch: expected {any}, found {any}&quot;</span>, .{
                expected, found,
            });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrapError</span>(err: <span class="tok-type">anyerror</span>) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;attempt to unwrap error: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">outOfBounds</span>(index: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;index out of bounds: index {d}, len {d}&quot;</span>, .{ index, len });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startGreaterThanEnd</span>(start: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;start index {d} is larger than end index {d}&quot;</span>, .{ start, end });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inactiveUnionField</span>(active: <span class="tok-kw">anytype</span>, accessed: <span class="tok-builtin">@TypeOf</span>(active)) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;access of union field '{s}' while field '{s}' is active&quot;</span>, .{
                <span class="tok-builtin">@tagName</span>(accessed), <span class="tok-builtin">@tagName</span>(active),
            });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceCastLenRemainder</span>(src_len: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;slice length '{d}' does not divide exactly into destination elements&quot;</span>, .{src_len});
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reachedUnreachable</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;reached unreachable code&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrapNull</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;attempt to use null value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castToNull</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;cast causes pointer to be null&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">incorrectAlignment</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;incorrect alignment&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">invalidErrorCode</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;invalid error code&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castTruncatedData</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer cast truncated bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negativeToUnsigned</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;attempt to cast negative value to unsigned integer&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">integerOverflow</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer overflow&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shlOverflow</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;left shift overflowed bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrOverflow</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;right shift overflowed bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divideByZero</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;division by zero&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exactDivisionRemainder</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;exact division produced remainder&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">integerPartOutOfBounds</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer part of floating point value out of bounds&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">corruptSwitch</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;switch on corrupt value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRhsTooBig</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;shift amount is greater than the type size&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">invalidEnumValue</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;invalid enum value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forLenMismatch</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;for loop over objects with non-equal lengths&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memcpyLenMismatch</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;@memcpy arguments have non-equal lengths&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memcpyAlias</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;@memcpy arguments alias&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noreturnReturned</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;'noreturn' function returned&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.UnwindError" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">UnwindError</span><a href="#src.zig-std.debug.UnwindError">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.UnwindError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnwindError = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>)
    <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(<a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.next_unwind">next_unwind</a>)).@&quot;fn&quot;.return_type.?).error_union.error_set
<span class="tok-kw">else</span>
    <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h2 id="std.debug.Trace" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Trace</span><a href="#src.zig-std.debug.Trace">[src]</a></h2><div class="tldDocs"><p>This API helps you track where a value originated and where it was mutated,
or any other points of interest.
In debug mode, it adds a small size penalty (104 bytes on 64-bit architectures)
to the aggregate that you add it to.
In release mode, it is size 0 and all methods are no-ops.
This is a pre-made type with default settings.
For more advanced usage, see <code><a href="std.debug.html#std.debug.ConfigurableTrace">ConfigurableTrace</a></code>.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Trace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Trace = <a href="std.debug.html#std.debug.ConfigurableTrace">ConfigurableTrace</a>(<span class="tok-number">2</span>, <span class="tok-number">4</span>, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug)</code></pre></details></div></div><div class="decl"><h2 id="std.debug.ConfigurableTrace" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ConfigurableTrace</span><a href="#src.zig-std.debug.ConfigurableTrace">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>size: <span class="tok-type">usize</span></code></pre></div><div><pre><code>stack_frame_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>is_enabled: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>addrs: [<a href="std.debug.html#std.debug.ConfigurableTrace.actual_size">actual_size</a>][stack_frame_count]<span class="tok-type">usize</span></code></pre></div><div><pre><code>notes: [<a href="std.debug.html#std.debug.ConfigurableTrace.actual_size">actual_size</a>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>index: <a href="std.debug.html#std.debug.ConfigurableTrace.Index">Index</a></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.debug.ConfigurableTrace.init" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.debug.ConfigurableTrace.init">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> init: <span class="tok-builtin">@This</span>() = .{
    .addrs = <span class="tok-null">undefined</span>,
    .notes = <span class="tok-null">undefined</span>,
    .index = <span class="tok-number">0</span>,
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.ConfigurableTrace.enabled" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">enabled</span><a href="#src.zig-std.debug.ConfigurableTrace.enabled">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace.enabled">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> enabled = is_enabled</code></pre></details></div></div><div class="decl"><h3 id="std.debug.ConfigurableTrace.add" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.debug.ConfigurableTrace.add">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace.add">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> add = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <a href="std.debug.html#std.debug.ConfigurableTrace.addNoInline">addNoInline</a> <span class="tok-kw">else</span> <a href="std.debug.html#std.debug.ConfigurableTrace.addNoOp">addNoOp</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.debug.ConfigurableTrace.addNoInline" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addNoInline</span><a href="#src.zig-std.debug.ConfigurableTrace.addNoInline">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoInline</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>t: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace.addNoInline">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoInline</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>);
    <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.ConfigurableTrace.addAddr">addAddr</a>(t, <span class="tok-builtin">@returnAddress</span>(), note);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.ConfigurableTrace.addNoOp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addNoOp</span><a href="#src.zig-std.debug.ConfigurableTrace.addNoOp">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoOp</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>t: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace.addNoOp">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoOp</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = t;
    _ = note;
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.ConfigurableTrace.addAddr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addAddr</span><a href="#src.zig-std.debug.ConfigurableTrace.addAddr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAddr</span>(t: *<span class="tok-builtin">@This</span>(), addr: <span class="tok-type">usize</span>, note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>t: *<span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>addr: <span class="tok-type">usize</span></code></pre></div><div><pre><code>note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace.addAddr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAddr</span>(t: *<span class="tok-builtin">@This</span>(), addr: <span class="tok-type">usize</span>, note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <span class="tok-kw">return</span>;

    <span class="tok-kw">if</span> (t.index &lt; size) {
        t.notes[t.index] = note;
        t.addrs[t.index] = [<span class="tok-number">1</span>]<span class="tok-type">usize</span>{<span class="tok-number">0</span>} ** stack_frame_count;
        <span class="tok-kw">var</span> stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a> = .{
            .index = <span class="tok-number">0</span>,
            .instruction_addresses = &amp;t.addrs[t.index],
        };
        <a href="std.debug.html#std.debug.captureStackTrace">captureStackTrace</a>(addr, &amp;stack_trace);
    }<span class="tok-comment">
    // Keep counting even if the end is reached so that the
    // user can find out how much more size they need.
    </span>t.index += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.ConfigurableTrace.dump" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dump</span><a href="#src.zig-std.debug.ConfigurableTrace.dump">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(t: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>t: <span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace.dump">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(t: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> tty_config = <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>());
    <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
    <span class="tok-kw">const</span> end = <span class="tok-builtin">@min</span>(t.index, size);
    <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
        stderr.print(
            <span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>,
            .{<span class="tok-builtin">@errorName</span>(err)},
        ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">return</span>;
    };
    <span class="tok-kw">for</span> (t.addrs[<span class="tok-number">0</span>..end], <span class="tok-number">0</span>..) |frames_array, i| {
        stderr.print(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{t.notes[i]}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">var</span> frames_array_mutable = frames_array;
        <span class="tok-kw">const</span> frames = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(frames_array_mutable[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a> = .{
            .index = frames.len,
            .instruction_addresses = frames,
        };
        <a href="std.debug.html#std.debug.writeStackTrace">writeStackTrace</a>(stack_trace, stderr, debug_info, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
    }
    <span class="tok-kw">if</span> (t.index &gt; end) {
        stderr.print(<span class="tok-str">&quot;{d} more traces not shown; consider increasing trace size\n&quot;</span>, .{
            t.index - end,
        }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.ConfigurableTrace.format" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">format</span><a href="#src.zig-std.debug.ConfigurableTrace.format">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>( t: <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>, writer: <span class="tok-kw">anytype</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>t: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace.format">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
    t: <span class="tok-builtin">@This</span>(),
    <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
    writer: <span class="tok-kw">anytype</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.invalidFmtError">invalidFmtError</a>(fmt, t);
    _ = options;
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) {
        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);
        t.dump();
        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> writer.writeAll(<span class="tok-str">&quot;(value tracing disabled)&quot;</span>);
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.ConfigurableTrace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ConfigurableTrace</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> stack_frame_count: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> is_enabled: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        addrs: [<a href="std.debug.html#std.debug.ConfigurableTrace.actual_size">actual_size</a>][stack_frame_count]<span class="tok-type">usize</span>,
        notes: [<a href="std.debug.html#std.debug.ConfigurableTrace.actual_size">actual_size</a>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        index: <a href="std.debug.html#std.debug.ConfigurableTrace.Index">Index</a>,

        <span class="tok-kw">const</span> actual_size = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) size <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> Index = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <span class="tok-type">usize</span> <span class="tok-kw">else</span> <span class="tok-type">u0</span>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> init: <span class="tok-builtin">@This</span>() = .{
            .addrs = <span class="tok-null">undefined</span>,
            .notes = <span class="tok-null">undefined</span>,
            .index = <span class="tok-number">0</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> enabled = is_enabled;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> add = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <a href="std.debug.html#std.debug.ConfigurableTrace.addNoInline">addNoInline</a> <span class="tok-kw">else</span> <a href="std.debug.html#std.debug.ConfigurableTrace.addNoOp">addNoOp</a>;

        <span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoInline</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>);
            <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.ConfigurableTrace.addAddr">addAddr</a>(t, <span class="tok-builtin">@returnAddress</span>(), note);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoOp</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            _ = t;
            _ = note;
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAddr</span>(t: *<span class="tok-builtin">@This</span>(), addr: <span class="tok-type">usize</span>, note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <span class="tok-kw">return</span>;

            <span class="tok-kw">if</span> (t.index &lt; size) {
                t.notes[t.index] = note;
                t.addrs[t.index] = [<span class="tok-number">1</span>]<span class="tok-type">usize</span>{<span class="tok-number">0</span>} ** stack_frame_count;
                <span class="tok-kw">var</span> stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a> = .{
                    .index = <span class="tok-number">0</span>,
                    .instruction_addresses = &amp;t.addrs[t.index],
                };
                <a href="std.debug.html#std.debug.captureStackTrace">captureStackTrace</a>(addr, &amp;stack_trace);
            }<span class="tok-comment">
            // Keep counting even if the end is reached so that the
            // user can find out how much more size they need.
            </span>t.index += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(t: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> tty_config = <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>());
            <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
            <span class="tok-kw">const</span> end = <span class="tok-builtin">@min</span>(t.index, size);
            <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
                stderr.print(
                    <span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>,
                    .{<span class="tok-builtin">@errorName</span>(err)},
                ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
                <span class="tok-kw">return</span>;
            };
            <span class="tok-kw">for</span> (t.addrs[<span class="tok-number">0</span>..end], <span class="tok-number">0</span>..) |frames_array, i| {
                stderr.print(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{t.notes[i]}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
                <span class="tok-kw">var</span> frames_array_mutable = frames_array;
                <span class="tok-kw">const</span> frames = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(frames_array_mutable[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);
                <span class="tok-kw">const</span> stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a> = .{
                    .index = frames.len,
                    .instruction_addresses = frames,
                };
                <a href="std.debug.html#std.debug.writeStackTrace">writeStackTrace</a>(stack_trace, stderr, debug_info, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">if</span> (t.index &gt; end) {
                stderr.print(<span class="tok-str">&quot;{d} more traces not shown; consider increasing trace size\n&quot;</span>, .{
                    t.index - end,
                }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
            t: <span class="tok-builtin">@This</span>(),
            <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
            writer: <span class="tok-kw">anytype</span>,
        ) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.invalidFmtError">invalidFmtError</a>(fmt, t);
            _ = options;
            <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) {
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);
                t.dump();
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> writer.writeAll(<span class="tok-str">&quot;(value tracing disabled)&quot;</span>);
            }
        }
    };
}</code></pre></details></div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.debug.runtime_safety" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">runtime_safety</span><a href="#src.zig-std.debug.runtime_safety">[src]</a></h2><div class="tldDocs"><p>Deprecated because it returns the optimization mode of the standard
library, when the caller probably wants to use the optimization mode of
their own module.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.runtime_safety">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> runtime_safety = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a>) {
    .Debug, .ReleaseSafe =&gt; <span class="tok-null">true</span>,
    .ReleaseFast, .ReleaseSmall =&gt; <span class="tok-null">false</span>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.sys_can_stack_trace" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">sys_can_stack_trace</span><a href="#src.zig-std.debug.sys_can_stack_trace">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.sys_can_stack_trace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> sys_can_stack_trace = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>) {<span class="tok-comment">
    // Observed to go into an infinite loop.
    // TODO: Make this work.
    </span>.mips,
    .mipsel,
    .mips64,
    .mips64el,
    .s390x,
    =&gt; <span class="tok-null">false</span>,<span class="tok-comment">

    // `@returnAddress()` in LLVM 10 gives
    // &quot;Non-Emscripten WebAssembly hasn't implemented __builtin_return_address&quot;.
    </span>.wasm32,
    .wasm64,
    =&gt; <a href="std.debug.html#std.debug.native_os">native_os</a> == .emscripten,<span class="tok-comment">

    // `@returnAddress()` is unsupported in LLVM 13.
    </span>.bpfel,
    .bpfeb,
    =&gt; <span class="tok-null">false</span>,

    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.have_ucontext" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">have_ucontext</span><a href="#src.zig-std.debug.have_ucontext">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.have_ucontext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_ucontext = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ucontext_t">ucontext_t</a> != <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h2 id="std.debug.ThreadContext" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ThreadContext</span><a href="#src.zig-std.debug.ThreadContext">[src]</a></h2><div class="tldDocs"><p>Platform-specific thread state. This contains register state, and on some platforms
information about the stack. This is not safe to trivially copy, because some platforms
use internal pointers within this structure. To make a copy, use <code><a href="std.debug.html#std.debug.copyContext">copyContext</a></code>.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.ThreadContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadContext = blk: {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <span class="tok-kw">break</span> :blk <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) {
        <span class="tok-kw">break</span> :blk <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ucontext_t">ucontext_t</a>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">break</span> :blk <span class="tok-type">void</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.have_getcontext" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">have_getcontext</span><a href="#src.zig-std.debug.have_getcontext">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.have_getcontext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_getcontext = <span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getcontext</a>) != <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h2 id="std.debug.have_segfault_handling_support" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">have_segfault_handling_support</span><a href="#src.zig-std.debug.have_segfault_handling_support">[src]</a></h2><div class="tldDocs"><p>Whether or not the current target can print useful debug information when a segfault occurs.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.have_segfault_handling_support">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_segfault_handling_support = <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.native_os">native_os</a>) {
    .linux,
    .macos,
    .netbsd,
    .solaris,
    .illumos,
    .windows,
    =&gt; <span class="tok-null">true</span>,

    .freebsd, .openbsd =&gt; <a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.default_enable_segfault_handler" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">default_enable_segfault_handler</span><a href="#src.zig-std.debug.default_enable_segfault_handler">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.default_enable_segfault_handler">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_enable_segfault_handler = <a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a> <span class="tok-kw">and</span> <a href="std.debug.html#std.debug.have_segfault_handling_support">have_segfault_handling_support</a></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.debug.lockStdErr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockStdErr</span><a href="#src.zig-std.debug.lockStdErr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockStdErr</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Allows the caller to freely write to stderr until <code><a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a></code> is called.</p>
<p>During the lock, any <code><a href="std.Progress.html">std.Progress</a></code> information is cleared from the terminal.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.lockStdErr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockStdErr</span>() <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.html#std.Progress.lockStdErr">lockStdErr</a>();
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.unlockStdErr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockStdErr</span><a href="#src.zig-std.debug.unlockStdErr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockStdErr</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.unlockStdErr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockStdErr</span>() <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.html#std.Progress.unlockStdErr">unlockStdErr</a>();
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.print" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">print</span><a href="#src.zig-std.debug.print">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Print to stderr, unbuffered, and silently returning on failure. Intended
for use in &quot;printf debugging.&quot; Use <code><a href="std.log.html">std.log</a></code> functions for proper logging.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.print">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
    <span class="tok-kw">defer</span> <a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();
    <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
    <span class="tok-kw">nosuspend</span> stderr.print(fmt, args) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.getStderrMutex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getStderrMutex</span><a href="#src.zig-std.debug.getStderrMutex">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStderrMutex</span>() *<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.getStderrMutex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStderrMutex</span>() *<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a> {
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated. call std.debug.lockStdErr() and std.debug.unlockStdErr() instead which will integrate properly with std.Progress&quot;</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.getSelfDebugInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getSelfDebugInfo</span><a href="#src.zig-std.debug.getSelfDebugInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSelfDebugInfo</span>() !*<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.getSelfDebugInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSelfDebugInfo</span>() !*<a href="std.debug.SelfInfo.html">SelfInfo</a> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.self_debug_info">self_debug_info</a>) |*info| {
        <span class="tok-kw">return</span> info;
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.self_debug_info">self_debug_info</a> = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.open">open</a>(<a href="std.debug.html#std.debug.getDebugInfoAllocator">getDebugInfoAllocator</a>());
        <span class="tok-kw">return</span> &amp;<a href="std.debug.html#std.debug.self_debug_info">self_debug_info</a>.?;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.dumpHex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dumpHex</span><a href="#src.zig-std.debug.dumpHex">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpHex</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Tries to print a hexadecimal view of the bytes, unbuffered, and ignores any error returned.
Obtains the stderr mutex while dumping.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.dumpHex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpHex</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
    <span class="tok-kw">defer</span> <a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();
    <a href="std.debug.html#std.debug.dumpHexFallible">dumpHexFallible</a>(bytes) <span class="tok-kw">catch</span> {};
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.dumpHexFallible" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dumpHexFallible</span><a href="#src.zig-std.debug.dumpHexFallible">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpHexFallible</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Prints a hexadecimal view of the bytes, unbuffered, returning any error that occurs.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.dumpHexFallible">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpHexFallible</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();
    <span class="tok-kw">const</span> ttyconf = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(stderr);
    <span class="tok-kw">const</span> writer = stderr.writer();
    <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.dumpHexInternal">dumpHexInternal</a>(bytes, ttyconf, writer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.dumpCurrentStackTrace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dumpCurrentStackTrace</span><a href="#src.zig-std.debug.dumpCurrentStackTrace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpCurrentStackTrace</span>(start_addr: ?<span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Tries to print the current stack trace to stderr, unbuffered, and ignores any error returned.
TODO multithreaded awareness</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>start_addr: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.dumpCurrentStackTrace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpCurrentStackTrace</span>(start_addr: ?<span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
            <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .wasi) {
                <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
        <a href="std.debug.html#std.debug.writeCurrentStackTrace">writeCurrentStackTrace</a>(stderr, debug_info, <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>()), start_addr) <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.copyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copyContext</span><a href="#src.zig-std.debug.copyContext">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyContext</span>(source: *<span class="tok-kw">const</span> <a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>, dest: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Copies one context to another, updating any internal pointers</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>source: *<span class="tok-kw">const</span> <a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a></code></pre></div><div><pre><code>dest: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.copyContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyContext</span>(source: *<span class="tok-kw">const</span> <a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>, dest: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) <span class="tok-kw">return</span> {};
    dest.* = source.*;
    <a href="std.debug.html#std.debug.relocateContext">relocateContext</a>(dest);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.relocateContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">relocateContext</span><a href="#src.zig-std.debug.relocateContext">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">relocateContext</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Updates any internal pointers in the context to reflect its current location</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.relocateContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">relocateContext</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.native_os">native_os</a>) {
        .macos =&gt; {
            context.mcontext = &amp;context.__mcontext_data;
        },
        <span class="tok-kw">else</span> =&gt; {},
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.debug.getContext">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Capture the current context. The register values in the context will reflect the
state after the platform <code>getcontext</code> function returns.</p>
<p>It is valid to call this if the platform doesn't have context capturing support,
in that case false will be returned.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.getContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        context.* = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>);
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlCaptureContext">RtlCaptureContext</a>(context);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">const</span> result = <a href="std.debug.html#std.debug.have_getcontext">have_getcontext</a> <span class="tok-kw">and</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getcontext</a>(context) == <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .macos) {
        <a href="std.debug.html#std.debug.assert">assert</a>(context.mcsize == <span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.mcontext_t">mcontext_t</a>));<span class="tok-comment">

        // On aarch64-macos, the system getcontext doesn't write anything into the pc
        // register slot, it only writes lr. This makes the context consistent with
        // other aarch64 getcontext implementations which write the current lr
        // (where getcontext will return to) into both the lr and pc slot of the context.
        </span><span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a> == .aarch64) context.mcontext.ss.pc = context.mcontext.ss.lr;
    }

    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.dumpStackTraceFromBase" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dumpStackTraceFromBase</span><a href="#src.zig-std.debug.dumpStackTraceFromBase">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTraceFromBase</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Tries to print the stack trace starting from the supplied base pointer to stderr,
unbuffered, and ignores any error returned.
TODO multithreaded awareness</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.dumpStackTraceFromBase">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTraceFromBase</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
            <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .wasi) {
                <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
        <span class="tok-kw">const</span> tty_config = <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>());
        <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {<span class="tok-comment">
            // On x86_64 and aarch64, the stack will be unwound using RtlVirtualUnwind using the context
            // provided by the exception handler. On x86, RtlVirtualUnwind doesn't exist. Instead, a new backtrace
            // will be captured and frames prior to the exception will be filtered.
            // The caveat is that RtlCaptureStackBackTrace does not include the KiUserExceptionDispatcher frame,
            // which is where the IP in `context` points to, so it can't be used as start_addr.
            // Instead, start_addr is recovered from the stack.
            </span><span class="tok-kw">const</span> start_addr = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a> == .x86) <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(context.getRegs().bp + <span class="tok-number">4</span>)).* <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            <a href="std.debug.html#std.debug.writeStackTraceWindows">writeStackTraceWindows</a>(stderr, debug_info, tty_config, context, start_addr) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">var</span> it = <a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.initWithContext">initWithContext</a>(<span class="tok-null">null</span>, debug_info, context) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">defer</span> it.deinit();<span class="tok-comment">

        // DWARF unwinding on aarch64-macos is not complete so we need to get pc address from mcontext
        </span><span class="tok-kw">const</span> pc_addr = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>() <span class="tok-kw">and</span> <a href="std.debug.html#std.debug.native_arch">native_arch</a> == .aarch64)
            context.mcontext.ss.pc
        <span class="tok-kw">else</span>
            it.unwind_state.?.dwarf_context.pc;
        <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, stderr, pc_addr, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;

        <span class="tok-kw">while</span> (it.next()) |return_address| {
            <a href="std.debug.html#std.debug.printLastUnwindError">printLastUnwindError</a>(&amp;it, debug_info, stderr, tty_config);<span class="tok-comment">

            // On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,
            // therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid
            // an overflow. We do not need to signal `StackIterator` as it will correctly detect this
            // condition on the subsequent iteration and return `null` thus terminating the loop.
            // same behaviour for x86-windows-msvc
            </span><span class="tok-kw">const</span> address = <span class="tok-kw">if</span> (return_address == <span class="tok-number">0</span>) return_address <span class="tok-kw">else</span> return_address - <span class="tok-number">1</span>;
            <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, stderr, address, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <a href="std.debug.html#std.debug.printLastUnwindError">printLastUnwindError</a>(&amp;it, debug_info, stderr, tty_config);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.captureStackTrace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">captureStackTrace</span><a href="#src.zig-std.debug.captureStackTrace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">captureStackTrace</span>(first_address: ?<span class="tok-type">usize</span>, stack_trace: *<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Returns a slice with the same pointer as addresses, with a potentially smaller len.
On Windows, when first_address is not null, we ask for at least 32 stack frames,
and then try to find the first address. If addresses.len is more than 32, we
capture that many stack frames exactly, and then look for the first address,
chopping off the irrelevant frames and shifting so that the returned addresses pointer
equals the passed in addresses pointer.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>first_address: ?<span class="tok-type">usize</span></code></pre></div><div><pre><code>stack_trace: *<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.captureStackTrace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">captureStackTrace</span>(first_address: ?<span class="tok-type">usize</span>, stack_trace: *<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> addrs = stack_trace.instruction_addresses;
        <span class="tok-kw">const</span> first_addr = first_address <span class="tok-kw">orelse</span> {
            stack_trace.index = <a href="std.debug.html#std.debug.walkStackWindows">walkStackWindows</a>(addrs[<span class="tok-number">0</span>..], <span class="tok-null">null</span>);
            <span class="tok-kw">return</span>;
        };
        <span class="tok-kw">var</span> addr_buf_stack: [<span class="tok-number">32</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> addr_buf = <span class="tok-kw">if</span> (addr_buf_stack.len &gt; addrs.len) addr_buf_stack[<span class="tok-number">0</span>..] <span class="tok-kw">else</span> addrs;
        <span class="tok-kw">const</span> n = <a href="std.debug.html#std.debug.walkStackWindows">walkStackWindows</a>(addr_buf[<span class="tok-number">0</span>..], <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> first_index = <span class="tok-kw">for</span> (addr_buf[<span class="tok-number">0</span>..n], <span class="tok-number">0</span>..) |addr, i| {
            <span class="tok-kw">if</span> (addr == first_addr) {
                <span class="tok-kw">break</span> i;
            }
        } <span class="tok-kw">else</span> {
            stack_trace.index = <span class="tok-number">0</span>;
            <span class="tok-kw">return</span>;
        };
        <span class="tok-kw">const</span> end_index = <span class="tok-builtin">@min</span>(first_index + addrs.len, n);
        <span class="tok-kw">const</span> slice = addr_buf[first_index..end_index];<span class="tok-comment">
        // We use a for loop here because slice and addrs may alias.
        </span><span class="tok-kw">for</span> (slice, <span class="tok-number">0</span>..) |addr, i| {
            addrs[i] = addr;
        }
        stack_trace.index = slice.len;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // TODO: This should use the DWARF unwinder if .eh_frame_hdr is available (so that full debug info parsing isn't required).
        //       A new path for loading SelfInfo needs to be created which will only attempt to parse in-memory sections, because
        //       stopping to load other debug info (ie. source line info) from disk here is not required for unwinding.
        </span><span class="tok-kw">var</span> it = <a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.init">init</a>(first_address, <span class="tok-null">null</span>);
        <span class="tok-kw">defer</span> it.deinit();
        <span class="tok-kw">for</span> (stack_trace.instruction_addresses, <span class="tok-number">0</span>..) |*addr, i| {
            addr.* = it.next() <span class="tok-kw">orelse</span> {
                stack_trace.index = i;
                <span class="tok-kw">return</span>;
            };
        }
        stack_trace.index = stack_trace.instruction_addresses.len;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.dumpStackTrace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dumpStackTrace</span><a href="#src.zig-std.debug.dumpStackTrace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTrace</span>(stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Tries to print a stack trace to stderr, unbuffered, and ignores any error returned.
TODO multithreaded awareness</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.dumpStackTrace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTrace</span>(stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
            <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .wasi) {
                <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
        <a href="std.debug.html#std.debug.writeStackTrace">writeStackTrace</a>(stack_trace, stderr, debug_info, <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>())) <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.assert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">assert</span><a href="#src.zig-std.debug.assert">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invokes detectable illegal behavior when <code>ok</code> is <code>false</code>.</p>
<p>In Debug and ReleaseSafe modes, calls to this function are always
generated, and the <code>unreachable</code> statement triggers a panic.</p>
<p>In ReleaseFast and ReleaseSmall modes, calls to this function are optimized
away, and in fact the optimizer is able to use the assertion in its
heuristics.</p>
<p>Inside a test block, it is best to use the <code><a href="std.testing.html">std.testing</a></code> module rather than
this function, because this function may not detect a test failure in
ReleaseFast and ReleaseSmall mode. Outside of a test block, this assert
function is the correct function to use.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ok: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.assert">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // assertion failure
</span>}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.assertReadable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">assertReadable</span><a href="#src.zig-std.debug.assertReadable">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assertReadable</span>(slice: []<span class="tok-kw">const</span> <span class="tok-kw">volatile</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Invokes detectable illegal behavior when the provided slice is not mapped
or lacks read permissions.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>slice: []<span class="tok-kw">const</span> <span class="tok-kw">volatile</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.assertReadable">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assertReadable</span>(slice: []<span class="tok-kw">const</span> <span class="tok-kw">volatile</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <span class="tok-kw">return</span>;
    <span class="tok-kw">for</span> (slice) |*byte| _ = byte.*;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.panic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">panic</span><a href="#src.zig-std.debug.panic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panic</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span></code></pre></div><div class="tldDocs"><p>Equivalent to <code>@panic</code> but with a formatted message.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.panic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panic</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), format, args);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.panicExtra" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">panicExtra</span><a href="#src.zig-std.debug.panicExtra">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicExtra</span>( ret_addr: ?<span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>, ) <span class="tok-type">noreturn</span></code></pre></div><div class="tldDocs"><p>Equivalent to <code>@panic</code> but with a formatted message, and with an explicitly
provided return address.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ret_addr: ?<span class="tok-type">usize</span></code></pre></div><div><pre><code>format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.panicExtra">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicExtra</span>(
    ret_addr: ?<span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);

    <span class="tok-kw">const</span> size = <span class="tok-number">0x1000</span>;
    <span class="tok-kw">const</span> trunc_msg = <span class="tok-str">&quot;(msg truncated)&quot;</span>;
    <span class="tok-kw">var</span> buf: [size + trunc_msg.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // a minor annoyance with this is that it will result in the NoSpaceLeft
    // error being part of the @panic stack trace (but that error should
    // only happen rarely)
    </span><span class="tok-kw">const</span> msg = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(buf[<span class="tok-number">0</span>..size], format, args) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; blk: {
            <span class="tok-builtin">@memcpy</span>(buf[size..], trunc_msg);
            <span class="tok-kw">break</span> :blk &amp;buf;
        },
    };
    <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.html#std.builtin.panic">panic</a>.<a href="#">call</a>(msg, ret_addr);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.defaultPanic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">defaultPanic</span><a href="#src.zig-std.debug.defaultPanic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">defaultPanic</span>( msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, first_trace_addr: ?<span class="tok-type">usize</span>, ) <span class="tok-type">noreturn</span></code></pre></div><div class="tldDocs"><p>Dumps a stack trace to standard error, then aborts.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>first_trace_addr: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.defaultPanic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">defaultPanic</span>(
    msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    first_trace_addr: ?<span class="tok-type">usize</span>,
) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);<span class="tok-comment">

    // For backends that cannot handle the language features depended on by the
    // default panic handler, we have a simpler panic handler:
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_wasm <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_arm <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_aarch64 <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86 <span class="tok-kw">or</span>
        (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86_64 <span class="tok-kw">and</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">ofmt</a> != .elf <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">ofmt</a> != .macho)) <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_sparc64 <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_spirv64)
    {
        <span class="tok-builtin">@trap</span>();
    }

    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .freestanding, .other =&gt; {
            <span class="tok-builtin">@trap</span>();
        },
        .uefi =&gt; {
            <span class="tok-kw">const</span> uefi = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.uefi.html">uefi</a>;

            <span class="tok-kw">var</span> utf16_buffer: [<span class="tok-number">1000</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> len_minus_3 = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16Le">utf8ToUtf16Le</a>(&amp;utf16_buffer, msg) <span class="tok-kw">catch</span> <span class="tok-number">0</span>;
            utf16_buffer[len_minus_3..][<span class="tok-number">0</span>..<span class="tok-number">3</span>].* = .{ <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span>, <span class="tok-number">0</span> };
            <span class="tok-kw">const</span> len = len_minus_3 + <span class="tok-number">3</span>;
            <span class="tok-kw">const</span> exit_msg = utf16_buffer[<span class="tok-number">0</span> .. len - <span class="tok-number">1</span> :<span class="tok-number">0</span>];<span class="tok-comment">

            // Output to both std_err and con_out, as std_err is easier
            // to read in stuff like QEMU at times, but, unlike con_out,
            // isn't visible on actual hardware if directly booted into
            </span><span class="tok-kw">inline</span> <span class="tok-kw">for</span> ([_]?*uefi.protocol.SimpleTextOutput{ uefi.system_table.std_err, uefi.system_table.con_out }) |o| {
                <span class="tok-kw">if</span> (o) |out| {
                    _ = out.setAttribute(uefi.protocol.SimpleTextOutput.red);
                    _ = out.outputString(exit_msg);
                    _ = out.setAttribute(uefi.protocol.SimpleTextOutput.white);
                }
            }

            <span class="tok-kw">if</span> (uefi.system_table.boot_services) |bs| {<span class="tok-comment">
                // ExitData buffer must be allocated using boot_services.allocatePool (spec: page 220)
                </span><span class="tok-kw">const</span> exit_data: []<span class="tok-type">u16</span> = uefi.raw_pool_allocator.alloc(<span class="tok-type">u16</span>, exit_msg.len + <span class="tok-number">1</span>) <span class="tok-kw">catch</span> <span class="tok-builtin">@trap</span>();
                <span class="tok-builtin">@memcpy</span>(exit_data, exit_msg[<span class="tok-number">0</span>..exit_data.len]);<span class="tok-comment"> // Includes null terminator.
                </span>_ = bs.exit(uefi.handle, .aborted, exit_data.len, exit_data.ptr);
            }
            <span class="tok-builtin">@trap</span>();
        },
        .cuda, .amdhsa =&gt; <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>(),
        .plan9 =&gt; {
            <span class="tok-kw">var</span> status: [<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.plan9.html">plan9</a>.<a href="std.os.plan9.html#std.os.plan9.ERRMAX">ERRMAX</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> len = <span class="tok-builtin">@min</span>(msg.len, status.len - <span class="tok-number">1</span>);
            <span class="tok-builtin">@memcpy</span>(status[<span class="tok-number">0</span>..len], msg[<span class="tok-number">0</span>..len]);
            status[len] = <span class="tok-number">0</span>;
            <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.plan9.html">plan9</a>.<a href="std.os.plan9.html#std.os.plan9.exits">exits</a>(status[<span class="tok-number">0</span>..len :<span class="tok-number">0</span>]);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.enable_segfault_handler">enable_segfault_handler</a>) {<span class="tok-comment">
        // If a segfault happens while panicking, we want it to actually segfault, not trigger
        // the handler.
        </span><a href="std.debug.html#std.debug.resetSegfaultHandler">resetSegfaultHandler</a>();
    }<span class="tok-comment">

    // Note there is similar logic in handleSegfaultPosix and handleSegfaultWindowsExtra.
    </span><span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.panic_stage">panic_stage</a>) {
        <span class="tok-number">0</span> =&gt; {
            <a href="std.debug.html#std.debug.panic_stage">panic_stage</a> = <span class="tok-number">1</span>;

            _ = <a href="std.debug.html#std.debug.panicking">panicking</a>.<a href="#">fetchAdd</a>(<span class="tok-number">1</span>, .seq_cst);

            {
                <a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
                <span class="tok-kw">defer</span> <a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();

                <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
                <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
                    stderr.print(<span class="tok-str">&quot;panic: &quot;</span>, .{}) <span class="tok-kw">catch</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">const</span> current_thread_id = <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.getCurrentId">getCurrentId</a>();
                    stderr.print(<span class="tok-str">&quot;thread {} panic: &quot;</span>, .{current_thread_id}) <span class="tok-kw">catch</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();
                }
                stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{msg}) <span class="tok-kw">catch</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();

                <span class="tok-kw">if</span> (<span class="tok-builtin">@errorReturnTrace</span>()) |t| <a href="std.debug.html#std.debug.dumpStackTrace">dumpStackTrace</a>(t.*);
                <a href="std.debug.html#std.debug.dumpCurrentStackTrace">dumpCurrentStackTrace</a>(first_trace_addr <span class="tok-kw">orelse</span> <span class="tok-builtin">@returnAddress</span>());
            }

            <a href="std.debug.html#std.debug.waitForOtherThreadToFinishPanicking">waitForOtherThreadToFinishPanicking</a>();
        },
        <span class="tok-number">1</span> =&gt; {
            <a href="std.debug.html#std.debug.panic_stage">panic_stage</a> = <span class="tok-number">2</span>;<span class="tok-comment">

            // A panic happened while trying to print a previous panic message.
            // We're still holding the mutex but that's fine as we're going to
            // call abort().
            </span><a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writeAll(<span class="tok-str">&quot;aborting due to recursive panic\n&quot;</span>) <span class="tok-kw">catch</span> {};
        },
        <span class="tok-kw">else</span> =&gt; {},<span class="tok-comment"> // Panicked while printing the recursive panic message.
    </span>};

    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.writeStackTrace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeStackTrace</span><a href="#src.zig-std.debug.writeStackTrace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTrace</span>( stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>, out_stream: <span class="tok-kw">anytype</span>, debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>, ) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a></code></pre></div><div><pre><code>debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div><pre><code>tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.writeStackTrace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTrace</span>(
    stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>,
    out_stream: <span class="tok-kw">anytype</span>,
    debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>,
    tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
    <span class="tok-kw">var</span> frame_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> frames_left: <span class="tok-type">usize</span> = <span class="tok-builtin">@min</span>(stack_trace.index, stack_trace.instruction_addresses.len);

    <span class="tok-kw">while</span> (frames_left != <span class="tok-number">0</span>) : ({
        frames_left -= <span class="tok-number">1</span>;
        frame_index = (frame_index + <span class="tok-number">1</span>) % stack_trace.instruction_addresses.len;
    }) {
        <span class="tok-kw">const</span> return_address = stack_trace.instruction_addresses[frame_index];
        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, out_stream, return_address - <span class="tok-number">1</span>, tty_config);
    }

    <span class="tok-kw">if</span> (stack_trace.index &gt; stack_trace.instruction_addresses.len) {
        <span class="tok-kw">const</span> dropped_frames = stack_trace.index - stack_trace.instruction_addresses.len;

        tty_config.setColor(out_stream, .bold) <span class="tok-kw">catch</span> {};
        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;({d} additional stack frames skipped...)\n&quot;</span>, .{dropped_frames});
        tty_config.setColor(out_stream, .reset) <span class="tok-kw">catch</span> {};
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.writeCurrentStackTrace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeCurrentStackTrace</span><a href="#src.zig-std.debug.writeCurrentStackTrace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCurrentStackTrace</span>( out_stream: <span class="tok-kw">anytype</span>, debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>, start_addr: ?<span class="tok-type">usize</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div><pre><code>tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a></code></pre></div><div><pre><code>start_addr: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.writeCurrentStackTrace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCurrentStackTrace</span>(
    out_stream: <span class="tok-kw">anytype</span>,
    debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>,
    tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>,
    start_addr: ?<span class="tok-type">usize</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> context: <a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a> = <span class="tok-null">undefined</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.debug.html#std.debug.getContext">getContext</a>(&amp;context));
        <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.writeStackTraceWindows">writeStackTraceWindows</a>(out_stream, debug_info, tty_config, &amp;context, start_addr);
    }
    <span class="tok-kw">var</span> context: <a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> has_context = <a href="std.debug.html#std.debug.getContext">getContext</a>(&amp;context);

    <span class="tok-kw">var</span> it = (<span class="tok-kw">if</span> (has_context) blk: {
        <span class="tok-kw">break</span> :blk <a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.initWithContext">initWithContext</a>(start_addr, debug_info, &amp;context) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> <span class="tok-null">null</span>) <span class="tok-kw">orelse</span> <a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.init">init</a>(start_addr, <span class="tok-null">null</span>);
    <span class="tok-kw">defer</span> it.deinit();

    <span class="tok-kw">while</span> (it.next()) |return_address| {
        <a href="std.debug.html#std.debug.printLastUnwindError">printLastUnwindError</a>(&amp;it, debug_info, out_stream, tty_config);<span class="tok-comment">

        // On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,
        // therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid
        // an overflow. We do not need to signal `StackIterator` as it will correctly detect this
        // condition on the subsequent iteration and return `null` thus terminating the loop.
        // same behaviour for x86-windows-msvc
        </span><span class="tok-kw">const</span> address = return_address -| <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, out_stream, address, tty_config);
    } <span class="tok-kw">else</span> <a href="std.debug.html#std.debug.printLastUnwindError">printLastUnwindError</a>(&amp;it, debug_info, out_stream, tty_config);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.walkStackWindows" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">walkStackWindows</span><a href="#src.zig-std.debug.walkStackWindows">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">walkStackWindows</span>(addresses: []<span class="tok-type">usize</span>, existing_context: ?*<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>addresses: []<span class="tok-type">usize</span></code></pre></div><div><pre><code>existing_context: ?*<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.walkStackWindows">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">walkStackWindows</span>(addresses: []<span class="tok-type">usize</span>, existing_context: ?*<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a> == .x86) {<span class="tok-comment">
        // RtlVirtualUnwind doesn't exist on x86
        </span><span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlCaptureStackBackTrace">RtlCaptureStackBackTrace</a>(<span class="tok-number">0</span>, addresses.len, <span class="tok-builtin">@as</span>(**<span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(addresses.ptr)), <span class="tok-null">null</span>);
    }

    <span class="tok-kw">const</span> tib = &amp;<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.teb">teb</a>().NtTib;

    <span class="tok-kw">var</span> context: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (existing_context) |context_ptr| {
        context = context_ptr.*;
    } <span class="tok-kw">else</span> {
        context = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>);
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlCaptureContext">RtlCaptureContext</a>(&amp;context);
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> image_base: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD64">DWORD64</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> history_table: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.UNWIND_HISTORY_TABLE.html">UNWIND_HISTORY_TABLE</a> = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.UNWIND_HISTORY_TABLE.html">UNWIND_HISTORY_TABLE</a>);

    <span class="tok-kw">while</span> (i &lt; addresses.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> current_regs = context.getRegs();
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlLookupFunctionEntry">RtlLookupFunctionEntry</a>(current_regs.ip, &amp;image_base, &amp;history_table)) |runtime_function| {
            <span class="tok-kw">var</span> handler_data: ?*<span class="tok-type">anyopaque</span> = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> establisher_frame: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
            _ = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlVirtualUnwind">RtlVirtualUnwind</a>(
                <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UNW_FLAG_NHANDLER">UNW_FLAG_NHANDLER</a>,
                image_base,
                current_regs.ip,
                runtime_function,
                &amp;context,
                &amp;handler_data,
                &amp;establisher_frame,
                <span class="tok-null">null</span>,
            );
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // leaf function
            </span>context.setIp(<span class="tok-builtin">@as</span>(*<span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(current_regs.sp)).*);
            context.setSp(current_regs.sp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>));
        }

        <span class="tok-kw">const</span> next_regs = context.getRegs();
        <span class="tok-kw">if</span> (next_regs.sp &lt; <span class="tok-builtin">@intFromPtr</span>(tib.StackLimit) <span class="tok-kw">or</span> next_regs.sp &gt; <span class="tok-builtin">@intFromPtr</span>(tib.StackBase)) {
            <span class="tok-kw">break</span>;
        }

        <span class="tok-kw">if</span> (next_regs.ip == <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span>;
        }

        addresses[i] = next_regs.ip;
    }

    <span class="tok-kw">return</span> i;
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.writeStackTraceWindows" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeStackTraceWindows</span><a href="#src.zig-std.debug.writeStackTraceWindows">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTraceWindows</span>( out_stream: <span class="tok-kw">anytype</span>, debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>, context: *<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>, start_addr: ?<span class="tok-type">usize</span>, ) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div><pre><code>tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a></code></pre></div><div><pre><code>context: *<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a></code></pre></div><div><pre><code>start_addr: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.writeStackTraceWindows">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTraceWindows</span>(
    out_stream: <span class="tok-kw">anytype</span>,
    debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>,
    tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>,
    context: *<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>,
    start_addr: ?<span class="tok-type">usize</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> addr_buf: [<span class="tok-number">1024</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> n = <a href="std.debug.html#std.debug.walkStackWindows">walkStackWindows</a>(addr_buf[<span class="tok-number">0</span>..], context);
    <span class="tok-kw">const</span> addrs = addr_buf[<span class="tok-number">0</span>..n];
    <span class="tok-kw">const</span> start_i: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (start_addr) |saddr| blk: {
        <span class="tok-kw">for</span> (addrs, <span class="tok-number">0</span>..) |addr, i| {
            <span class="tok-kw">if</span> (addr == saddr) <span class="tok-kw">break</span> :blk i;
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (addrs[start_i..]) |addr| {
        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, out_stream, addr - <span class="tok-number">1</span>, tty_config);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.printSourceAtAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">printSourceAtAddress</span><a href="#src.zig-std.debug.printSourceAtAddress">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printSourceAtAddress</span>(debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a></code></pre></div><div><pre><code>address: <span class="tok-type">usize</span></code></pre></div><div><pre><code>tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.printSourceAtAddress">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printSourceAtAddress</span>(debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> module = debug_info.getModuleForAddress(address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.printUnknownSource">printUnknownSource</a>(debug_info, out_stream, address, tty_config),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };

    <span class="tok-kw">const</span> symbol_info = module.getSymbolAtAddress(debug_info.allocator, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.printUnknownSource">printUnknownSource</a>(debug_info, out_stream, address, tty_config),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (symbol_info.source_location) |sl| debug_info.allocator.free(sl.file_name);

    <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.printLineInfo">printLineInfo</a>(
        out_stream,
        symbol_info.source_location,
        address,
        symbol_info.name,
        symbol_info.compile_unit_name,
        tty_config,
        <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.maybeEnableSegfaultHandler" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">maybeEnableSegfaultHandler</span><a href="#src.zig-std.debug.maybeEnableSegfaultHandler">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">maybeEnableSegfaultHandler</span>() <span class="tok-type">void</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.maybeEnableSegfaultHandler">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">maybeEnableSegfaultHandler</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.enable_segfault_handler">enable_segfault_handler</a>) {
        <a href="std.debug.html#std.debug.attachSegfaultHandler">attachSegfaultHandler</a>();
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.updateSegfaultHandler" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">updateSegfaultHandler</span><a href="#src.zig-std.debug.updateSegfaultHandler">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateSegfaultHandler</span>(act: ?*<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>act: ?*<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.updateSegfaultHandler">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateSegfaultHandler</span>(act: ?*<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>) <span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">SEGV</a>, act, <span class="tok-null">null</span>);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ILL</a>, act, <span class="tok-null">null</span>);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">BUS</a>, act, <span class="tok-null">null</span>);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">FPE</a>, act, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.attachSegfaultHandler" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">attachSegfaultHandler</span><a href="#src.zig-std.debug.attachSegfaultHandler">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attachSegfaultHandler</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Attaches a global SIGSEGV handler which calls <code>@panic(&quot;segmentation fault&quot;);</code></p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.attachSegfaultHandler">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attachSegfaultHandler</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.have_segfault_handling_support">have_segfault_handling_support</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;segfault handler not supported for this target&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <a href="std.debug.html#std.debug.windows_segfault_handle">windows_segfault_handle</a> = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.AddVectoredExceptionHandler">AddVectoredExceptionHandler</a>(<span class="tok-number">0</span>, <a href="std.debug.html#std.debug.handleSegfaultWindows">handleSegfaultWindows</a>);
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">var</span> act = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>{
        .handler = .{ .sigaction = <a href="std.debug.html#std.debug.handleSegfaultPosix">handleSegfaultPosix</a> },
        .mask = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.empty_sigset">empty_sigset</a>,
        .flags = (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">SIGINFO</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">RESTART</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">RESETHAND</a>),
    };

    <a href="std.debug.html#std.debug.updateSegfaultHandler">updateSegfaultHandler</a>(&amp;act);
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.dumpStackPointerAddr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dumpStackPointerAddr</span><a href="#src.zig-std.debug.dumpStackPointerAddr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackPointerAddr</span>(prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.dumpStackPointerAddr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackPointerAddr</span>(prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> sp = <span class="tok-kw">asm</span> (<span class="tok-str">&quot;&quot;</span>
        : [argc] <span class="tok-str">&quot;={rsp}&quot;</span> (-&gt; <span class="tok-type">usize</span>),
    );
    <a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{s} sp = 0x{x}\n&quot;</span>, .{ prefix, sp });
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.inValgrind" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inValgrind</span><a href="#src.zig-std.debug.inValgrind">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">inValgrind</span>() <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Detect whether the program is being executed in the Valgrind virtual machine.</p>
<p>When Valgrind integrations are disabled, this returns comptime-known false.
Otherwise, the result is runtime-known.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.inValgrind">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">inValgrind</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@inComptime</span>()) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.valgrind_support">valgrind_support</a>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.valgrind.html">valgrind</a>.<a href="std.valgrind.html#std.valgrind.runningOnValgrind">runningOnValgrind</a>() &gt; <span class="tok-number">0</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.debug">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> io = <a href="std.html">std</a>.<a href="std.io.html">io</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> root = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);
<span class="tok-kw">const</span> File = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
<span class="tok-kw">const</span> native_arch = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>;
<span class="tok-kw">const</span> native_os = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
<span class="tok-kw">const</span> native_endian = <a href="std.debug.html#std.debug.native_arch">native_arch</a>.<a href="#">endian</a>();

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MemoryAccessor = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/MemoryAccessor.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FixedBufferReader = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/FixedBufferReader.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Dwarf = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/Dwarf.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Pdb = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/Pdb.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SelfInfo = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/SelfInfo.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Info = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/Info.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Coverage = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/Coverage.zig&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> simple_panic = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/simple_panic.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> no_panic = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;debug/no_panic.zig&quot;</span>);

<span class="tok-comment">/// A fully-featured panic handler namespace which lowers all panics to calls to `panicFn`.</span>
<span class="tok-comment">/// Safety panics will use formatted printing to provide a meaningful error message.</span>
<span class="tok-comment">/// The signature of `panicFn` should match that of `defaultPanic`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">FullPanic</span>(<span class="tok-kw">comptime</span> panicFn: <span class="tok-kw">fn</span> ([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ?<span class="tok-type">usize</span>) <span class="tok-type">noreturn</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> call = panicFn;
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sentinelMismatch</span>(expected: <span class="tok-kw">anytype</span>, found: <span class="tok-builtin">@TypeOf</span>(expected)) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;sentinel mismatch: expected {any}, found {any}&quot;</span>, .{
                expected, found,
            });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrapError</span>(err: <span class="tok-type">anyerror</span>) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;attempt to unwrap error: {s}&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">outOfBounds</span>(index: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;index out of bounds: index {d}, len {d}&quot;</span>, .{ index, len });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startGreaterThanEnd</span>(start: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;start index {d} is larger than end index {d}&quot;</span>, .{ start, end });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inactiveUnionField</span>(active: <span class="tok-kw">anytype</span>, accessed: <span class="tok-builtin">@TypeOf</span>(active)) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;access of union field '{s}' while field '{s}' is active&quot;</span>, .{
                <span class="tok-builtin">@tagName</span>(accessed), <span class="tok-builtin">@tagName</span>(active),
            });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceCastLenRemainder</span>(src_len: <span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), <span class="tok-str">&quot;slice length '{d}' does not divide exactly into destination elements&quot;</span>, .{src_len});
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reachedUnreachable</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;reached unreachable code&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrapNull</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;attempt to use null value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castToNull</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;cast causes pointer to be null&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">incorrectAlignment</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;incorrect alignment&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">invalidErrorCode</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;invalid error code&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castTruncatedData</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer cast truncated bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">negativeToUnsigned</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;attempt to cast negative value to unsigned integer&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">integerOverflow</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer overflow&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shlOverflow</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;left shift overflowed bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrOverflow</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;right shift overflowed bits&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">divideByZero</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;division by zero&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exactDivisionRemainder</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;exact division produced remainder&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">integerPartOutOfBounds</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;integer part of floating point value out of bounds&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">corruptSwitch</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;switch on corrupt value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftRhsTooBig</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;shift amount is greater than the type size&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">invalidEnumValue</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;invalid enum value&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forLenMismatch</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;for loop over objects with non-equal lengths&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memcpyLenMismatch</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;@memcpy arguments have non-equal lengths&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">memcpyAlias</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;@memcpy arguments alias&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noreturnReturned</span>() <span class="tok-type">noreturn</span> {
            <span class="tok-builtin">@branchHint</span>(.cold);
            <a href="std.debug.html#std.debug.FullPanic.call">call</a>(<span class="tok-str">&quot;'noreturn' function returned&quot;</span>, <span class="tok-builtin">@returnAddress</span>());
        }
    };
}

<span class="tok-comment">/// Unresolved source locations can be represented with a single `usize` that</span>
<span class="tok-comment">/// corresponds to a virtual memory address of the program counter. Combined</span>
<span class="tok-comment">/// with debug information, those values can be converted into a resolved</span>
<span class="tok-comment">/// source location, including file, line, and column.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SourceLocation = <span class="tok-kw">struct</span> {
    line: <span class="tok-type">u64</span>,
    column: <span class="tok-type">u64</span>,
    file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> invalid: <a href="std.debug.SourceLocation.html">SourceLocation</a> = .{
        .line = <span class="tok-number">0</span>,
        .column = <span class="tok-number">0</span>,
        .file_name = &amp;.{},
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Symbol = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;???&quot;</span>,
    compile_unit_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;???&quot;</span>,
    source_location: ?<a href="std.debug.SourceLocation.html">SourceLocation</a> = <span class="tok-null">null</span>,
};

<span class="tok-comment">/// Deprecated because it returns the optimization mode of the standard</span>
<span class="tok-comment">/// library, when the caller probably wants to use the optimization mode of</span>
<span class="tok-comment">/// their own module.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> runtime_safety = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a>) {
    .Debug, .ReleaseSafe =&gt; <span class="tok-null">true</span>,
    .ReleaseFast, .ReleaseSmall =&gt; <span class="tok-null">false</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> sys_can_stack_trace = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>) {<span class="tok-comment">
    // Observed to go into an infinite loop.
    // TODO: Make this work.
    </span>.mips,
    .mipsel,
    .mips64,
    .mips64el,
    .s390x,
    =&gt; <span class="tok-null">false</span>,<span class="tok-comment">

    // `@returnAddress()` in LLVM 10 gives
    // &quot;Non-Emscripten WebAssembly hasn't implemented __builtin_return_address&quot;.
    </span>.wasm32,
    .wasm64,
    =&gt; <a href="std.debug.html#std.debug.native_os">native_os</a> == .emscripten,<span class="tok-comment">

    // `@returnAddress()` is unsupported in LLVM 13.
    </span>.bpfel,
    .bpfeb,
    =&gt; <span class="tok-null">false</span>,

    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
};

<span class="tok-comment">/// Allows the caller to freely write to stderr until `unlockStdErr` is called.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// During the lock, any `std.Progress` information is cleared from the terminal.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockStdErr</span>() <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.html#std.Progress.lockStdErr">lockStdErr</a>();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockStdErr</span>() <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.Progress.html">Progress</a>.<a href="std.Progress.html#std.Progress.unlockStdErr">unlockStdErr</a>();
}

<span class="tok-comment">/// Print to stderr, unbuffered, and silently returning on failure. Intended</span>
<span class="tok-comment">/// for use in &quot;printf debugging.&quot; Use `std.log` functions for proper logging.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
    <span class="tok-kw">defer</span> <a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();
    <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
    <span class="tok-kw">nosuspend</span> stderr.print(fmt, args) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStderrMutex</span>() *<a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a> {
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated. call std.debug.lockStdErr() and std.debug.unlockStdErr() instead which will integrate properly with std.Progress&quot;</span>);
}

<span class="tok-comment">/// TODO multithreaded awareness</span>
<span class="tok-kw">var</span> self_debug_info: ?<a href="std.debug.SelfInfo.html">SelfInfo</a> = <span class="tok-null">null</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSelfDebugInfo</span>() !*<a href="std.debug.SelfInfo.html">SelfInfo</a> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.self_debug_info">self_debug_info</a>) |*info| {
        <span class="tok-kw">return</span> info;
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.self_debug_info">self_debug_info</a> = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.open">open</a>(<a href="std.debug.html#std.debug.getDebugInfoAllocator">getDebugInfoAllocator</a>());
        <span class="tok-kw">return</span> &amp;<a href="std.debug.html#std.debug.self_debug_info">self_debug_info</a>.?;
    }
}

<span class="tok-comment">/// Tries to print a hexadecimal view of the bytes, unbuffered, and ignores any error returned.</span>
<span class="tok-comment">/// Obtains the stderr mutex while dumping.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpHex</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
    <span class="tok-kw">defer</span> <a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();
    <a href="std.debug.html#std.debug.dumpHexFallible">dumpHexFallible</a>(bytes) <span class="tok-kw">catch</span> {};
}

<span class="tok-comment">/// Prints a hexadecimal view of the bytes, unbuffered, returning any error that occurs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpHexFallible</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> stderr = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>();
    <span class="tok-kw">const</span> ttyconf = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(stderr);
    <span class="tok-kw">const</span> writer = stderr.writer();
    <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.dumpHexInternal">dumpHexInternal</a>(bytes, ttyconf, writer);
}

<span class="tok-kw">fn</span> <span class="tok-fn">dumpHexInternal</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ttyconf: <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> chunks = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, bytes, <span class="tok-number">16</span>, <span class="tok-number">16</span>);
    <span class="tok-kw">while</span> (chunks.next()) |window| {<span class="tok-comment">
        // 1. Print the address.
        </span><span class="tok-kw">const</span> address = (<span class="tok-builtin">@intFromPtr</span>(bytes.ptr) + <span class="tok-number">0x10</span> * (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, chunks.index <span class="tok-kw">orelse</span> bytes.len, <span class="tok-number">16</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>)) - <span class="tok-number">0x10</span>;
        <span class="tok-kw">try</span> ttyconf.setColor(writer, .dim);<span class="tok-comment">
        // We print the address in lowercase and the bytes in uppercase hexadecimal to distinguish them more.
        // Also, make sure all lines are aligned by padding the address.
        </span><span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{x:0&gt;[1]}  &quot;</span>, .{ address, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span> });
        <span class="tok-kw">try</span> ttyconf.setColor(writer, .reset);<span class="tok-comment">

        // 2. Print the bytes.
        </span><span class="tok-kw">for</span> (window, <span class="tok-number">0</span>..) |byte, index| {
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{X:0&gt;2} &quot;</span>, .{byte});
            <span class="tok-kw">if</span> (index == <span class="tok-number">7</span>) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">' '</span>);
        }
        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">' '</span>);
        <span class="tok-kw">if</span> (window.len &lt; <span class="tok-number">16</span>) {
            <span class="tok-kw">var</span> missing_columns = (<span class="tok-number">16</span> - window.len) * <span class="tok-number">3</span>;
            <span class="tok-kw">if</span> (window.len &lt; <span class="tok-number">8</span>) missing_columns += <span class="tok-number">1</span>;
            <span class="tok-kw">try</span> writer.writeByteNTimes(<span class="tok-str">' '</span>, missing_columns);
        }<span class="tok-comment">

        // 3. Print the characters.
        </span><span class="tok-kw">for</span> (window) |byte| {
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.isPrint">isPrint</a>(byte)) {
                <span class="tok-kw">try</span> writer.writeByte(byte);
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Related: https://github.com/ziglang/zig/issues/7600
                </span><span class="tok-kw">if</span> (ttyconf == .windows_api) {
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'.'</span>);
                    <span class="tok-kw">continue</span>;
                }<span class="tok-comment">

                // Let's print some common control codes as graphical Unicode symbols.
                // We don't want to do this for all control codes because most control codes apart from
                // the ones that Zig has escape sequences for are likely not very useful to print as symbols.
                </span><span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;&quot;</span>),
                    <span class="tok-str">'\r'</span> =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;&quot;</span>),
                    <span class="tok-str">'\t'</span> =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;&quot;</span>),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'.'</span>),
                }
            }
        }
        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
    }
}

<span class="tok-kw">test</span> dumpHexInternal {
    <span class="tok-kw">const</span> bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{ <span class="tok-number">0x00</span>, <span class="tok-number">0x11</span>, <span class="tok-number">0x22</span>, <span class="tok-number">0x33</span>, <span class="tok-number">0x44</span>, <span class="tok-number">0x55</span>, <span class="tok-number">0x66</span>, <span class="tok-number">0x77</span>, <span class="tok-number">0x88</span>, <span class="tok-number">0x99</span>, <span class="tok-number">0xaa</span>, <span class="tok-number">0xbb</span>, <span class="tok-number">0xcc</span>, <span class="tok-number">0xdd</span>, <span class="tok-number">0xee</span>, <span class="tok-number">0xff</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x13</span> };
    <span class="tok-kw">var</span> output = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> output.deinit();
    <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.dumpHexInternal">dumpHexInternal</a>(bytes, .no_color, output.writer());
    <span class="tok-kw">const</span> expected = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
        <span class="tok-str">\\{x:0&gt;[2]}  00 11 22 33 44 55 66 77  88 99 AA BB CC DD EE FF  ..&quot;3DUfw........</span>
        <span class="tok-str">\\{x:0&gt;[2]}  01 12 13                                          ...</span>
        <span class="tok-str">\\</span>
    , .{
        <span class="tok-builtin">@intFromPtr</span>(bytes.ptr),
        <span class="tok-builtin">@intFromPtr</span>(bytes.ptr) + <span class="tok-number">16</span>,
        <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>,
    });
    <span class="tok-kw">defer</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(expected);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output.items);
}

<span class="tok-comment">/// Tries to print the current stack trace to stderr, unbuffered, and ignores any error returned.</span>
<span class="tok-comment">/// TODO multithreaded awareness</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpCurrentStackTrace</span>(start_addr: ?<span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
            <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .wasi) {
                <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
        <a href="std.debug.html#std.debug.writeCurrentStackTrace">writeCurrentStackTrace</a>(stderr, debug_info, <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>()), start_addr) <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_ucontext = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ucontext_t">ucontext_t</a> != <span class="tok-type">void</span>;

<span class="tok-comment">/// Platform-specific thread state. This contains register state, and on some platforms</span>
<span class="tok-comment">/// information about the stack. This is not safe to trivially copy, because some platforms</span>
<span class="tok-comment">/// use internal pointers within this structure. To make a copy, use `copyContext`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadContext = blk: {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <span class="tok-kw">break</span> :blk <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) {
        <span class="tok-kw">break</span> :blk <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ucontext_t">ucontext_t</a>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">break</span> :blk <span class="tok-type">void</span>;
    }
};

<span class="tok-comment">/// Copies one context to another, updating any internal pointers</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyContext</span>(source: *<span class="tok-kw">const</span> <a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>, dest: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) <span class="tok-kw">return</span> {};
    dest.* = source.*;
    <a href="std.debug.html#std.debug.relocateContext">relocateContext</a>(dest);
}

<span class="tok-comment">/// Updates any internal pointers in the context to reflect its current location</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">relocateContext</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.native_os">native_os</a>) {
        .macos =&gt; {
            context.mcontext = &amp;context.__mcontext_data;
        },
        <span class="tok-kw">else</span> =&gt; {},
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_getcontext = <span class="tok-builtin">@TypeOf</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getcontext</a>) != <span class="tok-type">void</span>;

<span class="tok-comment">/// Capture the current context. The register values in the context will reflect the</span>
<span class="tok-comment">/// state after the platform `getcontext` function returns.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// It is valid to call this if the platform doesn't have context capturing support,</span>
<span class="tok-comment">/// in that case false will be returned.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        context.* = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>);
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlCaptureContext">RtlCaptureContext</a>(context);
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-kw">const</span> result = <a href="std.debug.html#std.debug.have_getcontext">have_getcontext</a> <span class="tok-kw">and</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.system">system</a>.<a href="#">getcontext</a>(context) == <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .macos) {
        <a href="std.debug.html#std.debug.assert">assert</a>(context.mcsize == <span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.mcontext_t">mcontext_t</a>));<span class="tok-comment">

        // On aarch64-macos, the system getcontext doesn't write anything into the pc
        // register slot, it only writes lr. This makes the context consistent with
        // other aarch64 getcontext implementations which write the current lr
        // (where getcontext will return to) into both the lr and pc slot of the context.
        </span><span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a> == .aarch64) context.mcontext.ss.pc = context.mcontext.ss.lr;
    }

    <span class="tok-kw">return</span> result;
}

<span class="tok-comment">/// Tries to print the stack trace starting from the supplied base pointer to stderr,</span>
<span class="tok-comment">/// unbuffered, and ignores any error returned.</span>
<span class="tok-comment">/// TODO multithreaded awareness</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTraceFromBase</span>(context: *<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
            <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .wasi) {
                <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
        <span class="tok-kw">const</span> tty_config = <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>());
        <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {<span class="tok-comment">
            // On x86_64 and aarch64, the stack will be unwound using RtlVirtualUnwind using the context
            // provided by the exception handler. On x86, RtlVirtualUnwind doesn't exist. Instead, a new backtrace
            // will be captured and frames prior to the exception will be filtered.
            // The caveat is that RtlCaptureStackBackTrace does not include the KiUserExceptionDispatcher frame,
            // which is where the IP in `context` points to, so it can't be used as start_addr.
            // Instead, start_addr is recovered from the stack.
            </span><span class="tok-kw">const</span> start_addr = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a> == .x86) <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(context.getRegs().bp + <span class="tok-number">4</span>)).* <span class="tok-kw">else</span> <span class="tok-null">null</span>;
            <a href="std.debug.html#std.debug.writeStackTraceWindows">writeStackTraceWindows</a>(stderr, debug_info, tty_config, context, start_addr) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">var</span> it = <a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.initWithContext">initWithContext</a>(<span class="tok-null">null</span>, debug_info, context) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
        <span class="tok-kw">defer</span> it.deinit();<span class="tok-comment">

        // DWARF unwinding on aarch64-macos is not complete so we need to get pc address from mcontext
        </span><span class="tok-kw">const</span> pc_addr = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>() <span class="tok-kw">and</span> <a href="std.debug.html#std.debug.native_arch">native_arch</a> == .aarch64)
            context.mcontext.ss.pc
        <span class="tok-kw">else</span>
            it.unwind_state.?.dwarf_context.pc;
        <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, stderr, pc_addr, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;

        <span class="tok-kw">while</span> (it.next()) |return_address| {
            <a href="std.debug.html#std.debug.printLastUnwindError">printLastUnwindError</a>(&amp;it, debug_info, stderr, tty_config);<span class="tok-comment">

            // On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,
            // therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid
            // an overflow. We do not need to signal `StackIterator` as it will correctly detect this
            // condition on the subsequent iteration and return `null` thus terminating the loop.
            // same behaviour for x86-windows-msvc
            </span><span class="tok-kw">const</span> address = <span class="tok-kw">if</span> (return_address == <span class="tok-number">0</span>) return_address <span class="tok-kw">else</span> return_address - <span class="tok-number">1</span>;
            <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, stderr, address, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
        } <span class="tok-kw">else</span> <a href="std.debug.html#std.debug.printLastUnwindError">printLastUnwindError</a>(&amp;it, debug_info, stderr, tty_config);
    }
}

<span class="tok-comment">/// Returns a slice with the same pointer as addresses, with a potentially smaller len.</span>
<span class="tok-comment">/// On Windows, when first_address is not null, we ask for at least 32 stack frames,</span>
<span class="tok-comment">/// and then try to find the first address. If addresses.len is more than 32, we</span>
<span class="tok-comment">/// capture that many stack frames exactly, and then look for the first address,</span>
<span class="tok-comment">/// chopping off the irrelevant frames and shifting so that the returned addresses pointer</span>
<span class="tok-comment">/// equals the passed in addresses pointer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">captureStackTrace</span>(first_address: ?<span class="tok-type">usize</span>, stack_trace: *<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> addrs = stack_trace.instruction_addresses;
        <span class="tok-kw">const</span> first_addr = first_address <span class="tok-kw">orelse</span> {
            stack_trace.index = <a href="std.debug.html#std.debug.walkStackWindows">walkStackWindows</a>(addrs[<span class="tok-number">0</span>..], <span class="tok-null">null</span>);
            <span class="tok-kw">return</span>;
        };
        <span class="tok-kw">var</span> addr_buf_stack: [<span class="tok-number">32</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> addr_buf = <span class="tok-kw">if</span> (addr_buf_stack.len &gt; addrs.len) addr_buf_stack[<span class="tok-number">0</span>..] <span class="tok-kw">else</span> addrs;
        <span class="tok-kw">const</span> n = <a href="std.debug.html#std.debug.walkStackWindows">walkStackWindows</a>(addr_buf[<span class="tok-number">0</span>..], <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> first_index = <span class="tok-kw">for</span> (addr_buf[<span class="tok-number">0</span>..n], <span class="tok-number">0</span>..) |addr, i| {
            <span class="tok-kw">if</span> (addr == first_addr) {
                <span class="tok-kw">break</span> i;
            }
        } <span class="tok-kw">else</span> {
            stack_trace.index = <span class="tok-number">0</span>;
            <span class="tok-kw">return</span>;
        };
        <span class="tok-kw">const</span> end_index = <span class="tok-builtin">@min</span>(first_index + addrs.len, n);
        <span class="tok-kw">const</span> slice = addr_buf[first_index..end_index];<span class="tok-comment">
        // We use a for loop here because slice and addrs may alias.
        </span><span class="tok-kw">for</span> (slice, <span class="tok-number">0</span>..) |addr, i| {
            addrs[i] = addr;
        }
        stack_trace.index = slice.len;
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // TODO: This should use the DWARF unwinder if .eh_frame_hdr is available (so that full debug info parsing isn't required).
        //       A new path for loading SelfInfo needs to be created which will only attempt to parse in-memory sections, because
        //       stopping to load other debug info (ie. source line info) from disk here is not required for unwinding.
        </span><span class="tok-kw">var</span> it = <a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.init">init</a>(first_address, <span class="tok-null">null</span>);
        <span class="tok-kw">defer</span> it.deinit();
        <span class="tok-kw">for</span> (stack_trace.instruction_addresses, <span class="tok-number">0</span>..) |*addr, i| {
            addr.* = it.next() <span class="tok-kw">orelse</span> {
                stack_trace.index = i;
                <span class="tok-kw">return</span>;
            };
        }
        stack_trace.index = stack_trace.instruction_addresses.len;
    }
}

<span class="tok-comment">/// Tries to print a stack trace to stderr, unbuffered, and ignores any error returned.</span>
<span class="tok-comment">/// TODO multithreaded awareness</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackTrace</span>(stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">isWasm</a>()) {
            <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .wasi) {
                <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
                stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: not implemented for Wasm\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: debug info stripped\n&quot;</span>, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
        <a href="std.debug.html#std.debug.writeStackTrace">writeStackTrace</a>(stack_trace, stderr, debug_info, <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>())) <span class="tok-kw">catch</span> |err| {
            stderr.print(<span class="tok-str">&quot;Unable to dump stack trace: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            <span class="tok-kw">return</span>;
        };
    }
}

<span class="tok-comment">/// Invokes detectable illegal behavior when `ok` is `false`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// In Debug and ReleaseSafe modes, calls to this function are always</span>
<span class="tok-comment">/// generated, and the `unreachable` statement triggers a panic.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// In ReleaseFast and ReleaseSmall modes, calls to this function are optimized</span>
<span class="tok-comment">/// away, and in fact the optimizer is able to use the assertion in its</span>
<span class="tok-comment">/// heuristics.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Inside a test block, it is best to use the `std.testing` module rather than</span>
<span class="tok-comment">/// this function, because this function may not detect a test failure in</span>
<span class="tok-comment">/// ReleaseFast and ReleaseSmall mode. Outside of a test block, this assert</span>
<span class="tok-comment">/// function is the correct function to use.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>;<span class="tok-comment"> // assertion failure
</span>}

<span class="tok-comment">/// Invokes detectable illegal behavior when the provided slice is not mapped</span>
<span class="tok-comment">/// or lacks read permissions.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assertReadable</span>(slice: []<span class="tok-kw">const</span> <span class="tok-kw">volatile</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <span class="tok-kw">return</span>;
    <span class="tok-kw">for</span> (slice) |*byte| _ = byte.*;
}

<span class="tok-comment">/// Equivalent to `@panic` but with a formatted message.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panic</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <a href="std.debug.html#std.debug.panicExtra">panicExtra</a>(<span class="tok-builtin">@returnAddress</span>(), format, args);
}

<span class="tok-comment">/// Equivalent to `@panic` but with a formatted message, and with an explicitly</span>
<span class="tok-comment">/// provided return address.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">panicExtra</span>(
    ret_addr: ?<span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);

    <span class="tok-kw">const</span> size = <span class="tok-number">0x1000</span>;
    <span class="tok-kw">const</span> trunc_msg = <span class="tok-str">&quot;(msg truncated)&quot;</span>;
    <span class="tok-kw">var</span> buf: [size + trunc_msg.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // a minor annoyance with this is that it will result in the NoSpaceLeft
    // error being part of the @panic stack trace (but that error should
    // only happen rarely)
    </span><span class="tok-kw">const</span> msg = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(buf[<span class="tok-number">0</span>..size], format, args) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; blk: {
            <span class="tok-builtin">@memcpy</span>(buf[size..], trunc_msg);
            <span class="tok-kw">break</span> :blk &amp;buf;
        },
    };
    <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.html#std.builtin.panic">panic</a>.<a href="#">call</a>(msg, ret_addr);
}

<span class="tok-comment">/// Non-zero whenever the program triggered a panic.</span>
<span class="tok-comment">/// The counter is incremented/decremented atomically.</span>
<span class="tok-kw">var</span> panicking = <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.Value">Value</a>(<span class="tok-type">u8</span>).init(<span class="tok-number">0</span>);

<span class="tok-comment">/// Counts how many times the panic handler is invoked by this thread.</span>
<span class="tok-comment">/// This is used to catch and handle panics triggered by the panic handler.</span>
<span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> panic_stage: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

<span class="tok-comment">/// Dumps a stack trace to standard error, then aborts.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">defaultPanic</span>(
    msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    first_trace_addr: ?<span class="tok-type">usize</span>,
) <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);<span class="tok-comment">

    // For backends that cannot handle the language features depended on by the
    // default panic handler, we have a simpler panic handler:
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_wasm <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_arm <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_aarch64 <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86 <span class="tok-kw">or</span>
        (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_x86_64 <span class="tok-kw">and</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">ofmt</a> != .elf <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">ofmt</a> != .macho)) <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_sparc64 <span class="tok-kw">or</span>
        <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_spirv64)
    {
        <span class="tok-builtin">@trap</span>();
    }

    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .freestanding, .other =&gt; {
            <span class="tok-builtin">@trap</span>();
        },
        .uefi =&gt; {
            <span class="tok-kw">const</span> uefi = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.uefi.html">uefi</a>;

            <span class="tok-kw">var</span> utf16_buffer: [<span class="tok-number">1000</span>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> len_minus_3 = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16Le">utf8ToUtf16Le</a>(&amp;utf16_buffer, msg) <span class="tok-kw">catch</span> <span class="tok-number">0</span>;
            utf16_buffer[len_minus_3..][<span class="tok-number">0</span>..<span class="tok-number">3</span>].* = .{ <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span>, <span class="tok-number">0</span> };
            <span class="tok-kw">const</span> len = len_minus_3 + <span class="tok-number">3</span>;
            <span class="tok-kw">const</span> exit_msg = utf16_buffer[<span class="tok-number">0</span> .. len - <span class="tok-number">1</span> :<span class="tok-number">0</span>];<span class="tok-comment">

            // Output to both std_err and con_out, as std_err is easier
            // to read in stuff like QEMU at times, but, unlike con_out,
            // isn't visible on actual hardware if directly booted into
            </span><span class="tok-kw">inline</span> <span class="tok-kw">for</span> ([_]?*uefi.protocol.SimpleTextOutput{ uefi.system_table.std_err, uefi.system_table.con_out }) |o| {
                <span class="tok-kw">if</span> (o) |out| {
                    _ = out.setAttribute(uefi.protocol.SimpleTextOutput.red);
                    _ = out.outputString(exit_msg);
                    _ = out.setAttribute(uefi.protocol.SimpleTextOutput.white);
                }
            }

            <span class="tok-kw">if</span> (uefi.system_table.boot_services) |bs| {<span class="tok-comment">
                // ExitData buffer must be allocated using boot_services.allocatePool (spec: page 220)
                </span><span class="tok-kw">const</span> exit_data: []<span class="tok-type">u16</span> = uefi.raw_pool_allocator.alloc(<span class="tok-type">u16</span>, exit_msg.len + <span class="tok-number">1</span>) <span class="tok-kw">catch</span> <span class="tok-builtin">@trap</span>();
                <span class="tok-builtin">@memcpy</span>(exit_data, exit_msg[<span class="tok-number">0</span>..exit_data.len]);<span class="tok-comment"> // Includes null terminator.
                </span>_ = bs.exit(uefi.handle, .aborted, exit_data.len, exit_data.ptr);
            }
            <span class="tok-builtin">@trap</span>();
        },
        .cuda, .amdhsa =&gt; <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>(),
        .plan9 =&gt; {
            <span class="tok-kw">var</span> status: [<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.plan9.html">plan9</a>.<a href="std.os.plan9.html#std.os.plan9.ERRMAX">ERRMAX</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> len = <span class="tok-builtin">@min</span>(msg.len, status.len - <span class="tok-number">1</span>);
            <span class="tok-builtin">@memcpy</span>(status[<span class="tok-number">0</span>..len], msg[<span class="tok-number">0</span>..len]);
            status[len] = <span class="tok-number">0</span>;
            <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.plan9.html">plan9</a>.<a href="std.os.plan9.html#std.os.plan9.exits">exits</a>(status[<span class="tok-number">0</span>..len :<span class="tok-number">0</span>]);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.enable_segfault_handler">enable_segfault_handler</a>) {<span class="tok-comment">
        // If a segfault happens while panicking, we want it to actually segfault, not trigger
        // the handler.
        </span><a href="std.debug.html#std.debug.resetSegfaultHandler">resetSegfaultHandler</a>();
    }<span class="tok-comment">

    // Note there is similar logic in handleSegfaultPosix and handleSegfaultWindowsExtra.
    </span><span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.panic_stage">panic_stage</a>) {
        <span class="tok-number">0</span> =&gt; {
            <a href="std.debug.html#std.debug.panic_stage">panic_stage</a> = <span class="tok-number">1</span>;

            _ = <a href="std.debug.html#std.debug.panicking">panicking</a>.<a href="#">fetchAdd</a>(<span class="tok-number">1</span>, .seq_cst);

            {
                <a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
                <span class="tok-kw">defer</span> <a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();

                <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
                <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
                    stderr.print(<span class="tok-str">&quot;panic: &quot;</span>, .{}) <span class="tok-kw">catch</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">const</span> current_thread_id = <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.html#std.Thread.getCurrentId">getCurrentId</a>();
                    stderr.print(<span class="tok-str">&quot;thread {} panic: &quot;</span>, .{current_thread_id}) <span class="tok-kw">catch</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();
                }
                stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{msg}) <span class="tok-kw">catch</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();

                <span class="tok-kw">if</span> (<span class="tok-builtin">@errorReturnTrace</span>()) |t| <a href="std.debug.html#std.debug.dumpStackTrace">dumpStackTrace</a>(t.*);
                <a href="std.debug.html#std.debug.dumpCurrentStackTrace">dumpCurrentStackTrace</a>(first_trace_addr <span class="tok-kw">orelse</span> <span class="tok-builtin">@returnAddress</span>());
            }

            <a href="std.debug.html#std.debug.waitForOtherThreadToFinishPanicking">waitForOtherThreadToFinishPanicking</a>();
        },
        <span class="tok-number">1</span> =&gt; {
            <a href="std.debug.html#std.debug.panic_stage">panic_stage</a> = <span class="tok-number">2</span>;<span class="tok-comment">

            // A panic happened while trying to print a previous panic message.
            // We're still holding the mutex but that's fine as we're going to
            // call abort().
            </span><a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writeAll(<span class="tok-str">&quot;aborting due to recursive panic\n&quot;</span>) <span class="tok-kw">catch</span> {};
        },
        <span class="tok-kw">else</span> =&gt; {},<span class="tok-comment"> // Panicked while printing the recursive panic message.
    </span>};

    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();
}

<span class="tok-comment">/// Must be called only after adding 1 to `panicking`. There are three callsites.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">waitForOtherThreadToFinishPanicking</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.panicking">panicking</a>.<a href="#">fetchSub</a>(<span class="tok-number">1</span>, .seq_cst) != <span class="tok-number">1</span>) {<span class="tok-comment">
        // Another thread is panicking, wait for the last one to finish
        // and call abort()
        </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) <span class="tok-kw">unreachable</span>;<span class="tok-comment">

        // Sleep forever without hammering the CPU
        </span><span class="tok-kw">var</span> futex = <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.Value">Value</a>(<span class="tok-type">u32</span>).init(<span class="tok-number">0</span>);
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Futex.html">Futex</a>.<a href="std.Thread.Futex.html#std.Thread.Futex.wait">wait</a>(&amp;futex, <span class="tok-number">0</span>);
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTrace</span>(
    stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a>,
    out_stream: <span class="tok-kw">anytype</span>,
    debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>,
    tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
    <span class="tok-kw">var</span> frame_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> frames_left: <span class="tok-type">usize</span> = <span class="tok-builtin">@min</span>(stack_trace.index, stack_trace.instruction_addresses.len);

    <span class="tok-kw">while</span> (frames_left != <span class="tok-number">0</span>) : ({
        frames_left -= <span class="tok-number">1</span>;
        frame_index = (frame_index + <span class="tok-number">1</span>) % stack_trace.instruction_addresses.len;
    }) {
        <span class="tok-kw">const</span> return_address = stack_trace.instruction_addresses[frame_index];
        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, out_stream, return_address - <span class="tok-number">1</span>, tty_config);
    }

    <span class="tok-kw">if</span> (stack_trace.index &gt; stack_trace.instruction_addresses.len) {
        <span class="tok-kw">const</span> dropped_frames = stack_trace.index - stack_trace.instruction_addresses.len;

        tty_config.setColor(out_stream, .bold) <span class="tok-kw">catch</span> {};
        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;({d} additional stack frames skipped...)\n&quot;</span>, .{dropped_frames});
        tty_config.setColor(out_stream, .reset) <span class="tok-kw">catch</span> {};
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnwindError = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>)
    <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(<a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.next_unwind">next_unwind</a>)).@&quot;fn&quot;.return_type.?).error_union.error_set
<span class="tok-kw">else</span>
    <span class="tok-type">void</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackIterator = <span class="tok-kw">struct</span> {<span class="tok-comment">
    // Skip every frame before this address is found.
    </span>first_address: ?<span class="tok-type">usize</span>,<span class="tok-comment">
    // Last known value of the frame pointer register.
    </span>fp: <span class="tok-type">usize</span>,
    ma: <a href="std.debug.MemoryAccessor.html">MemoryAccessor</a> = <a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>.<a href="std.debug.MemoryAccessor.html#std.debug.MemoryAccessor.init">init</a>,<span class="tok-comment">

    // When SelfInfo and a register context is available, this iterator can unwind
    // stacks with frames that don't use a frame pointer (ie. -fomit-frame-pointer),
    // using DWARF and MachO unwind info.
    </span>unwind_state: <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) ?<span class="tok-kw">struct</span> {
        debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>,
        dwarf_context: <a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>,
        last_error: ?<a href="std.debug.html#std.debug.UnwindError">UnwindError</a> = <span class="tok-null">null</span>,
        failed: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    } <span class="tok-kw">else</span> <span class="tok-type">void</span> = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) <span class="tok-null">null</span> <span class="tok-kw">else</span> {},

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(first_address: ?<span class="tok-type">usize</span>, fp: ?<span class="tok-type">usize</span>) <a href="std.debug.StackIterator.html">StackIterator</a> {
        <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a>.<a href="#">isSPARC</a>()) {<span class="tok-comment">
            // Flush all the register windows on stack.
            </span><span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.sparc.html">sparc</a>.<a href="std.Target.sparc.html#std.Target.sparc.featureSetHas">featureSetHas</a>(<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">features</a>, .v9))
                    <span class="tok-str">&quot;flushw&quot;</span>
                <span class="tok-kw">else</span>
                    <span class="tok-str">&quot;ta 3&quot;</span><span class="tok-comment"> // ST_FLUSH_WINDOWS
                </span>::: <span class="tok-str">&quot;memory&quot;</span>);
        }

        <span class="tok-kw">return</span> <a href="std.debug.StackIterator.html">StackIterator</a>{
            .first_address = first_address,<span class="tok-comment">
            // TODO: this is a workaround for #16876
            //.fp = fp orelse @frameAddress(),
            </span>.fp = fp <span class="tok-kw">orelse</span> blk: {
                <span class="tok-kw">const</span> fa = <span class="tok-builtin">@frameAddress</span>();
                <span class="tok-kw">break</span> :blk fa;
            },
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithContext</span>(first_address: ?<span class="tok-type">usize</span>, debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, context: *<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ucontext_t">ucontext_t</a>) !<a href="std.debug.StackIterator.html">StackIterator</a> {<span class="tok-comment">
        // The implementation of DWARF unwinding on aarch64-macos is not complete. However, Apple mandates that
        // the frame pointer register is always used, so on this platform we can safely use the FP-based unwinder.
        </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>() <span class="tok-kw">and</span> <a href="std.debug.html#std.debug.native_arch">native_arch</a> == .aarch64)
            <span class="tok-kw">return</span> <a href="std.debug.StackIterator.html#std.debug.StackIterator.init">init</a>(first_address, <span class="tok-builtin">@truncate</span>(context.mcontext.ss.fp));

        <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.supports_unwinding">supports_unwinding</a>) {
            <span class="tok-kw">var</span> iterator = <a href="std.debug.StackIterator.html#std.debug.StackIterator.init">init</a>(first_address, <span class="tok-null">null</span>);
            iterator.unwind_state = .{
                .debug_info = debug_info,
                .dwarf_context = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.UnwindContext.html">UnwindContext</a>.<a href="std.debug.SelfInfo.UnwindContext.html#std.debug.SelfInfo.UnwindContext.init">init</a>(debug_info.allocator, context),
            };
            <span class="tok-kw">return</span> iterator;
        }

        <span class="tok-kw">return</span> <a href="std.debug.StackIterator.html#std.debug.StackIterator.init">init</a>(first_address, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(it: *<a href="std.debug.StackIterator.html">StackIterator</a>) <span class="tok-type">void</span> {
        it.ma.deinit();
        <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a> <span class="tok-kw">and</span> it.unwind_state != <span class="tok-null">null</span>) it.unwind_state.?.dwarf_context.deinit();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLastError</span>(it: *<a href="std.debug.StackIterator.html">StackIterator</a>) ?<span class="tok-kw">struct</span> {
        err: <a href="std.debug.html#std.debug.UnwindError">UnwindError</a>,
        address: <span class="tok-type">usize</span>,
    } {
        <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">if</span> (it.unwind_state) |*unwind_state| {
            <span class="tok-kw">if</span> (unwind_state.last_error) |err| {
                unwind_state.last_error = <span class="tok-null">null</span>;
                <span class="tok-kw">return</span> .{
                    .err = err,
                    .address = unwind_state.dwarf_context.pc,
                };
            }
        }

        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }<span class="tok-comment">

    // Offset of the saved BP wrt the frame pointer.
    </span><span class="tok-kw">const</span> fp_offset = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a>.<a href="#">isRISCV</a>())<span class="tok-comment">
        // On RISC-V the frame pointer points to the top of the saved register
        // area, on pretty much every other architecture it points to the stack
        // slot where the previous frame pointer is saved.
        </span><span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a>.<a href="#">isSPARC</a>())<span class="tok-comment">
        // On SPARC the previous frame pointer is stored at 14 slots past %fp+BIAS.
        </span><span class="tok-number">14</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;

    <span class="tok-kw">const</span> fp_bias = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a>.<a href="#">isSPARC</a>())<span class="tok-comment">
        // On SPARC frame pointers are biased by a constant.
        </span><span class="tok-number">2047</span>
    <span class="tok-kw">else</span>
        <span class="tok-number">0</span>;<span class="tok-comment">

    // Positive offset of the saved PC wrt the frame pointer.
    </span><span class="tok-kw">const</span> pc_offset = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a> == .powerpc64le)
        <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)
    <span class="tok-kw">else</span>
        <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.debug.StackIterator.html">StackIterator</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">var</span> address = it.next_internal() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;

        <span class="tok-kw">if</span> (it.first_address) |first_address| {
            <span class="tok-kw">while</span> (address != first_address) {
                address = it.next_internal() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }
            it.first_address = <span class="tok-null">null</span>;
        }

        <span class="tok-kw">return</span> address;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">next_unwind</span>(it: *<a href="std.debug.StackIterator.html">StackIterator</a>) !<span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> unwind_state = &amp;it.unwind_state.?;
        <span class="tok-kw">const</span> module = <span class="tok-kw">try</span> unwind_state.debug_info.getModuleForAddress(unwind_state.dwarf_context.pc);
        <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.native_os">native_os</a>) {
            .macos, .ios, .watchos, .tvos, .visionos =&gt; {<span class="tok-comment">
                // __unwind_info is a requirement for unwinding on Darwin. It may fall back to DWARF, but unwinding
                // via DWARF before attempting to use the compact unwind info will produce incorrect results.
                </span><span class="tok-kw">if</span> (module.unwind_info) |unwind_info| {
                    <span class="tok-kw">if</span> (<a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.unwindFrameMachO">unwindFrameMachO</a>(
                        unwind_state.debug_info.allocator,
                        module.base_address,
                        &amp;unwind_state.dwarf_context,
                        &amp;it.ma,
                        unwind_info,
                        module.eh_frame,
                    )) |return_address| {
                        <span class="tok-kw">return</span> return_address;
                    } <span class="tok-kw">else</span> |err| {
                        <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.RequiresDWARFUnwind) <span class="tok-kw">return</span> err;
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;
            },
            <span class="tok-kw">else</span> =&gt; {},
        }

        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> module.getDwarfInfoForAddress(unwind_state.debug_info.allocator, unwind_state.dwarf_context.pc)) |di| {
            <span class="tok-kw">return</span> <a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.unwindFrameDwarf">unwindFrameDwarf</a>(
                unwind_state.debug_info.allocator,
                di,
                module.base_address,
                &amp;unwind_state.dwarf_context,
                &amp;it.ma,
                <span class="tok-null">null</span>,
            );
        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">next_internal</span>(it: *<a href="std.debug.StackIterator.html">StackIterator</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) {
            <span class="tok-kw">if</span> (it.unwind_state) |*unwind_state| {
                <span class="tok-kw">if</span> (!unwind_state.failed) {
                    <span class="tok-kw">if</span> (unwind_state.dwarf_context.pc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                    <span class="tok-kw">defer</span> it.fp = unwind_state.dwarf_context.getFp() <span class="tok-kw">catch</span> <span class="tok-number">0</span>;
                    <span class="tok-kw">if</span> (it.next_unwind()) |return_address| {
                        <span class="tok-kw">return</span> return_address;
                    } <span class="tok-kw">else</span> |err| {
                        unwind_state.last_error = err;
                        unwind_state.failed = <span class="tok-null">true</span>;<span class="tok-comment">

                        // Fall back to fp-based unwinding on the first failure.
                        // We can't attempt it again for other modules higher in the
                        // stack because the full register state won't have been unwound.
                    </span>}
                }
            }
        }

        <span class="tok-kw">const</span> fp = <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.native_arch">native_arch</a>.<a href="#">isSPARC</a>())<span class="tok-comment">
            // On SPARC the offset is positive. (!)
            </span><a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">usize</span>, it.fp, <a href="std.debug.StackIterator.html#std.debug.StackIterator.fp_offset">fp_offset</a>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>
        <span class="tok-kw">else</span>
            <a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">usize</span>, it.fp, <a href="std.debug.StackIterator.html#std.debug.StackIterator.fp_offset">fp_offset</a>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">

        // Sanity check.
        </span><span class="tok-kw">if</span> (fp == <span class="tok-number">0</span> <span class="tok-kw">or</span> !<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.isAligned">isAligned</a>(fp, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">usize</span>))) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> new_fp = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">usize</span>, it.ma.load(<span class="tok-type">usize</span>, fp) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>, <a href="std.debug.StackIterator.html#std.debug.StackIterator.fp_bias">fp_bias</a>) <span class="tok-kw">catch</span>
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">

        // Sanity check: the stack grows down thus all the parent frames must be
        // be at addresses that are greater (or equal) than the previous one.
        // A zero frame pointer often signals this is the last frame, that case
        // is gracefully handled by the next call to next_internal.
        </span><span class="tok-kw">if</span> (new_fp != <span class="tok-number">0</span> <span class="tok-kw">and</span> new_fp &lt; it.fp) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> new_pc = it.ma.load(<span class="tok-type">usize</span>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">usize</span>, fp, <a href="std.debug.StackIterator.html#std.debug.StackIterator.pc_offset">pc_offset</a>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>) <span class="tok-kw">orelse</span>
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;

        it.fp = new_fp;

        <span class="tok-kw">return</span> new_pc;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCurrentStackTrace</span>(
    out_stream: <span class="tok-kw">anytype</span>,
    debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>,
    tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>,
    start_addr: ?<span class="tok-type">usize</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> context: <a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a> = <span class="tok-null">undefined</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.debug.html#std.debug.getContext">getContext</a>(&amp;context));
        <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.writeStackTraceWindows">writeStackTraceWindows</a>(out_stream, debug_info, tty_config, &amp;context, start_addr);
    }
    <span class="tok-kw">var</span> context: <a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> has_context = <a href="std.debug.html#std.debug.getContext">getContext</a>(&amp;context);

    <span class="tok-kw">var</span> it = (<span class="tok-kw">if</span> (has_context) blk: {
        <span class="tok-kw">break</span> :blk <a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.initWithContext">initWithContext</a>(start_addr, debug_info, &amp;context) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> <span class="tok-null">null</span>) <span class="tok-kw">orelse</span> <a href="std.debug.StackIterator.html">StackIterator</a>.<a href="std.debug.StackIterator.html#std.debug.StackIterator.init">init</a>(start_addr, <span class="tok-null">null</span>);
    <span class="tok-kw">defer</span> it.deinit();

    <span class="tok-kw">while</span> (it.next()) |return_address| {
        <a href="std.debug.html#std.debug.printLastUnwindError">printLastUnwindError</a>(&amp;it, debug_info, out_stream, tty_config);<span class="tok-comment">

        // On arm64 macOS, the address of the last frame is 0x0 rather than 0x1 as on x86_64 macOS,
        // therefore, we do a check for `return_address == 0` before subtracting 1 from it to avoid
        // an overflow. We do not need to signal `StackIterator` as it will correctly detect this
        // condition on the subsequent iteration and return `null` thus terminating the loop.
        // same behaviour for x86-windows-msvc
        </span><span class="tok-kw">const</span> address = return_address -| <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, out_stream, address, tty_config);
    } <span class="tok-kw">else</span> <a href="std.debug.html#std.debug.printLastUnwindError">printLastUnwindError</a>(&amp;it, debug_info, out_stream, tty_config);
}

<span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">walkStackWindows</span>(addresses: []<span class="tok-type">usize</span>, existing_context: ?*<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a> == .x86) {<span class="tok-comment">
        // RtlVirtualUnwind doesn't exist on x86
        </span><span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlCaptureStackBackTrace">RtlCaptureStackBackTrace</a>(<span class="tok-number">0</span>, addresses.len, <span class="tok-builtin">@as</span>(**<span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(addresses.ptr)), <span class="tok-null">null</span>);
    }

    <span class="tok-kw">const</span> tib = &amp;<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.teb">teb</a>().NtTib;

    <span class="tok-kw">var</span> context: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (existing_context) |context_ptr| {
        context = context_ptr.*;
    } <span class="tok-kw">else</span> {
        context = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>);
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlCaptureContext">RtlCaptureContext</a>(&amp;context);
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> image_base: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD64">DWORD64</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> history_table: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.UNWIND_HISTORY_TABLE.html">UNWIND_HISTORY_TABLE</a> = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.UNWIND_HISTORY_TABLE.html">UNWIND_HISTORY_TABLE</a>);

    <span class="tok-kw">while</span> (i &lt; addresses.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> current_regs = context.getRegs();
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlLookupFunctionEntry">RtlLookupFunctionEntry</a>(current_regs.ip, &amp;image_base, &amp;history_table)) |runtime_function| {
            <span class="tok-kw">var</span> handler_data: ?*<span class="tok-type">anyopaque</span> = <span class="tok-null">null</span>;
            <span class="tok-kw">var</span> establisher_frame: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;
            _ = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlVirtualUnwind">RtlVirtualUnwind</a>(
                <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UNW_FLAG_NHANDLER">UNW_FLAG_NHANDLER</a>,
                image_base,
                current_regs.ip,
                runtime_function,
                &amp;context,
                &amp;handler_data,
                &amp;establisher_frame,
                <span class="tok-null">null</span>,
            );
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // leaf function
            </span>context.setIp(<span class="tok-builtin">@as</span>(*<span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(current_regs.sp)).*);
            context.setSp(current_regs.sp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>));
        }

        <span class="tok-kw">const</span> next_regs = context.getRegs();
        <span class="tok-kw">if</span> (next_regs.sp &lt; <span class="tok-builtin">@intFromPtr</span>(tib.StackLimit) <span class="tok-kw">or</span> next_regs.sp &gt; <span class="tok-builtin">@intFromPtr</span>(tib.StackBase)) {
            <span class="tok-kw">break</span>;
        }

        <span class="tok-kw">if</span> (next_regs.ip == <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span>;
        }

        addresses[i] = next_regs.ip;
    }

    <span class="tok-kw">return</span> i;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeStackTraceWindows</span>(
    out_stream: <span class="tok-kw">anytype</span>,
    debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>,
    tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>,
    context: *<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a>,
    start_addr: ?<span class="tok-type">usize</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> addr_buf: [<span class="tok-number">1024</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> n = <a href="std.debug.html#std.debug.walkStackWindows">walkStackWindows</a>(addr_buf[<span class="tok-number">0</span>..], context);
    <span class="tok-kw">const</span> addrs = addr_buf[<span class="tok-number">0</span>..n];
    <span class="tok-kw">const</span> start_i: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (start_addr) |saddr| blk: {
        <span class="tok-kw">for</span> (addrs, <span class="tok-number">0</span>..) |addr, i| {
            <span class="tok-kw">if</span> (addr == saddr) <span class="tok-kw">break</span> :blk i;
        }
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (addrs[start_i..]) |addr| {
        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(debug_info, out_stream, addr - <span class="tok-number">1</span>, tty_config);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">printUnknownSource</span>(debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> module_name = debug_info.getModuleNameForAddress(address);
    <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.printLineInfo">printLineInfo</a>(
        out_stream,
        <span class="tok-null">null</span>,
        address,
        <span class="tok-str">&quot;???&quot;</span>,
        module_name <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>,
        tty_config,
        <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>,
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">printLastUnwindError</span>(it: *<a href="std.debug.StackIterator.html">StackIterator</a>, debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, out_stream: <span class="tok-kw">anytype</span>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>) <span class="tok-kw">return</span>;
    <span class="tok-kw">if</span> (it.getLastError()) |unwind_error| {
        <a href="std.debug.html#std.debug.printUnwindError">printUnwindError</a>(debug_info, out_stream, unwind_error.address, unwind_error.err, tty_config) <span class="tok-kw">catch</span> {};
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">printUnwindError</span>(debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, err: <a href="std.debug.html#std.debug.UnwindError">UnwindError</a>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> module_name = debug_info.getModuleNameForAddress(address) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;???&quot;</span>;
    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .dim);
    <span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.MissingDebugInfo) {
        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;Unwind information for `{s}:0x{x}` was not available, trace may be incomplete\n\n&quot;</span>, .{ module_name, address });
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;Unwind error at address `{s}:0x{x}` ({}), trace may be incomplete\n\n&quot;</span>, .{ module_name, address, err });
    }
    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printSourceAtAddress</span>(debug_info: *<a href="std.debug.SelfInfo.html">SelfInfo</a>, out_stream: <span class="tok-kw">anytype</span>, address: <span class="tok-type">usize</span>, tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> module = debug_info.getModuleForAddress(address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.printUnknownSource">printUnknownSource</a>(debug_info, out_stream, address, tty_config),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };

    <span class="tok-kw">const</span> symbol_info = module.getSymbolAtAddress(debug_info.allocator, address) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.MissingDebugInfo, <span class="tok-kw">error</span>.InvalidDebugInfo =&gt; <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.printUnknownSource">printUnknownSource</a>(debug_info, out_stream, address, tty_config),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (symbol_info.source_location) |sl| debug_info.allocator.free(sl.file_name);

    <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.printLineInfo">printLineInfo</a>(
        out_stream,
        symbol_info.source_location,
        address,
        symbol_info.name,
        symbol_info.compile_unit_name,
        tty_config,
        <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>,
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">printLineInfo</span>(
    out_stream: <span class="tok-kw">anytype</span>,
    source_location: ?<a href="std.debug.SourceLocation.html">SourceLocation</a>,
    address: <span class="tok-type">usize</span>,
    symbol_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    compile_unit_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    tty_config: <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.Config.html">Config</a>,
    <span class="tok-kw">comptime</span> printLineFromFile: <span class="tok-kw">anytype</span>,
) !<span class="tok-type">void</span> {
    <span class="tok-kw">nosuspend</span> {
        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .bold);

        <span class="tok-kw">if</span> (source_location) |*sl| {
            <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;{s}:{d}:{d}&quot;</span>, .{ sl.file_name, sl.line, sl.column });
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;???:?:?&quot;</span>);
        }

        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);
        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;: &quot;</span>);
        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .dim);
        <span class="tok-kw">try</span> out_stream.print(<span class="tok-str">&quot;0x{x} in {s} ({s})&quot;</span>, .{ address, symbol_name, compile_unit_name });
        <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);
        <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;\n&quot;</span>);<span class="tok-comment">

        // Show the matching source code line if possible
        </span><span class="tok-kw">if</span> (source_location) |sl| {
            <span class="tok-kw">if</span> (printLineFromFile(out_stream, sl)) {
                <span class="tok-kw">if</span> (sl.column &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
                    // The caret already takes one char
                    </span><span class="tok-kw">const</span> space_needed = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(sl.column - <span class="tok-number">1</span>));

                    <span class="tok-kw">try</span> out_stream.writeByteNTimes(<span class="tok-str">' '</span>, space_needed);
                    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .green);
                    <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;^&quot;</span>);
                    <span class="tok-kw">try</span> tty_config.setColor(out_stream, .reset);
                }
                <span class="tok-kw">try</span> out_stream.writeAll(<span class="tok-str">&quot;\n&quot;</span>);
            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.EndOfFile, <span class="tok-kw">error</span>.FileNotFound =&gt; {},
                <span class="tok-kw">error</span>.BadPathName =&gt; {},
                <span class="tok-kw">error</span>.AccessDenied =&gt; {},
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            }
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">printLineFromFileAnyOs</span>(out_stream: <span class="tok-kw">anytype</span>, source_location: <a href="std.debug.SourceLocation.html">SourceLocation</a>) !<span class="tok-type">void</span> {<span class="tok-comment">
    // Need this to always block even in async I/O mode, because this could potentially
    // be called from e.g. the event loop code crashing.
    </span><span class="tok-kw">var</span> f = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().openFile(source_location.file_name, .{});
    <span class="tok-kw">defer</span> f.close();<span class="tok-comment">
    // TODO fstat and make sure that the file has the correct size

    </span><span class="tok-kw">var</span> buf: [<span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> amt_read = <span class="tok-kw">try</span> f.read(buf[<span class="tok-number">0</span>..]);
    <span class="tok-kw">const</span> line_start = seek: {
        <span class="tok-kw">var</span> current_line_start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> next_line: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">while</span> (next_line != source_location.line) {
            <span class="tok-kw">const</span> slice = buf[current_line_start..amt_read];
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, slice, <span class="tok-str">'\n'</span>)) |pos| {
                next_line += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (pos == slice.len - <span class="tok-number">1</span>) {
                    amt_read = <span class="tok-kw">try</span> f.read(buf[<span class="tok-number">0</span>..]);
                    current_line_start = <span class="tok-number">0</span>;
                } <span class="tok-kw">else</span> current_line_start += pos + <span class="tok-number">1</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (amt_read &lt; buf.len) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfFile;
            } <span class="tok-kw">else</span> {
                amt_read = <span class="tok-kw">try</span> f.read(buf[<span class="tok-number">0</span>..]);
                current_line_start = <span class="tok-number">0</span>;
            }
        }
        <span class="tok-kw">break</span> :seek current_line_start;
    };
    <span class="tok-kw">const</span> slice = buf[line_start..amt_read];
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, slice, <span class="tok-str">'\n'</span>)) |pos| {
        <span class="tok-kw">const</span> line = slice[<span class="tok-number">0</span> .. pos + <span class="tok-number">1</span>];
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.replaceScalar">replaceScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">'\t'</span>, <span class="tok-str">' '</span>);
        <span class="tok-kw">return</span> out_stream.writeAll(line);
    } <span class="tok-kw">else</span> {<span class="tok-comment"> // Line is the last inside the buffer, and requires another read to find delimiter. Alternatively the file ends.
        </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.replaceScalar">replaceScalar</a>(<span class="tok-type">u8</span>, slice, <span class="tok-str">'\t'</span>, <span class="tok-str">' '</span>);
        <span class="tok-kw">try</span> out_stream.writeAll(slice);
        <span class="tok-kw">while</span> (amt_read == buf.len) {
            amt_read = <span class="tok-kw">try</span> f.read(buf[<span class="tok-number">0</span>..]);
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, buf[<span class="tok-number">0</span>..amt_read], <span class="tok-str">'\n'</span>)) |pos| {
                <span class="tok-kw">const</span> line = buf[<span class="tok-number">0</span> .. pos + <span class="tok-number">1</span>];
                <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.replaceScalar">replaceScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">'\t'</span>, <span class="tok-str">' '</span>);
                <span class="tok-kw">return</span> out_stream.writeAll(line);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">const</span> line = buf[<span class="tok-number">0</span>..amt_read];
                <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.replaceScalar">replaceScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">'\t'</span>, <span class="tok-str">' '</span>);
                <span class="tok-kw">try</span> out_stream.writeAll(line);
            }
        }<span class="tok-comment">
        // Make sure printing last line of file inserts extra newline
        </span><span class="tok-kw">try</span> out_stream.writeByte(<span class="tok-str">'\n'</span>);
    }
}

<span class="tok-kw">test</span> printLineFromFileAnyOs {
    <span class="tok-kw">var</span> output = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> output.deinit();
    <span class="tok-kw">const</span> output_stream = output.writer();

    <span class="tok-kw">const</span> allocator = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;
    <span class="tok-kw">const</span> join = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>;
    <span class="tok-kw">const</span> expectError = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>;
    <span class="tok-kw">const</span> expectEqualStrings = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>;

    <span class="tok-kw">var</span> test_dir = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> test_dir.cleanup();<span class="tok-comment">
    // Relies on testing.tmpDir internals which is not ideal, but SourceLocation requires paths.
    </span><span class="tok-kw">const</span> test_dir_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ <span class="tok-str">&quot;.zig-cache&quot;</span>, <span class="tok-str">&quot;tmp&quot;</span>, test_dir.sub_path[<span class="tok-number">0</span>..] });
    <span class="tok-kw">defer</span> allocator.free(test_dir_path);<span class="tok-comment">

    // Cases
    </span>{
        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_dir_path, <span class="tok-str">&quot;one_line.zig&quot;</span> });
        <span class="tok-kw">defer</span> allocator.free(path);
        <span class="tok-kw">try</span> test_dir.dir.writeFile(.{ .sub_path = <span class="tok-str">&quot;one_line.zig&quot;</span>, .data = <span class="tok-str">&quot;no new lines in this file, but one is printed anyway&quot;</span> });

        <span class="tok-kw">try</span> expectError(<span class="tok-kw">error</span>.EndOfFile, <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">2</span>, .column = <span class="tok-number">0</span> }));

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">1</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;no new lines in this file, but one is printed anyway\n&quot;</span>, output.items);
        output.clearRetainingCapacity();
    }
    {
        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;.{ test_dir_path, <span class="tok-str">&quot;three_lines.zig&quot;</span> });
        <span class="tok-kw">defer</span> allocator.free(path);
        <span class="tok-kw">try</span> test_dir.dir.writeFile(.{
            .sub_path = <span class="tok-str">&quot;three_lines.zig&quot;</span>,
            .data =
            <span class="tok-str">\\1</span>
            <span class="tok-str">\\2</span>
            <span class="tok-str">\\3</span>
            ,
        });

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">1</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;1\n&quot;</span>, output.items);
        output.clearRetainingCapacity();

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">3</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;3\n&quot;</span>, output.items);
        output.clearRetainingCapacity();
    }
    {
        <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> test_dir.dir.createFile(<span class="tok-str">&quot;line_overlaps_page_boundary.zig&quot;</span>, .{});
        <span class="tok-kw">defer</span> file.close();
        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;.{ test_dir_path, <span class="tok-str">&quot;line_overlaps_page_boundary.zig&quot;</span> });
        <span class="tok-kw">defer</span> allocator.free(path);

        <span class="tok-kw">const</span> overlap = <span class="tok-number">10</span>;
        <span class="tok-kw">var</span> writer = file.writer();
        <span class="tok-kw">try</span> writer.writeByteNTimes(<span class="tok-str">'a'</span>, <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a> - overlap);
        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
        <span class="tok-kw">try</span> writer.writeByteNTimes(<span class="tok-str">'a'</span>, overlap);

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">2</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings((<span class="tok-str">&quot;a&quot;</span> ** overlap) ++ <span class="tok-str">&quot;\n&quot;</span>, output.items);
        output.clearRetainingCapacity();
    }
    {
        <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> test_dir.dir.createFile(<span class="tok-str">&quot;file_ends_on_page_boundary.zig&quot;</span>, .{});
        <span class="tok-kw">defer</span> file.close();
        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;.{ test_dir_path, <span class="tok-str">&quot;file_ends_on_page_boundary.zig&quot;</span> });
        <span class="tok-kw">defer</span> allocator.free(path);

        <span class="tok-kw">var</span> writer = file.writer();
        <span class="tok-kw">try</span> writer.writeByteNTimes(<span class="tok-str">'a'</span>, <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_max">page_size_max</a>);

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">1</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings((<span class="tok-str">&quot;a&quot;</span> ** <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_max">page_size_max</a>) ++ <span class="tok-str">&quot;\n&quot;</span>, output.items);
        output.clearRetainingCapacity();
    }
    {
        <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> test_dir.dir.createFile(<span class="tok-str">&quot;very_long_first_line_spanning_multiple_pages.zig&quot;</span>, .{});
        <span class="tok-kw">defer</span> file.close();
        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;.{ test_dir_path, <span class="tok-str">&quot;very_long_first_line_spanning_multiple_pages.zig&quot;</span> });
        <span class="tok-kw">defer</span> allocator.free(path);

        <span class="tok-kw">var</span> writer = file.writer();
        <span class="tok-kw">try</span> writer.writeByteNTimes(<span class="tok-str">'a'</span>, <span class="tok-number">3</span> * <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_max">page_size_max</a>);

        <span class="tok-kw">try</span> expectError(<span class="tok-kw">error</span>.EndOfFile, <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">2</span>, .column = <span class="tok-number">0</span> }));

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">1</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings((<span class="tok-str">&quot;a&quot;</span> ** (<span class="tok-number">3</span> * <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_max">page_size_max</a>)) ++ <span class="tok-str">&quot;\n&quot;</span>, output.items);
        output.clearRetainingCapacity();

        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;a\na&quot;</span>);

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">1</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings((<span class="tok-str">&quot;a&quot;</span> ** (<span class="tok-number">3</span> * <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_max">page_size_max</a>)) ++ <span class="tok-str">&quot;a\n&quot;</span>, output.items);
        output.clearRetainingCapacity();

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = <span class="tok-number">2</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;a\n&quot;</span>, output.items);
        output.clearRetainingCapacity();
    }
    {
        <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> test_dir.dir.createFile(<span class="tok-str">&quot;file_of_newlines.zig&quot;</span>, .{});
        <span class="tok-kw">defer</span> file.close();
        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.join">join</a>(allocator, &amp;.{ test_dir_path, <span class="tok-str">&quot;file_of_newlines.zig&quot;</span> });
        <span class="tok-kw">defer</span> allocator.free(path);

        <span class="tok-kw">var</span> writer = file.writer();
        <span class="tok-kw">const</span> real_file_start = <span class="tok-number">3</span> * <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>;
        <span class="tok-kw">try</span> writer.writeByteNTimes(<span class="tok-str">'\n'</span>, real_file_start);
        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;abc\ndef&quot;</span>);

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = real_file_start + <span class="tok-number">1</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;abc\n&quot;</span>, output.items);
        output.clearRetainingCapacity();

        <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printLineFromFileAnyOs">printLineFromFileAnyOs</a>(output_stream, .{ .file_name = path, .line = real_file_start + <span class="tok-number">2</span>, .column = <span class="tok-number">0</span> });
        <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;def\n&quot;</span>, output.items);
        output.clearRetainingCapacity();
    }
}

<span class="tok-comment">/// TODO multithreaded awareness</span>
<span class="tok-kw">var</span> debug_info_allocator: ?<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a> = <span class="tok-null">null</span>;
<span class="tok-kw">var</span> debug_info_arena_allocator: <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a> = <span class="tok-null">undefined</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">getDebugInfoAllocator</span>() <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.debug_info_allocator">debug_info_allocator</a>) |a| <span class="tok-kw">return</span> a;

    <a href="std.debug.html#std.debug.debug_info_arena_allocator">debug_info_arena_allocator</a> = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_allocator">page_allocator</a>);
    <span class="tok-kw">const</span> allocator = <a href="std.debug.html#std.debug.debug_info_arena_allocator">debug_info_arena_allocator</a>.<a href="#">allocator</a>();
    <a href="std.debug.html#std.debug.debug_info_allocator">debug_info_allocator</a> = allocator;
    <span class="tok-kw">return</span> allocator;
}

<span class="tok-comment">/// Whether or not the current target can print useful debug information when a segfault occurs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_segfault_handling_support = <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.native_os">native_os</a>) {
    .linux,
    .macos,
    .netbsd,
    .solaris,
    .illumos,
    .windows,
    =&gt; <span class="tok-null">true</span>,

    .freebsd, .openbsd =&gt; <a href="std.debug.html#std.debug.have_ucontext">have_ucontext</a>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
};

<span class="tok-kw">const</span> enable_segfault_handler = <a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">enable_segfault_handler</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_enable_segfault_handler = <a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a> <span class="tok-kw">and</span> <a href="std.debug.html#std.debug.have_segfault_handling_support">have_segfault_handling_support</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">maybeEnableSegfaultHandler</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.enable_segfault_handler">enable_segfault_handler</a>) {
        <a href="std.debug.html#std.debug.attachSegfaultHandler">attachSegfaultHandler</a>();
    }
}

<span class="tok-kw">var</span> windows_segfault_handle: ?<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.HANDLE">HANDLE</a> = <span class="tok-null">null</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateSegfaultHandler</span>(act: ?*<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>) <span class="tok-type">void</span> {
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">SEGV</a>, act, <span class="tok-null">null</span>);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ILL</a>, act, <span class="tok-null">null</span>);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">BUS</a>, act, <span class="tok-null">null</span>);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">FPE</a>, act, <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Attaches a global SIGSEGV handler which calls `@panic(&quot;segmentation fault&quot;);`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attachSegfaultHandler</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.have_segfault_handling_support">have_segfault_handling_support</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;segfault handler not supported for this target&quot;</span>);
    }
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <a href="std.debug.html#std.debug.windows_segfault_handle">windows_segfault_handle</a> = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.AddVectoredExceptionHandler">AddVectoredExceptionHandler</a>(<span class="tok-number">0</span>, <a href="std.debug.html#std.debug.handleSegfaultWindows">handleSegfaultWindows</a>);
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">var</span> act = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>{
        .handler = .{ .sigaction = <a href="std.debug.html#std.debug.handleSegfaultPosix">handleSegfaultPosix</a> },
        .mask = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.empty_sigset">empty_sigset</a>,
        .flags = (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">SIGINFO</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">RESTART</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SA">SA</a>.<a href="#">RESETHAND</a>),
    };

    <a href="std.debug.html#std.debug.updateSegfaultHandler">updateSegfaultHandler</a>(&amp;act);
}

<span class="tok-kw">fn</span> <span class="tok-fn">resetSegfaultHandler</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.windows_segfault_handle">windows_segfault_handle</a>) |handle| {
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.RemoveVectoredExceptionHandler">RemoveVectoredExceptionHandler</a>(handle) != <span class="tok-number">0</span>);
            <a href="std.debug.html#std.debug.windows_segfault_handle">windows_segfault_handle</a> = <span class="tok-null">null</span>;
        }
        <span class="tok-kw">return</span>;
    }
    <span class="tok-kw">var</span> act = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Sigaction">Sigaction</a>{
        .handler = .{ .handler = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">DFL</a> },
        .mask = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.empty_sigset">empty_sigset</a>,
        .flags = <span class="tok-number">0</span>,
    };
    <a href="std.debug.html#std.debug.updateSegfaultHandler">updateSegfaultHandler</a>(&amp;act);
}

<span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultPosix</span>(sig: <span class="tok-type">i32</span>, info: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.siginfo_t">siginfo_t</a>, ctx_ptr: ?*<span class="tok-type">anyopaque</span>) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">noreturn</span> {<span class="tok-comment">
    // Reset to the default handler so that if a segfault happens in this handler it will crash
    // the process. Also when this handler returns, the original instruction will be repeated
    // and the resulting segfault will crash the process rather than continually dump stack traces.
    </span><a href="std.debug.html#std.debug.resetSegfaultHandler">resetSegfaultHandler</a>();

    <span class="tok-kw">const</span> addr = <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.native_os">native_os</a>) {
        .linux =&gt; <span class="tok-builtin">@intFromPtr</span>(info.fields.sigfault.addr),
        .freebsd, .macos =&gt; <span class="tok-builtin">@intFromPtr</span>(info.addr),
        .netbsd =&gt; <span class="tok-builtin">@intFromPtr</span>(info.info.reason.fault.addr),
        .openbsd =&gt; <span class="tok-builtin">@intFromPtr</span>(info.data.fault.addr),
        .solaris, .illumos =&gt; <span class="tok-builtin">@intFromPtr</span>(info.reason.fault.addr),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };

    <span class="tok-kw">const</span> code = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .netbsd) info.info.code <span class="tok-kw">else</span> info.code;
    <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.panic_stage">panic_stage</a>) {
        <span class="tok-number">0</span> =&gt; {
            <a href="std.debug.html#std.debug.panic_stage">panic_stage</a> = <span class="tok-number">1</span>;
            _ = <a href="std.debug.html#std.debug.panicking">panicking</a>.<a href="#">fetchAdd</a>(<span class="tok-number">1</span>, .seq_cst);

            {
                <a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
                <span class="tok-kw">defer</span> <a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();

                <a href="std.debug.html#std.debug.dumpSegfaultInfoPosix">dumpSegfaultInfoPosix</a>(sig, code, addr, ctx_ptr);
            }

            <a href="std.debug.html#std.debug.waitForOtherThreadToFinishPanicking">waitForOtherThreadToFinishPanicking</a>();
        },
        <span class="tok-kw">else</span> =&gt; {<span class="tok-comment">
            // panic mutex already locked
            </span><a href="std.debug.html#std.debug.dumpSegfaultInfoPosix">dumpSegfaultInfoPosix</a>(sig, code, addr, ctx_ptr);
        },
    };<span class="tok-comment">

    // We cannot allow the signal handler to return because when it runs the original instruction
    // again, the memory may be mapped and undefined behavior would occur rather than repeating
    // the segfault. So we simply abort here.
    </span><a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();
}

<span class="tok-kw">fn</span> <span class="tok-fn">dumpSegfaultInfoPosix</span>(sig: <span class="tok-type">i32</span>, code: <span class="tok-type">i32</span>, addr: <span class="tok-type">usize</span>, ctx_ptr: ?*<span class="tok-type">anyopaque</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
    _ = <span class="tok-kw">switch</span> (sig) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">SEGV</a> =&gt; <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a> == .x86_64 <span class="tok-kw">and</span> <a href="std.debug.html#std.debug.native_os">native_os</a> == .linux <span class="tok-kw">and</span> code == <span class="tok-number">128</span>)<span class="tok-comment"> // SI_KERNEL
            // x86_64 doesn't have a full 64-bit virtual address space.
            // Addresses outside of that address space are non-canonical
            // and the CPU won't provide the faulting address to us.
            // This happens when accessing memory addresses such as 0xaaaaaaaaaaaaaaaa
            // but can also happen when no addressable memory is involved;
            // for example when reading/writing model-specific registers
            // by executing `rdmsr` or `wrmsr` in user-space (unprivileged mode).
            </span>stderr.print(<span class="tok-str">&quot;General protection exception (no address available)\n&quot;</span>, .{})
        <span class="tok-kw">else</span>
            stderr.print(<span class="tok-str">&quot;Segmentation fault at address 0x{x}\n&quot;</span>, .{addr}),
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ILL</a> =&gt; stderr.print(<span class="tok-str">&quot;Illegal instruction at address 0x{x}\n&quot;</span>, .{addr}),
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">BUS</a> =&gt; stderr.print(<span class="tok-str">&quot;Bus error at address 0x{x}\n&quot;</span>, .{addr}),
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">FPE</a> =&gt; stderr.print(<span class="tok-str">&quot;Arithmetic exception at address 0x{x}\n&quot;</span>, .{addr}),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    } <span class="tok-kw">catch</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();

    <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.native_arch">native_arch</a>) {
        .x86,
        .x86_64,
        .arm,
        .armeb,
        .thumb,
        .thumbeb,
        .aarch64,
        .aarch64_be,
        =&gt; {<span class="tok-comment">
            // Some kernels don't align `ctx_ptr` properly. Handle this defensively.
            </span><span class="tok-kw">const</span> ctx: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ucontext_t">ucontext_t</a> = <span class="tok-builtin">@ptrCast</span>(ctx_ptr);
            <span class="tok-kw">var</span> new_ctx: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ucontext_t">ucontext_t</a> = ctx.*;
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>.<a href="#">isDarwin</a>() <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a> == .aarch64) {<span class="tok-comment">
                // The kernel incorrectly writes the contents of `__mcontext_data` right after `mcontext`,
                // rather than after the 8 bytes of padding that are supposed to sit between the two. Copy the
                // contents to the right place so that the `mcontext` pointer will be correct after the
                // `relocateContext` call below.
                </span>new_ctx.__mcontext_data = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
                    onstack: <span class="tok-type">c_int</span>,
                    sigmask: <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.sigset_t">sigset_t</a>,
                    stack: <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.stack_t">stack_t</a>,
                    link: ?*<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.ucontext_t">ucontext_t</a>,
                    mcsize: <span class="tok-type">u64</span>,
                    mcontext: *<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.mcontext_t">mcontext_t</a>,
                    __mcontext_data: <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.mcontext_t">mcontext_t</a> <span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)),<span class="tok-comment"> // Disable padding after `mcontext`.
                </span>}, <span class="tok-builtin">@ptrCast</span>(ctx)).__mcontext_data;
            }
            <a href="std.debug.html#std.debug.relocateContext">relocateContext</a>(&amp;new_ctx);
            <a href="std.debug.html#std.debug.dumpStackTraceFromBase">dumpStackTraceFromBase</a>(&amp;new_ctx);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultWindows</span>(info: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.EXCEPTION_POINTERS.html">EXCEPTION_POINTERS</a>) <span class="tok-kw">callconv</span>(.winapi) <span class="tok-type">c_long</span> {
    <span class="tok-kw">switch</span> (info.ExceptionRecord.ExceptionCode) {
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.EXCEPTION_DATATYPE_MISALIGNMENT">EXCEPTION_DATATYPE_MISALIGNMENT</a> =&gt; <a href="std.debug.html#std.debug.handleSegfaultWindowsExtra">handleSegfaultWindowsExtra</a>(info, <span class="tok-number">0</span>, <span class="tok-str">&quot;Unaligned Memory Access&quot;</span>),
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.EXCEPTION_ACCESS_VIOLATION">EXCEPTION_ACCESS_VIOLATION</a> =&gt; <a href="std.debug.html#std.debug.handleSegfaultWindowsExtra">handleSegfaultWindowsExtra</a>(info, <span class="tok-number">1</span>, <span class="tok-null">null</span>),
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.EXCEPTION_ILLEGAL_INSTRUCTION">EXCEPTION_ILLEGAL_INSTRUCTION</a> =&gt; <a href="std.debug.html#std.debug.handleSegfaultWindowsExtra">handleSegfaultWindowsExtra</a>(info, <span class="tok-number">2</span>, <span class="tok-null">null</span>),
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.EXCEPTION_STACK_OVERFLOW">EXCEPTION_STACK_OVERFLOW</a> =&gt; <a href="std.debug.html#std.debug.handleSegfaultWindowsExtra">handleSegfaultWindowsExtra</a>(info, <span class="tok-number">0</span>, <span class="tok-str">&quot;Stack Overflow&quot;</span>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.EXCEPTION_CONTINUE_SEARCH">EXCEPTION_CONTINUE_SEARCH</a>,
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">handleSegfaultWindowsExtra</span>(info: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.EXCEPTION_POINTERS.html">EXCEPTION_POINTERS</a>, msg: <span class="tok-type">u8</span>, label: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CONTEXT">CONTEXT</a> != <span class="tok-type">void</span>);
    <span class="tok-kw">nosuspend</span> <span class="tok-kw">switch</span> (<a href="std.debug.html#std.debug.panic_stage">panic_stage</a>) {
        <span class="tok-number">0</span> =&gt; {
            <a href="std.debug.html#std.debug.panic_stage">panic_stage</a> = <span class="tok-number">1</span>;
            _ = <a href="std.debug.html#std.debug.panicking">panicking</a>.<a href="#">fetchAdd</a>(<span class="tok-number">1</span>, .seq_cst);

            {
                <a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
                <span class="tok-kw">defer</span> <a href="std.debug.html#std.debug.unlockStdErr">unlockStdErr</a>();

                <a href="std.debug.html#std.debug.dumpSegfaultInfoWindows">dumpSegfaultInfoWindows</a>(info, msg, label);
            }

            <a href="std.debug.html#std.debug.waitForOtherThreadToFinishPanicking">waitForOtherThreadToFinishPanicking</a>();
        },
        <span class="tok-number">1</span> =&gt; {
            <a href="std.debug.html#std.debug.panic_stage">panic_stage</a> = <span class="tok-number">2</span>;
            <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writeAll(<span class="tok-str">&quot;aborting due to recursive panic\n&quot;</span>) <span class="tok-kw">catch</span> {};
        },
        <span class="tok-kw">else</span> =&gt; {},
    };
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();
}

<span class="tok-kw">fn</span> <span class="tok-fn">dumpSegfaultInfoWindows</span>(info: *<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.EXCEPTION_POINTERS.html">EXCEPTION_POINTERS</a>, msg: <span class="tok-type">u8</span>, label: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
    _ = <span class="tok-kw">switch</span> (msg) {
        <span class="tok-number">0</span> =&gt; stderr.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{label.?}),
        <span class="tok-number">1</span> =&gt; stderr.print(<span class="tok-str">&quot;Segmentation fault at address 0x{x}\n&quot;</span>, .{info.ExceptionRecord.ExceptionInformation[<span class="tok-number">1</span>]}),
        <span class="tok-number">2</span> =&gt; stderr.print(<span class="tok-str">&quot;Illegal instruction at address 0x{x}\n&quot;</span>, .{info.ContextRecord.getRegs().ip}),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    } <span class="tok-kw">catch</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>();

    <a href="std.debug.html#std.debug.dumpStackTraceFromBase">dumpStackTraceFromBase</a>(info.ContextRecord);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpStackPointerAddr</span>(prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> sp = <span class="tok-kw">asm</span> (<span class="tok-str">&quot;&quot;</span>
        : [argc] <span class="tok-str">&quot;={rsp}&quot;</span> (-&gt; <span class="tok-type">usize</span>),
    );
    <a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;{s} sp = 0x{x}\n&quot;</span>, .{ prefix, sp });
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;manage resources correctly&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.strip_debug_info">strip_debug_info</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .wasi) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/13963
        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }<span class="tok-comment">

    // self-hosted debug info is still too buggy
    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> != .stage2_llvm) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.null_writer">null_writer</a>;
    <span class="tok-kw">var</span> di = <span class="tok-kw">try</span> <a href="std.debug.SelfInfo.html">SelfInfo</a>.<a href="std.debug.SelfInfo.html#std.debug.SelfInfo.open">open</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> di.deinit();
    <span class="tok-kw">try</span> <a href="std.debug.html#std.debug.printSourceAtAddress">printSourceAtAddress</a>(&amp;di, writer, <a href="std.debug.html#std.debug.showMyTrace">showMyTrace</a>(), <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>()));
}

<span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">showMyTrace</span>() <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@returnAddress</span>();
}

<span class="tok-comment">/// This API helps you track where a value originated and where it was mutated,</span>
<span class="tok-comment">/// or any other points of interest.</span>
<span class="tok-comment">/// In debug mode, it adds a small size penalty (104 bytes on 64-bit architectures)</span>
<span class="tok-comment">/// to the aggregate that you add it to.</span>
<span class="tok-comment">/// In release mode, it is size 0 and all methods are no-ops.</span>
<span class="tok-comment">/// This is a pre-made type with default settings.</span>
<span class="tok-comment">/// For more advanced usage, see `ConfigurableTrace`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Trace = <a href="std.debug.html#std.debug.ConfigurableTrace">ConfigurableTrace</a>(<span class="tok-number">2</span>, <span class="tok-number">4</span>, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ConfigurableTrace</span>(<span class="tok-kw">comptime</span> size: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> stack_frame_count: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> is_enabled: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        addrs: [<a href="std.debug.html#std.debug.ConfigurableTrace.actual_size">actual_size</a>][stack_frame_count]<span class="tok-type">usize</span>,
        notes: [<a href="std.debug.html#std.debug.ConfigurableTrace.actual_size">actual_size</a>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        index: <a href="std.debug.html#std.debug.ConfigurableTrace.Index">Index</a>,

        <span class="tok-kw">const</span> actual_size = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) size <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> Index = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <span class="tok-type">usize</span> <span class="tok-kw">else</span> <span class="tok-type">u0</span>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> init: <span class="tok-builtin">@This</span>() = .{
            .addrs = <span class="tok-null">undefined</span>,
            .notes = <span class="tok-null">undefined</span>,
            .index = <span class="tok-number">0</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> enabled = is_enabled;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> add = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <a href="std.debug.html#std.debug.ConfigurableTrace.addNoInline">addNoInline</a> <span class="tok-kw">else</span> <a href="std.debug.html#std.debug.ConfigurableTrace.addNoOp">addNoOp</a>;

        <span class="tok-kw">pub</span> <span class="tok-kw">noinline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoInline</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>);
            <span class="tok-kw">return</span> <a href="std.debug.html#std.debug.ConfigurableTrace.addAddr">addAddr</a>(t, <span class="tok-builtin">@returnAddress</span>(), note);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNoOp</span>(t: *<span class="tok-builtin">@This</span>(), note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            _ = t;
            _ = note;
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAddr</span>(t: *<span class="tok-builtin">@This</span>(), addr: <span class="tok-type">usize</span>, note: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <span class="tok-kw">return</span>;

            <span class="tok-kw">if</span> (t.index &lt; size) {
                t.notes[t.index] = note;
                t.addrs[t.index] = [<span class="tok-number">1</span>]<span class="tok-type">usize</span>{<span class="tok-number">0</span>} ** stack_frame_count;
                <span class="tok-kw">var</span> stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a> = .{
                    .index = <span class="tok-number">0</span>,
                    .instruction_addresses = &amp;t.addrs[t.index],
                };
                <a href="std.debug.html#std.debug.captureStackTrace">captureStackTrace</a>(addr, &amp;stack_trace);
            }<span class="tok-comment">
            // Keep counting even if the end is reached so that the
            // user can find out how much more size they need.
            </span>t.index += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(t: <span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> tty_config = <a href="std.io.html">io</a>.<a href="std.io.tty.html">tty</a>.<a href="std.io.tty.html#std.io.tty.detectConfig">detectConfig</a>(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>());
            <span class="tok-kw">const</span> stderr = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer();
            <span class="tok-kw">const</span> end = <span class="tok-builtin">@min</span>(t.index, size);
            <span class="tok-kw">const</span> debug_info = <a href="std.debug.html#std.debug.getSelfDebugInfo">getSelfDebugInfo</a>() <span class="tok-kw">catch</span> |err| {
                stderr.print(
                    <span class="tok-str">&quot;Unable to dump stack trace: Unable to open debug info: {s}\n&quot;</span>,
                    .{<span class="tok-builtin">@errorName</span>(err)},
                ) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
                <span class="tok-kw">return</span>;
            };
            <span class="tok-kw">for</span> (t.addrs[<span class="tok-number">0</span>..end], <span class="tok-number">0</span>..) |frames_array, i| {
                stderr.print(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{t.notes[i]}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
                <span class="tok-kw">var</span> frames_array_mutable = frames_array;
                <span class="tok-kw">const</span> frames = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(frames_array_mutable[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);
                <span class="tok-kw">const</span> stack_trace: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.StackTrace.html">StackTrace</a> = .{
                    .index = frames.len,
                    .instruction_addresses = frames,
                };
                <a href="std.debug.html#std.debug.writeStackTrace">writeStackTrace</a>(stack_trace, stderr, debug_info, tty_config) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;
            }
            <span class="tok-kw">if</span> (t.index &gt; end) {
                stderr.print(<span class="tok-str">&quot;{d} more traces not shown; consider increasing trace size\n&quot;</span>, .{
                    t.index - end,
                }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
            t: <span class="tok-builtin">@This</span>(),
            <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            options: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
            writer: <span class="tok-kw">anytype</span>,
        ) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (fmt.len != <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.invalidFmtError">invalidFmtError</a>(fmt, t);
            _ = options;
            <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.ConfigurableTrace.enabled">enabled</a>) {
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);
                t.dump();
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\n&quot;</span>);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> writer.writeAll(<span class="tok-str">&quot;(value tracing disabled)&quot;</span>);
            }
        }
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SafetyLock = <span class="tok-kw">struct</span> {
    state: <a href="std.debug.SafetyLock.html#std.debug.SafetyLock.State">State</a> = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) .unlocked <span class="tok-kw">else</span> .unknown,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> State = <span class="tok-kw">if</span> (<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <span class="tok-kw">enum</span> { unlocked, locked } <span class="tok-kw">else</span> <span class="tok-kw">enum</span> { unknown };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lock</span>(l: *<a href="std.debug.SafetyLock.html">SafetyLock</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <span class="tok-kw">return</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(l.state == .unlocked);
        l.state = .locked;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlock</span>(l: *<a href="std.debug.SafetyLock.html">SafetyLock</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <span class="tok-kw">return</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(l.state == .locked);
        l.state = .unlocked;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assertUnlocked</span>(l: <a href="std.debug.SafetyLock.html">SafetyLock</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <span class="tok-kw">return</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(l.state == .unlocked);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assertLocked</span>(l: <a href="std.debug.SafetyLock.html">SafetyLock</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) <span class="tok-kw">return</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(l.state == .locked);
    }
};

<span class="tok-kw">test</span> SafetyLock {
    <span class="tok-kw">var</span> safety_lock: <a href="std.debug.SafetyLock.html">SafetyLock</a> = .{};
    safety_lock.assertUnlocked();
    safety_lock.lock();
    safety_lock.assertLocked();
    safety_lock.unlock();
    safety_lock.assertUnlocked();
}

<span class="tok-comment">/// Detect whether the program is being executed in the Valgrind virtual machine.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// When Valgrind integrations are disabled, this returns comptime-known false.</span>
<span class="tok-comment">/// Otherwise, the result is runtime-known.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">inValgrind</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@inComptime</span>()) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.valgrind_support">valgrind_support</a>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.valgrind.html">valgrind</a>.<a href="std.valgrind.html#std.valgrind.runningOnValgrind">runningOnValgrind</a>() &gt; <span class="tok-number">0</span>;
}

<span class="tok-kw">test</span> {
    _ = &amp;<a href="std.debug.Dwarf.html">Dwarf</a>;
    _ = &amp;<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a>;
    _ = &amp;<a href="std.debug.FixedBufferReader.html">FixedBufferReader</a>;
    _ = &amp;<a href="std.debug.Pdb.html">Pdb</a>;
    _ = &amp;<a href="std.debug.SelfInfo.html">SelfInfo</a>;
    _ = &amp;<a href="std.debug.html#std.debug.dumpHex">dumpHex</a>;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
