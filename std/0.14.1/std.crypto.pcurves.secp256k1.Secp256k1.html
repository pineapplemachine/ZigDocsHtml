<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">crypto</a></li><li><a href="std.crypto.html" class="">pcurves</a></li><li><a href="std.crypto.pcurves.secp256k1.html" class="">secp256k1</a></li><li><a href="std.crypto.pcurves.secp256k1.Secp256k1.html" class="active">Secp256k1</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.crypto.pcurves.secp256k1.Secp256k1" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.crypto.pcurves.secp256k1.Secp256k1</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1">[src]</a></h1><div class="tldDocs"><p>Group operations over secp256k1.</p>
</div><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.crypto.pcurves.secp256k1.scalar.html">std.crypto.pcurves.secp256k1.scalar</a></li><li><a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html">std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.field.Fe" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Fe</span><a href="#src.zig-std.crypto.pcurves.secp256k1.field.Fe">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.field.Fe">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fe = <a href="std.crypto.pcurves.common.html#std.crypto.pcurves.common.Field">Field</a>(.{
    .fiat = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;secp256k1_64.zig&quot;</span>),
    .field_order = <span class="tok-number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span>,
    .field_bits = <span class="tok-number">256</span>,
    .saturated_bits = <span class="tok-number">256</span>,
    .encoded_length = <span class="tok-number">32</span>,
})</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>x: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a></code></pre></div><div><pre><code>y: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a></code></pre></div><div><pre><code>z: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a> = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">one</a></code></pre></div><div><pre><code>is_base: <span class="tok-type">bool</span> = <span class="tok-null">false</span></code></pre></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.basePoint" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">basePoint</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.basePoint">[src]</a></h2><div class="tldDocs"><p>The secp256k1 base point.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.basePoint">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> basePoint = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{
    .x = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromInt</a>(<span class="tok-number">55066263022277343669578718895168534326250603453777594175500187360389116729240</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
    .y = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromInt</a>(<span class="tok-number">32670510020758816978083085130507043184471273380659243275938904335757337482424</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
    .z = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">one</a>,
    .is_base = <span class="tok-null">true</span>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.identityElement" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">identityElement</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.identityElement">[src]</a></h2><div class="tldDocs"><p>The secp256k1 neutral element.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.identityElement">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> identityElement = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{ .x = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">zero</a>, .y = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">one</a>, .z = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">zero</a> }</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.B" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">B</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.B">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.B">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> B = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromInt</a>(<span class="tok-number">7</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.rejectIdentity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rejectIdentity</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.rejectIdentity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rejectIdentity</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Reject the neutral element.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.rejectIdentity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rejectIdentity</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> affine_0 = <span class="tok-builtin">@intFromBool</span>(p.x.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">x</a>)) &amp; (<span class="tok-builtin">@intFromBool</span>(p.y.isZero()) | <span class="tok-builtin">@intFromBool</span>(p.y.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">y</a>)));
    <span class="tok-kw">const</span> is_identity = <span class="tok-builtin">@intFromBool</span>(p.z.isZero()) | affine_0;
    <span class="tok-kw">if</span> (is_identity != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IdentityElement;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.fromAffineCoordinates" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromAffineCoordinates</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.fromAffineCoordinates">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromAffineCoordinates</span>(p: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Create a point from affine coordinates after checking that they match the curve equation.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.fromAffineCoordinates">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromAffineCoordinates</span>(p: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">const</span> x = p.x;
    <span class="tok-kw">const</span> y = p.y;
    <span class="tok-kw">const</span> x3B = x.sq().mul(x).add(<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.B">B</a>);
    <span class="tok-kw">const</span> yy = y.sq();
    <span class="tok-kw">const</span> on_curve = <span class="tok-builtin">@intFromBool</span>(x3B.equivalent(yy));
    <span class="tok-kw">const</span> is_identity = <span class="tok-builtin">@intFromBool</span>(x.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">x</a>)) &amp; <span class="tok-builtin">@intFromBool</span>(y.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">y</a>));
    <span class="tok-kw">if</span> ((on_curve | is_identity) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
    }
    <span class="tok-kw">var</span> ret = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{ .x = x, .y = y, .z = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">one</a> };
    ret.z.cMov(<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>.<a href="#">z</a>, is_identity);
    <span class="tok-kw">return</span> ret;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.fromSerializedAffineCoordinates" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromSerializedAffineCoordinates</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.fromSerializedAffineCoordinates">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSerializedAffineCoordinates</span>(xs: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, ys: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Create a point from serialized affine coordinates.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>xs: [<span class="tok-number">32</span>]<span class="tok-type">u8</span></code></pre></div><div><pre><code>ys: [<span class="tok-number">32</span>]<span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.fromSerializedAffineCoordinates">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSerializedAffineCoordinates</span>(xs: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, ys: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(xs, endian);
    <span class="tok-kw">const</span> y = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(ys, endian);
    <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.fromAffineCoordinates">fromAffineCoordinates</a>(.{ .x = x, .y = y });
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.recoverY" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">recoverY</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.recoverY">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recoverY</span>(x: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>, is_odd: <span class="tok-type">bool</span>) <a href="std.crypto.errors.html#std.crypto.errors.NotSquareError">NotSquareError</a>!<a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Recover the Y coordinate from the X coordinate.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>x: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a></code></pre></div><div><pre><code>is_odd: <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.recoverY">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recoverY</span>(x: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>, is_odd: <span class="tok-type">bool</span>) <a href="std.crypto.errors.html#std.crypto.errors.NotSquareError">NotSquareError</a>!<a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a> {
    <span class="tok-kw">const</span> x3B = x.sq().mul(x).add(<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.B">B</a>);
    <span class="tok-kw">var</span> y = <span class="tok-kw">try</span> x3B.sqrt();
    <span class="tok-kw">const</span> yn = y.neg();
    y.cMov(yn, <span class="tok-builtin">@intFromBool</span>(is_odd) ^ <span class="tok-builtin">@intFromBool</span>(y.isOdd()));
    <span class="tok-kw">return</span> y;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.fromSec1" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromSec1</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.fromSec1">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSec1</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NotSquareError">NotSquareError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Deserialize a SEC1-encoded point.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.fromSec1">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSec1</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NotSquareError">NotSquareError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">if</span> (s.len &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
    <span class="tok-kw">const</span> encoding_type = s[<span class="tok-number">0</span>];
    <span class="tok-kw">const</span> encoded = s[<span class="tok-number">1</span>..];
    <span class="tok-kw">switch</span> (encoding_type) {
        <span class="tok-number">0</span> =&gt; {
            <span class="tok-kw">if</span> (encoded.len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
            <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
        },
        <span class="tok-number">2</span>, <span class="tok-number">3</span> =&gt; {
            <span class="tok-kw">if</span> (encoded.len != <span class="tok-number">32</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
            <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(encoded[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*, .big);
            <span class="tok-kw">const</span> y_is_odd = (encoding_type == <span class="tok-number">3</span>);
            <span class="tok-kw">const</span> y = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.recoverY">recoverY</a>(x, y_is_odd);
            <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{ .x = x, .y = y };
        },
        <span class="tok-number">4</span> =&gt; {
            <span class="tok-kw">if</span> (encoded.len != <span class="tok-number">64</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
            <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(encoded[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*, .big);
            <span class="tok-kw">const</span> y = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(encoded[<span class="tok-number">32</span>..<span class="tok-number">64</span>].*, .big);
            <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.fromAffineCoordinates">fromAffineCoordinates</a>(.{ .x = x, .y = y });
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.toCompressedSec1" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toCompressedSec1</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.toCompressedSec1">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toCompressedSec1</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) [<span class="tok-number">33</span>]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Serialize a point using the compressed SEC-1 format.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.toCompressedSec1">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toCompressedSec1</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) [<span class="tok-number">33</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">33</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> xy = p.affineCoordinates();
    out[<span class="tok-number">0</span>] = <span class="tok-kw">if</span> (xy.y.isOdd()) <span class="tok-number">3</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>;
    out[<span class="tok-number">1</span>..].* = xy.x.toBytes(.big);
    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.toUncompressedSec1" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toUncompressedSec1</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.toUncompressedSec1">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toUncompressedSec1</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) [<span class="tok-number">65</span>]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Serialize a point using the uncompressed SEC-1 format.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.toUncompressedSec1">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toUncompressedSec1</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) [<span class="tok-number">65</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">var</span> out: [<span class="tok-number">65</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    out[<span class="tok-number">0</span>] = <span class="tok-number">4</span>;
    <span class="tok-kw">const</span> xy = p.affineCoordinates();
    out[<span class="tok-number">1</span>..<span class="tok-number">33</span>].* = xy.x.toBytes(.big);
    out[<span class="tok-number">33</span>..<span class="tok-number">65</span>].* = xy.y.toBytes(.big);
    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.random" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">random</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.random">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">random</span>() <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Return a random point.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.random">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">random</span>() <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">const</span> n = <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.random">random</a>(.little);
    <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePoint">basePoint</a>.<a href="#">mul</a>(n, .little) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.neg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">neg</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.neg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">neg</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Flip the sign of the X coordinate.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.neg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">neg</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">return</span> .{ .x = p.x, .y = p.y.neg(), .z = p.z };
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.dbl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dbl</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.dbl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dbl</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Double a secp256k1 point.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.dbl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dbl</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">var</span> t0 = p.y.sq();
    <span class="tok-kw">var</span> Z3 = t0.dbl();
    Z3 = Z3.dbl();
    Z3 = Z3.dbl();
    <span class="tok-kw">var</span> t1 = p.y.mul(p.z);
    <span class="tok-kw">var</span> t2 = p.z.sq();<span class="tok-comment">
    // b3 = (2^2)^2 + 2^2 + 1
    </span><span class="tok-kw">const</span> t2_4 = t2.dbl().dbl();
    t2 = t2_4.dbl().dbl().add(t2_4).add(t2);
    <span class="tok-kw">var</span> X3 = t2.mul(Z3);
    <span class="tok-kw">var</span> Y3 = t0.add(t2);
    Z3 = t1.mul(Z3);
    t1 = t2.dbl();
    t2 = t1.add(t2);
    t0 = t0.sub(t2);
    Y3 = t0.mul(Y3);
    Y3 = X3.add(Y3);
    t1 = p.x.mul(p.y);
    X3 = t0.mul(t1);
    X3 = X3.dbl();
    <span class="tok-kw">return</span> .{
        .x = X3,
        .y = Y3,
        .z = Z3,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.addMixed" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addMixed</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.addMixed">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addMixed</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Add secp256k1 points, the second being specified using affine coordinates.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>q: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.addMixed">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addMixed</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">var</span> t0 = p.x.mul(q.x);
    <span class="tok-kw">var</span> t1 = p.y.mul(q.y);
    <span class="tok-kw">var</span> t3 = q.x.add(q.y);
    <span class="tok-kw">var</span> t4 = p.x.add(p.y);
    t3 = t3.mul(t4);
    t4 = t0.add(t1);
    t3 = t3.sub(t4);
    t4 = q.y.mul(p.z);
    t4 = t4.add(p.y);
    <span class="tok-kw">var</span> Y3 = q.x.mul(p.z);
    Y3 = Y3.add(p.x);
    <span class="tok-kw">var</span> X3 = t0.dbl();
    t0 = X3.add(t0);<span class="tok-comment">
    // b3 = (2^2)^2 + 2^2 + 1
    </span><span class="tok-kw">const</span> t2_4 = p.z.dbl().dbl();
    <span class="tok-kw">var</span> t2 = t2_4.dbl().dbl().add(t2_4).add(p.z);
    <span class="tok-kw">var</span> Z3 = t1.add(t2);
    t1 = t1.sub(t2);
    <span class="tok-kw">const</span> Y3_4 = Y3.dbl().dbl();
    Y3 = Y3_4.dbl().dbl().add(Y3_4).add(Y3);
    X3 = t4.mul(Y3);
    t2 = t3.mul(t1);
    X3 = t2.sub(X3);
    Y3 = Y3.mul(t0);
    t1 = t1.mul(Z3);
    Y3 = t1.add(Y3);
    t0 = t0.mul(t3);
    Z3 = Z3.mul(t4);
    Z3 = Z3.add(t0);

    <span class="tok-kw">var</span> ret = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{
        .x = X3,
        .y = Y3,
        .z = Z3,
    };
    ret.cMov(p, <span class="tok-builtin">@intFromBool</span>(q.x.isZero()));
    <span class="tok-kw">return</span> ret;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.add">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Add secp256k1 points.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>q: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.add">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">var</span> t0 = p.x.mul(q.x);
    <span class="tok-kw">var</span> t1 = p.y.mul(q.y);
    <span class="tok-kw">var</span> t2 = p.z.mul(q.z);
    <span class="tok-kw">var</span> t3 = p.x.add(p.y);
    <span class="tok-kw">var</span> t4 = q.x.add(q.y);
    t3 = t3.mul(t4);
    t4 = t0.add(t1);
    t3 = t3.sub(t4);
    t4 = p.y.add(p.z);
    <span class="tok-kw">var</span> X3 = q.y.add(q.z);
    t4 = t4.mul(X3);
    X3 = t1.add(t2);
    t4 = t4.sub(X3);
    X3 = p.x.add(p.z);
    <span class="tok-kw">var</span> Y3 = q.x.add(q.z);
    X3 = X3.mul(Y3);
    Y3 = t0.add(t2);
    Y3 = X3.sub(Y3);
    X3 = t0.dbl();
    t0 = X3.add(t0);<span class="tok-comment">
    // b3 = (2^2)^2 + 2^2 + 1
    </span><span class="tok-kw">const</span> t2_4 = t2.dbl().dbl();
    t2 = t2_4.dbl().dbl().add(t2_4).add(t2);
    <span class="tok-kw">var</span> Z3 = t1.add(t2);
    t1 = t1.sub(t2);
    <span class="tok-kw">const</span> Y3_4 = Y3.dbl().dbl();
    Y3 = Y3_4.dbl().dbl().add(Y3_4).add(Y3);
    X3 = t4.mul(Y3);
    t2 = t3.mul(t1);
    X3 = t2.sub(X3);
    Y3 = Y3.mul(t0);
    t1 = t1.mul(Z3);
    Y3 = t1.add(Y3);
    t0 = t0.mul(t3);
    Z3 = Z3.mul(t4);
    Z3 = Z3.add(t0);

    <span class="tok-kw">return</span> .{
        .x = X3,
        .y = Y3,
        .z = Z3,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.sub" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sub</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.sub">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Subtract secp256k1 points.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>q: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.sub">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">return</span> p.add(q.neg());
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.subMixed" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subMixed</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.subMixed">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subMixed</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Subtract secp256k1 points, the second being specified using affine coordinates.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>q: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.subMixed">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subMixed</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">return</span> p.addMixed(q.neg());
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.affineCoordinates" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">affineCoordinates</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.affineCoordinates">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">affineCoordinates</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a></code></pre></div><div class="tldDocs"><p>Return affine coordinates.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.affineCoordinates">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">affineCoordinates</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a> {
    <span class="tok-kw">const</span> affine_0 = <span class="tok-builtin">@intFromBool</span>(p.x.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">x</a>)) &amp; (<span class="tok-builtin">@intFromBool</span>(p.y.isZero()) | <span class="tok-builtin">@intFromBool</span>(p.y.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">y</a>)));
    <span class="tok-kw">const</span> is_identity = <span class="tok-builtin">@intFromBool</span>(p.z.isZero()) | affine_0;
    <span class="tok-kw">const</span> zinv = p.z.invert();
    <span class="tok-kw">var</span> ret = <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>{
        .x = p.x.mul(zinv),
        .y = p.y.mul(zinv),
    };
    ret.cMov(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>, is_identity);
    <span class="tok-kw">return</span> ret;
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.equivalent" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">equivalent</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.equivalent">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">equivalent</span>(a: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, b: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Return true if both coordinate sets represent the same point.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>b: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.equivalent">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">equivalent</span>(a: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, b: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (a.sub(b).rejectIdentity()) {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.mul" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mul</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.mul">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Multiply an elliptic curve point by a scalar.
Return error.IdentityElement if the result is the identity element.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>s_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.mul">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">const</span> s = <span class="tok-kw">if</span> (endian == .little) s_ <span class="tok-kw">else</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">orderSwap</a>(s_);
    <span class="tok-kw">if</span> (p.is_base) {
        <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.pcMul16">pcMul16</a>(&amp;<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePointPc">basePointPc</a>, s, <span class="tok-null">false</span>);
    }
    <span class="tok-kw">try</span> p.rejectIdentity();
    <span class="tok-kw">const</span> pc = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p, <span class="tok-number">15</span>);
    <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.pcMul16">pcMul16</a>(&amp;pc, s, <span class="tok-null">false</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.mulPublic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mulPublic</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.mulPublic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulPublic</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Multiply an elliptic curve point by a <em>PUBLIC</em> scalar <em>IN VARIABLE TIME</em>
This can be used for signature verification.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>s_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.mulPublic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulPublic</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">const</span> s = <span class="tok-kw">if</span> (endian == .little) s_ <span class="tok-kw">else</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">orderSwap</a>(s_);
    <span class="tok-kw">const</span> zero = <span class="tok-kw">comptime</span> <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.Scalar.html">Scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.Scalar.html#std.crypto.pcurves.secp256k1.scalar.Scalar.zero">zero</a>.<a href="#">toBytes</a>(.little);
    <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;zero, &amp;s)) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IdentityElement;
    }
    <span class="tok-kw">const</span> pc = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p, <span class="tok-number">8</span>);
    <span class="tok-kw">var</span> lambda_p = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.pcMul">pcMul</a>(&amp;pc, <a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html">Endormorphism</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html#std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.lambda_s">lambda_s</a>, <span class="tok-null">true</span>);
    <span class="tok-kw">var</span> split_scalar = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html">Endormorphism</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html#std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.splitScalar">splitScalar</a>(s, .little);
    <span class="tok-kw">var</span> px = p;<span class="tok-comment">

    // If a key is negative, flip the sign to keep it half-sized,
    // and flip the sign of the Y point coordinate to compensate.
    </span><span class="tok-kw">if</span> (split_scalar.r1[split_scalar.r1.len / <span class="tok-number">2</span>] != <span class="tok-number">0</span>) {
        split_scalar.r1 = <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.neg">neg</a>(split_scalar.r1, .little) <span class="tok-kw">catch</span> zero;
        px = px.neg();
    }
    <span class="tok-kw">if</span> (split_scalar.r2[split_scalar.r2.len / <span class="tok-number">2</span>] != <span class="tok-number">0</span>) {
        split_scalar.r2 = <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.neg">neg</a>(split_scalar.r2, .little) <span class="tok-kw">catch</span> zero;
        lambda_p = lambda_p.neg();
    }
    <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.mulDoubleBasePublicEndo">mulDoubleBasePublicEndo</a>(px, split_scalar.r1, lambda_p, split_scalar.r2);
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.pcurves.secp256k1.Secp256k1.mulDoubleBasePublic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mulDoubleBasePublic</span><a href="#src.zig-std.crypto.pcurves.secp256k1.Secp256k1.mulDoubleBasePublic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulDoubleBasePublic</span>(p1: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s1_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, p2: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s2_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div class="tldDocs"><p>Double-base multiplication of public parameters - Compute (p1<em>s1)+(p2</em>s2) <em>IN VARIABLE TIME</em>
This can be used for signature verification.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>p1: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>s1_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span></code></pre></div><div><pre><code>p2: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a></code></pre></div><div><pre><code>s2_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1.mulDoubleBasePublic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulDoubleBasePublic</span>(p1: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s1_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, p2: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s2_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
    <span class="tok-kw">const</span> s1 = <span class="tok-kw">if</span> (endian == .little) s1_ <span class="tok-kw">else</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">orderSwap</a>(s1_);
    <span class="tok-kw">const</span> s2 = <span class="tok-kw">if</span> (endian == .little) s2_ <span class="tok-kw">else</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">orderSwap</a>(s2_);
    <span class="tok-kw">try</span> p1.rejectIdentity();
    <span class="tok-kw">var</span> pc1_array: [<span class="tok-number">9</span>]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> pc1 = <span class="tok-kw">if</span> (p1.is_base) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePointPc">basePointPc</a>[<span class="tok-number">0</span>..<span class="tok-number">9</span>] <span class="tok-kw">else</span> pc: {
        pc1_array = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p1, <span class="tok-number">8</span>);
        <span class="tok-kw">break</span> :pc &amp;pc1_array;
    };
    <span class="tok-kw">try</span> p2.rejectIdentity();
    <span class="tok-kw">var</span> pc2_array: [<span class="tok-number">9</span>]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> pc2 = <span class="tok-kw">if</span> (p2.is_base) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePointPc">basePointPc</a>[<span class="tok-number">0</span>..<span class="tok-number">9</span>] <span class="tok-kw">else</span> pc: {
        pc2_array = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p2, <span class="tok-number">8</span>);
        <span class="tok-kw">break</span> :pc &amp;pc2_array;
    };
    <span class="tok-kw">const</span> e1 = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.slide">slide</a>(s1);
    <span class="tok-kw">const</span> e2 = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.slide">slide</a>(s2);
    <span class="tok-kw">var</span> q = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
    <span class="tok-kw">var</span> pos: <span class="tok-type">usize</span> = <span class="tok-number">2</span> * <span class="tok-number">32</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (pos -= <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> slot1 = e1[pos];
        <span class="tok-kw">if</span> (slot1 &gt; <span class="tok-number">0</span>) {
            q = q.add(pc1[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(slot1))]);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slot1 &lt; <span class="tok-number">0</span>) {
            q = q.sub(pc1[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-slot1))]);
        }
        <span class="tok-kw">const</span> slot2 = e2[pos];
        <span class="tok-kw">if</span> (slot2 &gt; <span class="tok-number">0</span>) {
            q = q.add(pc2[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(slot2))]);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slot2 &lt; <span class="tok-number">0</span>) {
            q = q.sub(pc2[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-slot2))]);
        }
        <span class="tok-kw">if</span> (pos == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        q = q.dbl().dbl().dbl().dbl();
    }
    <span class="tok-kw">try</span> q.rejectIdentity();
    <span class="tok-kw">return</span> q;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.crypto.pcurves.secp256k1.Secp256k1">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Secp256k1 = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The underlying prime field.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fe = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;secp256k1/field.zig&quot;</span>).Fe;
    <span class="tok-comment">/// Field arithmetic mod the order of the main subgroup.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> scalar = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;secp256k1/scalar.zig&quot;</span>);

    x: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>,
    y: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>,
    z: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a> = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">one</a>,

    is_base: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// The secp256k1 base point.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> basePoint = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{
        .x = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromInt</a>(<span class="tok-number">55066263022277343669578718895168534326250603453777594175500187360389116729240</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
        .y = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromInt</a>(<span class="tok-number">32670510020758816978083085130507043184471273380659243275938904335757337482424</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
        .z = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">one</a>,
        .is_base = <span class="tok-null">true</span>,
    };

    <span class="tok-comment">/// The secp256k1 neutral element.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> identityElement = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{ .x = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">zero</a>, .y = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">one</a>, .z = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">zero</a> };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> B = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromInt</a>(<span class="tok-number">7</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Endormorphism = <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> lambda: <span class="tok-type">u256</span> = <span class="tok-number">37718080363155996902926221483475020450927657555482586988616620542887997980018</span>;
        <span class="tok-kw">const</span> beta: <span class="tok-type">u256</span> = <span class="tok-number">55594575648329892869085402983802832744385952214688224221778511981742606582254</span>;

        <span class="tok-kw">const</span> lambda_s = s: {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u256</span>, &amp;buf, <a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html">Endormorphism</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html#std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.lambda">lambda</a>, .little);
            <span class="tok-kw">break</span> :s buf;
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SplitScalar = <span class="tok-kw">struct</span> {
            r1: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>,
            r2: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>,
        };

        <span class="tok-comment">/// Compute r1 and r2 so that k = r1 + r2*lambda (mod L).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitScalar</span>(s: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.SplitScalar.html">SplitScalar</a> {
            <span class="tok-kw">const</span> b1_neg_s = <span class="tok-kw">comptime</span> s: {
                <span class="tok-kw">var</span> buf: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u256</span>, &amp;buf, <span class="tok-number">303414439467246543595250775667605759171</span>, .little);
                <span class="tok-kw">break</span> :s buf;
            };
            <span class="tok-kw">const</span> b2_neg_s = <span class="tok-kw">comptime</span> s: {
                <span class="tok-kw">var</span> buf: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
                <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u256</span>, &amp;buf, <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.field_order">field_order</a> - <span class="tok-number">64502973549206556628585045361533709077</span>, .little);
                <span class="tok-kw">break</span> :s buf;
            };
            <span class="tok-kw">const</span> k = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u256</span>, &amp;s, endian);

            <span class="tok-kw">const</span> t1 = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(<span class="tok-type">u256</span>, k, <span class="tok-number">21949224512762693861512883645436906316123769664773102907882521278123970637873</span>);
            <span class="tok-kw">const</span> t2 = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(<span class="tok-type">u256</span>, k, <span class="tok-number">103246583619904461035481197785446227098457807945486720222659797044629401272177</span>);

            <span class="tok-kw">const</span> c1 = <span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-builtin">@truncate</span>(t1 &gt;&gt; <span class="tok-number">384</span>)) + <span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-builtin">@truncate</span>(t1 &gt;&gt; <span class="tok-number">383</span>));
            <span class="tok-kw">const</span> c2 = <span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-builtin">@truncate</span>(t2 &gt;&gt; <span class="tok-number">384</span>)) + <span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-builtin">@truncate</span>(t2 &gt;&gt; <span class="tok-number">383</span>));

            <span class="tok-kw">var</span> buf: [<span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u256</span>, &amp;buf, c1, .little);
            <span class="tok-kw">const</span> c1x = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.mul">mul</a>(buf, b1_neg_s, .little);

            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u256</span>, &amp;buf, c2, .little);
            <span class="tok-kw">const</span> c2x = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.mul">mul</a>(buf, b2_neg_s, .little);

            <span class="tok-kw">const</span> r2 = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.add">add</a>(c1x, c2x, .little);

            <span class="tok-kw">var</span> r1 = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.mul">mul</a>(r2, <a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html#std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.lambda_s">lambda_s</a>, .little);
            r1 = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.sub">sub</a>(s, r1, .little);

            <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.SplitScalar.html">SplitScalar</a>{ .r1 = r1, .r2 = r2 };
        }
    };

    <span class="tok-comment">/// Reject the neutral element.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rejectIdentity</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> affine_0 = <span class="tok-builtin">@intFromBool</span>(p.x.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">x</a>)) &amp; (<span class="tok-builtin">@intFromBool</span>(p.y.isZero()) | <span class="tok-builtin">@intFromBool</span>(p.y.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">y</a>)));
        <span class="tok-kw">const</span> is_identity = <span class="tok-builtin">@intFromBool</span>(p.z.isZero()) | affine_0;
        <span class="tok-kw">if</span> (is_identity != <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IdentityElement;
        }
    }

    <span class="tok-comment">/// Create a point from affine coordinates after checking that they match the curve equation.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromAffineCoordinates</span>(p: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">const</span> x = p.x;
        <span class="tok-kw">const</span> y = p.y;
        <span class="tok-kw">const</span> x3B = x.sq().mul(x).add(<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.B">B</a>);
        <span class="tok-kw">const</span> yy = y.sq();
        <span class="tok-kw">const</span> on_curve = <span class="tok-builtin">@intFromBool</span>(x3B.equivalent(yy));
        <span class="tok-kw">const</span> is_identity = <span class="tok-builtin">@intFromBool</span>(x.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">x</a>)) &amp; <span class="tok-builtin">@intFromBool</span>(y.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">y</a>));
        <span class="tok-kw">if</span> ((on_curve | is_identity) == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
        }
        <span class="tok-kw">var</span> ret = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{ .x = x, .y = y, .z = <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">one</a> };
        ret.z.cMov(<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>.<a href="#">z</a>, is_identity);
        <span class="tok-kw">return</span> ret;
    }

    <span class="tok-comment">/// Create a point from serialized affine coordinates.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSerializedAffineCoordinates</span>(xs: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, ys: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(xs, endian);
        <span class="tok-kw">const</span> y = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(ys, endian);
        <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.fromAffineCoordinates">fromAffineCoordinates</a>(.{ .x = x, .y = y });
    }

    <span class="tok-comment">/// Recover the Y coordinate from the X coordinate.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recoverY</span>(x: <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>, is_odd: <span class="tok-type">bool</span>) <a href="std.crypto.errors.html#std.crypto.errors.NotSquareError">NotSquareError</a>!<a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a> {
        <span class="tok-kw">const</span> x3B = x.sq().mul(x).add(<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.B">B</a>);
        <span class="tok-kw">var</span> y = <span class="tok-kw">try</span> x3B.sqrt();
        <span class="tok-kw">const</span> yn = y.neg();
        y.cMov(yn, <span class="tok-builtin">@intFromBool</span>(is_odd) ^ <span class="tok-builtin">@intFromBool</span>(y.isOdd()));
        <span class="tok-kw">return</span> y;
    }

    <span class="tok-comment">/// Deserialize a SEC1-encoded point.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSec1</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NotSquareError">NotSquareError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">if</span> (s.len &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
        <span class="tok-kw">const</span> encoding_type = s[<span class="tok-number">0</span>];
        <span class="tok-kw">const</span> encoded = s[<span class="tok-number">1</span>..];
        <span class="tok-kw">switch</span> (encoding_type) {
            <span class="tok-number">0</span> =&gt; {
                <span class="tok-kw">if</span> (encoded.len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
                <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
            },
            <span class="tok-number">2</span>, <span class="tok-number">3</span> =&gt; {
                <span class="tok-kw">if</span> (encoded.len != <span class="tok-number">32</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
                <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(encoded[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*, .big);
                <span class="tok-kw">const</span> y_is_odd = (encoding_type == <span class="tok-number">3</span>);
                <span class="tok-kw">const</span> y = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.recoverY">recoverY</a>(x, y_is_odd);
                <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{ .x = x, .y = y };
            },
            <span class="tok-number">4</span> =&gt; {
                <span class="tok-kw">if</span> (encoded.len != <span class="tok-number">64</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding;
                <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(encoded[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*, .big);
                <span class="tok-kw">const</span> y = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">fromBytes</a>(encoded[<span class="tok-number">32</span>..<span class="tok-number">64</span>].*, .big);
                <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.fromAffineCoordinates">fromAffineCoordinates</a>(.{ .x = x, .y = y });
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidEncoding,
        }
    }

    <span class="tok-comment">/// Serialize a point using the compressed SEC-1 format.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toCompressedSec1</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) [<span class="tok-number">33</span>]<span class="tok-type">u8</span> {
        <span class="tok-kw">var</span> out: [<span class="tok-number">33</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> xy = p.affineCoordinates();
        out[<span class="tok-number">0</span>] = <span class="tok-kw">if</span> (xy.y.isOdd()) <span class="tok-number">3</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>;
        out[<span class="tok-number">1</span>..].* = xy.x.toBytes(.big);
        <span class="tok-kw">return</span> out;
    }

    <span class="tok-comment">/// Serialize a point using the uncompressed SEC-1 format.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toUncompressedSec1</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) [<span class="tok-number">65</span>]<span class="tok-type">u8</span> {
        <span class="tok-kw">var</span> out: [<span class="tok-number">65</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        out[<span class="tok-number">0</span>] = <span class="tok-number">4</span>;
        <span class="tok-kw">const</span> xy = p.affineCoordinates();
        out[<span class="tok-number">1</span>..<span class="tok-number">33</span>].* = xy.x.toBytes(.big);
        out[<span class="tok-number">33</span>..<span class="tok-number">65</span>].* = xy.y.toBytes(.big);
        <span class="tok-kw">return</span> out;
    }

    <span class="tok-comment">/// Return a random point.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">random</span>() <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">const</span> n = <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.random">random</a>(.little);
        <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePoint">basePoint</a>.<a href="#">mul</a>(n, .little) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-comment">/// Flip the sign of the X coordinate.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">neg</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">return</span> .{ .x = p.x, .y = p.y.neg(), .z = p.z };
    }

    <span class="tok-comment">/// Double a secp256k1 point.</span><span class="tok-comment">
    // Algorithm 9 from https://eprint.iacr.org/2015/1060.pdf
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dbl</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">var</span> t0 = p.y.sq();
        <span class="tok-kw">var</span> Z3 = t0.dbl();
        Z3 = Z3.dbl();
        Z3 = Z3.dbl();
        <span class="tok-kw">var</span> t1 = p.y.mul(p.z);
        <span class="tok-kw">var</span> t2 = p.z.sq();<span class="tok-comment">
        // b3 = (2^2)^2 + 2^2 + 1
        </span><span class="tok-kw">const</span> t2_4 = t2.dbl().dbl();
        t2 = t2_4.dbl().dbl().add(t2_4).add(t2);
        <span class="tok-kw">var</span> X3 = t2.mul(Z3);
        <span class="tok-kw">var</span> Y3 = t0.add(t2);
        Z3 = t1.mul(Z3);
        t1 = t2.dbl();
        t2 = t1.add(t2);
        t0 = t0.sub(t2);
        Y3 = t0.mul(Y3);
        Y3 = X3.add(Y3);
        t1 = p.x.mul(p.y);
        X3 = t0.mul(t1);
        X3 = X3.dbl();
        <span class="tok-kw">return</span> .{
            .x = X3,
            .y = Y3,
            .z = Z3,
        };
    }

    <span class="tok-comment">/// Add secp256k1 points, the second being specified using affine coordinates.</span><span class="tok-comment">
    // Algorithm 8 from https://eprint.iacr.org/2015/1060.pdf
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addMixed</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">var</span> t0 = p.x.mul(q.x);
        <span class="tok-kw">var</span> t1 = p.y.mul(q.y);
        <span class="tok-kw">var</span> t3 = q.x.add(q.y);
        <span class="tok-kw">var</span> t4 = p.x.add(p.y);
        t3 = t3.mul(t4);
        t4 = t0.add(t1);
        t3 = t3.sub(t4);
        t4 = q.y.mul(p.z);
        t4 = t4.add(p.y);
        <span class="tok-kw">var</span> Y3 = q.x.mul(p.z);
        Y3 = Y3.add(p.x);
        <span class="tok-kw">var</span> X3 = t0.dbl();
        t0 = X3.add(t0);<span class="tok-comment">
        // b3 = (2^2)^2 + 2^2 + 1
        </span><span class="tok-kw">const</span> t2_4 = p.z.dbl().dbl();
        <span class="tok-kw">var</span> t2 = t2_4.dbl().dbl().add(t2_4).add(p.z);
        <span class="tok-kw">var</span> Z3 = t1.add(t2);
        t1 = t1.sub(t2);
        <span class="tok-kw">const</span> Y3_4 = Y3.dbl().dbl();
        Y3 = Y3_4.dbl().dbl().add(Y3_4).add(Y3);
        X3 = t4.mul(Y3);
        t2 = t3.mul(t1);
        X3 = t2.sub(X3);
        Y3 = Y3.mul(t0);
        t1 = t1.mul(Z3);
        Y3 = t1.add(Y3);
        t0 = t0.mul(t3);
        Z3 = Z3.mul(t4);
        Z3 = Z3.add(t0);

        <span class="tok-kw">var</span> ret = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>{
            .x = X3,
            .y = Y3,
            .z = Z3,
        };
        ret.cMov(p, <span class="tok-builtin">@intFromBool</span>(q.x.isZero()));
        <span class="tok-kw">return</span> ret;
    }

    <span class="tok-comment">/// Add secp256k1 points.</span><span class="tok-comment">
    // Algorithm 7 from https://eprint.iacr.org/2015/1060.pdf
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">var</span> t0 = p.x.mul(q.x);
        <span class="tok-kw">var</span> t1 = p.y.mul(q.y);
        <span class="tok-kw">var</span> t2 = p.z.mul(q.z);
        <span class="tok-kw">var</span> t3 = p.x.add(p.y);
        <span class="tok-kw">var</span> t4 = q.x.add(q.y);
        t3 = t3.mul(t4);
        t4 = t0.add(t1);
        t3 = t3.sub(t4);
        t4 = p.y.add(p.z);
        <span class="tok-kw">var</span> X3 = q.y.add(q.z);
        t4 = t4.mul(X3);
        X3 = t1.add(t2);
        t4 = t4.sub(X3);
        X3 = p.x.add(p.z);
        <span class="tok-kw">var</span> Y3 = q.x.add(q.z);
        X3 = X3.mul(Y3);
        Y3 = t0.add(t2);
        Y3 = X3.sub(Y3);
        X3 = t0.dbl();
        t0 = X3.add(t0);<span class="tok-comment">
        // b3 = (2^2)^2 + 2^2 + 1
        </span><span class="tok-kw">const</span> t2_4 = t2.dbl().dbl();
        t2 = t2_4.dbl().dbl().add(t2_4).add(t2);
        <span class="tok-kw">var</span> Z3 = t1.add(t2);
        t1 = t1.sub(t2);
        <span class="tok-kw">const</span> Y3_4 = Y3.dbl().dbl();
        Y3 = Y3_4.dbl().dbl().add(Y3_4).add(Y3);
        X3 = t4.mul(Y3);
        t2 = t3.mul(t1);
        X3 = t2.sub(X3);
        Y3 = Y3.mul(t0);
        t1 = t1.mul(Z3);
        Y3 = t1.add(Y3);
        t0 = t0.mul(t3);
        Z3 = Z3.mul(t4);
        Z3 = Z3.add(t0);

        <span class="tok-kw">return</span> .{
            .x = X3,
            .y = Y3,
            .z = Z3,
        };
    }

    <span class="tok-comment">/// Subtract secp256k1 points.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">return</span> p.add(q.neg());
    }

    <span class="tok-comment">/// Subtract secp256k1 points, the second being specified using affine coordinates.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subMixed</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, q: <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">return</span> p.addMixed(q.neg());
    }

    <span class="tok-comment">/// Return affine coordinates.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">affineCoordinates</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a> {
        <span class="tok-kw">const</span> affine_0 = <span class="tok-builtin">@intFromBool</span>(p.x.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">x</a>)) &amp; (<span class="tok-builtin">@intFromBool</span>(p.y.isZero()) | <span class="tok-builtin">@intFromBool</span>(p.y.equivalent(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>.<a href="#">y</a>)));
        <span class="tok-kw">const</span> is_identity = <span class="tok-builtin">@intFromBool</span>(p.z.isZero()) | affine_0;
        <span class="tok-kw">const</span> zinv = p.z.invert();
        <span class="tok-kw">var</span> ret = <a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>{
            .x = p.x.mul(zinv),
            .y = p.y.mul(zinv),
        };
        ret.cMov(<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html">AffineCoordinates</a>.<a href="std.crypto.pcurves.secp256k1.AffineCoordinates.html#std.crypto.pcurves.secp256k1.AffineCoordinates.identityElement">identityElement</a>, is_identity);
        <span class="tok-kw">return</span> ret;
    }

    <span class="tok-comment">/// Return true if both coordinate sets represent the same point.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">equivalent</span>(a: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, b: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (a.sub(b).rejectIdentity()) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        } <span class="tok-kw">else</span> |_| {
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">cMov</span>(p: *<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, a: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, c: <span class="tok-type">u1</span>) <span class="tok-type">void</span> {
        p.x.cMov(a.x, c);
        p.y.cMov(a.y, c);
        p.z.cMov(a.z, c);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">pcSelect</span>(<span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>, pc: *<span class="tok-kw">const</span> [n]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, b: <span class="tok-type">u8</span>) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">var</span> t = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; pc.len) : (i += <span class="tok-number">1</span>) {
            t.cMov(pc[i], <span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-builtin">@truncate</span>((<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, b ^ i) -% <span class="tok-number">1</span>) &gt;&gt; <span class="tok-number">8</span>)));
        }
        <span class="tok-kw">return</span> t;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">slide</span>(s: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>) [<span class="tok-number">2</span> * <span class="tok-number">32</span> + <span class="tok-number">1</span>]<span class="tok-type">i8</span> {
        <span class="tok-kw">var</span> e: [<span class="tok-number">2</span> * <span class="tok-number">32</span> + <span class="tok-number">1</span>]<span class="tok-type">i8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">for</span> (s, <span class="tok-number">0</span>..) |x, i| {
            e[i * <span class="tok-number">2</span> + <span class="tok-number">0</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@truncate</span>(x)));
            e[i * <span class="tok-number">2</span> + <span class="tok-number">1</span>] = <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-number">4</span>)));
        }<span class="tok-comment">
        // Now, e[0..63] is between 0 and 15, e[63] is between 0 and 7
        </span><span class="tok-kw">var</span> carry: <span class="tok-type">i8</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (e[<span class="tok-number">0</span>..<span class="tok-number">64</span>]) |*x| {
            x.* += carry;
            carry = (x.* + <span class="tok-number">8</span>) &gt;&gt; <span class="tok-number">4</span>;
            x.* -= carry * <span class="tok-number">16</span>;
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(x.* &gt;= -<span class="tok-number">8</span> <span class="tok-kw">and</span> x.* &lt;= <span class="tok-number">8</span>);
        }
        e[<span class="tok-number">64</span>] = carry;<span class="tok-comment">
        // Now, e[*] is between -8 and 8, including e[64]
        </span><a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(carry &gt;= -<span class="tok-number">8</span> <span class="tok-kw">and</span> carry &lt;= <span class="tok-number">8</span>);
        <span class="tok-kw">return</span> e;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">pcMul</span>(pc: *<span class="tok-kw">const</span> [<span class="tok-number">9</span>]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> vartime: <span class="tok-type">bool</span>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(vartime);
        <span class="tok-kw">const</span> e = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.slide">slide</a>(s);
        <span class="tok-kw">var</span> q = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
        <span class="tok-kw">var</span> pos = e.len - <span class="tok-number">1</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (pos -= <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> slot = e[pos];
            <span class="tok-kw">if</span> (slot &gt; <span class="tok-number">0</span>) {
                q = q.add(pc[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(slot))]);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slot &lt; <span class="tok-number">0</span>) {
                q = q.sub(pc[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-slot))]);
            }
            <span class="tok-kw">if</span> (pos == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            q = q.dbl().dbl().dbl().dbl();
        }
        <span class="tok-kw">try</span> q.rejectIdentity();
        <span class="tok-kw">return</span> q;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">pcMul16</span>(pc: *<span class="tok-kw">const</span> [<span class="tok-number">16</span>]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> vartime: <span class="tok-type">bool</span>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">var</span> q = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
        <span class="tok-kw">var</span> pos: <span class="tok-type">usize</span> = <span class="tok-number">252</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (pos -= <span class="tok-number">4</span>) {
            <span class="tok-kw">const</span> slot = <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@truncate</span>((s[pos &gt;&gt; <span class="tok-number">3</span>] &gt;&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@truncate</span>(pos)))));
            <span class="tok-kw">if</span> (vartime) {
                <span class="tok-kw">if</span> (slot != <span class="tok-number">0</span>) {
                    q = q.add(pc[slot]);
                }
            } <span class="tok-kw">else</span> {
                q = q.add(<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.pcSelect">pcSelect</a>(<span class="tok-number">16</span>, pc, slot));
            }
            <span class="tok-kw">if</span> (pos == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            q = q.dbl().dbl().dbl().dbl();
        }
        <span class="tok-kw">try</span> q.rejectIdentity();
        <span class="tok-kw">return</span> q;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">precompute</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, <span class="tok-kw">comptime</span> count: <span class="tok-type">usize</span>) [<span class="tok-number">1</span> + count]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">var</span> pc: [<span class="tok-number">1</span> + count]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> = <span class="tok-null">undefined</span>;
        pc[<span class="tok-number">0</span>] = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
        pc[<span class="tok-number">1</span>] = p;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;
        <span class="tok-kw">while</span> (i &lt;= count) : (i += <span class="tok-number">1</span>) {
            pc[i] = <span class="tok-kw">if</span> (i % <span class="tok-number">2</span> == <span class="tok-number">0</span>) pc[i / <span class="tok-number">2</span>].dbl() <span class="tok-kw">else</span> pc[i - <span class="tok-number">1</span>].add(p);
        }
        <span class="tok-kw">return</span> pc;
    }

    <span class="tok-kw">const</span> basePointPc = pc: {
        <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">50000</span>);
        <span class="tok-kw">break</span> :pc <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePoint">basePoint</a>, <span class="tok-number">15</span>);
    };

    <span class="tok-comment">/// Multiply an elliptic curve point by a scalar.</span>
    <span class="tok-comment">/// Return error.IdentityElement if the result is the identity element.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">const</span> s = <span class="tok-kw">if</span> (endian == .little) s_ <span class="tok-kw">else</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">orderSwap</a>(s_);
        <span class="tok-kw">if</span> (p.is_base) {
            <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.pcMul16">pcMul16</a>(&amp;<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePointPc">basePointPc</a>, s, <span class="tok-null">false</span>);
        }
        <span class="tok-kw">try</span> p.rejectIdentity();
        <span class="tok-kw">const</span> pc = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p, <span class="tok-number">15</span>);
        <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.pcMul16">pcMul16</a>(&amp;pc, s, <span class="tok-null">false</span>);
    }

    <span class="tok-comment">/// Multiply an elliptic curve point by a *PUBLIC* scalar *IN VARIABLE TIME*</span>
    <span class="tok-comment">/// This can be used for signature verification.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulPublic</span>(p: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a>)!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">const</span> s = <span class="tok-kw">if</span> (endian == .little) s_ <span class="tok-kw">else</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">orderSwap</a>(s_);
        <span class="tok-kw">const</span> zero = <span class="tok-kw">comptime</span> <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.Scalar.html">Scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.Scalar.html#std.crypto.pcurves.secp256k1.scalar.Scalar.zero">zero</a>.<a href="#">toBytes</a>(.little);
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;zero, &amp;s)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IdentityElement;
        }
        <span class="tok-kw">const</span> pc = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p, <span class="tok-number">8</span>);
        <span class="tok-kw">var</span> lambda_p = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.pcMul">pcMul</a>(&amp;pc, <a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html">Endormorphism</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html#std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.lambda_s">lambda_s</a>, <span class="tok-null">true</span>);
        <span class="tok-kw">var</span> split_scalar = <span class="tok-kw">try</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html">Endormorphism</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.html#std.crypto.pcurves.secp256k1.Secp256k1.Endormorphism.splitScalar">splitScalar</a>(s, .little);
        <span class="tok-kw">var</span> px = p;<span class="tok-comment">

        // If a key is negative, flip the sign to keep it half-sized,
        // and flip the sign of the Y point coordinate to compensate.
        </span><span class="tok-kw">if</span> (split_scalar.r1[split_scalar.r1.len / <span class="tok-number">2</span>] != <span class="tok-number">0</span>) {
            split_scalar.r1 = <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.neg">neg</a>(split_scalar.r1, .little) <span class="tok-kw">catch</span> zero;
            px = px.neg();
        }
        <span class="tok-kw">if</span> (split_scalar.r2[split_scalar.r2.len / <span class="tok-number">2</span>] != <span class="tok-number">0</span>) {
            split_scalar.r2 = <a href="std.crypto.pcurves.secp256k1.scalar.html">scalar</a>.<a href="std.crypto.pcurves.secp256k1.scalar.html#std.crypto.pcurves.secp256k1.scalar.neg">neg</a>(split_scalar.r2, .little) <span class="tok-kw">catch</span> zero;
            lambda_p = lambda_p.neg();
        }
        <span class="tok-kw">return</span> <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.mulDoubleBasePublicEndo">mulDoubleBasePublicEndo</a>(px, split_scalar.r1, lambda_p, split_scalar.r2);
    }<span class="tok-comment">

    // Half-size double-base public multiplication when using the curve endomorphism.
    // Scalars must be in little-endian.
    // The second point is unlikely to be the generator, so don't even try to use the comptime table for it.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">mulDoubleBasePublicEndo</span>(p1: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s1: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, p2: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s2: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">var</span> pc1_array: [<span class="tok-number">9</span>]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> pc1 = <span class="tok-kw">if</span> (p1.is_base) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePointPc">basePointPc</a>[<span class="tok-number">0</span>..<span class="tok-number">9</span>] <span class="tok-kw">else</span> pc: {
            pc1_array = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p1, <span class="tok-number">8</span>);
            <span class="tok-kw">break</span> :pc &amp;pc1_array;
        };
        <span class="tok-kw">const</span> pc2 = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p2, <span class="tok-number">8</span>);
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(s1[s1.len / <span class="tok-number">2</span>] == <span class="tok-number">0</span>);
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(s2[s2.len / <span class="tok-number">2</span>] == <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> e1 = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.slide">slide</a>(s1);
        <span class="tok-kw">const</span> e2 = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.slide">slide</a>(s2);
        <span class="tok-kw">var</span> q = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
        <span class="tok-kw">var</span> pos: <span class="tok-type">usize</span> = <span class="tok-number">2</span> * <span class="tok-number">32</span> / <span class="tok-number">2</span>;<span class="tok-comment"> // second half is all zero
        </span><span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (pos -= <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> slot1 = e1[pos];
            <span class="tok-kw">if</span> (slot1 &gt; <span class="tok-number">0</span>) {
                q = q.add(pc1[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(slot1))]);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slot1 &lt; <span class="tok-number">0</span>) {
                q = q.sub(pc1[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-slot1))]);
            }
            <span class="tok-kw">const</span> slot2 = e2[pos];
            <span class="tok-kw">if</span> (slot2 &gt; <span class="tok-number">0</span>) {
                q = q.add(pc2[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(slot2))]);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slot2 &lt; <span class="tok-number">0</span>) {
                q = q.sub(pc2[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-slot2))]);
            }
            <span class="tok-kw">if</span> (pos == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            q = q.dbl().dbl().dbl().dbl();
        }
        <span class="tok-kw">try</span> q.rejectIdentity();
        <span class="tok-kw">return</span> q;
    }

    <span class="tok-comment">/// Double-base multiplication of public parameters - Compute (p1*s1)+(p2*s2) *IN VARIABLE TIME*</span>
    <span class="tok-comment">/// This can be used for signature verification.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mulDoubleBasePublic</span>(p1: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s1_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, p2: <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>, s2_: [<span class="tok-number">32</span>]<span class="tok-type">u8</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> {
        <span class="tok-kw">const</span> s1 = <span class="tok-kw">if</span> (endian == .little) s1_ <span class="tok-kw">else</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">orderSwap</a>(s1_);
        <span class="tok-kw">const</span> s2 = <span class="tok-kw">if</span> (endian == .little) s2_ <span class="tok-kw">else</span> <a href="std.crypto.pcurves.secp256k1.field.html#std.crypto.pcurves.secp256k1.field.Fe">Fe</a>.<a href="#">orderSwap</a>(s2_);
        <span class="tok-kw">try</span> p1.rejectIdentity();
        <span class="tok-kw">var</span> pc1_array: [<span class="tok-number">9</span>]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> pc1 = <span class="tok-kw">if</span> (p1.is_base) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePointPc">basePointPc</a>[<span class="tok-number">0</span>..<span class="tok-number">9</span>] <span class="tok-kw">else</span> pc: {
            pc1_array = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p1, <span class="tok-number">8</span>);
            <span class="tok-kw">break</span> :pc &amp;pc1_array;
        };
        <span class="tok-kw">try</span> p2.rejectIdentity();
        <span class="tok-kw">var</span> pc2_array: [<span class="tok-number">9</span>]<a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> pc2 = <span class="tok-kw">if</span> (p2.is_base) <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.basePointPc">basePointPc</a>[<span class="tok-number">0</span>..<span class="tok-number">9</span>] <span class="tok-kw">else</span> pc: {
            pc2_array = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.precompute">precompute</a>(p2, <span class="tok-number">8</span>);
            <span class="tok-kw">break</span> :pc &amp;pc2_array;
        };
        <span class="tok-kw">const</span> e1 = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.slide">slide</a>(s1);
        <span class="tok-kw">const</span> e2 = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.slide">slide</a>(s2);
        <span class="tok-kw">var</span> q = <a href="std.crypto.pcurves.secp256k1.Secp256k1.html">Secp256k1</a>.<a href="std.crypto.pcurves.secp256k1.Secp256k1.html#std.crypto.pcurves.secp256k1.Secp256k1.identityElement">identityElement</a>;
        <span class="tok-kw">var</span> pos: <span class="tok-type">usize</span> = <span class="tok-number">2</span> * <span class="tok-number">32</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (pos -= <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> slot1 = e1[pos];
            <span class="tok-kw">if</span> (slot1 &gt; <span class="tok-number">0</span>) {
                q = q.add(pc1[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(slot1))]);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slot1 &lt; <span class="tok-number">0</span>) {
                q = q.sub(pc1[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-slot1))]);
            }
            <span class="tok-kw">const</span> slot2 = e2[pos];
            <span class="tok-kw">if</span> (slot2 &gt; <span class="tok-number">0</span>) {
                q = q.add(pc2[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(slot2))]);
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slot2 &lt; <span class="tok-number">0</span>) {
                q = q.sub(pc2[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-slot2))]);
            }
            <span class="tok-kw">if</span> (pos == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            q = q.dbl().dbl().dbl().dbl();
        }
        <span class="tok-kw">try</span> q.rejectIdentity();
        <span class="tok-kw">return</span> q;
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
